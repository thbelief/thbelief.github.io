<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">
  <script>
    (function(){
        if(''){
            if (prompt('请输入博客密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="我这个人只是英俊 潇洒了些许~">
<meta property="og:type" content="website">
<meta property="og:title" content="THBELIEF">
<meta property="og:url" content="http://thbelief.coding.me/page/7/index.html">
<meta property="og:site_name" content="THBELIEF">
<meta property="og:description" content="我这个人只是英俊 潇洒了些许~">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="THBELIEF">
<meta name="twitter:description" content="我这个人只是英俊 潇洒了些许~">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://thbelief.coding.me/page/7/">





  <title>THBELIEF</title>
  








  <script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">THBELIEF</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Thbelief's blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/26/C-常用函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/26/C-常用函数/" itemprop="url">C++常用函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-26T22:00:54+08:00">
                2019-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#c">C++</a><ul>
<li><a href="#cstdlib">cstdlib</a></li>
<li><a href="#cctype">cctype</a></li>
<li><a href="#algorithm">algorithm</a></li>
<li><a href="#cmath">cmath</a></li>
<li><a href="#cstdlib-1">cstdlib</a></li>
</ul>
</li>
<li><a href="#c">C</a></li>
</ul>
<!-- tocstop -->
<h2><span id="前言">前言</span></h2><p>目前在备战CCF，算法题刷了蛮多的了，这次就记录一下，常用的C++/C的函数。（只记录<strong>常用且实用</strong>的，不是大全，再次强调）</p>
<h2><span id="c">C++</span></h2><h3><span id="cstdlib">cstdlib</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">begin       得到指向字符串开头的Iterator（迭代器）</span><br><span class="line">end         得到指向字符串结尾的Iterator</span><br><span class="line">rbegin      得到指向反向字符串开头的Iterator</span><br><span class="line">rend        得到指向反向字符串结尾的Iterator</span><br><span class="line">size        得到字符串的大小</span><br><span class="line">length()    和size函数功能相同</span><br><span class="line">max_size    字符串可能的最大大小</span><br><span class="line">empty       判断是否为空</span><br><span class="line">operator[]  取第几个元素，相当于数组</span><br><span class="line">c_str       取得C风格的const char* 字符串</span><br><span class="line">swap        交换函数</span><br><span class="line">insert      插入字符</span><br><span class="line">append      追加字符</span><br><span class="line">push_back   追加字符</span><br><span class="line">erase       删除字符串</span><br><span class="line">clear       清空字符容器中所有内容</span><br><span class="line">replace     替代</span><br><span class="line">copy        字符串到空间</span><br><span class="line">find        查找,返回基于0的索引号</span><br><span class="line">substr(n1,len)       得到字符串从n1开始的长度为len的子串</span><br><span class="line">compare              比较字符串(支持所有的关系运算符)</span><br><span class="line">getline              从输入流中读入一行</span><br></pre></td></tr></table></figure>
<h3><span id="cctype">cctype</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using ::isalpha; //是否字母</span><br><span class="line"></span><br><span class="line">using ::isdigit; //是否是数字</span><br><span class="line"></span><br><span class="line">using ::isgraph; //是否字母、数字或标点</span><br><span class="line"></span><br><span class="line">using ::islower; //是否小写</span><br><span class="line"></span><br><span class="line">using ::ispunct; //是否标点</span><br><span class="line"></span><br><span class="line">using ::isspace; //是否空格</span><br><span class="line"></span><br><span class="line">using ::isupper; //是否大写</span><br><span class="line"></span><br><span class="line">using ::isxdigit; //是否十六进制数字</span><br><span class="line"></span><br><span class="line">using ::tolower; //转为小写</span><br><span class="line"></span><br><span class="line">using ::toupper; //转为大写</span><br></pre></td></tr></table></figure>
<h3><span id="algorithm">algorithm</span></h3><table>
<thead>
<tr>
<th>循环</th>
<th>对序列中的每个元素执行某项操作</th>
<th>for_each()</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找</td>
<td>在序列中找出某个值的第一次出现的位置</td>
<td>find(a,a+size,n) 返回<em>b,</em>当<em>b=a+size</em>即没找到，<em>a</em>为指针</td>
</tr>
<tr>
<td>在序列中找出符合某谓词的第一个元素</td>
<td>find_if()</td>
<td></td>
</tr>
<tr>
<td>在序列中找出一子序列的最后一次出现的位置</td>
<td>find_end()</td>
<td></td>
</tr>
<tr>
<td>在序列中找出第一次出现指定值集中之值位置</td>
<td>find_first_of()</td>
<td></td>
</tr>
<tr>
<td>在序列中找出相邻的一对值</td>
<td>adjacent_find()</td>
<td></td>
</tr>
<tr>
<td>计数</td>
<td>在序列中统计某个值出现的次数</td>
<td>count()</td>
</tr>
<tr>
<td>在序列中统计与某谓词匹配的次数</td>
<td>count_if()</td>
<td></td>
</tr>
<tr>
<td>比较</td>
<td>找出两个序列相异的第一个元素</td>
<td>mismatch()</td>
</tr>
<tr>
<td>两个序列中的对应元素都相同时为真</td>
<td>equal(a,a+n,b,cmp)</td>
<td></td>
</tr>
<tr>
<td>在序列中找到等于某值的连续<em>n</em>次出现的位置</td>
<td>equal_range(a,a+n,x)</td>
<td></td>
</tr>
<tr>
<td>搜索</td>
<td>在序列中找出一子序列的第一次出现的位置</td>
<td>search()</td>
</tr>
<tr>
<td>在序列中找出一值的连续<em>n</em>次出现的位置</td>
<td>search_n()</td>
<td></td>
</tr>
<tr>
<td>复制</td>
<td>从序列的第一个元素起进行复制</td>
<td>copy()</td>
</tr>
<tr>
<td>从序列的最后一个元素起进行复制</td>
<td>copy_backward()</td>
<td></td>
</tr>
<tr>
<td>交换</td>
<td>交换两个元素</td>
<td>swap()</td>
</tr>
<tr>
<td>交换指定范围的元素</td>
<td>swap_ranges()</td>
<td></td>
</tr>
<tr>
<td>交换由迭代器所指的两个元素</td>
<td>iter_swap()</td>
<td></td>
</tr>
<tr>
<td>变换</td>
<td>将某操作应用于指定范围的每个元素</td>
<td>transform()</td>
</tr>
<tr>
<td>替换</td>
<td>用一个给定值替换一些值</td>
<td>replace()</td>
</tr>
<tr>
<td>替换满足谓词的一些元素</td>
<td>replace_if()</td>
<td></td>
</tr>
<tr>
<td>复制序列时用一给定值替换元素</td>
<td>replace_copy()</td>
<td></td>
</tr>
<tr>
<td>复制序列时替换满足谓词的元素</td>
<td>replace_copy_if()</td>
<td></td>
</tr>
<tr>
<td>填充</td>
<td>用一给定值取代所有元素</td>
<td>fill()</td>
</tr>
<tr>
<td>用一给定值取代前<em>n</em>个元素</td>
<td>fill_n()</td>
<td></td>
</tr>
<tr>
<td>生成</td>
<td>用一操作的结果取代所有元素</td>
<td>generate()</td>
</tr>
<tr>
<td>用一操作的结果取代前<em>n</em>个元素</td>
<td>generate_n()</td>
<td></td>
</tr>
<tr>
<td>删除</td>
<td>删除具有给定值的元素</td>
<td>remove()</td>
</tr>
<tr>
<td>删除满足谓词的元素</td>
<td>remove_if()</td>
<td></td>
</tr>
<tr>
<td>复制序列时删除具有给定值的元素</td>
<td>remove_copy()</td>
<td></td>
</tr>
<tr>
<td>复制序列时删除满足谓词的元素</td>
<td>remove_copy_if()</td>
<td></td>
</tr>
<tr>
<td>唯一</td>
<td>删除相邻的重复元素</td>
<td>unique()</td>
</tr>
<tr>
<td>复制序列时删除相邻的重复元素</td>
<td>unique_copy()</td>
<td></td>
</tr>
<tr>
<td>反转</td>
<td>反转元素的次序</td>
<td>reverse(a,a+n)</td>
</tr>
<tr>
<td>复制序列时反转元素的次序</td>
<td>reverse_copy()</td>
<td></td>
</tr>
<tr>
<td>环移</td>
<td>循环移动元素</td>
<td>rotate(a,a+m,a+n)以<em>m</em>位置为界交换前后序列</td>
</tr>
<tr>
<td>复制序列时循环移动元素</td>
<td>rotate_copy()</td>
<td></td>
</tr>
<tr>
<td>随机</td>
<td>采用均匀分布来随机移动元素</td>
<td>random_shuffle()</td>
</tr>
<tr>
<td>划分</td>
<td>将满足某谓词的元素都放到前面</td>
<td>partition()</td>
</tr>
<tr>
<td>将满足某谓词的元素都放到前面并维持原顺序</td>
<td>stable_partition()</td>
<td></td>
</tr>
<tr>
<td>排序</td>
<td>以很好的平均效率排序</td>
<td>sort(a,a+20,cmp)bool cmp( int a, int b ){ return a&gt;b; }在容器中或<em>string</em>用<em>begin</em>（）</td>
</tr>
<tr>
<td>排序，并维持相同元素的原有顺序</td>
<td>stable_sort()</td>
<td></td>
</tr>
<tr>
<td>将序列的前一部分排好序</td>
<td>partial_sort()</td>
<td></td>
</tr>
<tr>
<td>复制的同时将序列的前一部分排好序</td>
<td>partial_sort_copy()</td>
<td></td>
</tr>
<tr>
<td>第<em>n</em>个元素</td>
<td>将第<em>n</em>各元素放到它的正确位置</td>
<td>nth_element()</td>
</tr>
<tr>
<td>二分检索</td>
<td>找到大于等于某值的第一次出现</td>
<td>lower_bound()</td>
</tr>
<tr>
<td>找到大于某值的第一次出现</td>
<td>upper_bound()</td>
<td></td>
</tr>
<tr>
<td>找到（在不破坏顺序的前提下）可插入给定值的最大范围</td>
<td>equal_range()</td>
<td></td>
</tr>
<tr>
<td>在有序序列中确定给定元素是否存在</td>
<td>binary_search()</td>
<td></td>
</tr>
<tr>
<td>归并</td>
<td>归并两个有序序列</td>
<td>merge()</td>
</tr>
<tr>
<td>归并两个接续的有序序列</td>
<td>inplace_merge()</td>
<td></td>
</tr>
<tr>
<td>有序结构上的集合操作</td>
<td>一序列为另一序列的子序列时为真</td>
<td>includes()</td>
</tr>
<tr>
<td>构造两个集合的有序并集</td>
<td>set_union()</td>
<td></td>
</tr>
<tr>
<td>构造两个集合的有序交集</td>
<td>set_intersection()</td>
<td></td>
</tr>
<tr>
<td>构造两个集合的有序差集</td>
<td>set_difference()</td>
<td></td>
</tr>
<tr>
<td>构造两个集合的有序对称差集（并<em>-</em>交）</td>
<td>set_symmetric_difference()</td>
<td></td>
</tr>
<tr>
<td>堆操作</td>
<td>向堆中加入元素</td>
<td>push_heap()</td>
</tr>
<tr>
<td>从堆中弹出元素</td>
<td>pop_heap()</td>
<td></td>
</tr>
<tr>
<td>从序列构造堆</td>
<td>make_heap()</td>
<td></td>
</tr>
<tr>
<td>给堆排序</td>
<td>sort_heap()</td>
<td></td>
</tr>
<tr>
<td>最大和最小</td>
<td>两个值中较小的</td>
<td>min()</td>
</tr>
<tr>
<td>两个值中较大的</td>
<td>max()</td>
<td></td>
</tr>
<tr>
<td>序列中的最小元素</td>
<td>min_element(a,a+n)</td>
<td></td>
</tr>
<tr>
<td>序列中的最大元素</td>
<td>max_element()</td>
<td></td>
</tr>
<tr>
<td>词典比较</td>
<td>两个序列按字典序的第一个在前</td>
<td>lexicographical_compare()</td>
</tr>
<tr>
<td>排列生成器</td>
<td>按字典序的下一个排列</td>
<td>next_permutation()</td>
</tr>
<tr>
<td>按字典序的前一个排列</td>
<td>prev_permutation()</td>
</tr>
</tbody>
</table>
<h3><span id="cmath">cmath</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">using ::abs; //绝对值</span><br><span class="line"></span><br><span class="line">using ::exp; //指数值</span><br><span class="line"></span><br><span class="line">using ::fabs; //绝对值</span><br><span class="line"></span><br><span class="line">using ::fmod; //求余</span><br><span class="line"></span><br><span class="line">using ::sqrt; //开方</span><br></pre></td></tr></table></figure>
<h3><span id="cstdlib">cstdlib</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">double atof(const char *str);</span><br><span class="line"></span><br><span class="line">把字符串str转换成double类型。等价于：strtod(str, (char**)NULL)。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">int atoi(const char *str);</span><br><span class="line"></span><br><span class="line">把字符串str转换成int类型。等价于：(int)strtol(str, (char**)NULL, 10)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int rand(void);</span><br><span class="line"></span><br><span class="line">产生一个0到RAND_MAX之间的伪随机整数。RAND_MAX值至少为32767。</span><br><span class="line"></span><br><span class="line">void srand(unsigned int seed);</span><br><span class="line"></span><br><span class="line">设置新的伪随机数序列的种子为seed。种子的初值为1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void *malloc(size_t size);</span><br><span class="line"></span><br><span class="line">为大小为size的对象分配足够的内存，并返回指向所分配区域的第一个字节的指针；如果内存不足以满足要求，则返回NULL。</span><br><span class="line"></span><br><span class="line">不对分配的内存区域进行初始化。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void free(void *ptr);</span><br><span class="line"></span><br><span class="line">释放ptr指向的内存空间，若ptr为NULL，则什么也不做。ptr必须指向先前用动态分配函数malloc、realloc或calloc分配的空间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void exit(int status);</span><br><span class="line"></span><br><span class="line">使程序正常终止。atexit函数以与注册相反的顺序被调用，所有打开的文件被刷新，所有打开的流被关闭。status的值如何被返回依具体的实现而定，但用0表示正常终止，也可用值EXIT_SUCCESS和EXIT_FAILURE。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void qsort(void *base, size_t n, size_t size,</span><br><span class="line"></span><br><span class="line">int (*compare)(const void *, const void *));</span><br><span class="line"></span><br><span class="line">对由n个大小为size的对象构成的数组base进行升序排序。</span><br><span class="line"></span><br><span class="line">比较函数compare的形式如下：</span><br><span class="line"></span><br><span class="line">int func_name(const void *arg1, const voie *arg2);</span><br><span class="line"></span><br><span class="line">其返回值必须如下所示：</span><br><span class="line"></span><br><span class="line">arg1 &lt; arg2，返回值&lt;0；</span><br><span class="line"></span><br><span class="line">arg1 == arg2，返回值==0；</span><br><span class="line"></span><br><span class="line">arg1 &gt; arg2，返回值&gt;0。</span><br></pre></td></tr></table></figure>
<h2><span id="c">C</span></h2><p>未完待续（貌似也差不多的说…）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/25/Win10-64位Debug安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/Win10-64位Debug安装/" itemprop="url">Win10-64位Debug安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T10:39:36+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/其它/" itemprop="url" rel="index">
                    <span itemprop="name">其它</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  842
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#正文">正文</a><ul>
<li><a href="#安装">安装</a></li>
<li><a href="#配置">配置</a></li>
<li><a href="#测试">测试</a><ul>
<li><a href="#debug">Debug</a></li>
<li><a href="#debug常用功能">Debug常用功能</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="前言">前言</span></h2><p>由于本学期开设了汇编实验这门课，相对应的，也有了汇编实验的实验课，由于需要用到debug，再加上win10需要配置，不像win7可以直接使用，这里就写一篇博客记录一下配置过程。</p>
<p>其实win10上使用debug一般有两种方法，一种是在电脑上面装上虚拟机，用win7直接使用debug，第二种就是今天介绍的用<strong>DOSBox</strong>来解决。</p>
<h2><span id="正文">正文</span></h2><p>DOSBox是一种<strong>模拟器软件</strong>，主要是在IBM PC兼容机下，模拟旧时的操作系统：MS-DOS，支持许多IBM PC兼容的显卡和声卡，为本地的DOS程序提供执行环境，使这些程序可以正常运行于大多数现代计算机上的不同操作系统。DOSBox特别是为运行早期的计算机游戏所设计，主要以C++编写，是以GNU通用公共许可证许可发布的自由软件。</p>
<p>上面是对DOSBox的简单介绍，摘自维基百科，下面开始介绍具体流程。</p>
<p>首先，众所周知，win10上面是不支持直接使用debug的，如果一旦点击debug.exe的话，会报错。</p>
<p><img src="/2019/03/25/Win10-64位Debug安装/不支持.jpg" alt=""></p>
<h3><span id="安装">安装</span></h3><p>关于debug与DOSBox的下载的话，都可以直接在搜索引擎搜索下载，这里要注意一下DOSBox的下载：</p>
<p><a href="https://www.dosbox.com/download.php?main=1" target="_blank" rel="noopener">DOSBox官网</a>点击进去之后，会看到这样的画面。</p>
<p><img src="/2019/03/25/Win10-64位Debug安装/DOSBox官网.jpg" alt=""></p>
<p>然后就是点击这个，然后进去下载就可以。</p>
<p><img src="/2019/03/25/Win10-64位Debug安装/DOSBox下载.jpg" alt=""></p>
<p>下载完DOSBox之后会发现它是一个安装器，自己选择安装到哪里，但是一定要知道位置。至于debug.exe的安装位置的话，我的建议是，在C盘下面直接建一个<strong>MYDEBUG</strong>的文件夹，然后把相关文件放进去。（我这里的DEBUG是网盘里面找到的，实际上搜索下载的貌似只要一个debug.exe就可以）</p>
<p><img src="/2019/03/25/Win10-64位Debug安装/MYDEBUG.jpg" alt=""></p>
<h3><span id="配置">配置</span></h3><p>安装完成之后，找到DOSBox安装目录下的DOSBox 0.74 Options.bat文件，然后双击:</p>
<p><img src="/2019/03/25/Win10-64位Debug安装/DOSBox文件夹.jpg" alt=""></p>
<p>然后在末尾添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOUNT C C:\MYDEBUG</span><br><span class="line">C:</span><br><span class="line">debug</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/25/Win10-64位Debug安装/DOSBox配置.jpg" alt=""></p>
<p>这样配置的目的很单纯，只是让每次编译的时候不用准备前面这些条件，就可以直接使用，如果每次都要配置，太麻烦。</p>
<h3><span id="测试">测试</span></h3><p>安装配置完之后自然要测试一下能不能用，先介绍一下debug，如下：</p>
<h4><span id="debug">Debug</span></h4><p><strong>Debug是DOS、Windows都提供的实模式(8086方式)程序的调试工具。</strong></p>
<p><strong>使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级别跟踪程序的运行。</strong></p>
<h4><span id="debug常用功能">Debug常用功能</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用Debug的R命令查看、改变CPU寄存器的内容;</span><br><span class="line"></span><br><span class="line"> 用Debug的D命令查看内存中的内容;</span><br><span class="line"></span><br><span class="line"> 用Debug的E命令改写内存中的内容;</span><br><span class="line"></span><br><span class="line"> 用Debug的U命令将内存中的机器指令翻译成汇编指令;</span><br><span class="line"></span><br><span class="line"> 用Debug的T命令执行一条机器指令;</span><br><span class="line"></span><br><span class="line"> 用Debug的A命令以汇编指令的格式在内存中写入一条机器指令;</span><br></pre></td></tr></table></figure>
<p>这里用命令测试一下是否可以使用：</p>
<p><img src="/2019/03/25/Win10-64位Debug安装/测试.jpg" alt=""></p>
<p>绿色部分是之前配置的部分，红色箭头指向的就是命令，实测没问题可以使用，这样就可以开始<strong>愉快的</strong>汇编编程了。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/24/递归递推与试除法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/24/递归递推与试除法/" itemprop="url">递归递推与试除法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T20:49:36+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#递推">递推</a></li>
<li><a href="#递归">递归</a><ul>
<li><a href="#1联系">1.联系</a></li>
<li><a href="#2区别">2.区别</a></li>
</ul>
</li>
<li><a href="#试除法求解素数">试除法（求解素数）</a></li>
</ul>
<!-- tocstop -->
<h2><span id="递推">递推</span></h2><p>递推是一种经常被使用的简单算法，定义是<strong>一种用若干步可重复的简单运算来描述复杂问题的方法。</strong></p>
<p>递推的特点在于，<strong>每一项都和他前面的若干项由一定的关联</strong>，这种关联一般可以通过<strong>递推关系式</strong>来表示，可以通过其前面若干项得出某项的数据。</p>
<p>对于递推问题的求解一般从初始的一个或若干个数据项出发，<strong>通过递推关系式逐步推进，从而得出想要的结果，</strong>这种求解问题的方法叫<strong>递推法</strong>。其中，初始的若干数据项称为<strong>边界</strong>。</p>
<p>简单实例如下：</p>
<p>喜欢西游记的同学肯定都知道悟空偷吃蟠桃的故事，你们一定都觉得这猴子太闹腾了，其实你们是有所不知：悟空是在研究一个数学问题！<br>    什么问题？他研究的问题是蟠桃一共有多少个！<br>    不过，到最后，他还是没能解决这个难题，呵呵^-^<br>    当时的情况是这样的：<br>    第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？</p>
<p>Input<br>    输入数据有多组，每组占一行，包含一个正整数n（1&lt;n&lt;30），表示只剩下一个桃子的时候是在第n天发生的。</p>
<p>Output<br>    对于每组输入数据，输出第一天开始吃的时候桃子的总数，每个测试实例占一行。</p>
<p>Sample Input<br>    2 4</p>
<p>Sample Output</p>
<p>4 22</p>
<p><strong>分析：</strong></p>
<p>这其实就是一个<strong>递推问题</strong>，需要注意的是，<strong>一般而言递推的计算效率要大于递归</strong>。由题意得f(n) = 2 * ( f(n-1) + 1 )，另外f(1)=1。这就可以求解出相应的答案了，由于题目太简单，这里只写思路。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int peach(int n) &#123;//这里就是递推</span><br><span class="line">    if(n == 1)</span><br><span class="line">        return 1;</span><br><span class="line">    else &#123;</span><br><span class="line">        long res = 1L;</span><br><span class="line">        while(--n)</span><br><span class="line">            res = 2 * (res + 1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line"> </span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;n) != EOF)</span><br><span class="line">        printf(&quot;%d\n&quot;, peach(n));</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="递归">递归</span></h2><p>上面说到，一般来说，递推的计算效率是高于递归的，那么递归与递推有什么区别和联系呢？</p>
<h3><span id="1联系">1.联系</span></h3><p>递归和递推有一定的相似性。<br>    这两个问题都可以描述为以下形式：<br>    <strong>f(n)=g(f(n-1)，…，f(0))</strong><br>    这是二者的共同特点。</p>
<h3><span id="2区别">2.区别</span></h3><p>1）递归表现出来的是<strong>自己调用自己</strong>，递推则没有这样的形式。</p>
<p>2）递归是从问题的<strong>最终目标</strong>出发，将问题<strong>简单化</strong>，这就是<strong>逆向的</strong>求解。</p>
<p>递推则是从<strong>简单问题</strong>出发，<strong>正向的</strong>解决问题。</p>
<p>3）递归中，<strong>n是已知的</strong>。递推则可以是在计算中知道，不需要提前知道。</p>
<p>4）一般来说，<strong>递推的效率是大于递归的。</strong></p>
<h2><span id="试除法求解素数">试除法（求解素数）</span></h2><p>一般来说，求解素数的话，要用到两种方式，<strong>一个是试除法一个是筛选法</strong>，<a href="https://thbelief.coding.me/2019/03/21/%E5%88%86%E6%8B%86%E7%B4%A0%E6%95%B0%E5%92%8C/">这篇博客</a>里面就写到了Eratosthenes筛选法，这里的话就介绍一下另外一种方法，试除法。试除法其实一般有很多种，这里只介绍一点。大致知道算法就行，现场写也可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">/*</span><br><span class="line">质数：一个自然数，如果只有1和它本身两个约数，这个数叫做质数（也称素数）．</span><br><span class="line">对于一个整数n，只需用小于等于√n所有素数去除，所以本算法的时间复杂度为O(√)的。</span><br><span class="line">*/</span><br><span class="line">bool IsPrime(int n,int prime[],int length)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for(i = 2; (long long)i*i &lt;= n&amp;&amp;prime[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(n %i == 0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/23/java基础-略知一二/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/23/java基础-略知一二/" itemprop="url">java基础-略知一二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-23T17:45:45+08:00">
                2019-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#collection">Collection</a></li>
<li><a href="#set">Set</a><ul>
<li><a href="#hashset">HashSet</a></li>
<li><a href="#linkedhashset">LinkedHashSet</a></li>
<li><a href="#sortedset">SortedSet</a></li>
<li><a href="#treeset">TreeSet</a></li>
</ul>
</li>
<li><a href="#list">List</a></li>
<li><a href="#arraylist">ArrayList</a><ul>
<li><a href="#构造方法">构造方法</a></li>
</ul>
</li>
<li><a href="#linkedlist">LinkedList</a><ul>
<li><a href="#构造方法-1">构造方法</a></li>
</ul>
</li>
<li><a href="#map">Map</a><ul>
<li><a href="#特性">特性</a></li>
<li><a href="#方法">方法</a></li>
</ul>
</li>
<li><a href="#hashmap">HashMap</a><ul>
<li><a href="#常用操作">常用操作</a></li>
</ul>
</li>
<li><a href="#iterator">Iterator</a></li>
</ul>
<!-- tocstop -->
<h2><span id="collection">Collection</span></h2><p><strong>集合中只能放置对象的引用，不能放置原生数据类型。</strong></p>
<p>常用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 将所有元素从一个列表复制到另一个列表</span><br><span class="line">Collections.copy(new ArrayList(), new ArrayList());</span><br><span class="line">// 如果两个指定collection中没有相同的元素,则返回 true</span><br><span class="line">Collections.disjoint(new ArrayList(), new ArrayList());</span><br><span class="line">// 使用指定元素替换指定列表中的所有元素</span><br><span class="line">Collections.fill(new ArrayList(), new Object());</span><br><span class="line">// 返回指定 collection 中等于指定对象的元素数</span><br><span class="line">Collections.frequency(new ArrayList(), new Object());</span><br><span class="line">// 返回指定源列表中第一次出现指定目标列表的起始位置,如果没有出现这样的列表,则返回 -1</span><br><span class="line">Collections.indexOfSubList(new ArrayList(), new ArrayList());</span><br><span class="line">// 根据元素的自然顺序，返回给定 collection 的最大元素</span><br><span class="line">Collections.max(new ArrayList());</span><br><span class="line">// //根据元素的自然顺序，返回给定 collection 的最大元素</span><br><span class="line">Collections.min(new ArrayList());</span><br><span class="line">// 使用另一个值替换列表中出现的所有某一指定值</span><br><span class="line">Collections.replaceAll(new ArrayList(), &quot;oldVal&quot;, &quot;newVal&quot;);</span><br><span class="line">// 反转指定列表中元素的顺序</span><br><span class="line">Collections.reverse(new ArrayList());</span><br><span class="line">// 返回一个比较器,它强行反转</span><br><span class="line">Collections.reverseOrder();</span><br><span class="line">// 返回一个比较器,它强行反转指定比较器的顺序</span><br><span class="line">Collections.reverseOrder(new Comparator() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public int compare(Object o1, Object o2) &#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 使用默认随机源随机更改指定列表的序列</span><br><span class="line">Collections.shuffle(new ArrayList());</span><br><span class="line">// 根据元素的自然顺序对指定列表按升序进行排序</span><br><span class="line">Collections.sort(new ArrayList());</span><br><span class="line">// 根据元素的自然顺序对指定列表按降序进行排序</span><br><span class="line">Collections.sort(new ArrayList(), Collections.reverseOrder());</span><br><span class="line">// 在指定列表的指定位置处交换元素</span><br><span class="line">Collections.swap(new ArrayList(), 1, 2);</span><br></pre></td></tr></table></figure>
<h2><span id="set">Set</span></h2><p><strong>实现类：HashSet,LinkedHashSet.</strong></p>
<p><strong>子接口：SortSet，TreeSet.</strong></p>
<p>不包含重复元素，最多包含一个null，元素没有顺序。</p>
<h3><span id="hashset">HashSet</span></h3><p>HashSet不是Ordered也不是Sorted,存储对象引用时是按照<strong>哈希策略</strong>来实现的,<br>    HashSet中是否存在一个对象是通过<strong>equals()</strong>和<strong>hashCode()</strong>协同判断，不保证顺序。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashSet()  </span><br><span class="line">public HashSet(int initialCapacity)  </span><br><span class="line">public HashSet(Collection c)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public HashSet(Collection c)</span><br></pre></td></tr></table></figure>
<p>HashSet底层是使用<strong>HashMap</strong>实现的<br>HashSet的add()方法详解:<br>    <strong>判断已经存储在集合中的对象hashCode值是否与增加对象的hashCode值一致。</strong><br>    如果不一致,直接加进去。<br>    如果一致,再进行equals()比较，如果equals()返回true,对象已经存在不增加进去，如果equals()返回false,把对象增加进去。</p>
<h3><span id="linkedhashset">LinkedHashSet</span></h3><p>LinkedHashSet是Ordered,采用<strong>双链表</strong>实现的，有<strong>固定顺序</strong>,也就是插入顺序。<br>LinkedHashSet底层是使用<strong>LinkedHashMap</strong>实现的。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashSet()  </span><br><span class="line">public LinkedHashSet(int initialCapacity)  </span><br><span class="line">public LinkedHashSet(Collection c)</span><br></pre></td></tr></table></figure>
<h3><span id="sortedset">SortedSet</span></h3><p><strong>保证迭代器按照元素递增顺序遍历的集合,可以按照元素的自然顺序进行排序。</strong></p>
<p><strong>常用方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object first()</span><br><span class="line">		 返回此有序集合中当前第一个(最小的)元素</span><br><span class="line">	Object last()</span><br><span class="line">		返回此有序集合中最后一个(最大的)元素</span><br><span class="line">	SortedSet headSet(Object toElement)</span><br><span class="line">		返回此有序集合的部分视图,其元素严格小于toElement</span><br><span class="line">	SortedSet tailSet(Object fromElement)</span><br><span class="line">		返回此有序集合的部分视图,其元素大于或等于fromElement</span><br><span class="line">	SortedSet subSet(Object fromElement,Object toElement)</span><br><span class="line">		返回此有序集合的部分视图,元素范围从fromElement(包括)到toElement(不包括)</span><br><span class="line">	Comparator comparator()</span><br><span class="line">		返回与此有序集合关联的比较器,如果使用元素的自然顺序,则返回 null</span><br></pre></td></tr></table></figure>
<h3><span id="treeset">TreeSet</span></h3><p>TreeSet是SortedSet接口的实现,<strong>元素不论以什么元素插入,在遍历的时候,都会以天然顺序遍历</strong>。因为它是自带排序的，所以如果想要增加自定义类型就必须指定排序的规则。<br>TreeSet底层是使用<strong>TreeMap</strong>实现的。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public TreeSet()</span><br><span class="line">public TreeSet(SortedSet s)  </span><br><span class="line">public TreeSet(int initialCapacity)</span><br><span class="line">public TreeSet(Comparator&lt;? super E&gt;)</span><br><span class="line">public TreeSet(Collection c)</span><br></pre></td></tr></table></figure>
<h2><span id="list">List</span></h2><p>具有<strong>列表</strong>的功能,元素顺序均是<strong>按添加的先后进行排列的,</strong>允许<strong>重复的</strong>元素,允许多个null元素。</p>
<p><strong>常用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">// 向列表的尾部追加指定的元素</span><br><span class="line">list.add(&quot;lwc&quot;);</span><br><span class="line">// 在列表的指定位置插入指定元素</span><br><span class="line">list.add(1, &quot;nxj&quot;);</span><br><span class="line">// 追加指定 collection 中的所有元素到此列表的结尾</span><br><span class="line">list.addAll(new ArrayList());</span><br><span class="line">// 从列表中移除所有元素</span><br><span class="line">list.clear();</span><br><span class="line">// 如果列表包含指定的元素,则返回true</span><br><span class="line">list.contains(&quot;nxj&quot;);</span><br><span class="line">// 如果列表包含指定 collection 的所有元素,则返回 true</span><br><span class="line">list.containsAll(new ArrayList());</span><br><span class="line">// 比较指定的对象与列表是否相等</span><br><span class="line">list.equals(new ArrayList());</span><br><span class="line">// 返回列表中指定位置的元素</span><br><span class="line">list.get(0);</span><br><span class="line">// 返回列表的哈希码值</span><br><span class="line">list.hashCode();</span><br><span class="line">// 返回列表中首次出现指定元素的索引,如果列表不包含此元素,则返回 -1</span><br><span class="line">list.indexOf(&quot;lwc&quot;);</span><br><span class="line">// 返回列表中最后出现指定元素的索引,如果列表不包含此元素,则返回 -1</span><br><span class="line">list.lastIndexOf(&quot;lwc&quot;);</span><br><span class="line">// 如果列表不包含元素,则返回 true</span><br><span class="line">list.isEmpty();</span><br><span class="line">// 移除列表中指定位置的元素</span><br><span class="line">list.remove(0);</span><br><span class="line">// 移除列表中出现的首个指定元素</span><br><span class="line">list.remove(&quot;lwc&quot;);</span><br><span class="line">// 从列表中移除指定 collection 中包含的所有元素</span><br><span class="line">list.removeAll(new ArrayList());</span><br><span class="line">// 用指定元素替换列表中指定位置的元素</span><br><span class="line">list.set(0, &quot;lp&quot;);</span><br><span class="line">// 返回列表中的元素数</span><br><span class="line">list.size();</span><br><span class="line">// 返回列表中指定的fromIndex(包括)和toIndex(不包括)之间的部分视图</span><br><span class="line">list.subList(1, 2);</span><br><span class="line">// 返回以正确顺序包含列表中的所有元素的数组</span><br><span class="line">list.toArray();</span><br><span class="line">// 返回以正确顺序包含列表中所有元素的数组</span><br><span class="line">list.toArray(new String[] &#123; &quot;a&quot;, &quot;b&quot; &#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="arraylist">ArrayList</span></h2><h3><span id="构造方法">构造方法</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList()</span><br><span class="line">public ArrayList(int initialCapacity)</span><br><span class="line">public ArrayList(Collection c)</span><br></pre></td></tr></table></figure>
<p> ArrayList依赖于<strong>数组</strong>实现的,初始长度为10的Object[],并且可随需要而增加的<strong>动态数组</strong>。<br>    当元素超过10,那么ArrayList底层会<strong>新生成一个数组,</strong>长度为原来的1.5倍+1,然后将原数组内容复制到新数组中,并且后续增加的内容会放到新数组中,当新数组无法容纳增加的元素,重复该过程即可。</p>
<h2><span id="linkedlist">LinkedList</span></h2><p>LinkedList功能与ArrayList,Vector相同,内部是<strong>依赖双链表实现</strong>的,因此有很好的插入和删除性能,但随机访问元素的性能很差。</p>
<h3><span id="构造方法">构造方法</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList()</span><br><span class="line">public LinkedList(Collection c)</span><br></pre></td></tr></table></figure>
<p>LinkedList类中有一个<strong>Entry内部类</strong>,Entry内部类包含3个部分<strong>向前的引用,向后的引用,数据</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header.next = header.previous = header;</span><br></pre></td></tr></table></figure>
<h2><span id="map">Map</span></h2><p><strong>Map接口中键和值一一映射. 可以通过键来获取值.</strong></p>
<h3><span id="特性">特性</span></h3><ul>
<li>给定一个键和一个值，你可以将该值存储在一个Map对象. 之后，你可以通过键来访问对应的值。</li>
<li>当访问的值不存在的时候，方法就会抛出一个NoSuchElementException异常。</li>
<li>当对象的类型和Map里元素类型不兼容的时候，就会抛出一个 ClassCastException异常。</li>
<li>当在不允许使用Null对象的Map中使用Null对象，会抛出一个NullPointerException 异常。</li>
<li>当尝试修改一个只读的Map时，会抛出一个UnsupportedOperationException异常。</li>
</ul>
<h3><span id="方法">方法</span></h3><table>
<thead>
<tr>
<th>1</th>
<th>void clear( )  从此映射中移除所有映射关系（可选操作）。</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>boolean containsKey(Object k) 如果此映射包含指定键的映射关系，则返回 true。</td>
</tr>
<tr>
<td>3</td>
<td>boolean containsValue(Object v) 如果此映射将一个或多个键映射到指定值，则返回 true。</td>
</tr>
<tr>
<td>4</td>
<td>Set entrySet( ) 返回此映射中包含的映射关系的 Set 视图。</td>
</tr>
<tr>
<td>5</td>
<td>boolean equals(Object obj) 比较指定的对象与此映射是否相等。</td>
</tr>
<tr>
<td>6</td>
<td>Object get(Object k) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</td>
</tr>
<tr>
<td>7</td>
<td>int hashCode( ) 返回此映射的哈希码值。</td>
</tr>
<tr>
<td>8</td>
<td>boolean isEmpty( ) 如果此映射未包含键-值映射关系，则返回 true。</td>
</tr>
<tr>
<td>9</td>
<td>Set keySet( ) 返回此映射中包含的键的 Set 视图。</td>
</tr>
<tr>
<td>10</td>
<td>Object put(Object k, Object v) 将指定的值与此映射中的指定键关联（可选操作）。</td>
</tr>
<tr>
<td>11</td>
<td>void putAll(Map m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。</td>
</tr>
<tr>
<td>12</td>
<td>Object remove(Object k) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</td>
</tr>
<tr>
<td>13</td>
<td>int size( ) 返回此映射中的键-值映射关系数。</td>
</tr>
<tr>
<td>14</td>
<td>Collection values( ) 返回此映射中包含的值的 Collection 视图。</td>
</tr>
</tbody>
</table>
<h2><span id="hashmap">HashMap</span></h2><h3><span id="常用操作">常用操作</span></h3><p>1.第一步就是给HashMap里面put一些<strong>键值对</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		hashMap.put(5, 2);</span><br><span class="line">		hashMap.put(9, 2);</span><br><span class="line">		hashMap.put(8, 1);</span><br><span class="line">		hashMap.put(7, 3);</span><br><span class="line">		hashMap.put(16, 1);</span><br><span class="line">		hashMap.put(10, 2);</span><br><span class="line">		hashMap.put(6, 2);</span><br><span class="line">		//下面两个键值对是没有存的，因为key存过的不会重复存储，只会覆盖之前的vlue</span><br><span class="line">		hashMap.put(5, 2);</span><br><span class="line">		hashMap.put(5, 3);</span><br></pre></td></tr></table></figure>
<p>2.containsKey(Object key)方法，返回值为boolean，用于<strong>判断当前HashMap中是否包含key对应的key-value</strong>。</p>
<p>3.containsValue(Object value)方法，返回值为boolean，用于<strong>判断当前HashMap中是否包含value对应的key-value</strong>。</p>
<p>4.遍历HashMap的两种方式：</p>
<p>1）利用haspmap.entrySet().iterator()：利用迭代器，从Entry中取出键、取出值，推荐使用这种方式进行遍历，效率较高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;Integer, Integer&gt;&gt; iterator = hashMap.entrySet().iterator();</span><br><span class="line">		while (iterator.hasNext()) &#123;</span><br><span class="line">			Entry&lt;Integer, Integer&gt; entry = iterator.next();</span><br><span class="line">			Integer key = entry.getKey();</span><br><span class="line">			Integer value = entry.getValue();</span><br><span class="line">			System.out.print(key + &quot;---&gt;&quot; + value);</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>2）利用hashmap.keySet().iterator()：利用键的迭代器，每次取出一个键，再根据键，从HashMap中取出值，这种方式的效率不高，不推荐使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator2 = hashMap.keySet().iterator();</span><br><span class="line">		while (iterator2.hasNext()) &#123;</span><br><span class="line">			Integer key = iterator2.next();</span><br><span class="line">			Integer value = hashMap.get(key);</span><br><span class="line">			System.out.print(key + &quot;---&quot; + value);</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/u013398759/article/details/77679632" target="_blank" rel="noopener">参考链接</a></p>
<h2><span id="iterator">Iterator</span></h2><p> 在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：<strong>对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。</strong>迭代器与枚举有两点不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。</span><br><span class="line"></span><br><span class="line">2、方法名称得到了改进。</span><br></pre></td></tr></table></figure>
<p><strong>接口定义：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line">　　boolean hasNext();</span><br><span class="line">　　Object next();</span><br><span class="line">　　void remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Object next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型。</p>
<p>boolean hasNext()：判断容器内是否还有可供访问的元素。</p>
<p>void remove()：删除迭代器刚越过的元素。</p>
<p><strong>未完待续~~~</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/22/java基础-略有小成/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/22/java基础-略有小成/" itemprop="url">java基础-略有小成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-22T22:00:24+08:00">
                2019-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#基本数据类型">基本数据类型</a><ul>
<li><a href="#种类">种类</a></li>
<li><a href="#占用空间">占用空间</a></li>
<li><a href="#类型转换">类型转换</a></li>
</ul>
</li>
<li><a href="#包装类">包装类</a><ul>
<li><a href="#类型转换方法">类型转换方法</a></li>
<li><a href="#引用问题">引用问题</a></li>
</ul>
</li>
<li><a href="#system类">System类</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#成员变量">成员变量</a></li>
<li><a href="#成员方法">成员方法</a></li>
</ul>
</li>
<li><a href="#runtime类">RunTime类</a></li>
<li><a href="#date与dateformat">Date与DateFormat</a><ul>
<li><a href="#构造函数">构造函数</a></li>
<li><a href="#方法">方法</a></li>
<li><a href="#日期比较">日期比较</a></li>
<li><a href="#simpledateformat格式化日期">SimpleDateFormat格式化日期</a></li>
<li><a href="#格式化编码">格式化编码</a></li>
<li><a href="#printf格式化日期">printf格式化日期</a></li>
<li><a href="#解析字符串">解析字符串</a></li>
<li><a href="#sleep">sleep</a></li>
</ul>
</li>
<li><a href="#calendar类与gregoriancalendar类">Calendar类与GregorianCalendar类</a></li>
</ul>
<!-- tocstop -->
<h2><span id="基本数据类型">基本数据类型</span></h2><h3><span id="种类">种类</span></h3><p><img src="/2019/03/22/java基础-略有小成/基本数据类型.jpg" alt=""></p>
<p>讲到基本类型的话，不可避免的就是<strong>字面量值</strong>，其实它的意思就是<strong>表面上的值。</strong></p>
<p>byte、short、int、long类型变量都可以赋予整型字面量值，譬如byte a = 10、short b = 0x45都是合法的赋值操作。Java编译器在编译是会检查字面量值所表示的数字大小是否处于变量类型的合法范围内，如果不在，则无法通过编译。如果多种数值类型的数据进行数学运算时，计算结果的类型是其中这些数值中<strong>最高等级或者其更高等级类型。</strong></p>
<h3><span id="占用空间">占用空间</span></h3><p>byte（字节）用<strong>无符号的8位</strong>表示，它的取值范围是[-2^7, 2^7-1]。它是最小的整型类型，默认值是0。<br>    short（短整型）用<strong>有符号的16位</strong>表示，它的取值范围是[-2^15, 2^15-1]。默认值是0。<br>    int（整型）用有符号的32位表示，它的取值范围是[-2^31, 2^31-1]，计算机中用存放的是整型数值的<strong>二进制补码</strong>。默认值是0。<br>    long（长整型）用<strong>有符号的64位</strong>表示，它的取值范围是[-2^63, 2^63-1]。它的字面量表示以l或者L结束，如 long a = 45454L。默认值是0L。<br>    float（单精度浮点型）用<strong>32位</strong>表示，float类型字面量值通常以f或者F结束。由于整型可以自动转换为float类型，所以，也可以将整型字面量值直接赋予float类型变量。默认值是<strong>0F</strong>。<br>    double（双精度浮点型）用<strong>64位</strong>表示，遵循IEEE 754规范。它能表示比float更高精度的数值。double是Java基本类型中能达到的最高精度，如果还不能满足要求，可以使用Java中的<strong>BigDecimal</strong>类。默认值是0.0。<br>    char（字符）用<strong>无符号的16位</strong>表示，它的取值范围是[0, 2^16-1]。Java中使用<strong>Unicode字符集</strong>来表示字符，Unicode将人类语言的所有已知字符映射成16位数字，所以Java中的char是16位的。默认值是\u00000。</p>
<p>boolean（ 布尔型）只要<strong>true和false</strong>两个字面量值，可用于逻辑判断。boolean只能表示1位的信息量，但是它的大小并没有精确地定义。</p>
<h3><span id="类型转换">类型转换</span></h3><p>在JAVA里面除了boolean类型之外，其他7中类型相互之间可以<strong>进行转换</strong>。转换分为<strong>自动转换</strong>和<strong>强制转换</strong>。对于自动转换（隐式），无需任何操作，而强制类型转换需要<strong>显式转换</strong>，即使用转换操作符（type）。</p>
<p>占用空间大小进行排序：<strong>byte &lt;（short=char）&lt; int &lt; long &lt; float &lt; double</strong></p>
<p>类型转换的总则是：<strong>小可直接转大、大转小会失去精度</strong>。小转大是Java帮我们自动进行转换的，与正常的赋值操作完全一样；大转小需要进行强制转换操作，其语法是<strong>target-type var =（target-type） value</strong>。</p>
<p><strong>特别注意：大转小有可能在某些情况下产生不可预估的问题。</strong></p>
<h2><span id="包装类">包装类</span></h2><p>Java里面的每一种<strong>基本类型</strong>都会对应一个<strong>唯一的</strong>包装类，基本类型与其包装类都可以通过包装类中的<strong>静态</strong>或者<strong>成员方法</strong>进行转换。所有的包装类都是<strong>final</strong>修饰的，也就是它们都是<strong>无法被继承和重写</strong>的。</p>
<p><img src="/2019/03/22/java基础-略有小成/包装类.jpg" alt=""></p>
<p><strong>基础类型和包装类型都可以通过赋值语法赋值给对立的变量类型。</strong></p>
<h3><span id="类型转换方法">类型转换方法</span></h3><p><img src="/2019/03/22/java基础-略有小成/类型转换方法.jpg" alt=""></p>
<h3><span id="引用问题">引用问题</span></h3><p>在Java中，“==”符号判断的<strong>内存地址</strong>所对应的值的<strong>相等性</strong>，具体来说，<strong>基本类型判断值是否相等</strong>，<strong>引用类型判断其指向的地址是否相等。</strong></p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a1 = 1;</span><br><span class="line">Integer a2 = 1;</span><br><span class="line">System.out.println(a1 == a2); // true</span><br><span class="line"></span><br><span class="line">Integer b1 = 222;</span><br><span class="line">Integer b2 = 222;</span><br><span class="line">System.out.println(b1 == b2); // false</span><br></pre></td></tr></table></figure>
<p>这是为什么呢？</p>
<p>如果打开Integer类中的valueOf()方法会发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) // 判断实参是否在可缓存范围内，默认为[-128, 127]</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)]; // 如果在，则取出初始化的Integer对象</span><br><span class="line">    return new Integer(i); // 如果不在，则创建一个新的Integer对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于1属于[-128, 127]集合范围内，所以valueOf()每次都会取出<strong>同一个Integer对象</strong>，故第一个“==”判断结果为true；</p>
<p>而222不属于[-128, 127]集合范围内，所以valueOf()每次都会创建一个<strong>新的Integer对象</strong>，由于两个新创建的对象的地址不一样，故第一个“==”判断结果为false。</p>
<p><a href="https://blog.csdn.net/xialei199023/article/details/63251295" target="_blank" rel="noopener">参考链接</a></p>
<h2><span id="system类">System类</span></h2><h3><span id="简介">简介</span></h3><p>system类在java中的作用其实就是类似于<strong>系统</strong>的作用，它的内部包含了很多系统级别的<strong>属性以及控制方法</strong>。</p>
<h3><span id="成员变量">成员变量</span></h3><p>主要就是包含了<strong>in（标准输入流，键盘输入），out（标准输出流，显示器）以及err（标准错误输出流）。</strong></p>
<p><strong>out与err的差别</strong></p>
<p>System.out在JVM和操作系统都具有缓存功能，其实就是输出的数据<strong>不一定实时输出</strong>，有时候会积攒到一定数量才会输出；System.err会<strong>实时输出</strong>。</p>
<h3><span id="成员方法">成员方法</span></h3><p>1.static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</p>
<p>该方法的作用是<strong>数组拷贝</strong>，src为被拷贝的数组，srcPos为src要拷贝的初始位置，dest为目的数组，目的数组dest放置拷贝数据的初始位置，length为从src拷贝到的数据长度。</p>
<p>2.static long currentTimeMillis()<br>    该方法的作用是<strong>返回当前的计算机时间</strong>，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
<p>3.static void exit(int status)<br>    该方法的作用是<strong>退出程序</strong>。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
<p>4.static void gc()<br>    请求系统进行<strong>垃圾回收</strong>。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p>
<p>5.static Properties getProperties()<br>    <strong>获取系统的属性信息</strong>，并存储到Properties集合中。Properties集合中存储的都是String类型的键值对。</p>
<p>6.static String getProperty(String key)</p>
<p><strong>获得系统中属性名为key的属性对应的值</strong>。系统中常见的属性名以及属性的作用如下表所示：</p>
<p><img src="/2019/03/22/java基础-略有小成/属性.jpg" alt=""></p>
<p>7.static String setProperty(String key, String value)<br>    给系统<strong>设置一些属性信息</strong>，这些信息是全局的，其他程序都可以使用。</p>
<h2><span id="runtime类">RunTime类</span></h2><p>Runtime类<strong>封装了运行时的环境</strong>。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。该类<strong>无法创建对象</strong>。</p>
<p><strong>常用方法</strong><br>    <strong>static Runtime getRuntime() 返回一个Runtime实例</strong>。<br>    <strong>Process exec(String command) 指定某个exe文件并返回该程序进程，参数command为本地exe文件路径。</strong></p>
<p><strong>long freeMemory() 返回Java虚拟机中的空闲内存量，以字节为单位</strong><br>    <strong>long maxMemory() 返回Java虚拟机试图使用的最大内存量</strong></p>
<p><strong>long totalMemory() 返回Java虚拟机中的内存总量</strong></p>
<h2><span id="date与dateformat">Date与DateFormat</span></h2><p>Date是Java中提供来<strong>封装当前的日期与时间</strong>的类。</p>
<h3><span id="构造函数">构造函数</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date( );//使用当前日期和时间来初始化对象。</span><br><span class="line">Date(long millisec);//接收一个参数，该参数是从1970年1月1日起的毫秒数。</span><br></pre></td></tr></table></figure>
<h3><span id="方法">方法</span></h3><p><img src="/2019/03/22/java基础-略有小成/方法.jpg" alt=""></p>
<h3><span id="日期比较">日期比较</span></h3><p> 使用 <strong>getTime()</strong> 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。<br>    使用方法 <strong>before()，after() 和 equals()</strong>。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。<br>    使用 <strong>compareTo()</strong> 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。</p>
<h3><span id="simpledateformat格式化日期">SimpleDateFormat格式化日期</span></h3><p>SimpleDateFormat 允许用户选择<strong>任何自定义日期时间格式</strong>来运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import  java.util.*;</span><br><span class="line">import java.text.*;</span><br><span class="line"> </span><br><span class="line">public class DateDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line"> </span><br><span class="line">      Date dNow = new Date( );</span><br><span class="line">      /*这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。*/</span><br><span class="line">      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">      System.out.println(&quot;当前时间为: &quot; + ft.format(dNow));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="格式化编码">格式化编码</span></h3><table>
<thead>
<tr>
<th><strong>字母</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>纪元标记</td>
<td>AD</td>
</tr>
<tr>
<td>y</td>
<td>四位年份</td>
<td>2001</td>
</tr>
<tr>
<td>M</td>
<td>月份</td>
<td>July or 07</td>
</tr>
<tr>
<td>d</td>
<td>一个月的日期</td>
<td>10</td>
</tr>
<tr>
<td>h</td>
<td>A.M./P.M. (1~12)格式小时</td>
<td>12</td>
</tr>
<tr>
<td>H</td>
<td>一天中的小时 (0~23)</td>
<td>22</td>
</tr>
<tr>
<td>m</td>
<td>分钟数</td>
<td>30</td>
</tr>
<tr>
<td>s</td>
<td>秒数</td>
<td>55</td>
</tr>
<tr>
<td>S</td>
<td>毫秒数</td>
<td>234</td>
</tr>
<tr>
<td>E</td>
<td>星期几</td>
<td>Tuesday</td>
</tr>
<tr>
<td>D</td>
<td>一年中的日子</td>
<td>360</td>
</tr>
<tr>
<td>F</td>
<td>一个月中第几周的周几</td>
<td>2 (second Wed. in July)</td>
</tr>
<tr>
<td>w</td>
<td>一年中第几周</td>
<td>40</td>
</tr>
<tr>
<td>W</td>
<td>一个月中第几周</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>A.M./P.M. 标记</td>
<td>PM</td>
</tr>
<tr>
<td>k</td>
<td>一天中的小时(1~24)</td>
<td>24</td>
</tr>
<tr>
<td>K</td>
<td>A.M./P.M. (0~11)格式小时</td>
<td>10</td>
</tr>
<tr>
<td>z</td>
<td>时区</td>
<td>Eastern Standard Time</td>
</tr>
<tr>
<td>‘</td>
<td>文字定界符</td>
<td>Delimiter</td>
</tr>
<tr>
<td>“</td>
<td>单引号</td>
<td>`</td>
</tr>
</tbody>
</table>
<h3><span id="printf格式化日期">printf格式化日期</span></h3><p>printf 方法可以很轻松地格式化时间和日期。使用<strong>两个字母</strong>格式，它以 <strong>%t</strong> 开头并且以下面表格中的一个字母结尾。</p>
<table>
<thead>
<tr>
<th>转  换  符</th>
<th>说    明</th>
<th>示    例</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>包括全部日期和时间信息</td>
<td>星期六 十月 27 14:21:20 CST 2007</td>
</tr>
<tr>
<td>F</td>
<td>“年-月-日”格式</td>
<td>2007-10-27</td>
</tr>
<tr>
<td>D</td>
<td>“月/日/年”格式</td>
<td>10/27/07</td>
</tr>
<tr>
<td>r</td>
<td>“HH:MM:SS PM”格式（12时制）</td>
<td>02:25:51 下午</td>
</tr>
<tr>
<td>T</td>
<td>“HH:MM:SS”格式（24时制）</td>
<td>14:28:16</td>
</tr>
<tr>
<td>R</td>
<td>“HH:MM”格式（24时制）</td>
<td>14:28</td>
</tr>
</tbody>
</table>
<h3><span id="解析字符串">解析字符串</span></h3><p><strong>SimpleDateFormat 类的parse()方法来按照对应的格式化存储来解析字符串。</strong></p>
<h3><span id="sleep">sleep</span></h3><p>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(1000);   // 休眠1秒</span><br></pre></td></tr></table></figure>
<h2><span id="calendar类与gregoriancalendar类">Calendar类与GregorianCalendar类</span></h2><p>略…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/21/分拆素数和/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/分拆素数和/" itemprop="url">分拆素数和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T15:27:21+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  922
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#题目内容">题目内容</a></li>
<li><a href="#题目分析">题目分析</a></li>
<li><a href="#eratosthenes筛选法">Eratosthenes筛选法</a></li>
<li><a href="#试探法回溯法">试探法（回溯法）</a></li>
<li><a href="#代码详解">代码详解</a></li>
</ul>
<!-- tocstop -->
<h2><span id="题目内容">题目内容</span></h2><p><img src="/2019/03/21/分拆素数和/题目.jpg" alt=""></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2098" target="_blank" rel="noopener">原题链接</a></p>
<h2><span id="题目分析">题目分析</span></h2><p>很明显，本题的要求是要求解<strong>分解的个数</strong>，主要思路就是利用Eratosthenes筛选法来求必要的素数，然后用试探法来求分解的个数。</p>
<p><strong>原理：对于任何一个可以分解为两个素数之和的偶数，其中一个必然是小于或者等于1/2的。</strong></p>
<h2><span id="eratosthenes筛选法">Eratosthenes筛选法</span></h2><p><strong>筛选法又称筛法</strong>，具体做法是：先把N个自然数按次序排列起来。1不是质数，也不是合数，要划去。第二个数2是质数留下来，而把2后面所有能被2整除的数都划去。2后面第一个没划去的数是3，把3留下，再把3后面所有能被3整除的数都划去。3后面第一个没划去的数是5，把5留下，再把5后面所有能被5整除的数都划去。<strong>这样一直做下去，就会把不超过N的全部合数都筛掉，留下的就是不超过N的全部质数。</strong></p>
<p>（合数：一个正整数，除了1和它本身以外，还能被其他正整数整除，这个数就叫做合数。）</p>
<p>（质数（prime number）又称<a href="https://baike.baidu.com/item/%E7%B4%A0%E6%95%B0/115069" target="_blank" rel="noopener">素数</a>，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他<a href="https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0/9539111" target="_blank" rel="noopener">因数</a>。）</p>
<p><strong>埃拉托斯特尼筛选法</strong>是最为知名的产生素数的筛选法，适用于产生<strong>最小的N个素数</strong>。</p>
<p>该方法的唯一缺点是使用的存储空间大，可以进一步改进。</p>
<p>另外，该算法也<strong>不适用于计算某个范围内的全部素数</strong>。</p>
<h2><span id="试探法回溯法">试探法（回溯法）</span></h2><p>先选择某一种可能的情况进行试探，在试探过程中，一旦发现此选择的假设是错误的，就退回一步重新选择，继续向前试探，如此反复进行，直到证明解或者无解。</p>
<h2><span id="代码详解">代码详解</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define Max 10000</span><br><span class="line">using namespace std;</span><br><span class="line">//Eratosthenes筛选法</span><br><span class="line">void eratosthenesFunction(int num[],int n)</span><br><span class="line">&#123;</span><br><span class="line">	//两个参数一个是筛选的数组，一个是筛选的最大值</span><br><span class="line">	//由于数组在函数中修改的值类似于取址赋值，这里直接里面修改外面也修改了</span><br><span class="line">	num[0]=num[1]=0;</span><br><span class="line">	num[2]=1;//从2开始的质数才算进去</span><br><span class="line">	//首先先初始化，把所有质数序号的数组值赋值为1</span><br><span class="line">	for(int i=3;i&lt;=n;i++)</span><br><span class="line">	&#123; </span><br><span class="line">		num[i]=1;</span><br><span class="line">		i++; </span><br><span class="line">		num[i]=0;	</span><br><span class="line">	&#125; </span><br><span class="line">	int max=sqrt(n);</span><br><span class="line">	for(int i=3;i&lt;=max;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		//下面就开始筛选了，把所有的之前出现过的质数的倍数给去掉 </span><br><span class="line">		if(num[i])&#123;</span><br><span class="line">			for(int j=i+i;j&lt;n;j+=i)&#123;</span><br><span class="line">				num[j]=0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int num[Max+1]=&#123;0&#125;;//因为我们算的都是正数，意思是没有用到下标为0的 </span><br><span class="line">	int sum,count;//依次表示的是输入的正数和拆分个数</span><br><span class="line">	eratosthenesFunction(num,Max);//送进去筛选</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		cin&gt;&gt;sum;</span><br><span class="line">		if(sum==0) break;//要先判断是否是终止条件</span><br><span class="line">		count=0;//这个是必须的，在循环中每一次循环都是不同的数字，必须重置</span><br><span class="line">		for(int i=2;i&lt;sum/2;i++)&#123;</span><br><span class="line">			//对于任何一个可以分解为两个素数之和的偶数，其中一个必然是小于或者等于1/2的。</span><br><span class="line">			if(num[i]&amp;&amp;num[sum-i])&#123;</span><br><span class="line">				//这里就是判断是否是两个质数</span><br><span class="line">				if(i!=sum-i)&#123;</span><br><span class="line">					count++; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后结果：</p>
<p><img src="/2019/03/21/分拆素数和/accept.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/21/Dart学习笔记-一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/Dart学习笔记-一/" itemprop="url">Dart学习笔记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T13:29:36+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/Dart/" itemprop="url" rel="index">
                    <span itemprop="name">Dart</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  980
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#简单实例">简单实例</a></li>
<li><a href="#重要概念">重要概念</a></li>
<li><a href="#关键字">关键字</a></li>
<li><a href="#变量">变量</a><ul>
<li><a href="#未初始化">未初始化</a></li>
<li><a href="#final与const关键字">Final与const关键字</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="前言">前言</span></h2><p>由于最近写的一个东西需要到Flutter，所以Dart语言也必须学好，不多说，现在立马就开始吧。由于是个人向的学习笔记，所以，默认是已经学过其他编程语言了，然后很多和其他类似的语法就不过多赘述，只是表达目前新的东西。</p>
<h2><span id="简单实例">简单实例</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个函数</span><br><span class="line">printInteger(int aNumber) &#123;</span><br><span class="line">  print(&apos;The number is $aNumber.&apos;); // Print to console.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 程序执行入口</span><br><span class="line">main() &#123;</span><br><span class="line">  var number = 42; // Declare and initialize a variable.</span><br><span class="line">  printInteger(number); // Call a function.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dart内置的类型包括int，string，list，bool。</strong></p>
<p>print()用于<strong>显示输出</strong>。</p>
<p>main()是一种特殊的，必须的顶级函数，应用程序就从这里<strong>开始执行</strong>。</p>
<h2><span id="重要概念">重要概念</span></h2><p>在变量中可以放置的所有东西都是<strong>对象</strong>，而每个对象都是类的实例。无论数字、函数和null都是对象。<strong>所有对象都继承自[Object]类。</strong><br>    尽管Dart是<strong>强类型的</strong>，但类型声明是可选的，因为Dart可以推断类型。 在上面的代码中，数字被推断为int类型。 <strong>如果要明确说明不需要任何类型，请使用[特殊类型dynamic]。</strong><br>    Dart支持<strong>通用类型</strong>，如List<int>(整数列表)或List<dynamic>(任何类型的对象列表)。<br>    Dart支持<strong>顶级函数</strong>(如main())，以及绑定到类或对象(分别是静态方法（static）和实例（instance）方法)的函数。您还可以在函数(嵌套或局部函数)中创建函数。<br>    Dart支持<strong>顶级变量</strong>，以及绑定到类或对象(静态和实例变量)的变量。<strong>实例变量有时被称为字段或属性</strong>。<br>    与Java不同，<strong>Dart没有公开、保护和私有的关键字</strong>。如果标识符以下划线(<em>)开头，则该标识符对其库是<strong>私有的</strong>。<br>    标识符可以以字母或下划线(</em>)开头，然后是这些字符加上数字的<strong>任何组合</strong>。<br>    有时候，某事物是<strong>一个表达（expression ）还是一个语句（statement）</strong>是很重要的，所以这两个词要准确。</dynamic></int></p>
<h2><span id="关键字">关键字</span></h2><p>这就是Dart里面所有的关键字：</p>
<p>(1)带有上标1的单词是<strong>内置标识符</strong>。避免使用内置标识符作为标识符。如果尝试为类或类型名使用内置标识符，则会发生编译时错误。<br>    (2)使用上标2的单词是在Dart的1.0版本之后添加的与异步支持相关的<strong>更新的、有限的保留字</strong>。在以async, async<em>, 或者 sync</em> 标记的任何函数体中，不能使用async, await, 或者 yield作为标识符。</p>
<p>关键字表中的所有其他词都是<strong>保留词</strong>。<strong>不能使用保留词作为标识符。</strong></p>
<p><img src="/2019/03/21/Dart学习笔记-一/关键字.jpg" alt=""></p>
<h2><span id="变量">变量</span></h2><h3><span id="未初始化">未初始化</span></h3><p><strong>未初始化的变量的初始值为null。</strong>甚至具有数字类型的变量最初也是null，因为数字——就像dart中的其他东西一样——是<strong>对象</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int lineCount;</span><br><span class="line">assert(lineCount == null);</span><br></pre></td></tr></table></figure>
<h3><span id="final与const关键字">Final与const关键字</span></h3><p><strong>最终变量只能设置一次</strong>，const变量是一个编译时常数。(Const变量是<strong>隐式最终变量</strong>。)最终的顶级或类变量在第一次使用时被初始化。</p>
<p>注意:<strong>实例变量可以是final，但不能是const。</strong>[实例变量定义在对象一级，它可以被类中的任何方法或者其他类中的方法访问，但是不能被<strong>静态方法</strong>访问。]</p>
<p>对于想要<strong>在编译时确定并且不再变</strong>的变量，使用const。如果const变量位于<strong>类级别</strong>，则将其标记为<strong>静态const</strong>。</p>
<p>const关键字<strong>不只是声明常量变量</strong>。还可以使用它来创建常量值，以及声明创建常量值的构造函数。<strong>任何变量都可以赋一个常量值。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/21/java基础-渐入佳境/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/java基础-渐入佳境/" itemprop="url">java基础-渐入佳境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T12:35:17+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#对象实例化过程">对象实例化过程</a></li>
<li><a href="#方法的覆盖">方法的覆盖</a><ul>
<li><a href="#定义">定义</a></li>
<li><a href="#特点">特点</a></li>
</ul>
</li>
<li><a href="#final关键字">final关键字</a><ul>
<li><a href="#数据">数据</a></li>
<li><a href="#类">类</a></li>
<li><a href="#方法">方法</a></li>
<li><a href="#空final">空final</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="前言">前言</span></h2><p>关于Java基础系列的学习路线，我已经在<a href="https://thbelief.coding.me/2019/02/26/android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%80%BB%E7%BB%93plus/">安卓学习路线总结plus</a>里面写到了，我是按照那个上面的路线来学习的，如果有不明白的地方的话，可以移步前往作为 参考，也可以当成是目录。</p>
<h2><span id="对象实例化过程">对象实例化过程</span></h2><p>1.检查类<strong>是否已经加载</strong>，如果没有加载的话就加载这个类，需要加载所有的父类。</p>
<p>2.在内存堆中分配对象空间，递归分配所有父类和子类属性空间.先父类型再子类型,属性<strong>默认自动初始化</strong>.自动初始化为”0”值。</p>
<p>3.进行属性的赋值。</p>
<p>4.递归调用父类的构造器（默认的是调用父类的无参数构造器）。</p>
<p>5.调用本类的构造器。</p>
<p><strong>注意：</strong></p>
<p>1）静态初始化是指执行静态初始化块儿里面的内容。</p>
<p>2）实例初始化是指执行实例初始化块儿里面的内容。</p>
<p>3）构造方法：一个名称跟类的名称一样的方法，特殊在于不带返回值。</p>
<p><strong>实例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class TestInstanceInit &#123;</span><br><span class="line"></span><br><span class="line">public static int n = 0;// 静态变量</span><br><span class="line"></span><br><span class="line">static &#123;// 这是静态初始化块</span><br><span class="line">print();</span><br><span class="line">System.out.println(&quot;this is static block&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;// 实例初始化块</span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TestInstanceInit() &#123;// 构造方法</span><br><span class="line">System.out.println(&quot;this is TestInstanceInit&apos;s constructor~&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void print() &#123;// 静态方法</span><br><span class="line">System.out.println(&quot;this is static method~&quot;);</span><br><span class="line">System.out.println(n);</span><br><span class="line">n += 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new TestInstanceInit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this is static method~</span><br><span class="line">0</span><br><span class="line">this is static block</span><br><span class="line">1</span><br><span class="line">this is TestInstanceInit&apos;s constructor~</span><br></pre></td></tr></table></figure>
<p><strong>执行顺序：</strong></p>
<p><strong>(静态变量、静态初始化块)&gt;(变量、初始化快)&gt;构造器</strong>。</p>
<p>静态变量和静态初始化快/变量和初始化快的先后顺序取决于它们在类中出现的<strong>先后顺序</strong>。</p>
<p><a href="https://blog.csdn.net/avinegar/article/details/7749431" target="_blank" rel="noopener">参考链接</a></p>
<h2><span id="方法的覆盖">方法的覆盖</span></h2><h3><span id="定义">定义</span></h3><p>如果在子类中定义一个方法，其名称、返回类型及参数签名正好与父类中某个方法的名称、返回类型及参数签名相<strong>匹配</strong>，那么可以说，子类的方法覆盖了父类的方法。</p>
<h3><span id="特点">特点</span></h3><p> 子类的方法名称返回类型及参数签名 必须与父类的一致。<br>    子类方法不能缩小父类方法的访问权限。<br>    子类方法不能抛出比父类方法更多的异常。<br>    方法覆盖只存在于子类和父类之间，同一个类中只能重载。<br>    父类的静态方法不能被子类覆盖为非静态方法。<br>    子类可以定义于父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法（满足覆盖约束）， 而且Java虚拟机把静态方法和所属的类绑定，而把实例方法和所属的实例绑定。<br>    父类的非静态方法不能被子类覆盖为静态方法。<br>    父类的私有方法不能被子类覆盖。<br>    父类的抽象方法可以被子类通过两种途径覆盖（即实现和覆盖）。</p>
<p>父类的非抽象方法可以被覆盖为抽象方法。</p>
<h2><span id="final关键字">final关键字</span></h2><p>在Java中final关键字可以用来修饰数据，方法，参数以及类。</p>
<h3><span id="数据">数据</span></h3><p>final修饰的基本类型，在初始化之后就不能在赋值了，同理，修饰的对象一旦引用被初始化指向一个对象的话，就无法把它改指向另外一个对象。</p>
<p>但是要注意，被final修饰的对象引用，只是对象的应用不能修改，但是<strong>其自身却是可以修改的</strong>。</p>
<h3><span id="类">类</span></h3><p>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。</p>
<p>final类中的成员变量可以根据需要设为final，但是要注意final类中的所有<strong>成员方法</strong>都会被隐式地指定为<strong>final方法</strong>。</p>
<h3><span id="方法">方法</span></h3><p>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。</p>
<p><strong>注意:类的private方法会被隐式的指定为final方法。</strong></p>
<h3><span id="空final">空final</span></h3><p>谓的”空白final”是指被声明的为final但又为给定初值的对象引用或者基本数据。无论在什么情况下，编译器都会去确保final在使用前必须被初始化。若不进行初始化，会提示错误，这就意味着，必须在域的定义处或者每个构造器中使用表达式对final进行赋值，这正是final域在使用前被初始化的原因所在。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/20/JavaScript学习笔记-二/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/20/JavaScript学习笔记-二/" itemprop="url">JavaScript学习笔记(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-20T22:02:27+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#函数定义与调用">函数定义与调用</a><ul>
<li><a href="#定义函数">定义函数</a></li>
<li><a href="#调用函数">调用函数</a></li>
<li><a href="#特殊arguments">特殊arguments</a></li>
<li><a href="#rest参数">rest参数</a></li>
</ul>
</li>
<li><a href="#变量相关">变量相关</a><ul>
<li><a href="#变量提升">变量提升</a></li>
<li><a href="#全局作用域">全局作用域</a></li>
<li><a href="#名字空间">名字空间</a></li>
<li><a href="#局部作用域">局部作用域</a></li>
<li><a href="#常量">常量</a></li>
<li><a href="#解构赋值">解构赋值</a></li>
</ul>
</li>
<li><a href="#方法">方法</a><ul>
<li><a href="#apply">apply</a></li>
<li><a href="#装饰器">装饰器</a></li>
</ul>
</li>
<li><a href="#四个常用的高阶函数">四个常用的高阶函数</a><ul>
<li><a href="#map">map</a></li>
<li><a href="#reduce">reduce</a></li>
<li><a href="#filter">filter</a></li>
<li><a href="#sort">sort</a></li>
</ul>
</li>
<li><a href="#闭包">闭包</a><ul>
<li><a href="#函数作为返回值">函数作为返回值</a></li>
<li><a href="#箭头函数">箭头函数</a></li>
</ul>
</li>
<li><a href="#generator">generator</a><ul>
<li><a href="#优势">优势</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="函数定义与调用">函数定义与调用</span></h2><h3><span id="定义函数">定义函数</span></h3><p>第一种方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function hanshu()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.function指出这是一个<strong>函数定义</strong>；<br>    2.hanshu是<strong>函数的名称</strong>；<br>    3.(x)括号内列出函数的参数，多个参数<strong>以,分隔</strong>；<br>    4.{ … }之间的代码是<strong>函数体</strong>，可以包含若干语句，甚至可以没有任何语句。</p>
<p>第二种方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var hanshu = function (x) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>function (x) { … }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量hanshu，所以，通过变量hanshu就可以调用该函数。这两种其实是完全等价的，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。</p>
<h3><span id="调用函数">调用函数</span></h3><p>JS中有点儿特殊，主要就是特殊在JS中对于一个函数传进去的参数<strong>不做限制</strong>，传多了没有问题，只是在内部没有用而已，传少了的话计算结果会变成NaN。如果想保险一点儿的话，可以直接在函数里面对于传进来的参数做判断即可。</p>
<h3><span id="特殊arguments">特殊arguments</span></h3><p>在<strong>函数内部</strong>起作用，并且永远指向<strong>当前函数的调用者传入的所有参数</strong>。arguments类似Array但它不是一个Array。意思也就是，就算函数并没有定义任何的变量，也是可以拿到参数的值。</p>
<h3><span id="rest参数">rest参数</span></h3><p>（ES6引入）rest参数只能写在<strong>最后</strong>，前面用…标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments就获取了全部参数。</p>
<p>如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个<strong>空数组</strong>（注意<strong>不是undefined</strong>）。</p>
<p>特别注意:JS里面有一个<strong>自动在行末添加分号</strong>的性质，所以特别需要注意。</p>
<h2><span id="变量相关">变量相关</span></h2><p>注意，由于JS支持函数嵌套，在查找变量时从自身函数定义开始，<strong>从“内”向“外”</strong>查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“<strong>屏蔽</strong>”外部函数的变量。</p>
<h3><span id="变量提升">变量提升</span></h3><p>JS函数的特性，它执行前会扫描整个函数体，<strong>把所有声明的变量都放到顶部</strong>。但是要注意，它<strong>只是提升变量的声明，并没有提升变量的赋值</strong>。</p>
<p>所以为了避免有些错误，建议是在函数体内，<strong>把所有的变量声明都放到函数的开头</strong>。</p>
<h3><span id="全局作用域">全局作用域</span></h3><p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var bianliang=&apos;thbelief&apos;;</span><br><span class="line">function hanshu()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的话，访问bianliang与访问window.bianliang是完全一样的。</p>
<p>同时，第二种函数的定义方式其实也是一种全局的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var hanshu = function (x) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以，其实JS只有一个<strong>全局作用域</strong>。</p>
<h3><span id="名字空间">名字空间</span></h3><p>全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成<strong>命名冲突</strong>，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部<strong>绑定到一个全局变量中</strong>。</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 唯一的全局变量MYAPP:</span><br><span class="line">var MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 其他变量:</span><br><span class="line">MYAPP.name = &apos;myapp&apos;;</span><br><span class="line">MYAPP.version = 1.0;</span><br><span class="line"></span><br><span class="line">// 其他函数:</span><br><span class="line">MYAPP.foo = function () &#123;</span><br><span class="line">    return &apos;foo&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个其实是一个特别实用的方法，必须提倡。</p>
<h3><span id="局部作用域">局部作用域</span></h3><p>在循环中，一般使用let替代var声明次级作用域的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var sum = 0;</span><br><span class="line">    for (let i=0; i&lt;100; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    i += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="常量">常量</span></h3><p>ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域。但是需要注意，<strong>不是所有的地方都支持</strong>，因为ES6才引进。</p>
<h3><span id="解构赋值">解构赋值</span></h3><p>可以直接对多个变量同时赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">// 如果浏览器支持解构赋值就不会报错:</span><br><span class="line">var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;];</span><br></pre></td></tr></table></figure>
<p>注意，对数组元素进行解构赋值时，<strong>多个变量要用[…]括起来</strong>。</p>
<p>有些时候数组本身还有<strong>嵌套</strong>，也可以解构赋值，但是需要保持嵌套层次和位置的<strong>一致性</strong>。</p>
<p>解构赋值还有<strong>很多用法</strong>，这里就不一一阐述了，需要的时候直接去查就好啦。</p>
<h2><span id="方法">方法</span></h2><p>在一个对象中绑定函数，这就是这个对象的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var thbelief = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;,</span><br><span class="line">    birth: 1999,</span><br><span class="line">    age: function () &#123;</span><br><span class="line">        var y = new Date().getFullYear();</span><br><span class="line">        return y - this.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">thbelief.age; // function thbelief.age()</span><br><span class="line">thbelief.age();</span><br></pre></td></tr></table></figure>
<p>同时，this关键字在JS里面也有和C++同样的作用，可以直接调用本函数的方法。</p>
<p>但是一定要用对象的形式调用，这才是指向本函数里面的方法，不然的话就是对于整个全局作用域来说的。</p>
<p>解决的方法其实也有，就是<strong>var that = this;</strong>这条语句加上去在用的地方就可以了。</p>
<h3><span id="apply">apply</span></h3><p>虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，还是可以<strong>控制this的指向</strong>！</p>
<p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>用apply修复getAge()调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getAge() &#123;</span><br><span class="line">    var y = new Date().getFullYear();</span><br><span class="line">    return y - this.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var thbelief = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;,</span><br><span class="line">    birth: 1999,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">thbelief.age(); </span><br><span class="line">getAge.apply(thbelief, []);</span><br></pre></td></tr></table></figure>
<p>另一个与apply()类似的方法是<strong>call()</strong>，唯一<strong>区别</strong>是：</p>
<p>apply()把参数打包成Array再传入；</p>
<p>call()把参数按顺序传入。</p>
<p>比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max.apply(null, [3, 5, 4]); // 5</span><br><span class="line">Math.max.call(null, 3, 5, 4); // 5</span><br></pre></td></tr></table></figure>
<h3><span id="装饰器">装饰器</span></h3><p>利用apply()，我们还可以<strong>动态改变函数的行为</strong>。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以<strong>重新</strong>指向新的函数。</p>
<h2><span id="四个常用的高阶函数">四个常用的高阶函数</span></h2><h3><span id="map">map</span></h3><p>map可以传入任意的变量或者自己定义的相关函数，比如说做一个2的次方运算，相比较于我们傻乎乎的使用循环一层一层的套，map作为高阶函数无疑是更加具有实力的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">function pow(x) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure>
<h3><span id="reduce">reduce</span></h3><p>Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数<strong>必须接收两个参数</strong>，reduce()把结果继续和序列的下一个元素做累积计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 5, 7, 9];</span><br><span class="line">arr.reduce(function (x, y) &#123;</span><br><span class="line">    return x * 10 + y;</span><br><span class="line">&#125;); // 13579</span><br></pre></td></tr></table></figure>
<h3><span id="filter">filter</span></h3><p>其实有点儿类似于Android里面的过滤器。它的作用就是将Array里面的某些元素过滤掉，然后返回剩下的元素。</p>
<p>和map()类似，Array的filter()也接收<strong>一个函数</strong>。和map()不同的是，filter()把传入的函数<strong>依次</strong>作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, null, undefined, &apos;C&apos;, &apos;  &apos;];</span><br><span class="line">var r = arr.filter(function (s) &#123;</span><br><span class="line">    return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法</span><br><span class="line">&#125;);</span><br><span class="line">r; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br></pre></td></tr></table></figure>
<h3><span id="sort">sort</span></h3><p>需要注意的是，sort<strong>默认的排序</strong>不是简简单单的针对于数字进行排序。</p>
<p>它的默认把所有元素<strong>先转换为String</strong>再排序。</p>
<p>同时，作为一个函数，sort可以传入一个比较函数来作为依据。</p>
<p>比如说下面这个按照数字大小来进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var arr = [10, 20, 1, 2];</span><br><span class="line">arr.sort(function (x, y) &#123;</span><br><span class="line">    if (x &lt; y) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; y) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="闭包">闭包</span></h2><h3><span id="函数作为返回值">函数作为返回值</span></h3><p>高阶函数除了可以接受函数作为参数外，还可以<strong>把函数作为结果值</strong>返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function lazy_sum(arr) &#123;</span><br><span class="line">    var sum = function () &#123;</span><br><span class="line">        return arr.reduce(function (x, y) &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()</span><br></pre></td></tr></table></figure>
<p>调用函数f时，才真正计算求和的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(); // 15</span><br></pre></td></tr></table></figure>
<p>函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>返回闭包时牢记的一点就是：<strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong>。因为它只会锁定最后一个结果。如果一定要引用循环变量的话，方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的<strong>值不变</strong>。</p>
<p>闭包还有很多应用，这里只是阐述基本概念，相关的使用要用的时候自己查即可。</p>
<h3><span id="箭头函数">箭头函数</span></h3><p>是在ES6之后推出的，<strong>只支持ES6之后的版本</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x * x;</span><br><span class="line">//两者完全等价</span><br><span class="line">function (x) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数相当于<strong>匿名函数</strong>，并且<strong>简化了函数定义</strong>。</p>
<p>箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。</p>
<p>还有一种可以包含多条语句，这时候就<strong>不能省略{ … }和return</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    if (x &gt; 0) &#123;</span><br><span class="line">        return x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return - x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 两个参数:</span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line"></span><br><span class="line">// 无参数:</span><br><span class="line">() =&gt; 3.14</span><br><span class="line"></span><br><span class="line">// 可变参数:</span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    var i, sum = x + y;</span><br><span class="line">    for (i=0; i&lt;rest.length; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要返回一个对象，并且是单表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ok:</span><br><span class="line">x =&gt; (&#123; foo: x &#125;)</span><br></pre></td></tr></table></figure>
<p><strong>this：</strong></p>
<p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。由于this在箭头函数中已经被绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略…</p>
<h2><span id="generator">generator</span></h2><p>generator（生成器）是ES6新引入的新的数据类型。<strong>一个generator看上去像一个函数，但可以返回多次</strong>。</p>
<p>定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function* foo(x) &#123;</span><br><span class="line">    yield x + 1;</span><br><span class="line">    yield x + 2;</span><br><span class="line">    return x + 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>generator和函数不同的是，generator由function<em>定义（注意多出的</em>号），并且，除了return语句，还可以用yield返回多次。</p>
<h3><span id="优势">优势</span></h3><p>1.因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就<strong>可以实现需要用面向对象才能实现的功能</strong>。</p>
<p>2.把异步回调代码变成“同步”代码。（深）</p>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">参考链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/19/Auto-js-Script开发-一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/Auto-js-Script开发-一/" itemprop="url">Auto.js Script开发(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T10:20:57+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/" itemprop="url" rel="index">
                    <span itemprop="name">移动端开发</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/Auto-js/" itemprop="url" rel="index">
                    <span itemprop="name">Auto.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#正文">正文</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#下个版本">下个版本</a></li>
</ul>
<!-- tocstop -->
<h2><span id="简介">简介</span></h2><p>Auto.js使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">JavaScript</a>作为脚本语言，目前使用<a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/Rhino" target="_blank" rel="noopener">Rhino 1.7.7.2</a>作为脚本引擎，支持ES5与部分ES6特性。</p>
<p>最开始接触Auto.js只是单纯的想写一个I西科自动签到的脚本，接触后才发现，写这样一个脚本其实简单的不行，然后了解了Auto.js的相关特性之后，我决定好好的学习一下这个工具，毕竟，它实在是太简约了，不像其他的脚本语言那么复杂，虽然…有点儿bug，毕竟开发者自己也只是一个大学生，不能指望有多完善，但是这种自动化脚本编辑实在是太有魅力了。</p>
<h2><span id="正文">正文</span></h2><p>最近正在开发的<strong>Script</strong>，主要目的是借用Auto.js自带的UI模块儿集成一个个人向的脚本库。</p>
<p>这个版本的展示图：</p>
<p><img src="/2019/03/19/Auto-js-Script开发-一/菜单.png" alt=""></p>
<p><img src="/2019/03/19/Auto-js-Script开发-一/自动签到.png" alt=""></p>
<p><img src="/2019/03/19/Auto-js-Script开发-一/自动回复.jpg" alt=""></p>
<p>目前代码展示如下，由于太简单，懒得上传到Github了，直接贴代码（后期如果有升级或者说是改良，会在下一个博客继续写）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&quot;ui&quot;;</span><br><span class="line">//下面就是主界面</span><br><span class="line">ui.layout(</span><br><span class="line">    &lt;vertical&gt;</span><br><span class="line">        &lt;horizontal&gt;</span><br><span class="line">            &lt;text text=&quot;菜单&quot; w=&quot;*&quot; h=&quot;*&quot; layout_weight=&quot;1&quot; gravity=&quot;center&quot; textSize=&quot;30sp&quot; color=&quot;#000000&quot;/&gt;</span><br><span class="line">        &lt;/horizontal&gt;</span><br><span class="line">        &lt;horizontal&gt;</span><br><span class="line">            &lt;button id=&quot;autoReply&quot; text=&quot;QQ自动回复&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">            &lt;button id=&quot;autoReplyClose&quot; text=&quot;关闭&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;/horizontal&gt;</span><br><span class="line">        &lt;horizontal&gt;</span><br><span class="line">            &lt;button id=&quot;autoSignIn&quot; text=&quot;i西科自动签到&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">            &lt;button id=&quot;autoSignInClose&quot; text=&quot;关闭&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;/horizontal&gt;</span><br><span class="line">    &lt;/vertical&gt;</span><br><span class="line">);</span><br><span class="line">//封装的回复方法</span><br><span class="line">function WhatReply(notificationText)&#123;</span><br><span class="line">    if(notificationText==&apos;A&apos;)&#123;</span><br><span class="line">        return(&quot;您好，我是主人正在开发的人工智障robot001.\n   ——robot001欢喜的答道。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(notificationText==&apos;B&apos;)&#123;</span><br><span class="line">        return(&quot;好的，我马上联系主人...\n   ——robot001郑重的答道。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return &quot;主人在忙呢！\n有问题请回复下列单个字母：\n A.robot是谁？\n B.有要事迅速联系thbelief. \n   ——robot001如此回答道。&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//先封装一个自动回复的方法</span><br><span class="line">function autoReplyFunction()&#123;</span><br><span class="line">    auto();//检查是否开启了无障碍服务权限</span><br><span class="line">    events.observeNotification();//监听消息</span><br><span class="line">    events.onNotification(function(notification)&#123;</span><br><span class="line">        var string1=&quot;com.tencent.mobileqq&quot;;//如果是QQ消息的话</span><br><span class="line">        if(string1==notification.getPackageName())&#123;</span><br><span class="line">            notification.click();//点击直接进入对应的聊天界面</span><br><span class="line">            //跳转必须要用startActivity</span><br><span class="line">            waitForPackage(&quot;com.tencent.mobileqq&quot;);</span><br><span class="line">            var t=className(&quot;android.widget.EditText&quot;).id(&quot;input&quot;).findOnce();//找到聊天输入控件</span><br><span class="line">            t.setText(WhatReply(notification.getText()));//这里加入回复的方法</span><br><span class="line">            className(&quot;android.widget.Button&quot;).id(&quot;fun_btn&quot;).findOnce().click();//发送即可</span><br><span class="line">            home();//直接返回桌面</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">//自动签到的方法</span><br><span class="line">function autoSignInFunction()&#123;</span><br><span class="line">    auto();</span><br><span class="line">    //打开i西科</span><br><span class="line">    launchApp(&quot;i西科&quot;);</span><br><span class="line">    //跳转到相应的界面</span><br><span class="line">    waitForPackage(&quot;org.weixvn.frame&quot;);</span><br><span class="line">    //找到首页上签到的按钮，点击进去</span><br><span class="line">    id(&quot;it_sign_in&quot;).clickable().findOne().click();</span><br><span class="line">    waitForActivity(&quot;com.example.z.iswust.view.activity.impl.SignInActivity&quot;);</span><br><span class="line">    //点击签到</span><br><span class="line">    if(id(&quot;btn_signin&quot;).clickable().findOne().click())&#123;</span><br><span class="line">        //完成任务后返回桌面</span><br><span class="line">        home();</span><br><span class="line">        toast(&quot;签到成功了哟，亲~~~&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">//自动回复按钮的点击事件</span><br><span class="line">ui.autoReply.click(()=&gt;&#123;</span><br><span class="line">    //UI模式的情况下必须用Promise形式或者回调模式</span><br><span class="line">    confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123;</span><br><span class="line">        if(sure)&#123;</span><br><span class="line">            //修改控件信息必须更改线程</span><br><span class="line">            threads.start(function()&#123;</span><br><span class="line">                autoReplyFunction();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">//自动回复按钮的关闭点击事件</span><br><span class="line">ui.autoReplyClose.click(()=&gt;&#123;</span><br><span class="line">    //这里由于只有一个脚本，我就直接把所有的脚本都关闭了，如果是很多脚本的话必须改</span><br><span class="line">    engines.stopAll();</span><br><span class="line">    toast(&quot;自动回复脚本已经关闭了哦，亲~&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//i西科自动签到的点击事件</span><br><span class="line">ui.autoSignIn.click(()=&gt;&#123;</span><br><span class="line">    confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123;</span><br><span class="line">        if(sure)&#123;</span><br><span class="line">            //修改控件信息必须更改线程</span><br><span class="line">            threads.start(function()&#123;</span><br><span class="line">                //自动签到的方法</span><br><span class="line">                autoSignInFunction();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="总结">总结</span></h2><p>1.一定要判断是否开启了<strong>无障碍服务权限</strong>以及<strong>通知使用权</strong>。</p>
<p>2.无论是不是用intent跳转页面或者应用，都应该用<strong>waitForActivity或者waitForPackage</strong>来跳转，不然容易出错。</p>
<p>3.基于控件的操作的时候，一定要注意寻找的依据，<strong>尽量使用不重复的依据</strong>，例如desc或者说id这种，提高兼容性。</p>
<p>4.方法的封装应该是根据<strong>功能</strong>来的，这一点本版本还没有做完善。</p>
<p>5.提示信息一定要做到位，该Toast的地方就一定要毫不犹豫的<strong>Toast</strong>.</p>
<p>6.如果想进入某个界面做某事，可以直接在外面套个if，这样出错的几率会小很多，比如说本版本的<strong>autoSignInFunction</strong>函数里面的点击签到。</p>
<p>7.UI模式情况下必须使用<strong>Promise形式</strong>或者说是<strong>回调模式</strong>。</p>
<p>8.还有就是，运行多个脚本的时候，都要使用<strong>多线程</strong>。</p>
<h2><span id="下个版本">下个版本</span></h2><p>1.UI界面做的是真的丑，下个版本尽量修复。</p>
<p>2.添加检查更新的功能，直接app内检查更新并更新到最新版本。</p>
<p>3.添加更多的脚本选项。</p>
<p>4.定时运行，比如说，定时自启之类的，例如本版本的i西科自动签到功能，定时启动签到。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/zhangguoron.jpg" alt="THBELIEF">
            
              <p class="site-author-name" itemprop="name">THBELIEF</p>
              <p class="site-description motion-element" itemprop="description">我这个人只是英俊 潇洒了些许~</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">83</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">136</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/thbelief" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2465749045@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/thbelief" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">THBELIEF</span>

  
</div>


  <!--<div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>
-->



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共116.2k字</span>
</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":125,"height":150},"mobile":{"show":false},"log":false,"tagMode":false});</script></body>
</html>
