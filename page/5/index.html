<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="我这个人只是英俊 潇洒了些许~">
<meta property="og:type" content="website">
<meta property="og:title" content="THBELIEF">
<meta property="og:url" content="http://thbelief.coding.me/page/5/index.html">
<meta property="og:site_name" content="THBELIEF">
<meta property="og:description" content="我这个人只是英俊 潇洒了些许~">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="THBELIEF">
<meta name="twitter:description" content="我这个人只是英俊 潇洒了些许~">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://thbelief.coding.me/page/5/">





  <title>THBELIEF</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">THBELIEF</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Thbelief's blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/30/Android-Menu菜单/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/Android-Menu菜单/" itemprop="url">Android-Menu菜单</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T15:34:56+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/" itemprop="url" rel="index">
                    <span itemprop="name">移动端开发</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#menu菜单">Menu菜单</a><ul>
<li><a href="#选项菜单optionsmenu">选项菜单OptionsMenu</a></li>
<li><a href="#上下文菜单contextmenu">上下文菜单ContextMenu</a></li>
<li><a href="#浮动菜单popupmenu">浮动菜单PopupMenu</a></li>
</ul>
</li>
<li><a href="#创建">创建</a><ul>
<li><a href="#1代码">1.代码</a></li>
<li><a href="#2xml">2.XML</a></li>
</ul>
</li>
<li><a href="#在xml中定义menu">在XML中定义Menu</a></li>
<li><a href="#选项菜单">选项菜单</a><ul>
<li><a href="#使用">使用</a></li>
<li><a href="#处理">处理</a></li>
</ul>
</li>
<li><a href="#上下文菜单">上下文菜单</a><ul>
<li><a href="#使用-1">使用</a></li>
<li><a href="#处理-1">处理</a></li>
<li><a href="#注意">注意</a></li>
</ul>
</li>
<li><a href="#浮动菜单">浮动菜单</a><ul>
<li><a href="#使用函数">使用函数</a></li>
<li><a href="#使用方式">使用方式</a></li>
</ul>
</li>
<li><a href="#浮动窗口popupwindow">浮动窗口PopupWindow</a></li>
</ul>
<!-- tocstop -->
<h2><span id="menu菜单">Menu菜单</span></h2><p>菜单是一种常见的与用户交互的一种<strong>用户界面组件</strong>。Android3.0以后推荐使用ActionBar来代替Menu。</p>
<p>Menu主要分为下面三种：</p>
<h3><span id="选项菜单optionsmenu">选项菜单OptionsMenu</span></h3><p>右上方三个点，点击之后出现的列表都是由选项菜单的对象进行控制的。</p>
<h3><span id="上下文菜单contextmenu">上下文菜单ContextMenu</span></h3><p>长按指定控件，在屏幕中心弹出列表对话框。</p>
<h3><span id="浮动菜单popupmenu">浮动菜单PopupMenu</span></h3><p>通过指定的控件指定监听，触发显示，可以让菜单列表显示在指定控件的下方。</p>
<h2><span id="创建">创建</span></h2><h3><span id="1代码">1.代码</span></h3><h3><span id="2xml">2.XML</span></h3><p>以上两种方法下面详说。</p>
<h2><span id="在xml中定义menu">在XML中定义Menu</span></h2><p>在<strong>res/menu目录</strong>下的xml文件中操作：（menu文件夹是用户自己新建的）</p>
<p><img src="/2019/03/30/Android-Menu菜单/res目录下.jpg" alt=""></p>
<p>然后下面是<strong>具体参数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu&gt;：代表菜单资源</span><br><span class="line"></span><br><span class="line">&lt;item&gt;：菜单项</span><br><span class="line"></span><br><span class="line">         android:id  // 菜单项的id</span><br><span class="line"></span><br><span class="line">         android:icon  // 菜单项的图标</span><br><span class="line"></span><br><span class="line">         android:title  // 菜单项的标题</span><br><span class="line"></span><br><span class="line">         android:orderInCategory // 排序</span><br><span class="line"></span><br><span class="line">         android:showAsAction // 在ActionBar上的显示参数（API 11）</span><br><span class="line"></span><br><span class="line">                   never：不将MenuItem显示在ActionBar上（是默认值）</span><br><span class="line"></span><br><span class="line">                   always：总是将该MenuItem显示在ActionBar上</span><br><span class="line"></span><br><span class="line">                   ifRoom：当AcitonBar上有空间时将该MenuItem显示在ActionBar上，没有空间就放入溢出菜单中</span><br><span class="line"></span><br><span class="line">                   withText：将该MenuItem显示在ActionBar上，并显示该菜单项的文本</span><br><span class="line"></span><br><span class="line">                   显示自定义ActionBar的View，需要和actionViewClass这组参数结合使用（API14）</span><br><span class="line"></span><br><span class="line">&lt;group&gt;：菜单组</span><br></pre></td></tr></table></figure>
<p><strong>二级菜单</strong>（子菜单的创建）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">概念：在menu Item中嵌套menu元素，可以实现多级菜单，嵌套的菜单叫做子菜单，一般只会使用二级菜单，如果菜单层次太深，会严重影响用户体验。</span><br><span class="line"></span><br><span class="line">二级可选菜单</span><br><span class="line"></span><br><span class="line">          android:checkableBehavior</span><br><span class="line"></span><br><span class="line">          有三个属性值可选</span><br><span class="line"></span><br><span class="line">                   all（多选）</span><br><span class="line"></span><br><span class="line">                   single（单选）</span><br><span class="line"></span><br><span class="line">                   none（不可选）</span><br></pre></td></tr></table></figure>
<h2><span id="选项菜单">选项菜单</span></h2><h3><span id="使用">使用</span></h3><p> <strong>初始化选项菜单：onCreateOptionsMenu(Menu menu)</strong></p>
<p><strong>为菜单项设置监听器：onOptionsItemSelected(MenuItem item)</strong></p>
<h3><span id="处理">处理</span></h3><p>  1.在res文件夹内容准备一个<strong>menu文件夹</strong>，所有控制菜单显示的xml文件均被存于此处。</p>
<ol start="2">
<li>在menu文件夹中创建一个xml文件，让该文件<strong>以menu标签作为根标签。</strong></li>
<li>在menu标签之间<strong>添加item标签</strong>，每一个item标签代表一个<strong>菜单选项</strong>。</li>
<li>处理item标签中的<strong>属性</strong>。</li>
</ol>
<p>XML中代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    android:id 用于设置item的id，即唯一标识，用于稍后的点击判断</span><br><span class="line">    android:title 用于设置标题</span><br><span class="line">    android:orderInCategory 用于设置item选项在菜单列表中的排列顺序</span><br><span class="line">    属性值越小，排列顺序越靠前，</span><br><span class="line">    如果属性值相同，哪个item的代码在前面，哪个item就排名靠前</span><br><span class="line">    android:icon 用于设置图标。注意：如果item是显示在菜单列表中，那么</span><br><span class="line">    图标永远不显示</span><br><span class="line">    android:showAsAction android3.0 以后才出的属性</span><br><span class="line">    用于设置item在标题栏上的显示特点</span><br><span class="line">    可选属性值：</span><br><span class="line">    never  该选项永远显示在菜单列表中</span><br><span class="line">    ifRoom 如果标题栏上有剩余空间，就显示在标题栏上，如果没有，就显示在菜单列表中</span><br><span class="line">    always 该选项永远直接显示在标题栏上</span><br><span class="line">    withText  让图标和文字同时显示</span><br><span class="line">    --&gt;</span><br><span class="line">         &lt;item</span><br><span class="line">             android:id=&quot;@+id/item1&quot;</span><br><span class="line">             android:title=&quot;菜单项一&quot;</span><br><span class="line">            android:orderInCategory=&quot;3000&quot;</span><br><span class="line">            android:showAsAction=&quot;always|withText&quot;</span><br><span class="line">             android:icon=&quot;@drawable/ic_launcher&quot;/&gt;</span><br><span class="line">         &lt;item</span><br><span class="line">             android:id=&quot;@+id/item2&quot;</span><br><span class="line">             android:title=&quot;菜单项二&quot;</span><br><span class="line">            android:orderInCategory=&quot;10&quot;</span><br><span class="line">            android:showAsAction=&quot;ifRoom&quot;</span><br><span class="line">             android:icon=&quot;@drawable/ic_launcher&quot;/&gt;</span><br><span class="line">         &lt;item</span><br><span class="line">             android:id=&quot;@+id/item3&quot;</span><br><span class="line">            android:orderInCategory=&quot;20&quot;</span><br><span class="line">             android:title=&quot;菜单项三&quot;</span><br><span class="line">             android:icon=&quot;@drawable/ic_launcher&quot;/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>
<p>MainActivity中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">         @Override</span><br><span class="line">         protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">                   super.onCreate(savedInstanceState);</span><br><span class="line">                   setContentView(R.layout.activity_main);</span><br><span class="line">         &#125;</span><br><span class="line">         /*</span><br><span class="line"></span><br><span class="line">          * 重写onCreateOptionsMenu方法，在此方法中加载xml文件参数：代表要显示的菜单对象</span><br><span class="line"></span><br><span class="line">          *</span><br><span class="line"></span><br><span class="line">          * 返回值：true 显示菜单， false 不显示菜单</span><br><span class="line"></span><br><span class="line">          */</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public boolean onCreateOptionsMenu(Menu menu)&#123;</span><br><span class="line">                   // TODOAuto-generated method stub</span><br><span class="line">                   /*</span><br><span class="line">                    * 将my.xml文件中的所有item菜单选项添加到参数二指定的menu对象中显示</span><br><span class="line">                    */</span><br><span class="line">                   getMenuInflater().inflate(R.menu.my_menu, menu);</span><br><span class="line">                   //通过代码添加菜单选项</span><br><span class="line">                   /*</span><br><span class="line">                    * 1. 该菜单选项所在组的groupId</span><br><span class="line">                    * 2. 该菜单的唯一标识，id属性的值</span><br><span class="line">                    * 3. 控制排列顺序，作用等同于orderInCategory属性</span><br><span class="line">                    * 4：选项上要显示的文字标题</span><br><span class="line">                    * */</span><br><span class="line">                   menu.add(0, 1, 20, &quot;代码添加menu&quot;);</span><br><span class="line">                   return true;</span><br><span class="line">         &#125;</span><br><span class="line">         //重写此方法，获取菜单项的点击事件，参数代表被点击的菜单选项</span><br><span class="line">         @Override</span><br><span class="line">         public boolean onOptionsItemSelected(MenuItemitem) &#123;</span><br><span class="line">                   // TODOAuto-generated method stub</span><br><span class="line">                   Toast.makeText(this,item.getTitle()+String.valueOf(item.getItemId()), Toast.LENGTH_SHORT).show();</span><br><span class="line">                   //区分被点击的item</span><br><span class="line">                   switch (item.getItemId())&#123;</span><br><span class="line">                   caseR.id.item1:                 </span><br><span class="line">                            break;</span><br><span class="line">                   caseR.id.item2:</span><br><span class="line">                            break;</span><br><span class="line">                   caseR.id.item3:</span><br><span class="line">                            break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   return super.onOptionsItemSelected(item);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="上下文菜单">上下文菜单</span></h2><h3><span id="使用">使用</span></h3><p> <strong>初始化上下文菜单：onCreateContextMenu(ContextMenu menu, View v,ContextMenuInfo menuInfo)</strong></p>
<p> <strong>为指定控件注册上下文菜单：registerForContextMenu(Viewview)</strong></p>
<p> <strong>为菜单项设置监听器：onContextItemSelected(MenuItemitem)</strong></p>
<h3><span id="处理">处理</span></h3><ol>
<li>通过menu文件夹中的xml文件定义菜单列表中要<strong>显示的内容</strong>。</li>
<li>重写onCreateContextMenu方法，在该方法中<strong>通过</strong>。</li>
<li>重写onContextItemSelected方法<strong>获取菜单选项被点击的监听事件</strong>。</li>
<li>在页面的onCreate方法中通过registerForContextMenu方法的参数<strong>指定</strong>长按哪个控件对象显示菜单。</li>
</ol>
<h3><span id="注意">注意</span></h3><p>当<strong>registerForContextMenu</strong>方法中传递的是一个<strong>listview</strong>对象时，<strong>ContextMenu</strong>是针对列表中<strong>每个item</strong>进行设置。</p>
<p>在onContextItemSelected方法中可以通过以下方式获取别长按的item在listview中对应的<strong>position位置。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AdapterContextMenuInfo aci = (AdapterContextMenuInfo) item.getMenuInfo();</span><br><span class="line">//通过菜单信息封装对象获取被点击的item的位置</span><br><span class="line">int position = aci.position;</span><br></pre></td></tr></table></figure>
<p>XML示例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">       android:id=&quot;@+id/list_item1&quot;</span><br><span class="line">       android:title=&quot;复制&quot;/&gt;</span><br><span class="line">     &lt;item</span><br><span class="line">       android:id=&quot;@+id/list_item2&quot;</span><br><span class="line">       android:title=&quot;删除&quot;/&gt;</span><br><span class="line">      &lt;item</span><br><span class="line">       android:id=&quot;@+id/list_item3&quot;</span><br><span class="line">       android:title=&quot;重命名&quot;/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="浮动菜单">浮动菜单</span></h2><h3><span id="使用函数">使用函数</span></h3><p>创建浮动菜单对象：PopupMenu popupMenu = newPopupMenu(this, btn_show_popupmenu);</p>
<p>  参数1：<strong>上下文环境。</strong></p>
<p>  参数2：<strong>需要绑定浮动菜单的控件id。</strong></p>
<p> 将菜单文件加载到内存中：getMenuInflater().inflate(R.menu.popup_menu,popupMenu.getMenu());</p>
<p> 为菜单项设置监听器：popupMenu.setOnMenuItemClickListener(OnMenuItemClickListener);</p>
<p> 显示菜单：popupMenu.show();</p>
<h3><span id="使用方式">使用方式</span></h3><p>1.获取控件对象，设置任意监听，例如设置tv的点击事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PopupMenu pm = newPopupMenu(PopupMenuActivity.this,tv);</span><br></pre></td></tr></table></figure>
<p>2.向popupmenu对象中添加要显示的菜单选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.inflate(R.menu.popup_menu);</span><br></pre></td></tr></table></figure>
<p>3.通过show方法显示popupmenu对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.show();</span><br></pre></td></tr></table></figure>
<h2><span id="浮动窗口popupwindow">浮动窗口PopupWindow</span></h2><p>这个其实就是Auto.js里面的悬浮窗。</p>
<p>构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> PopupWindow(View contentView, intwidth, int height)</span><br><span class="line">          参数1：contentView，浮动窗口中显示的内容</span><br><span class="line"></span><br><span class="line">          参数2：width，浮动窗口的宽度</span><br><span class="line"></span><br><span class="line">          参数3：height，浮动窗口的高度</span><br><span class="line"></span><br><span class="line">显示浮动窗口：showAsDropDown(Viewanchor, int xoff, int yoff)</span><br><span class="line"></span><br><span class="line">          参数1：anchor，浮动窗口出现在指定控件的下方</span><br><span class="line"></span><br><span class="line">          参数2：xoff，在X轴上的偏移量</span><br><span class="line"></span><br><span class="line">          参数3：yoff，在Y轴上的偏移量</span><br><span class="line"></span><br><span class="line">隐藏浮动窗口：dismiss()</span><br></pre></td></tr></table></figure>
<p>显示带列表的浮动窗口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">创建ListView对象</span><br><span class="line"></span><br><span class="line">          setAdapter(ListAdapter)：设置列表适配器，用于填充列表数据</span><br><span class="line"></span><br><span class="line">          setOnItemClickListener(OnItemClickListener)：设置列表项的监听事件</span><br><span class="line"></span><br><span class="line">setFocusable(true)：使浮动窗口可以获取焦点</span><br><span class="line"></span><br><span class="line">setBackgroundDrawable(newColorDrawable())：为解决焦点问题，这行代码必须执行</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/codingmyworld/archive/2011/08/28/2155594.html" target="_blank" rel="noopener">参考链接1</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/29/c-中的vector与set/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/29/c-中的vector与set/" itemprop="url">c++中的vector与set</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-29T19:06:14+08:00">
                2019-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#c合法标识符">C合法标识符</a></li>
<li><a href="#vector">vector</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#声明和初始化">声明和初始化</a><ul>
<li><a href="#输入访问">输入访问</a></li>
<li><a href="#基本操作">基本操作</a></li>
<li><a href="#二维">二维</a></li>
<li><a href="#析构函数">析构函数</a><ul>
<li><a href="#c~vector">c.~vector ()</a></li>
</ul>
</li>
<li><a href="#成员函数">成员函数</a><ul>
<li><a href="#cassignab">c.assign(a，b)</a></li>
<li><a href="#catidx">c.at(idx)</a></li>
<li><a href="#cback">c.back()</a></li>
<li><a href="#cbegin">c.begin()</a></li>
<li><a href="#ccapacity">c.capacity()</a></li>
<li><a href="#cclear">c.clear()</a></li>
<li><a href="#cempty">c.empty()</a></li>
<li><a href="#cend">c.end()</a></li>
<li><a href="#cerasepos">c.erase(pos)</a></li>
<li><a href="#cfront">c.front()</a></li>
<li><a href="#get_allocator">get_allocator</a></li>
<li><a href="#cinsertposelem">c.insert(pos,elem)</a></li>
<li><a href="#cinsertposnelem">c.insert(pos,n,elem)</a></li>
<li><a href="#cinsertposbegend">c.insert(pos,beg,end)</a></li>
<li><a href="#cmax_size">c.max_size()</a></li>
<li><a href="#cpop_back">c.pop_back()</a></li>
<li><a href="#cpush_backelem">c.push_back(elem)</a></li>
<li><a href="#crbegin">c.rbegin()</a></li>
<li><a href="#crend">c.rend()</a></li>
<li><a href="#cresizenum">c.resize(num)</a></li>
<li><a href="#creserve">c.reserve()</a></li>
<li><a href="#csize">c.size()</a></li>
<li><a href="#c1swapc2-swapc1c2">c1.swap(c2)、swap(c1,c2)</a></li>
<li><a href="#operator">operator[]</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#set">Set</a><ul>
<li><a href="#特性">特性</a></li>
<li><a href="#成员函数-1">成员函数</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="c合法标识符">C合法标识符</span></h2><p>C语言的标识符是<strong>字母或下划线(‘<em>‘)开头的，字母、下划线(‘</em>‘)和数字的字符串。</strong></p>
<p>判断合法标识符的时候需要注意一下，很多时候需要用gets输入而不是scanf来输入，因为有可能输入的字符串含有空格。</p>
<h2><span id="vector">vector</span></h2><h3><span id="简介">简介</span></h3><p><strong>向量 vector 是一种对象实体, 能够容纳许多其他类型相同的元素,</strong> 因此又被称为<strong>容器</strong>。</p>
<p>vector的优势就是在于可以随时调整自己的容量大小以便容纳数据。</p>
<p>使用的时候要加上头文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;vector&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="声明和初始化">声明和初始化</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a ;                                //声明一个int型向量a</span><br><span class="line">    vector&lt;int&gt; a(10) ;                            //声明一个初始大小为10的向量</span><br><span class="line">    vector&lt;int&gt; a(10, 1) ;                         //声明一个初始大小为10且初始值都为1的向量</span><br><span class="line">    vector&lt;int&gt; b(a) ;                             //声明并用向量a初始化向量b</span><br><span class="line">    vector&lt;int&gt; b(a.begin(), a.begin()+3) ;        //将a向量中从第0个到第2个(共3个)作为向量b的初始值</span><br><span class="line">    int n[] = &#123;1, 2, 3, 4, 5&#125; ;</span><br><span class="line">    vector&lt;int&gt; a(n, n+5) ;              //将数组n的前5个元素作为向量a的初值</span><br><span class="line">    vector&lt;int&gt; a(&amp;n[1], &amp;n[4]) ;        //将n[1] - n[4]范围内的元素作为向量a的初值</span><br></pre></td></tr></table></figure>
<h4><span id="输入访问">输入访问</span></h4><p>可以用普通的<strong>cin</strong>与<strong>cout</strong>进行输入与输出。</p>
<p>输出的时候还可以使用<strong>迭代器</strong>进行输出控制。</p>
<h4><span id="基本操作">基本操作</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a.size()获取元素个数</span><br><span class="line">a.empty()判断是否为空</span><br><span class="line">a.clear()清空元素</span><br><span class="line">a.insert(a.begin(), 1000)将1000插入到向量a的起始位置前 </span><br><span class="line">a.insert(a.begin(), 3, 1000)将1000分别插入到向量元素位置的0-2处(共3个元素)</span><br><span class="line">b.erase(b.begin())将起始位置的元素删除 </span><br><span class="line">b.erase(b.begin(), b.begin()+3)将(b.begin(), b.begin()+3)之间的元素删除</span><br><span class="line">a.swap(b)将向量a，b交换</span><br></pre></td></tr></table></figure>
<h4><span id="二维">二维</span></h4><p>其它操作与一维操作差不多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt; vector&lt;int&gt; &gt; b(10, vector&lt;int&gt;(5));        //创建一个10*5的int型二维向量</span><br></pre></td></tr></table></figure>
<h4><span id="析构函数">析构函数</span></h4><h5><span id="c~vector">c.~vector ()</span></h5><p><strong>销毁所有数据，释放内存</strong>。</p>
<h4><span id="成员函数">成员函数</span></h4><h5><span id="cassignab">c.assign(a，b)</span></h5><p>将a到b区间（前闭区间后开区间）中的数据赋值给c。</p>
<h5><span id="catidx">c.at(idx)</span></h5><p>传回idx所指向的数据，如果越界的话就抛出越界异常。</p>
<h5><span id="cback">c.back()</span></h5><p>传回最后一个数据并且不检查是否存在这个数据。</p>
<h5><span id="cbegin">c.begin()</span></h5><p>传回迭代器里面的第一个数据地址。</p>
<h5><span id="ccapacity">c.capacity()</span></h5><p>返回容器中的数据个数。</p>
<h5><span id="cclear">c.clear()</span></h5><p>清除容器中的所有数据。</p>
<h5><span id="cempty">c.empty()</span></h5><p>判断是否容器为空。</p>
<h5><span id="cend">c.end()</span></h5><p>指向迭代器末端元素的下一个，也就是指向一个不存在的元素。</p>
<h5><span id="cerasepos">c.erase(pos)</span></h5><p>删除pos位置的数据，然后返回下一个数据的位置。</p>
<h5><span id="cfront">c.front()</span></h5><p>传回第一个数据。</p>
<h5><span id="get_allocator">get_allocator</span></h5><p>使用构造函数返回一个拷贝。</p>
<h5><span id="cinsertposelem">c.insert(pos,elem)</span></h5><p>在pos位置插入一个elem拷贝，传回新数据位置。</p>
<h5><span id="cinsertposnelem">c.insert(pos,n,elem)</span></h5><p>在pos位置插入n个elem数据。无返回值。</p>
<h5><span id="cinsertposbegend">c.insert(pos,beg,end)</span></h5><p>在pos位置插入在[beg,end)区间的数据。无返回值。
　　</p>
<h5><span id="cmax_size">c.max_size()</span></h5><p>返回容器中最大数据的数量。</p>
<h5><span id="cpop_back">c.pop_back()</span></h5><p>删除最后一个数据。</p>
<h5><span id="cpush_backelem">c.push_back(elem)</span></h5><p>在尾部加入一个数据。</p>
<h5><span id="crbegin">c.rbegin()</span></h5><p>传回一个逆向队列的第一个数据。</p>
<h5><span id="crend">c.rend()</span></h5><p>传回一个逆向队列的最后一个数据的下一个位置。</p>
<h5><span id="cresizenum">c.resize(num)</span></h5><p>重新指定队列的长度。</p>
<h5><span id="creserve">c.reserve()</span></h5><p>保留适当的容量。</p>
<h5><span id="csize">c.size()</span></h5><p>返回容器中实际数据的个数。</p>
<h5><span id="c1swapc2-swapc1c2">c1.swap(c2)、swap(c1,c2)</span></h5><p>将c1和c2元素互换。同上操作。</p>
<h5><span id="operator">operator[]</span></h5><p>返回容器中指定位置的一个引用。</p>
<h2><span id="set">Set</span></h2><p>set（）是一种包含<strong>已排序对象</strong>的关联容器。 set集合容器实现了红黑树（Red-Black Tree）的<strong>平衡二叉检索树</strong>的数据结构，在插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，它<strong>不会插入相同键值</strong>的元素，而采取忽略处理。</p>
<p>平衡二叉树的检索使用<strong>中序遍历</strong>算法，<strong>检索效率高于vector、deque和list等容器。</strong></p>
<p>对于set容器中的键值，不可直接去修改！应该<strong>先删除该键值，再插入新的键值。</strong></p>
<h4><span id="特性">特性</span></h4><p>1) 不能直接改变元素值，因为那样会打乱原本正确的顺序，要改变元素值必须先删除旧元素，则插入新元素。</p>
<p>2) 不提供直接存取元素的任何操作函数，只能通过迭代器进行间接存取，而且从迭代器角度来看，元素值是常数。</p>
<p>3) 元素比较动作只能用于型别相同的容器(即元素和排序准则必须相同)。</p>
<h4><span id="成员函数">成员函数</span></h4><ol>
<li>begin()–返回指向第一个元素的迭代器。</li>
<li>clear()–清除所有元素。</li>
<li>count()–返回某个值元素的个数。</li>
<li>empty()–如果集合为空，返回true。</li>
<li>end()–返回指向最后一个元素的迭代器。</li>
<li>equal_range()–返回集合中与给定值相等的上下限的两个迭代器。</li>
<li>erase()–删除集合中的元素。</li>
<li>find()–返回一个指向被查找到元素的迭代器。</li>
<li>get_allocator()–返回集合的分配器。</li>
<li>insert()–在集合中插入元素。</li>
<li>lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器。</li>
<li>key_comp()–返回一个用于元素间值比较的函数。</li>
<li>max_size()–返回集合能容纳的元素的最大限值。</li>
<li>rbegin()–返回指向集合中最后一个元素的反向迭代器。</li>
<li>rend()–返回指向集合中第一个元素的反向迭代器。</li>
<li>size()–集合中元素的数目。</li>
<li>swap()–交换两个集合变量。</li>
<li>upper_bound()–返回大于某个值元素的迭代器。</li>
<li>value_comp()–返回一个用于比较元素间的值的函数。</li>
</ol>
<p><a href="https://www.cnblogs.com/omelet/p/6627667.html" target="_blank" rel="noopener">set参考链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/28/素性测试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/28/素性测试/" itemprop="url">素性测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-28T22:59:58+08:00">
                2019-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  287
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#素性测试">素性测试</a><ul>
<li><a href="#随机算法">随机算法</a><ul>
<li><a href="#fermat-primality-test">Fermat primality test</a></li>
<li><a href="#millerrabin-primality-test">Miller–Rabin primality test</a></li>
<li><a href="#solovaystrassen-primality-test">Solovay–Strassen primality test</a></li>
</ul>
</li>
<li><a href="#确定型启发式算法">确定型启发式算法</a><ul>
<li><a href="#aks-primality-test">AKS primality test</a></li>
<li><a href="#bailliepsw-primality-test">Baillie–PSW primality test</a></li>
</ul>
</li>
<li><a href="#试除法">试除法</a><ul>
<li><a href="#lucas-primality-test">Lucas primality test</a></li>
<li><a href="#lucaslehmer-primality-test">Lucas–Lehmer primality test</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="素性测试">素性测试</span></h2><p>所谓的素性测试就是<strong>判定一个整数是否为素数</strong>的方法。</p>
<p>素性测试算法分为<strong>确定型启发式算法</strong>以及<strong>随机算法</strong>。</p>
<h3><span id="随机算法">随机算法</span></h3><h4><span id="fermat-primality-test">Fermat primality test</span></h4><p><strong>费马素性检验是一种素数判定法则，利用随机化算法判断一个数是合数还是可能是素数。</strong></p>
<p><img src="/2019/03/28/素性测试/费马.jpg" alt=""></p>
<h4><span id="millerrabin-primality-test">Miller–Rabin primality test</span></h4><p><strong>米勒-拉宾素性检验是一种素数判定法则，利用随机化算法判断一个数是合数还是可能是素数。</strong></p>
<p><img src="/2019/03/28/素性测试/米勒.jpg" alt=""></p>
<h4><span id="solovaystrassen-primality-test">Solovay–Strassen primality test</span></h4><p><img src="/2019/03/28/素性测试/Solovay.jpg" alt=""></p>
<h3><span id="确定型启发式算法">确定型启发式算法</span></h3><h4><span id="aks-primality-test">AKS primality test</span></h4><p>AKS素性测试（又被称为 Agrawal–Kayal–Saxena素性测试 和 Cyclotomic AKS test）是一个<strong>决定型素性测试算法</strong> ，这个算法<strong>可以在多项式时间之内，决定一个给定整数是素数或者合数</strong>。</p>
<p><img src="/2019/03/28/素性测试/AKS.jpg" alt=""></p>
<h4><span id="bailliepsw-primality-test">Baillie–PSW primality test</span></h4><p><a href="https://en.wikipedia.org/wiki/Baillie%E2%80%93PSW_primality_test" target="_blank" rel="noopener">维基百科参考链接</a></p>
<h3><span id="试除法">试除法</span></h3><h4><span id="lucas-primality-test">Lucas primality test</span></h4><p><img src="/2019/03/28/素性测试/Lucas.jpg" alt=""></p>
<h4><span id="lucaslehmer-primality-test">Lucas–Lehmer primality test</span></h4><p><a href="https://en.wikipedia.org/wiki/Lucas%E2%80%93Lehmer_primality_test" target="_blank" rel="noopener">维基百科参考链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/27/Flutter-Widget框架（一）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/Flutter-Widget框架（一）/" itemprop="url">Flutter-Widget框架（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T20:13:46+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/" itemprop="url" rel="index">
                    <span itemprop="name">移动端开发</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/Flutter/" itemprop="url" rel="index">
                    <span itemprop="name">Flutter</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  697
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#widget框架">Widget框架</a><ul>
<li><a href="#简单实例">简单实例</a></li>
<li><a href="#基础widget">基础Widget</a><ul>
<li><a href="#常用基础widget">常用基础widget</a><ul>
<li><a href="#text">Text</a></li>
</ul>
</li>
<li><a href="#rowcolumn">Row，Column</a></li>
<li><a href="#stack">Stack</a></li>
<li><a href="#container">Container</a></li>
</ul>
</li>
<li><a href="#手势">手势</a></li>
<li><a href="#statefulwidget">StatefulWidget</a></li>
<li><a href="#响应widget生命周期事件">响应widget生命周期事件</a></li>
<li><a href="#key">Key</a></li>
</ul>
</li>
<li><a href="#备注">备注：</a></li>
</ul>
<!-- tocstop -->
<h2><span id="widget框架">Widget框架</span></h2><p>参考地址：Flutter中文网。</p>
<h3><span id="简单实例">简单实例</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    new Center(</span><br><span class="line">      child: new Text(</span><br><span class="line">        &apos;Hello, world!&apos;,</span><br><span class="line">        textDirection: TextDirection.ltr,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编写应用程序时，通常会创建<strong>新的widget</strong>，这些widget是<strong>无状态的StatelessWidget</strong>或者是<strong>有状态的StatefulWidget</strong>， 具体的选择取决于您的widget<strong>是否需要管理一些状态</strong>。widget的主要工作是实现一个<strong>build函数</strong>，用以构建自身。</p>
<h3><span id="基础widget">基础Widget</span></h3><h4><span id="常用基础widget">常用基础widget</span></h4><h5><span id="text">Text</span></h5><p>创建一个带格式的文本。</p>
<h4><span id="rowcolumn">Row，Column</span></h4><p>水平与垂直方向上面灵活的布局。</p>
<h4><span id="stack">Stack</span></h4><p>与线性布局类似，允许Widget堆叠。同时可以使用Positioned来定位堆叠的Widget相对于Stack的上下左右四条边的位置。</p>
<h4><span id="container">Container</span></h4><p>创建矩形视觉元素。</p>
<h3><span id="手势">手势</span></h3><p>手势的交互首先就是要检测输入的手势。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class MyButton extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new GestureDetector(</span><br><span class="line">      onTap: () &#123;</span><br><span class="line">        print(&apos;MyButton was tapped!&apos;);</span><br><span class="line">      &#125;,</span><br><span class="line">      child: new Container(</span><br><span class="line">        height: 36.0,</span><br><span class="line">        padding: const EdgeInsets.all(8.0),</span><br><span class="line">        margin: const EdgeInsets.symmetric(horizontal: 8.0),</span><br><span class="line">        decoration: new BoxDecoration(</span><br><span class="line">          borderRadius: new BorderRadius.circular(5.0),</span><br><span class="line">          color: Colors.lightGreen[500],</span><br><span class="line">        ),</span><br><span class="line">        child: new Center(</span><br><span class="line">          child: new Text(&apos;Engage&apos;),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GestureDetector widget</strong>并不具有显示效果，而是<strong>检测由用户做出的手势。</strong> 许多widget都会使用一个GestureDetector为其他widget提供<strong>可选的回调</strong>。 </p>
<h3><span id="statefulwidget">StatefulWidget</span></h3><p>StatefulWidgets是特殊的widget，它知道如何<strong>生成State对象</strong>，然后用它来<strong>保持状态</strong>。 </p>
<p>在Flutter中，Stateful与State是单独的对象，他们的对象具有不同的生命周期： <strong>Widget是临时对象，用于构建当前状态下的应用程序，而State对象在多次调用build()之间保持不变，允许它们记住信息(状态)。</strong></p>
<p>在Flutter中，<strong>事件流是“向上”传递的，而状态流是“向下”传递的</strong>，重定向这一流程的共同父元素是<strong>State</strong>。</p>
<h3><span id="响应widget生命周期事件">响应widget生命周期事件</span></h3><p>在StatefulWidget调用<strong>createState</strong>之后，框架将新的状态对象插入树中，然后调用状态对象的<strong>initState</strong>。 子类化State可以重写initState，以完成仅需要执行一次的工作。 </p>
<p>当一个状态对象不再需要时，框架调用状态对象的<strong>dispose</strong>。 可以覆盖该dispose方法来执行<strong>清理工作。</strong></p>
<h3><span id="key">Key</span></h3><p><strong>可以使用key来控制框架将在widget重建时与哪些其他widget匹配。</strong>默认情况下，框架根据它们的<strong>runtimeType</strong>和它们的<strong>显示顺序</strong>来匹配。 使用key时，框架要求两个widget具有<strong>相同的key和runtimeType。</strong></p>
<p><strong>全局的key可以用来标识子Widget。</strong>同时在整个Widget结构中必须是全局唯一的，所以可以用全局Key来检索与WIdget关联的状态。</p>
<h2><span id="备注">备注：</span></h2><p><a href="https://flutterchina.club/widgets/basics/" target="_blank" rel="noopener">Flutter中文网Widget目录</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/26/C-常用函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/26/C-常用函数/" itemprop="url">C++常用函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-26T22:00:54+08:00">
                2019-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#c">C++</a><ul>
<li><a href="#cstdlib">cstdlib</a></li>
<li><a href="#cctype">cctype</a></li>
<li><a href="#algorithm">algorithm</a></li>
<li><a href="#cmath">cmath</a></li>
<li><a href="#cstdlib-1">cstdlib</a></li>
</ul>
</li>
<li><a href="#c">C</a></li>
</ul>
<!-- tocstop -->
<h2><span id="前言">前言</span></h2><p>目前在备战CCF，算法题刷了蛮多的了，这次就记录一下，常用的C++/C的函数。（只记录<strong>常用且实用</strong>的，不是大全，再次强调）</p>
<h2><span id="c">C++</span></h2><h3><span id="cstdlib">cstdlib</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">begin       得到指向字符串开头的Iterator（迭代器）</span><br><span class="line">end         得到指向字符串结尾的Iterator</span><br><span class="line">rbegin      得到指向反向字符串开头的Iterator</span><br><span class="line">rend        得到指向反向字符串结尾的Iterator</span><br><span class="line">size        得到字符串的大小</span><br><span class="line">length()    和size函数功能相同</span><br><span class="line">max_size    字符串可能的最大大小</span><br><span class="line">empty       判断是否为空</span><br><span class="line">operator[]  取第几个元素，相当于数组</span><br><span class="line">c_str       取得C风格的const char* 字符串</span><br><span class="line">swap        交换函数</span><br><span class="line">insert      插入字符</span><br><span class="line">append      追加字符</span><br><span class="line">push_back   追加字符</span><br><span class="line">erase       删除字符串</span><br><span class="line">clear       清空字符容器中所有内容</span><br><span class="line">replace     替代</span><br><span class="line">copy        字符串到空间</span><br><span class="line">find        查找,返回基于0的索引号</span><br><span class="line">substr(n1,len)       得到字符串从n1开始的长度为len的子串</span><br><span class="line">compare              比较字符串(支持所有的关系运算符)</span><br><span class="line">getline              从输入流中读入一行</span><br></pre></td></tr></table></figure>
<h3><span id="cctype">cctype</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using ::isalpha; //是否字母</span><br><span class="line"></span><br><span class="line">using ::isdigit; //是否是数字</span><br><span class="line"></span><br><span class="line">using ::isgraph; //是否字母、数字或标点</span><br><span class="line"></span><br><span class="line">using ::islower; //是否小写</span><br><span class="line"></span><br><span class="line">using ::ispunct; //是否标点</span><br><span class="line"></span><br><span class="line">using ::isspace; //是否空格</span><br><span class="line"></span><br><span class="line">using ::isupper; //是否大写</span><br><span class="line"></span><br><span class="line">using ::isxdigit; //是否十六进制数字</span><br><span class="line"></span><br><span class="line">using ::tolower; //转为小写</span><br><span class="line"></span><br><span class="line">using ::toupper; //转为大写</span><br></pre></td></tr></table></figure>
<h3><span id="algorithm">algorithm</span></h3><table>
<thead>
<tr>
<th>循环</th>
<th>对序列中的每个元素执行某项操作</th>
<th>for_each()</th>
</tr>
</thead>
<tbody>
<tr>
<td>查找</td>
<td>在序列中找出某个值的第一次出现的位置</td>
<td>find(a,a+size,n) 返回<em>b,</em>当<em>b=a+size</em>即没找到，<em>a</em>为指针</td>
</tr>
<tr>
<td>在序列中找出符合某谓词的第一个元素</td>
<td>find_if()</td>
<td></td>
</tr>
<tr>
<td>在序列中找出一子序列的最后一次出现的位置</td>
<td>find_end()</td>
<td></td>
</tr>
<tr>
<td>在序列中找出第一次出现指定值集中之值位置</td>
<td>find_first_of()</td>
<td></td>
</tr>
<tr>
<td>在序列中找出相邻的一对值</td>
<td>adjacent_find()</td>
<td></td>
</tr>
<tr>
<td>计数</td>
<td>在序列中统计某个值出现的次数</td>
<td>count()</td>
</tr>
<tr>
<td>在序列中统计与某谓词匹配的次数</td>
<td>count_if()</td>
<td></td>
</tr>
<tr>
<td>比较</td>
<td>找出两个序列相异的第一个元素</td>
<td>mismatch()</td>
</tr>
<tr>
<td>两个序列中的对应元素都相同时为真</td>
<td>equal(a,a+n,b,cmp)</td>
<td></td>
</tr>
<tr>
<td>在序列中找到等于某值的连续<em>n</em>次出现的位置</td>
<td>equal_range(a,a+n,x)</td>
<td></td>
</tr>
<tr>
<td>搜索</td>
<td>在序列中找出一子序列的第一次出现的位置</td>
<td>search()</td>
</tr>
<tr>
<td>在序列中找出一值的连续<em>n</em>次出现的位置</td>
<td>search_n()</td>
<td></td>
</tr>
<tr>
<td>复制</td>
<td>从序列的第一个元素起进行复制</td>
<td>copy()</td>
</tr>
<tr>
<td>从序列的最后一个元素起进行复制</td>
<td>copy_backward()</td>
<td></td>
</tr>
<tr>
<td>交换</td>
<td>交换两个元素</td>
<td>swap()</td>
</tr>
<tr>
<td>交换指定范围的元素</td>
<td>swap_ranges()</td>
<td></td>
</tr>
<tr>
<td>交换由迭代器所指的两个元素</td>
<td>iter_swap()</td>
<td></td>
</tr>
<tr>
<td>变换</td>
<td>将某操作应用于指定范围的每个元素</td>
<td>transform()</td>
</tr>
<tr>
<td>替换</td>
<td>用一个给定值替换一些值</td>
<td>replace()</td>
</tr>
<tr>
<td>替换满足谓词的一些元素</td>
<td>replace_if()</td>
<td></td>
</tr>
<tr>
<td>复制序列时用一给定值替换元素</td>
<td>replace_copy()</td>
<td></td>
</tr>
<tr>
<td>复制序列时替换满足谓词的元素</td>
<td>replace_copy_if()</td>
<td></td>
</tr>
<tr>
<td>填充</td>
<td>用一给定值取代所有元素</td>
<td>fill()</td>
</tr>
<tr>
<td>用一给定值取代前<em>n</em>个元素</td>
<td>fill_n()</td>
<td></td>
</tr>
<tr>
<td>生成</td>
<td>用一操作的结果取代所有元素</td>
<td>generate()</td>
</tr>
<tr>
<td>用一操作的结果取代前<em>n</em>个元素</td>
<td>generate_n()</td>
<td></td>
</tr>
<tr>
<td>删除</td>
<td>删除具有给定值的元素</td>
<td>remove()</td>
</tr>
<tr>
<td>删除满足谓词的元素</td>
<td>remove_if()</td>
<td></td>
</tr>
<tr>
<td>复制序列时删除具有给定值的元素</td>
<td>remove_copy()</td>
<td></td>
</tr>
<tr>
<td>复制序列时删除满足谓词的元素</td>
<td>remove_copy_if()</td>
<td></td>
</tr>
<tr>
<td>唯一</td>
<td>删除相邻的重复元素</td>
<td>unique()</td>
</tr>
<tr>
<td>复制序列时删除相邻的重复元素</td>
<td>unique_copy()</td>
<td></td>
</tr>
<tr>
<td>反转</td>
<td>反转元素的次序</td>
<td>reverse(a,a+n)</td>
</tr>
<tr>
<td>复制序列时反转元素的次序</td>
<td>reverse_copy()</td>
<td></td>
</tr>
<tr>
<td>环移</td>
<td>循环移动元素</td>
<td>rotate(a,a+m,a+n)以<em>m</em>位置为界交换前后序列</td>
</tr>
<tr>
<td>复制序列时循环移动元素</td>
<td>rotate_copy()</td>
<td></td>
</tr>
<tr>
<td>随机</td>
<td>采用均匀分布来随机移动元素</td>
<td>random_shuffle()</td>
</tr>
<tr>
<td>划分</td>
<td>将满足某谓词的元素都放到前面</td>
<td>partition()</td>
</tr>
<tr>
<td>将满足某谓词的元素都放到前面并维持原顺序</td>
<td>stable_partition()</td>
<td></td>
</tr>
<tr>
<td>排序</td>
<td>以很好的平均效率排序</td>
<td>sort(a,a+20,cmp)bool cmp( int a, int b ){ return a&gt;b; }在容器中或<em>string</em>用<em>begin</em>（）</td>
</tr>
<tr>
<td>排序，并维持相同元素的原有顺序</td>
<td>stable_sort()</td>
<td></td>
</tr>
<tr>
<td>将序列的前一部分排好序</td>
<td>partial_sort()</td>
<td></td>
</tr>
<tr>
<td>复制的同时将序列的前一部分排好序</td>
<td>partial_sort_copy()</td>
<td></td>
</tr>
<tr>
<td>第<em>n</em>个元素</td>
<td>将第<em>n</em>各元素放到它的正确位置</td>
<td>nth_element()</td>
</tr>
<tr>
<td>二分检索</td>
<td>找到大于等于某值的第一次出现</td>
<td>lower_bound()</td>
</tr>
<tr>
<td>找到大于某值的第一次出现</td>
<td>upper_bound()</td>
<td></td>
</tr>
<tr>
<td>找到（在不破坏顺序的前提下）可插入给定值的最大范围</td>
<td>equal_range()</td>
<td></td>
</tr>
<tr>
<td>在有序序列中确定给定元素是否存在</td>
<td>binary_search()</td>
<td></td>
</tr>
<tr>
<td>归并</td>
<td>归并两个有序序列</td>
<td>merge()</td>
</tr>
<tr>
<td>归并两个接续的有序序列</td>
<td>inplace_merge()</td>
<td></td>
</tr>
<tr>
<td>有序结构上的集合操作</td>
<td>一序列为另一序列的子序列时为真</td>
<td>includes()</td>
</tr>
<tr>
<td>构造两个集合的有序并集</td>
<td>set_union()</td>
<td></td>
</tr>
<tr>
<td>构造两个集合的有序交集</td>
<td>set_intersection()</td>
<td></td>
</tr>
<tr>
<td>构造两个集合的有序差集</td>
<td>set_difference()</td>
<td></td>
</tr>
<tr>
<td>构造两个集合的有序对称差集（并<em>-</em>交）</td>
<td>set_symmetric_difference()</td>
<td></td>
</tr>
<tr>
<td>堆操作</td>
<td>向堆中加入元素</td>
<td>push_heap()</td>
</tr>
<tr>
<td>从堆中弹出元素</td>
<td>pop_heap()</td>
<td></td>
</tr>
<tr>
<td>从序列构造堆</td>
<td>make_heap()</td>
<td></td>
</tr>
<tr>
<td>给堆排序</td>
<td>sort_heap()</td>
<td></td>
</tr>
<tr>
<td>最大和最小</td>
<td>两个值中较小的</td>
<td>min()</td>
</tr>
<tr>
<td>两个值中较大的</td>
<td>max()</td>
<td></td>
</tr>
<tr>
<td>序列中的最小元素</td>
<td>min_element(a,a+n)</td>
<td></td>
</tr>
<tr>
<td>序列中的最大元素</td>
<td>max_element()</td>
<td></td>
</tr>
<tr>
<td>词典比较</td>
<td>两个序列按字典序的第一个在前</td>
<td>lexicographical_compare()</td>
</tr>
<tr>
<td>排列生成器</td>
<td>按字典序的下一个排列</td>
<td>next_permutation()</td>
</tr>
<tr>
<td>按字典序的前一个排列</td>
<td>prev_permutation()</td>
</tr>
</tbody>
</table>
<h3><span id="cmath">cmath</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">using ::abs; //绝对值</span><br><span class="line"></span><br><span class="line">using ::exp; //指数值</span><br><span class="line"></span><br><span class="line">using ::fabs; //绝对值</span><br><span class="line"></span><br><span class="line">using ::fmod; //求余</span><br><span class="line"></span><br><span class="line">using ::sqrt; //开方</span><br></pre></td></tr></table></figure>
<h3><span id="cstdlib">cstdlib</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">double atof(const char *str);</span><br><span class="line"></span><br><span class="line">把字符串str转换成double类型。等价于：strtod(str, (char**)NULL)。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">int atoi(const char *str);</span><br><span class="line"></span><br><span class="line">把字符串str转换成int类型。等价于：(int)strtol(str, (char**)NULL, 10)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int rand(void);</span><br><span class="line"></span><br><span class="line">产生一个0到RAND_MAX之间的伪随机整数。RAND_MAX值至少为32767。</span><br><span class="line"></span><br><span class="line">void srand(unsigned int seed);</span><br><span class="line"></span><br><span class="line">设置新的伪随机数序列的种子为seed。种子的初值为1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void *malloc(size_t size);</span><br><span class="line"></span><br><span class="line">为大小为size的对象分配足够的内存，并返回指向所分配区域的第一个字节的指针；如果内存不足以满足要求，则返回NULL。</span><br><span class="line"></span><br><span class="line">不对分配的内存区域进行初始化。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void free(void *ptr);</span><br><span class="line"></span><br><span class="line">释放ptr指向的内存空间，若ptr为NULL，则什么也不做。ptr必须指向先前用动态分配函数malloc、realloc或calloc分配的空间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void exit(int status);</span><br><span class="line"></span><br><span class="line">使程序正常终止。atexit函数以与注册相反的顺序被调用，所有打开的文件被刷新，所有打开的流被关闭。status的值如何被返回依具体的实现而定，但用0表示正常终止，也可用值EXIT_SUCCESS和EXIT_FAILURE。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void qsort(void *base, size_t n, size_t size,</span><br><span class="line"></span><br><span class="line">int (*compare)(const void *, const void *));</span><br><span class="line"></span><br><span class="line">对由n个大小为size的对象构成的数组base进行升序排序。</span><br><span class="line"></span><br><span class="line">比较函数compare的形式如下：</span><br><span class="line"></span><br><span class="line">int func_name(const void *arg1, const voie *arg2);</span><br><span class="line"></span><br><span class="line">其返回值必须如下所示：</span><br><span class="line"></span><br><span class="line">arg1 &lt; arg2，返回值&lt;0；</span><br><span class="line"></span><br><span class="line">arg1 == arg2，返回值==0；</span><br><span class="line"></span><br><span class="line">arg1 &gt; arg2，返回值&gt;0。</span><br></pre></td></tr></table></figure>
<h2><span id="c">C</span></h2><p>未完待续（貌似也差不多的说…）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/25/Win10-64位Debug安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/Win10-64位Debug安装/" itemprop="url">Win10-64位Debug安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T10:39:36+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/其它/" itemprop="url" rel="index">
                    <span itemprop="name">其它</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  842
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#正文">正文</a><ul>
<li><a href="#安装">安装</a></li>
<li><a href="#配置">配置</a></li>
<li><a href="#测试">测试</a><ul>
<li><a href="#debug">Debug</a></li>
<li><a href="#debug常用功能">Debug常用功能</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="前言">前言</span></h2><p>由于本学期开设了汇编实验这门课，相对应的，也有了汇编实验的实验课，由于需要用到debug，再加上win10需要配置，不像win7可以直接使用，这里就写一篇博客记录一下配置过程。</p>
<p>其实win10上使用debug一般有两种方法，一种是在电脑上面装上虚拟机，用win7直接使用debug，第二种就是今天介绍的用<strong>DOSBox</strong>来解决。</p>
<h2><span id="正文">正文</span></h2><p>DOSBox是一种<strong>模拟器软件</strong>，主要是在IBM PC兼容机下，模拟旧时的操作系统：MS-DOS，支持许多IBM PC兼容的显卡和声卡，为本地的DOS程序提供执行环境，使这些程序可以正常运行于大多数现代计算机上的不同操作系统。DOSBox特别是为运行早期的计算机游戏所设计，主要以C++编写，是以GNU通用公共许可证许可发布的自由软件。</p>
<p>上面是对DOSBox的简单介绍，摘自维基百科，下面开始介绍具体流程。</p>
<p>首先，众所周知，win10上面是不支持直接使用debug的，如果一旦点击debug.exe的话，会报错。</p>
<p><img src="/2019/03/25/Win10-64位Debug安装/不支持.jpg" alt=""></p>
<h3><span id="安装">安装</span></h3><p>关于debug与DOSBox的下载的话，都可以直接在搜索引擎搜索下载，这里要注意一下DOSBox的下载：</p>
<p><a href="https://www.dosbox.com/download.php?main=1" target="_blank" rel="noopener">DOSBox官网</a>点击进去之后，会看到这样的画面。</p>
<p><img src="/2019/03/25/Win10-64位Debug安装/DOSBox官网.jpg" alt=""></p>
<p>然后就是点击这个，然后进去下载就可以。</p>
<p><img src="/2019/03/25/Win10-64位Debug安装/DOSBox下载.jpg" alt=""></p>
<p>下载完DOSBox之后会发现它是一个安装器，自己选择安装到哪里，但是一定要知道位置。至于debug.exe的安装位置的话，我的建议是，在C盘下面直接建一个<strong>MYDEBUG</strong>的文件夹，然后把相关文件放进去。（我这里的DEBUG是网盘里面找到的，实际上搜索下载的貌似只要一个debug.exe就可以）</p>
<p><img src="/2019/03/25/Win10-64位Debug安装/MYDEBUG.jpg" alt=""></p>
<h3><span id="配置">配置</span></h3><p>安装完成之后，找到DOSBox安装目录下的DOSBox 0.74 Options.bat文件，然后双击:</p>
<p><img src="/2019/03/25/Win10-64位Debug安装/DOSBox文件夹.jpg" alt=""></p>
<p>然后在末尾添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOUNT C C:\MYDEBUG</span><br><span class="line">C:</span><br><span class="line">debug</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/25/Win10-64位Debug安装/DOSBox配置.jpg" alt=""></p>
<p>这样配置的目的很单纯，只是让每次编译的时候不用准备前面这些条件，就可以直接使用，如果每次都要配置，太麻烦。</p>
<h3><span id="测试">测试</span></h3><p>安装配置完之后自然要测试一下能不能用，先介绍一下debug，如下：</p>
<h4><span id="debug">Debug</span></h4><p><strong>Debug是DOS、Windows都提供的实模式(8086方式)程序的调试工具。</strong></p>
<p><strong>使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级别跟踪程序的运行。</strong></p>
<h4><span id="debug常用功能">Debug常用功能</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用Debug的R命令查看、改变CPU寄存器的内容;</span><br><span class="line"></span><br><span class="line"> 用Debug的D命令查看内存中的内容;</span><br><span class="line"></span><br><span class="line"> 用Debug的E命令改写内存中的内容;</span><br><span class="line"></span><br><span class="line"> 用Debug的U命令将内存中的机器指令翻译成汇编指令;</span><br><span class="line"></span><br><span class="line"> 用Debug的T命令执行一条机器指令;</span><br><span class="line"></span><br><span class="line"> 用Debug的A命令以汇编指令的格式在内存中写入一条机器指令;</span><br></pre></td></tr></table></figure>
<p>这里用命令测试一下是否可以使用：</p>
<p><img src="/2019/03/25/Win10-64位Debug安装/测试.jpg" alt=""></p>
<p>绿色部分是之前配置的部分，红色箭头指向的就是命令，实测没问题可以使用，这样就可以开始<strong>愉快的</strong>汇编编程了。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/24/递归递推与试除法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/24/递归递推与试除法/" itemprop="url">递归递推与试除法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T20:49:36+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#递推">递推</a></li>
<li><a href="#递归">递归</a><ul>
<li><a href="#1联系">1.联系</a></li>
<li><a href="#2区别">2.区别</a></li>
</ul>
</li>
<li><a href="#试除法求解素数">试除法（求解素数）</a></li>
</ul>
<!-- tocstop -->
<h2><span id="递推">递推</span></h2><p>递推是一种经常被使用的简单算法，定义是<strong>一种用若干步可重复的简单运算来描述复杂问题的方法。</strong></p>
<p>递推的特点在于，<strong>每一项都和他前面的若干项由一定的关联</strong>，这种关联一般可以通过<strong>递推关系式</strong>来表示，可以通过其前面若干项得出某项的数据。</p>
<p>对于递推问题的求解一般从初始的一个或若干个数据项出发，<strong>通过递推关系式逐步推进，从而得出想要的结果，</strong>这种求解问题的方法叫<strong>递推法</strong>。其中，初始的若干数据项称为<strong>边界</strong>。</p>
<p>简单实例如下：</p>
<p>喜欢西游记的同学肯定都知道悟空偷吃蟠桃的故事，你们一定都觉得这猴子太闹腾了，其实你们是有所不知：悟空是在研究一个数学问题！<br>    什么问题？他研究的问题是蟠桃一共有多少个！<br>    不过，到最后，他还是没能解决这个难题，呵呵^-^<br>    当时的情况是这样的：<br>    第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？</p>
<p>Input<br>    输入数据有多组，每组占一行，包含一个正整数n（1&lt;n&lt;30），表示只剩下一个桃子的时候是在第n天发生的。</p>
<p>Output<br>    对于每组输入数据，输出第一天开始吃的时候桃子的总数，每个测试实例占一行。</p>
<p>Sample Input<br>    2 4</p>
<p>Sample Output</p>
<p>4 22</p>
<p><strong>分析：</strong></p>
<p>这其实就是一个<strong>递推问题</strong>，需要注意的是，<strong>一般而言递推的计算效率要大于递归</strong>。由题意得f(n) = 2 * ( f(n-1) + 1 )，另外f(1)=1。这就可以求解出相应的答案了，由于题目太简单，这里只写思路。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int peach(int n) &#123;//这里就是递推</span><br><span class="line">    if(n == 1)</span><br><span class="line">        return 1;</span><br><span class="line">    else &#123;</span><br><span class="line">        long res = 1L;</span><br><span class="line">        while(--n)</span><br><span class="line">            res = 2 * (res + 1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line"> </span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;n) != EOF)</span><br><span class="line">        printf(&quot;%d\n&quot;, peach(n));</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="递归">递归</span></h2><p>上面说到，一般来说，递推的计算效率是高于递归的，那么递归与递推有什么区别和联系呢？</p>
<h3><span id="1联系">1.联系</span></h3><p>递归和递推有一定的相似性。<br>    这两个问题都可以描述为以下形式：<br>    <strong>f(n)=g(f(n-1)，…，f(0))</strong><br>    这是二者的共同特点。</p>
<h3><span id="2区别">2.区别</span></h3><p>1）递归表现出来的是<strong>自己调用自己</strong>，递推则没有这样的形式。</p>
<p>2）递归是从问题的<strong>最终目标</strong>出发，将问题<strong>简单化</strong>，这就是<strong>逆向的</strong>求解。</p>
<p>递推则是从<strong>简单问题</strong>出发，<strong>正向的</strong>解决问题。</p>
<p>3）递归中，<strong>n是已知的</strong>。递推则可以是在计算中知道，不需要提前知道。</p>
<p>4）一般来说，<strong>递推的效率是大于递归的。</strong></p>
<h2><span id="试除法求解素数">试除法（求解素数）</span></h2><p>一般来说，求解素数的话，要用到两种方式，<strong>一个是试除法一个是筛选法</strong>，<a href="https://thbelief.coding.me/2019/03/21/%E5%88%86%E6%8B%86%E7%B4%A0%E6%95%B0%E5%92%8C/">这篇博客</a>里面就写到了Eratosthenes筛选法，这里的话就介绍一下另外一种方法，试除法。试除法其实一般有很多种，这里只介绍一点。大致知道算法就行，现场写也可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">/*</span><br><span class="line">质数：一个自然数，如果只有1和它本身两个约数，这个数叫做质数（也称素数）．</span><br><span class="line">对于一个整数n，只需用小于等于√n所有素数去除，所以本算法的时间复杂度为O(√)的。</span><br><span class="line">*/</span><br><span class="line">bool IsPrime(int n,int prime[],int length)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for(i = 2; (long long)i*i &lt;= n&amp;&amp;prime[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(n %i == 0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/23/java基础-略知一二/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/23/java基础-略知一二/" itemprop="url">java基础-略知一二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-23T17:45:45+08:00">
                2019-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#collection">Collection</a></li>
<li><a href="#set">Set</a><ul>
<li><a href="#hashset">HashSet</a></li>
<li><a href="#linkedhashset">LinkedHashSet</a></li>
<li><a href="#sortedset">SortedSet</a></li>
<li><a href="#treeset">TreeSet</a></li>
</ul>
</li>
<li><a href="#list">List</a></li>
<li><a href="#arraylist">ArrayList</a><ul>
<li><a href="#构造方法">构造方法</a></li>
</ul>
</li>
<li><a href="#linkedlist">LinkedList</a><ul>
<li><a href="#构造方法-1">构造方法</a></li>
</ul>
</li>
<li><a href="#map">Map</a><ul>
<li><a href="#特性">特性</a></li>
<li><a href="#方法">方法</a></li>
</ul>
</li>
<li><a href="#hashmap">HashMap</a><ul>
<li><a href="#常用操作">常用操作</a></li>
</ul>
</li>
<li><a href="#iterator">Iterator</a></li>
</ul>
<!-- tocstop -->
<h2><span id="collection">Collection</span></h2><p><strong>集合中只能放置对象的引用，不能放置原生数据类型。</strong></p>
<p>常用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 将所有元素从一个列表复制到另一个列表</span><br><span class="line">Collections.copy(new ArrayList(), new ArrayList());</span><br><span class="line">// 如果两个指定collection中没有相同的元素,则返回 true</span><br><span class="line">Collections.disjoint(new ArrayList(), new ArrayList());</span><br><span class="line">// 使用指定元素替换指定列表中的所有元素</span><br><span class="line">Collections.fill(new ArrayList(), new Object());</span><br><span class="line">// 返回指定 collection 中等于指定对象的元素数</span><br><span class="line">Collections.frequency(new ArrayList(), new Object());</span><br><span class="line">// 返回指定源列表中第一次出现指定目标列表的起始位置,如果没有出现这样的列表,则返回 -1</span><br><span class="line">Collections.indexOfSubList(new ArrayList(), new ArrayList());</span><br><span class="line">// 根据元素的自然顺序，返回给定 collection 的最大元素</span><br><span class="line">Collections.max(new ArrayList());</span><br><span class="line">// //根据元素的自然顺序，返回给定 collection 的最大元素</span><br><span class="line">Collections.min(new ArrayList());</span><br><span class="line">// 使用另一个值替换列表中出现的所有某一指定值</span><br><span class="line">Collections.replaceAll(new ArrayList(), &quot;oldVal&quot;, &quot;newVal&quot;);</span><br><span class="line">// 反转指定列表中元素的顺序</span><br><span class="line">Collections.reverse(new ArrayList());</span><br><span class="line">// 返回一个比较器,它强行反转</span><br><span class="line">Collections.reverseOrder();</span><br><span class="line">// 返回一个比较器,它强行反转指定比较器的顺序</span><br><span class="line">Collections.reverseOrder(new Comparator() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public int compare(Object o1, Object o2) &#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 使用默认随机源随机更改指定列表的序列</span><br><span class="line">Collections.shuffle(new ArrayList());</span><br><span class="line">// 根据元素的自然顺序对指定列表按升序进行排序</span><br><span class="line">Collections.sort(new ArrayList());</span><br><span class="line">// 根据元素的自然顺序对指定列表按降序进行排序</span><br><span class="line">Collections.sort(new ArrayList(), Collections.reverseOrder());</span><br><span class="line">// 在指定列表的指定位置处交换元素</span><br><span class="line">Collections.swap(new ArrayList(), 1, 2);</span><br></pre></td></tr></table></figure>
<h2><span id="set">Set</span></h2><p><strong>实现类：HashSet,LinkedHashSet.</strong></p>
<p><strong>子接口：SortSet，TreeSet.</strong></p>
<p>不包含重复元素，最多包含一个null，元素没有顺序。</p>
<h3><span id="hashset">HashSet</span></h3><p>HashSet不是Ordered也不是Sorted,存储对象引用时是按照<strong>哈希策略</strong>来实现的,<br>    HashSet中是否存在一个对象是通过<strong>equals()</strong>和<strong>hashCode()</strong>协同判断，不保证顺序。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashSet()  </span><br><span class="line">public HashSet(int initialCapacity)  </span><br><span class="line">public HashSet(Collection c)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public HashSet(Collection c)</span><br></pre></td></tr></table></figure>
<p>HashSet底层是使用<strong>HashMap</strong>实现的<br>HashSet的add()方法详解:<br>    <strong>判断已经存储在集合中的对象hashCode值是否与增加对象的hashCode值一致。</strong><br>    如果不一致,直接加进去。<br>    如果一致,再进行equals()比较，如果equals()返回true,对象已经存在不增加进去，如果equals()返回false,把对象增加进去。</p>
<h3><span id="linkedhashset">LinkedHashSet</span></h3><p>LinkedHashSet是Ordered,采用<strong>双链表</strong>实现的，有<strong>固定顺序</strong>,也就是插入顺序。<br>LinkedHashSet底层是使用<strong>LinkedHashMap</strong>实现的。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashSet()  </span><br><span class="line">public LinkedHashSet(int initialCapacity)  </span><br><span class="line">public LinkedHashSet(Collection c)</span><br></pre></td></tr></table></figure>
<h3><span id="sortedset">SortedSet</span></h3><p><strong>保证迭代器按照元素递增顺序遍历的集合,可以按照元素的自然顺序进行排序。</strong></p>
<p><strong>常用方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object first()</span><br><span class="line">		 返回此有序集合中当前第一个(最小的)元素</span><br><span class="line">	Object last()</span><br><span class="line">		返回此有序集合中最后一个(最大的)元素</span><br><span class="line">	SortedSet headSet(Object toElement)</span><br><span class="line">		返回此有序集合的部分视图,其元素严格小于toElement</span><br><span class="line">	SortedSet tailSet(Object fromElement)</span><br><span class="line">		返回此有序集合的部分视图,其元素大于或等于fromElement</span><br><span class="line">	SortedSet subSet(Object fromElement,Object toElement)</span><br><span class="line">		返回此有序集合的部分视图,元素范围从fromElement(包括)到toElement(不包括)</span><br><span class="line">	Comparator comparator()</span><br><span class="line">		返回与此有序集合关联的比较器,如果使用元素的自然顺序,则返回 null</span><br></pre></td></tr></table></figure>
<h3><span id="treeset">TreeSet</span></h3><p>TreeSet是SortedSet接口的实现,<strong>元素不论以什么元素插入,在遍历的时候,都会以天然顺序遍历</strong>。因为它是自带排序的，所以如果想要增加自定义类型就必须指定排序的规则。<br>TreeSet底层是使用<strong>TreeMap</strong>实现的。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public TreeSet()</span><br><span class="line">public TreeSet(SortedSet s)  </span><br><span class="line">public TreeSet(int initialCapacity)</span><br><span class="line">public TreeSet(Comparator&lt;? super E&gt;)</span><br><span class="line">public TreeSet(Collection c)</span><br></pre></td></tr></table></figure>
<h2><span id="list">List</span></h2><p>具有<strong>列表</strong>的功能,元素顺序均是<strong>按添加的先后进行排列的,</strong>允许<strong>重复的</strong>元素,允许多个null元素。</p>
<p><strong>常用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">// 向列表的尾部追加指定的元素</span><br><span class="line">list.add(&quot;lwc&quot;);</span><br><span class="line">// 在列表的指定位置插入指定元素</span><br><span class="line">list.add(1, &quot;nxj&quot;);</span><br><span class="line">// 追加指定 collection 中的所有元素到此列表的结尾</span><br><span class="line">list.addAll(new ArrayList());</span><br><span class="line">// 从列表中移除所有元素</span><br><span class="line">list.clear();</span><br><span class="line">// 如果列表包含指定的元素,则返回true</span><br><span class="line">list.contains(&quot;nxj&quot;);</span><br><span class="line">// 如果列表包含指定 collection 的所有元素,则返回 true</span><br><span class="line">list.containsAll(new ArrayList());</span><br><span class="line">// 比较指定的对象与列表是否相等</span><br><span class="line">list.equals(new ArrayList());</span><br><span class="line">// 返回列表中指定位置的元素</span><br><span class="line">list.get(0);</span><br><span class="line">// 返回列表的哈希码值</span><br><span class="line">list.hashCode();</span><br><span class="line">// 返回列表中首次出现指定元素的索引,如果列表不包含此元素,则返回 -1</span><br><span class="line">list.indexOf(&quot;lwc&quot;);</span><br><span class="line">// 返回列表中最后出现指定元素的索引,如果列表不包含此元素,则返回 -1</span><br><span class="line">list.lastIndexOf(&quot;lwc&quot;);</span><br><span class="line">// 如果列表不包含元素,则返回 true</span><br><span class="line">list.isEmpty();</span><br><span class="line">// 移除列表中指定位置的元素</span><br><span class="line">list.remove(0);</span><br><span class="line">// 移除列表中出现的首个指定元素</span><br><span class="line">list.remove(&quot;lwc&quot;);</span><br><span class="line">// 从列表中移除指定 collection 中包含的所有元素</span><br><span class="line">list.removeAll(new ArrayList());</span><br><span class="line">// 用指定元素替换列表中指定位置的元素</span><br><span class="line">list.set(0, &quot;lp&quot;);</span><br><span class="line">// 返回列表中的元素数</span><br><span class="line">list.size();</span><br><span class="line">// 返回列表中指定的fromIndex(包括)和toIndex(不包括)之间的部分视图</span><br><span class="line">list.subList(1, 2);</span><br><span class="line">// 返回以正确顺序包含列表中的所有元素的数组</span><br><span class="line">list.toArray();</span><br><span class="line">// 返回以正确顺序包含列表中所有元素的数组</span><br><span class="line">list.toArray(new String[] &#123; &quot;a&quot;, &quot;b&quot; &#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="arraylist">ArrayList</span></h2><h3><span id="构造方法">构造方法</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList()</span><br><span class="line">public ArrayList(int initialCapacity)</span><br><span class="line">public ArrayList(Collection c)</span><br></pre></td></tr></table></figure>
<p> ArrayList依赖于<strong>数组</strong>实现的,初始长度为10的Object[],并且可随需要而增加的<strong>动态数组</strong>。<br>    当元素超过10,那么ArrayList底层会<strong>新生成一个数组,</strong>长度为原来的1.5倍+1,然后将原数组内容复制到新数组中,并且后续增加的内容会放到新数组中,当新数组无法容纳增加的元素,重复该过程即可。</p>
<h2><span id="linkedlist">LinkedList</span></h2><p>LinkedList功能与ArrayList,Vector相同,内部是<strong>依赖双链表实现</strong>的,因此有很好的插入和删除性能,但随机访问元素的性能很差。</p>
<h3><span id="构造方法">构造方法</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList()</span><br><span class="line">public LinkedList(Collection c)</span><br></pre></td></tr></table></figure>
<p>LinkedList类中有一个<strong>Entry内部类</strong>,Entry内部类包含3个部分<strong>向前的引用,向后的引用,数据</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header.next = header.previous = header;</span><br></pre></td></tr></table></figure>
<h2><span id="map">Map</span></h2><p><strong>Map接口中键和值一一映射. 可以通过键来获取值.</strong></p>
<h3><span id="特性">特性</span></h3><ul>
<li>给定一个键和一个值，你可以将该值存储在一个Map对象. 之后，你可以通过键来访问对应的值。</li>
<li>当访问的值不存在的时候，方法就会抛出一个NoSuchElementException异常。</li>
<li>当对象的类型和Map里元素类型不兼容的时候，就会抛出一个 ClassCastException异常。</li>
<li>当在不允许使用Null对象的Map中使用Null对象，会抛出一个NullPointerException 异常。</li>
<li>当尝试修改一个只读的Map时，会抛出一个UnsupportedOperationException异常。</li>
</ul>
<h3><span id="方法">方法</span></h3><table>
<thead>
<tr>
<th>1</th>
<th>void clear( )  从此映射中移除所有映射关系（可选操作）。</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>boolean containsKey(Object k) 如果此映射包含指定键的映射关系，则返回 true。</td>
</tr>
<tr>
<td>3</td>
<td>boolean containsValue(Object v) 如果此映射将一个或多个键映射到指定值，则返回 true。</td>
</tr>
<tr>
<td>4</td>
<td>Set entrySet( ) 返回此映射中包含的映射关系的 Set 视图。</td>
</tr>
<tr>
<td>5</td>
<td>boolean equals(Object obj) 比较指定的对象与此映射是否相等。</td>
</tr>
<tr>
<td>6</td>
<td>Object get(Object k) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</td>
</tr>
<tr>
<td>7</td>
<td>int hashCode( ) 返回此映射的哈希码值。</td>
</tr>
<tr>
<td>8</td>
<td>boolean isEmpty( ) 如果此映射未包含键-值映射关系，则返回 true。</td>
</tr>
<tr>
<td>9</td>
<td>Set keySet( ) 返回此映射中包含的键的 Set 视图。</td>
</tr>
<tr>
<td>10</td>
<td>Object put(Object k, Object v) 将指定的值与此映射中的指定键关联（可选操作）。</td>
</tr>
<tr>
<td>11</td>
<td>void putAll(Map m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。</td>
</tr>
<tr>
<td>12</td>
<td>Object remove(Object k) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</td>
</tr>
<tr>
<td>13</td>
<td>int size( ) 返回此映射中的键-值映射关系数。</td>
</tr>
<tr>
<td>14</td>
<td>Collection values( ) 返回此映射中包含的值的 Collection 视图。</td>
</tr>
</tbody>
</table>
<h2><span id="hashmap">HashMap</span></h2><h3><span id="常用操作">常用操作</span></h3><p>1.第一步就是给HashMap里面put一些<strong>键值对</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		hashMap.put(5, 2);</span><br><span class="line">		hashMap.put(9, 2);</span><br><span class="line">		hashMap.put(8, 1);</span><br><span class="line">		hashMap.put(7, 3);</span><br><span class="line">		hashMap.put(16, 1);</span><br><span class="line">		hashMap.put(10, 2);</span><br><span class="line">		hashMap.put(6, 2);</span><br><span class="line">		//下面两个键值对是没有存的，因为key存过的不会重复存储，只会覆盖之前的vlue</span><br><span class="line">		hashMap.put(5, 2);</span><br><span class="line">		hashMap.put(5, 3);</span><br></pre></td></tr></table></figure>
<p>2.containsKey(Object key)方法，返回值为boolean，用于<strong>判断当前HashMap中是否包含key对应的key-value</strong>。</p>
<p>3.containsValue(Object value)方法，返回值为boolean，用于<strong>判断当前HashMap中是否包含value对应的key-value</strong>。</p>
<p>4.遍历HashMap的两种方式：</p>
<p>1）利用haspmap.entrySet().iterator()：利用迭代器，从Entry中取出键、取出值，推荐使用这种方式进行遍历，效率较高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;Integer, Integer&gt;&gt; iterator = hashMap.entrySet().iterator();</span><br><span class="line">		while (iterator.hasNext()) &#123;</span><br><span class="line">			Entry&lt;Integer, Integer&gt; entry = iterator.next();</span><br><span class="line">			Integer key = entry.getKey();</span><br><span class="line">			Integer value = entry.getValue();</span><br><span class="line">			System.out.print(key + &quot;---&gt;&quot; + value);</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>2）利用hashmap.keySet().iterator()：利用键的迭代器，每次取出一个键，再根据键，从HashMap中取出值，这种方式的效率不高，不推荐使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator2 = hashMap.keySet().iterator();</span><br><span class="line">		while (iterator2.hasNext()) &#123;</span><br><span class="line">			Integer key = iterator2.next();</span><br><span class="line">			Integer value = hashMap.get(key);</span><br><span class="line">			System.out.print(key + &quot;---&quot; + value);</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/u013398759/article/details/77679632" target="_blank" rel="noopener">参考链接</a></p>
<h2><span id="iterator">Iterator</span></h2><p> 在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：<strong>对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。</strong>迭代器与枚举有两点不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。</span><br><span class="line"></span><br><span class="line">2、方法名称得到了改进。</span><br></pre></td></tr></table></figure>
<p><strong>接口定义：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line">　　boolean hasNext();</span><br><span class="line">　　Object next();</span><br><span class="line">　　void remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Object next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型。</p>
<p>boolean hasNext()：判断容器内是否还有可供访问的元素。</p>
<p>void remove()：删除迭代器刚越过的元素。</p>
<p><strong>未完待续~~~</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/22/java基础-略有小成/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/22/java基础-略有小成/" itemprop="url">java基础-略有小成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-22T22:00:24+08:00">
                2019-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#基本数据类型">基本数据类型</a><ul>
<li><a href="#种类">种类</a></li>
<li><a href="#占用空间">占用空间</a></li>
<li><a href="#类型转换">类型转换</a></li>
</ul>
</li>
<li><a href="#包装类">包装类</a><ul>
<li><a href="#类型转换方法">类型转换方法</a></li>
<li><a href="#引用问题">引用问题</a></li>
</ul>
</li>
<li><a href="#system类">System类</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#成员变量">成员变量</a></li>
<li><a href="#成员方法">成员方法</a></li>
</ul>
</li>
<li><a href="#runtime类">RunTime类</a></li>
<li><a href="#date与dateformat">Date与DateFormat</a><ul>
<li><a href="#构造函数">构造函数</a></li>
<li><a href="#方法">方法</a></li>
<li><a href="#日期比较">日期比较</a></li>
<li><a href="#simpledateformat格式化日期">SimpleDateFormat格式化日期</a></li>
<li><a href="#格式化编码">格式化编码</a></li>
<li><a href="#printf格式化日期">printf格式化日期</a></li>
<li><a href="#解析字符串">解析字符串</a></li>
<li><a href="#sleep">sleep</a></li>
</ul>
</li>
<li><a href="#calendar类与gregoriancalendar类">Calendar类与GregorianCalendar类</a></li>
</ul>
<!-- tocstop -->
<h2><span id="基本数据类型">基本数据类型</span></h2><h3><span id="种类">种类</span></h3><p><img src="/2019/03/22/java基础-略有小成/基本数据类型.jpg" alt=""></p>
<p>讲到基本类型的话，不可避免的就是<strong>字面量值</strong>，其实它的意思就是<strong>表面上的值。</strong></p>
<p>byte、short、int、long类型变量都可以赋予整型字面量值，譬如byte a = 10、short b = 0x45都是合法的赋值操作。Java编译器在编译是会检查字面量值所表示的数字大小是否处于变量类型的合法范围内，如果不在，则无法通过编译。如果多种数值类型的数据进行数学运算时，计算结果的类型是其中这些数值中<strong>最高等级或者其更高等级类型。</strong></p>
<h3><span id="占用空间">占用空间</span></h3><p>byte（字节）用<strong>无符号的8位</strong>表示，它的取值范围是[-2^7, 2^7-1]。它是最小的整型类型，默认值是0。<br>    short（短整型）用<strong>有符号的16位</strong>表示，它的取值范围是[-2^15, 2^15-1]。默认值是0。<br>    int（整型）用有符号的32位表示，它的取值范围是[-2^31, 2^31-1]，计算机中用存放的是整型数值的<strong>二进制补码</strong>。默认值是0。<br>    long（长整型）用<strong>有符号的64位</strong>表示，它的取值范围是[-2^63, 2^63-1]。它的字面量表示以l或者L结束，如 long a = 45454L。默认值是0L。<br>    float（单精度浮点型）用<strong>32位</strong>表示，float类型字面量值通常以f或者F结束。由于整型可以自动转换为float类型，所以，也可以将整型字面量值直接赋予float类型变量。默认值是<strong>0F</strong>。<br>    double（双精度浮点型）用<strong>64位</strong>表示，遵循IEEE 754规范。它能表示比float更高精度的数值。double是Java基本类型中能达到的最高精度，如果还不能满足要求，可以使用Java中的<strong>BigDecimal</strong>类。默认值是0.0。<br>    char（字符）用<strong>无符号的16位</strong>表示，它的取值范围是[0, 2^16-1]。Java中使用<strong>Unicode字符集</strong>来表示字符，Unicode将人类语言的所有已知字符映射成16位数字，所以Java中的char是16位的。默认值是\u00000。</p>
<p>boolean（ 布尔型）只要<strong>true和false</strong>两个字面量值，可用于逻辑判断。boolean只能表示1位的信息量，但是它的大小并没有精确地定义。</p>
<h3><span id="类型转换">类型转换</span></h3><p>在JAVA里面除了boolean类型之外，其他7中类型相互之间可以<strong>进行转换</strong>。转换分为<strong>自动转换</strong>和<strong>强制转换</strong>。对于自动转换（隐式），无需任何操作，而强制类型转换需要<strong>显式转换</strong>，即使用转换操作符（type）。</p>
<p>占用空间大小进行排序：<strong>byte &lt;（short=char）&lt; int &lt; long &lt; float &lt; double</strong></p>
<p>类型转换的总则是：<strong>小可直接转大、大转小会失去精度</strong>。小转大是Java帮我们自动进行转换的，与正常的赋值操作完全一样；大转小需要进行强制转换操作，其语法是<strong>target-type var =（target-type） value</strong>。</p>
<p><strong>特别注意：大转小有可能在某些情况下产生不可预估的问题。</strong></p>
<h2><span id="包装类">包装类</span></h2><p>Java里面的每一种<strong>基本类型</strong>都会对应一个<strong>唯一的</strong>包装类，基本类型与其包装类都可以通过包装类中的<strong>静态</strong>或者<strong>成员方法</strong>进行转换。所有的包装类都是<strong>final</strong>修饰的，也就是它们都是<strong>无法被继承和重写</strong>的。</p>
<p><img src="/2019/03/22/java基础-略有小成/包装类.jpg" alt=""></p>
<p><strong>基础类型和包装类型都可以通过赋值语法赋值给对立的变量类型。</strong></p>
<h3><span id="类型转换方法">类型转换方法</span></h3><p><img src="/2019/03/22/java基础-略有小成/类型转换方法.jpg" alt=""></p>
<h3><span id="引用问题">引用问题</span></h3><p>在Java中，“==”符号判断的<strong>内存地址</strong>所对应的值的<strong>相等性</strong>，具体来说，<strong>基本类型判断值是否相等</strong>，<strong>引用类型判断其指向的地址是否相等。</strong></p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a1 = 1;</span><br><span class="line">Integer a2 = 1;</span><br><span class="line">System.out.println(a1 == a2); // true</span><br><span class="line"></span><br><span class="line">Integer b1 = 222;</span><br><span class="line">Integer b2 = 222;</span><br><span class="line">System.out.println(b1 == b2); // false</span><br></pre></td></tr></table></figure>
<p>这是为什么呢？</p>
<p>如果打开Integer类中的valueOf()方法会发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) // 判断实参是否在可缓存范围内，默认为[-128, 127]</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)]; // 如果在，则取出初始化的Integer对象</span><br><span class="line">    return new Integer(i); // 如果不在，则创建一个新的Integer对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于1属于[-128, 127]集合范围内，所以valueOf()每次都会取出<strong>同一个Integer对象</strong>，故第一个“==”判断结果为true；</p>
<p>而222不属于[-128, 127]集合范围内，所以valueOf()每次都会创建一个<strong>新的Integer对象</strong>，由于两个新创建的对象的地址不一样，故第一个“==”判断结果为false。</p>
<p><a href="https://blog.csdn.net/xialei199023/article/details/63251295" target="_blank" rel="noopener">参考链接</a></p>
<h2><span id="system类">System类</span></h2><h3><span id="简介">简介</span></h3><p>system类在java中的作用其实就是类似于<strong>系统</strong>的作用，它的内部包含了很多系统级别的<strong>属性以及控制方法</strong>。</p>
<h3><span id="成员变量">成员变量</span></h3><p>主要就是包含了<strong>in（标准输入流，键盘输入），out（标准输出流，显示器）以及err（标准错误输出流）。</strong></p>
<p><strong>out与err的差别</strong></p>
<p>System.out在JVM和操作系统都具有缓存功能，其实就是输出的数据<strong>不一定实时输出</strong>，有时候会积攒到一定数量才会输出；System.err会<strong>实时输出</strong>。</p>
<h3><span id="成员方法">成员方法</span></h3><p>1.static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</p>
<p>该方法的作用是<strong>数组拷贝</strong>，src为被拷贝的数组，srcPos为src要拷贝的初始位置，dest为目的数组，目的数组dest放置拷贝数据的初始位置，length为从src拷贝到的数据长度。</p>
<p>2.static long currentTimeMillis()<br>    该方法的作用是<strong>返回当前的计算机时间</strong>，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
<p>3.static void exit(int status)<br>    该方法的作用是<strong>退出程序</strong>。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
<p>4.static void gc()<br>    请求系统进行<strong>垃圾回收</strong>。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p>
<p>5.static Properties getProperties()<br>    <strong>获取系统的属性信息</strong>，并存储到Properties集合中。Properties集合中存储的都是String类型的键值对。</p>
<p>6.static String getProperty(String key)</p>
<p><strong>获得系统中属性名为key的属性对应的值</strong>。系统中常见的属性名以及属性的作用如下表所示：</p>
<p><img src="/2019/03/22/java基础-略有小成/属性.jpg" alt=""></p>
<p>7.static String setProperty(String key, String value)<br>    给系统<strong>设置一些属性信息</strong>，这些信息是全局的，其他程序都可以使用。</p>
<h2><span id="runtime类">RunTime类</span></h2><p>Runtime类<strong>封装了运行时的环境</strong>。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。该类<strong>无法创建对象</strong>。</p>
<p><strong>常用方法</strong><br>    <strong>static Runtime getRuntime() 返回一个Runtime实例</strong>。<br>    <strong>Process exec(String command) 指定某个exe文件并返回该程序进程，参数command为本地exe文件路径。</strong></p>
<p><strong>long freeMemory() 返回Java虚拟机中的空闲内存量，以字节为单位</strong><br>    <strong>long maxMemory() 返回Java虚拟机试图使用的最大内存量</strong></p>
<p><strong>long totalMemory() 返回Java虚拟机中的内存总量</strong></p>
<h2><span id="date与dateformat">Date与DateFormat</span></h2><p>Date是Java中提供来<strong>封装当前的日期与时间</strong>的类。</p>
<h3><span id="构造函数">构造函数</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date( );//使用当前日期和时间来初始化对象。</span><br><span class="line">Date(long millisec);//接收一个参数，该参数是从1970年1月1日起的毫秒数。</span><br></pre></td></tr></table></figure>
<h3><span id="方法">方法</span></h3><p><img src="/2019/03/22/java基础-略有小成/方法.jpg" alt=""></p>
<h3><span id="日期比较">日期比较</span></h3><p> 使用 <strong>getTime()</strong> 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。<br>    使用方法 <strong>before()，after() 和 equals()</strong>。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。<br>    使用 <strong>compareTo()</strong> 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。</p>
<h3><span id="simpledateformat格式化日期">SimpleDateFormat格式化日期</span></h3><p>SimpleDateFormat 允许用户选择<strong>任何自定义日期时间格式</strong>来运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import  java.util.*;</span><br><span class="line">import java.text.*;</span><br><span class="line"> </span><br><span class="line">public class DateDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line"> </span><br><span class="line">      Date dNow = new Date( );</span><br><span class="line">      /*这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。*/</span><br><span class="line">      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">      System.out.println(&quot;当前时间为: &quot; + ft.format(dNow));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="格式化编码">格式化编码</span></h3><table>
<thead>
<tr>
<th><strong>字母</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>纪元标记</td>
<td>AD</td>
</tr>
<tr>
<td>y</td>
<td>四位年份</td>
<td>2001</td>
</tr>
<tr>
<td>M</td>
<td>月份</td>
<td>July or 07</td>
</tr>
<tr>
<td>d</td>
<td>一个月的日期</td>
<td>10</td>
</tr>
<tr>
<td>h</td>
<td>A.M./P.M. (1~12)格式小时</td>
<td>12</td>
</tr>
<tr>
<td>H</td>
<td>一天中的小时 (0~23)</td>
<td>22</td>
</tr>
<tr>
<td>m</td>
<td>分钟数</td>
<td>30</td>
</tr>
<tr>
<td>s</td>
<td>秒数</td>
<td>55</td>
</tr>
<tr>
<td>S</td>
<td>毫秒数</td>
<td>234</td>
</tr>
<tr>
<td>E</td>
<td>星期几</td>
<td>Tuesday</td>
</tr>
<tr>
<td>D</td>
<td>一年中的日子</td>
<td>360</td>
</tr>
<tr>
<td>F</td>
<td>一个月中第几周的周几</td>
<td>2 (second Wed. in July)</td>
</tr>
<tr>
<td>w</td>
<td>一年中第几周</td>
<td>40</td>
</tr>
<tr>
<td>W</td>
<td>一个月中第几周</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>A.M./P.M. 标记</td>
<td>PM</td>
</tr>
<tr>
<td>k</td>
<td>一天中的小时(1~24)</td>
<td>24</td>
</tr>
<tr>
<td>K</td>
<td>A.M./P.M. (0~11)格式小时</td>
<td>10</td>
</tr>
<tr>
<td>z</td>
<td>时区</td>
<td>Eastern Standard Time</td>
</tr>
<tr>
<td>‘</td>
<td>文字定界符</td>
<td>Delimiter</td>
</tr>
<tr>
<td>“</td>
<td>单引号</td>
<td>`</td>
</tr>
</tbody>
</table>
<h3><span id="printf格式化日期">printf格式化日期</span></h3><p>printf 方法可以很轻松地格式化时间和日期。使用<strong>两个字母</strong>格式，它以 <strong>%t</strong> 开头并且以下面表格中的一个字母结尾。</p>
<table>
<thead>
<tr>
<th>转  换  符</th>
<th>说    明</th>
<th>示    例</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>包括全部日期和时间信息</td>
<td>星期六 十月 27 14:21:20 CST 2007</td>
</tr>
<tr>
<td>F</td>
<td>“年-月-日”格式</td>
<td>2007-10-27</td>
</tr>
<tr>
<td>D</td>
<td>“月/日/年”格式</td>
<td>10/27/07</td>
</tr>
<tr>
<td>r</td>
<td>“HH:MM:SS PM”格式（12时制）</td>
<td>02:25:51 下午</td>
</tr>
<tr>
<td>T</td>
<td>“HH:MM:SS”格式（24时制）</td>
<td>14:28:16</td>
</tr>
<tr>
<td>R</td>
<td>“HH:MM”格式（24时制）</td>
<td>14:28</td>
</tr>
</tbody>
</table>
<h3><span id="解析字符串">解析字符串</span></h3><p><strong>SimpleDateFormat 类的parse()方法来按照对应的格式化存储来解析字符串。</strong></p>
<h3><span id="sleep">sleep</span></h3><p>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(1000);   // 休眠1秒</span><br></pre></td></tr></table></figure>
<h2><span id="calendar类与gregoriancalendar类">Calendar类与GregorianCalendar类</span></h2><p>略…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/21/分拆素数和/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/分拆素数和/" itemprop="url">分拆素数和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T15:27:21+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  922
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#题目内容">题目内容</a></li>
<li><a href="#题目分析">题目分析</a></li>
<li><a href="#eratosthenes筛选法">Eratosthenes筛选法</a></li>
<li><a href="#试探法回溯法">试探法（回溯法）</a></li>
<li><a href="#代码详解">代码详解</a></li>
</ul>
<!-- tocstop -->
<h2><span id="题目内容">题目内容</span></h2><p><img src="/2019/03/21/分拆素数和/题目.jpg" alt=""></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2098" target="_blank" rel="noopener">原题链接</a></p>
<h2><span id="题目分析">题目分析</span></h2><p>很明显，本题的要求是要求解<strong>分解的个数</strong>，主要思路就是利用Eratosthenes筛选法来求必要的素数，然后用试探法来求分解的个数。</p>
<p><strong>原理：对于任何一个可以分解为两个素数之和的偶数，其中一个必然是小于或者等于1/2的。</strong></p>
<h2><span id="eratosthenes筛选法">Eratosthenes筛选法</span></h2><p><strong>筛选法又称筛法</strong>，具体做法是：先把N个自然数按次序排列起来。1不是质数，也不是合数，要划去。第二个数2是质数留下来，而把2后面所有能被2整除的数都划去。2后面第一个没划去的数是3，把3留下，再把3后面所有能被3整除的数都划去。3后面第一个没划去的数是5，把5留下，再把5后面所有能被5整除的数都划去。<strong>这样一直做下去，就会把不超过N的全部合数都筛掉，留下的就是不超过N的全部质数。</strong></p>
<p>（合数：一个正整数，除了1和它本身以外，还能被其他正整数整除，这个数就叫做合数。）</p>
<p>（质数（prime number）又称<a href="https://baike.baidu.com/item/%E7%B4%A0%E6%95%B0/115069" target="_blank" rel="noopener">素数</a>，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他<a href="https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0/9539111" target="_blank" rel="noopener">因数</a>。）</p>
<p><strong>埃拉托斯特尼筛选法</strong>是最为知名的产生素数的筛选法，适用于产生<strong>最小的N个素数</strong>。</p>
<p>该方法的唯一缺点是使用的存储空间大，可以进一步改进。</p>
<p>另外，该算法也<strong>不适用于计算某个范围内的全部素数</strong>。</p>
<h2><span id="试探法回溯法">试探法（回溯法）</span></h2><p>先选择某一种可能的情况进行试探，在试探过程中，一旦发现此选择的假设是错误的，就退回一步重新选择，继续向前试探，如此反复进行，直到证明解或者无解。</p>
<h2><span id="代码详解">代码详解</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define Max 10000</span><br><span class="line">using namespace std;</span><br><span class="line">//Eratosthenes筛选法</span><br><span class="line">void eratosthenesFunction(int num[],int n)</span><br><span class="line">&#123;</span><br><span class="line">	//两个参数一个是筛选的数组，一个是筛选的最大值</span><br><span class="line">	//由于数组在函数中修改的值类似于取址赋值，这里直接里面修改外面也修改了</span><br><span class="line">	num[0]=num[1]=0;</span><br><span class="line">	num[2]=1;//从2开始的质数才算进去</span><br><span class="line">	//首先先初始化，把所有质数序号的数组值赋值为1</span><br><span class="line">	for(int i=3;i&lt;=n;i++)</span><br><span class="line">	&#123; </span><br><span class="line">		num[i]=1;</span><br><span class="line">		i++; </span><br><span class="line">		num[i]=0;	</span><br><span class="line">	&#125; </span><br><span class="line">	int max=sqrt(n);</span><br><span class="line">	for(int i=3;i&lt;=max;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		//下面就开始筛选了，把所有的之前出现过的质数的倍数给去掉 </span><br><span class="line">		if(num[i])&#123;</span><br><span class="line">			for(int j=i+i;j&lt;n;j+=i)&#123;</span><br><span class="line">				num[j]=0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int num[Max+1]=&#123;0&#125;;//因为我们算的都是正数，意思是没有用到下标为0的 </span><br><span class="line">	int sum,count;//依次表示的是输入的正数和拆分个数</span><br><span class="line">	eratosthenesFunction(num,Max);//送进去筛选</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		cin&gt;&gt;sum;</span><br><span class="line">		if(sum==0) break;//要先判断是否是终止条件</span><br><span class="line">		count=0;//这个是必须的，在循环中每一次循环都是不同的数字，必须重置</span><br><span class="line">		for(int i=2;i&lt;sum/2;i++)&#123;</span><br><span class="line">			//对于任何一个可以分解为两个素数之和的偶数，其中一个必然是小于或者等于1/2的。</span><br><span class="line">			if(num[i]&amp;&amp;num[sum-i])&#123;</span><br><span class="line">				//这里就是判断是否是两个质数</span><br><span class="line">				if(i!=sum-i)&#123;</span><br><span class="line">					count++; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后结果：</p>
<p><img src="/2019/03/21/分拆素数和/accept.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/zhangguoron.jpg" alt="THBELIEF">
            
              <p class="site-author-name" itemprop="name">THBELIEF</p>
              <p class="site-description motion-element" itemprop="description">我这个人只是英俊 潇洒了些许~</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">101</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:thbelief520@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">THBELIEF</span>

  
</div>


  <!--<div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>
-->



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共99.2k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
