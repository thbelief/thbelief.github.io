<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">
  <script>
    (function(){
        if(''){
            if (prompt('请输入博客密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="我这个人只是英俊 潇洒了些许~">
<meta property="og:type" content="website">
<meta property="og:title" content="THBELIEF">
<meta property="og:url" content="http://thbelief.coding.me/page/9/index.html">
<meta property="og:site_name" content="THBELIEF">
<meta property="og:description" content="我这个人只是英俊 潇洒了些许~">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="THBELIEF">
<meta name="twitter:description" content="我这个人只是英俊 潇洒了些许~">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://thbelief.coding.me/page/9/">





  <title>THBELIEF</title>
  








  <script type="text/javascript" src="/js/src/love.js"></script>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">THBELIEF</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Thbelief's blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/22/java基础-略有小成/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/22/java基础-略有小成/" itemprop="url">java基础-略有小成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-22T22:00:24+08:00">
                2019-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#基本数据类型">基本数据类型</a><ul>
<li><a href="#种类">种类</a></li>
<li><a href="#占用空间">占用空间</a></li>
<li><a href="#类型转换">类型转换</a></li>
</ul>
</li>
<li><a href="#包装类">包装类</a><ul>
<li><a href="#类型转换方法">类型转换方法</a></li>
<li><a href="#引用问题">引用问题</a></li>
</ul>
</li>
<li><a href="#system类">System类</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#成员变量">成员变量</a></li>
<li><a href="#成员方法">成员方法</a></li>
</ul>
</li>
<li><a href="#runtime类">RunTime类</a></li>
<li><a href="#date与dateformat">Date与DateFormat</a><ul>
<li><a href="#构造函数">构造函数</a></li>
<li><a href="#方法">方法</a></li>
<li><a href="#日期比较">日期比较</a></li>
<li><a href="#simpledateformat格式化日期">SimpleDateFormat格式化日期</a></li>
<li><a href="#格式化编码">格式化编码</a></li>
<li><a href="#printf格式化日期">printf格式化日期</a></li>
<li><a href="#解析字符串">解析字符串</a></li>
<li><a href="#sleep">sleep</a></li>
</ul>
</li>
<li><a href="#calendar类与gregoriancalendar类">Calendar类与GregorianCalendar类</a></li>
</ul>
<!-- tocstop -->
<h2><span id="基本数据类型">基本数据类型</span></h2><h3><span id="种类">种类</span></h3><p><img src="/2019/03/22/java基础-略有小成/基本数据类型.jpg" alt=""></p>
<p>讲到基本类型的话，不可避免的就是<strong>字面量值</strong>，其实它的意思就是<strong>表面上的值。</strong></p>
<p>byte、short、int、long类型变量都可以赋予整型字面量值，譬如byte a = 10、short b = 0x45都是合法的赋值操作。Java编译器在编译是会检查字面量值所表示的数字大小是否处于变量类型的合法范围内，如果不在，则无法通过编译。如果多种数值类型的数据进行数学运算时，计算结果的类型是其中这些数值中<strong>最高等级或者其更高等级类型。</strong></p>
<h3><span id="占用空间">占用空间</span></h3><p>byte（字节）用<strong>无符号的8位</strong>表示，它的取值范围是[-2^7, 2^7-1]。它是最小的整型类型，默认值是0。<br>    short（短整型）用<strong>有符号的16位</strong>表示，它的取值范围是[-2^15, 2^15-1]。默认值是0。<br>    int（整型）用有符号的32位表示，它的取值范围是[-2^31, 2^31-1]，计算机中用存放的是整型数值的<strong>二进制补码</strong>。默认值是0。<br>    long（长整型）用<strong>有符号的64位</strong>表示，它的取值范围是[-2^63, 2^63-1]。它的字面量表示以l或者L结束，如 long a = 45454L。默认值是0L。<br>    float（单精度浮点型）用<strong>32位</strong>表示，float类型字面量值通常以f或者F结束。由于整型可以自动转换为float类型，所以，也可以将整型字面量值直接赋予float类型变量。默认值是<strong>0F</strong>。<br>    double（双精度浮点型）用<strong>64位</strong>表示，遵循IEEE 754规范。它能表示比float更高精度的数值。double是Java基本类型中能达到的最高精度，如果还不能满足要求，可以使用Java中的<strong>BigDecimal</strong>类。默认值是0.0。<br>    char（字符）用<strong>无符号的16位</strong>表示，它的取值范围是[0, 2^16-1]。Java中使用<strong>Unicode字符集</strong>来表示字符，Unicode将人类语言的所有已知字符映射成16位数字，所以Java中的char是16位的。默认值是\u00000。</p>
<p>boolean（ 布尔型）只要<strong>true和false</strong>两个字面量值，可用于逻辑判断。boolean只能表示1位的信息量，但是它的大小并没有精确地定义。</p>
<h3><span id="类型转换">类型转换</span></h3><p>在JAVA里面除了boolean类型之外，其他7中类型相互之间可以<strong>进行转换</strong>。转换分为<strong>自动转换</strong>和<strong>强制转换</strong>。对于自动转换（隐式），无需任何操作，而强制类型转换需要<strong>显式转换</strong>，即使用转换操作符（type）。</p>
<p>占用空间大小进行排序：<strong>byte &lt;（short=char）&lt; int &lt; long &lt; float &lt; double</strong></p>
<p>类型转换的总则是：<strong>小可直接转大、大转小会失去精度</strong>。小转大是Java帮我们自动进行转换的，与正常的赋值操作完全一样；大转小需要进行强制转换操作，其语法是<strong>target-type var =（target-type） value</strong>。</p>
<p><strong>特别注意：大转小有可能在某些情况下产生不可预估的问题。</strong></p>
<h2><span id="包装类">包装类</span></h2><p>Java里面的每一种<strong>基本类型</strong>都会对应一个<strong>唯一的</strong>包装类，基本类型与其包装类都可以通过包装类中的<strong>静态</strong>或者<strong>成员方法</strong>进行转换。所有的包装类都是<strong>final</strong>修饰的，也就是它们都是<strong>无法被继承和重写</strong>的。</p>
<p><img src="/2019/03/22/java基础-略有小成/包装类.jpg" alt=""></p>
<p><strong>基础类型和包装类型都可以通过赋值语法赋值给对立的变量类型。</strong></p>
<h3><span id="类型转换方法">类型转换方法</span></h3><p><img src="/2019/03/22/java基础-略有小成/类型转换方法.jpg" alt=""></p>
<h3><span id="引用问题">引用问题</span></h3><p>在Java中，“==”符号判断的<strong>内存地址</strong>所对应的值的<strong>相等性</strong>，具体来说，<strong>基本类型判断值是否相等</strong>，<strong>引用类型判断其指向的地址是否相等。</strong></p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a1 = 1;</span><br><span class="line">Integer a2 = 1;</span><br><span class="line">System.out.println(a1 == a2); // true</span><br><span class="line"></span><br><span class="line">Integer b1 = 222;</span><br><span class="line">Integer b2 = 222;</span><br><span class="line">System.out.println(b1 == b2); // false</span><br></pre></td></tr></table></figure>
<p>这是为什么呢？</p>
<p>如果打开Integer类中的valueOf()方法会发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) // 判断实参是否在可缓存范围内，默认为[-128, 127]</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)]; // 如果在，则取出初始化的Integer对象</span><br><span class="line">    return new Integer(i); // 如果不在，则创建一个新的Integer对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于1属于[-128, 127]集合范围内，所以valueOf()每次都会取出<strong>同一个Integer对象</strong>，故第一个“==”判断结果为true；</p>
<p>而222不属于[-128, 127]集合范围内，所以valueOf()每次都会创建一个<strong>新的Integer对象</strong>，由于两个新创建的对象的地址不一样，故第一个“==”判断结果为false。</p>
<p><a href="https://blog.csdn.net/xialei199023/article/details/63251295" target="_blank" rel="noopener">参考链接</a></p>
<h2><span id="system类">System类</span></h2><h3><span id="简介">简介</span></h3><p>system类在java中的作用其实就是类似于<strong>系统</strong>的作用，它的内部包含了很多系统级别的<strong>属性以及控制方法</strong>。</p>
<h3><span id="成员变量">成员变量</span></h3><p>主要就是包含了<strong>in（标准输入流，键盘输入），out（标准输出流，显示器）以及err（标准错误输出流）。</strong></p>
<p><strong>out与err的差别</strong></p>
<p>System.out在JVM和操作系统都具有缓存功能，其实就是输出的数据<strong>不一定实时输出</strong>，有时候会积攒到一定数量才会输出；System.err会<strong>实时输出</strong>。</p>
<h3><span id="成员方法">成员方法</span></h3><p>1.static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</p>
<p>该方法的作用是<strong>数组拷贝</strong>，src为被拷贝的数组，srcPos为src要拷贝的初始位置，dest为目的数组，目的数组dest放置拷贝数据的初始位置，length为从src拷贝到的数据长度。</p>
<p>2.static long currentTimeMillis()<br>    该方法的作用是<strong>返回当前的计算机时间</strong>，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
<p>3.static void exit(int status)<br>    该方法的作用是<strong>退出程序</strong>。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
<p>4.static void gc()<br>    请求系统进行<strong>垃圾回收</strong>。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p>
<p>5.static Properties getProperties()<br>    <strong>获取系统的属性信息</strong>，并存储到Properties集合中。Properties集合中存储的都是String类型的键值对。</p>
<p>6.static String getProperty(String key)</p>
<p><strong>获得系统中属性名为key的属性对应的值</strong>。系统中常见的属性名以及属性的作用如下表所示：</p>
<p><img src="/2019/03/22/java基础-略有小成/属性.jpg" alt=""></p>
<p>7.static String setProperty(String key, String value)<br>    给系统<strong>设置一些属性信息</strong>，这些信息是全局的，其他程序都可以使用。</p>
<h2><span id="runtime类">RunTime类</span></h2><p>Runtime类<strong>封装了运行时的环境</strong>。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。该类<strong>无法创建对象</strong>。</p>
<p><strong>常用方法</strong><br>    <strong>static Runtime getRuntime() 返回一个Runtime实例</strong>。<br>    <strong>Process exec(String command) 指定某个exe文件并返回该程序进程，参数command为本地exe文件路径。</strong></p>
<p><strong>long freeMemory() 返回Java虚拟机中的空闲内存量，以字节为单位</strong><br>    <strong>long maxMemory() 返回Java虚拟机试图使用的最大内存量</strong></p>
<p><strong>long totalMemory() 返回Java虚拟机中的内存总量</strong></p>
<h2><span id="date与dateformat">Date与DateFormat</span></h2><p>Date是Java中提供来<strong>封装当前的日期与时间</strong>的类。</p>
<h3><span id="构造函数">构造函数</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date( );//使用当前日期和时间来初始化对象。</span><br><span class="line">Date(long millisec);//接收一个参数，该参数是从1970年1月1日起的毫秒数。</span><br></pre></td></tr></table></figure>
<h3><span id="方法">方法</span></h3><p><img src="/2019/03/22/java基础-略有小成/方法.jpg" alt=""></p>
<h3><span id="日期比较">日期比较</span></h3><p> 使用 <strong>getTime()</strong> 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。<br>    使用方法 <strong>before()，after() 和 equals()</strong>。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。<br>    使用 <strong>compareTo()</strong> 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。</p>
<h3><span id="simpledateformat格式化日期">SimpleDateFormat格式化日期</span></h3><p>SimpleDateFormat 允许用户选择<strong>任何自定义日期时间格式</strong>来运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import  java.util.*;</span><br><span class="line">import java.text.*;</span><br><span class="line"> </span><br><span class="line">public class DateDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line"> </span><br><span class="line">      Date dNow = new Date( );</span><br><span class="line">      /*这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。*/</span><br><span class="line">      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">      System.out.println(&quot;当前时间为: &quot; + ft.format(dNow));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="格式化编码">格式化编码</span></h3><table>
<thead>
<tr>
<th><strong>字母</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>纪元标记</td>
<td>AD</td>
</tr>
<tr>
<td>y</td>
<td>四位年份</td>
<td>2001</td>
</tr>
<tr>
<td>M</td>
<td>月份</td>
<td>July or 07</td>
</tr>
<tr>
<td>d</td>
<td>一个月的日期</td>
<td>10</td>
</tr>
<tr>
<td>h</td>
<td>A.M./P.M. (1~12)格式小时</td>
<td>12</td>
</tr>
<tr>
<td>H</td>
<td>一天中的小时 (0~23)</td>
<td>22</td>
</tr>
<tr>
<td>m</td>
<td>分钟数</td>
<td>30</td>
</tr>
<tr>
<td>s</td>
<td>秒数</td>
<td>55</td>
</tr>
<tr>
<td>S</td>
<td>毫秒数</td>
<td>234</td>
</tr>
<tr>
<td>E</td>
<td>星期几</td>
<td>Tuesday</td>
</tr>
<tr>
<td>D</td>
<td>一年中的日子</td>
<td>360</td>
</tr>
<tr>
<td>F</td>
<td>一个月中第几周的周几</td>
<td>2 (second Wed. in July)</td>
</tr>
<tr>
<td>w</td>
<td>一年中第几周</td>
<td>40</td>
</tr>
<tr>
<td>W</td>
<td>一个月中第几周</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>A.M./P.M. 标记</td>
<td>PM</td>
</tr>
<tr>
<td>k</td>
<td>一天中的小时(1~24)</td>
<td>24</td>
</tr>
<tr>
<td>K</td>
<td>A.M./P.M. (0~11)格式小时</td>
<td>10</td>
</tr>
<tr>
<td>z</td>
<td>时区</td>
<td>Eastern Standard Time</td>
</tr>
<tr>
<td>‘</td>
<td>文字定界符</td>
<td>Delimiter</td>
</tr>
<tr>
<td>“</td>
<td>单引号</td>
<td>`</td>
</tr>
</tbody>
</table>
<h3><span id="printf格式化日期">printf格式化日期</span></h3><p>printf 方法可以很轻松地格式化时间和日期。使用<strong>两个字母</strong>格式，它以 <strong>%t</strong> 开头并且以下面表格中的一个字母结尾。</p>
<table>
<thead>
<tr>
<th>转  换  符</th>
<th>说    明</th>
<th>示    例</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>包括全部日期和时间信息</td>
<td>星期六 十月 27 14:21:20 CST 2007</td>
</tr>
<tr>
<td>F</td>
<td>“年-月-日”格式</td>
<td>2007-10-27</td>
</tr>
<tr>
<td>D</td>
<td>“月/日/年”格式</td>
<td>10/27/07</td>
</tr>
<tr>
<td>r</td>
<td>“HH:MM:SS PM”格式（12时制）</td>
<td>02:25:51 下午</td>
</tr>
<tr>
<td>T</td>
<td>“HH:MM:SS”格式（24时制）</td>
<td>14:28:16</td>
</tr>
<tr>
<td>R</td>
<td>“HH:MM”格式（24时制）</td>
<td>14:28</td>
</tr>
</tbody>
</table>
<h3><span id="解析字符串">解析字符串</span></h3><p><strong>SimpleDateFormat 类的parse()方法来按照对应的格式化存储来解析字符串。</strong></p>
<h3><span id="sleep">sleep</span></h3><p>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(1000);   // 休眠1秒</span><br></pre></td></tr></table></figure>
<h2><span id="calendar类与gregoriancalendar类">Calendar类与GregorianCalendar类</span></h2><p>略…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/21/分拆素数和/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/分拆素数和/" itemprop="url">分拆素数和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T15:27:21+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  922
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#题目内容">题目内容</a></li>
<li><a href="#题目分析">题目分析</a></li>
<li><a href="#eratosthenes筛选法">Eratosthenes筛选法</a></li>
<li><a href="#试探法回溯法">试探法（回溯法）</a></li>
<li><a href="#代码详解">代码详解</a></li>
</ul>
<!-- tocstop -->
<h2><span id="题目内容">题目内容</span></h2><p><img src="/2019/03/21/分拆素数和/题目.jpg" alt=""></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2098" target="_blank" rel="noopener">原题链接</a></p>
<h2><span id="题目分析">题目分析</span></h2><p>很明显，本题的要求是要求解<strong>分解的个数</strong>，主要思路就是利用Eratosthenes筛选法来求必要的素数，然后用试探法来求分解的个数。</p>
<p><strong>原理：对于任何一个可以分解为两个素数之和的偶数，其中一个必然是小于或者等于1/2的。</strong></p>
<h2><span id="eratosthenes筛选法">Eratosthenes筛选法</span></h2><p><strong>筛选法又称筛法</strong>，具体做法是：先把N个自然数按次序排列起来。1不是质数，也不是合数，要划去。第二个数2是质数留下来，而把2后面所有能被2整除的数都划去。2后面第一个没划去的数是3，把3留下，再把3后面所有能被3整除的数都划去。3后面第一个没划去的数是5，把5留下，再把5后面所有能被5整除的数都划去。<strong>这样一直做下去，就会把不超过N的全部合数都筛掉，留下的就是不超过N的全部质数。</strong></p>
<p>（合数：一个正整数，除了1和它本身以外，还能被其他正整数整除，这个数就叫做合数。）</p>
<p>（质数（prime number）又称<a href="https://baike.baidu.com/item/%E7%B4%A0%E6%95%B0/115069" target="_blank" rel="noopener">素数</a>，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他<a href="https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0/9539111" target="_blank" rel="noopener">因数</a>。）</p>
<p><strong>埃拉托斯特尼筛选法</strong>是最为知名的产生素数的筛选法，适用于产生<strong>最小的N个素数</strong>。</p>
<p>该方法的唯一缺点是使用的存储空间大，可以进一步改进。</p>
<p>另外，该算法也<strong>不适用于计算某个范围内的全部素数</strong>。</p>
<h2><span id="试探法回溯法">试探法（回溯法）</span></h2><p>先选择某一种可能的情况进行试探，在试探过程中，一旦发现此选择的假设是错误的，就退回一步重新选择，继续向前试探，如此反复进行，直到证明解或者无解。</p>
<h2><span id="代码详解">代码详解</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define Max 10000</span><br><span class="line">using namespace std;</span><br><span class="line">//Eratosthenes筛选法</span><br><span class="line">void eratosthenesFunction(int num[],int n)</span><br><span class="line">&#123;</span><br><span class="line">	//两个参数一个是筛选的数组，一个是筛选的最大值</span><br><span class="line">	//由于数组在函数中修改的值类似于取址赋值，这里直接里面修改外面也修改了</span><br><span class="line">	num[0]=num[1]=0;</span><br><span class="line">	num[2]=1;//从2开始的质数才算进去</span><br><span class="line">	//首先先初始化，把所有质数序号的数组值赋值为1</span><br><span class="line">	for(int i=3;i&lt;=n;i++)</span><br><span class="line">	&#123; </span><br><span class="line">		num[i]=1;</span><br><span class="line">		i++; </span><br><span class="line">		num[i]=0;	</span><br><span class="line">	&#125; </span><br><span class="line">	int max=sqrt(n);</span><br><span class="line">	for(int i=3;i&lt;=max;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		//下面就开始筛选了，把所有的之前出现过的质数的倍数给去掉 </span><br><span class="line">		if(num[i])&#123;</span><br><span class="line">			for(int j=i+i;j&lt;n;j+=i)&#123;</span><br><span class="line">				num[j]=0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int num[Max+1]=&#123;0&#125;;//因为我们算的都是正数，意思是没有用到下标为0的 </span><br><span class="line">	int sum,count;//依次表示的是输入的正数和拆分个数</span><br><span class="line">	eratosthenesFunction(num,Max);//送进去筛选</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		cin&gt;&gt;sum;</span><br><span class="line">		if(sum==0) break;//要先判断是否是终止条件</span><br><span class="line">		count=0;//这个是必须的，在循环中每一次循环都是不同的数字，必须重置</span><br><span class="line">		for(int i=2;i&lt;sum/2;i++)&#123;</span><br><span class="line">			//对于任何一个可以分解为两个素数之和的偶数，其中一个必然是小于或者等于1/2的。</span><br><span class="line">			if(num[i]&amp;&amp;num[sum-i])&#123;</span><br><span class="line">				//这里就是判断是否是两个质数</span><br><span class="line">				if(i!=sum-i)&#123;</span><br><span class="line">					count++; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后结果：</p>
<p><img src="/2019/03/21/分拆素数和/accept.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/21/Dart学习笔记-一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/Dart学习笔记-一/" itemprop="url">Dart学习笔记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T13:29:36+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/Dart/" itemprop="url" rel="index">
                    <span itemprop="name">Dart</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  980
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#简单实例">简单实例</a></li>
<li><a href="#重要概念">重要概念</a></li>
<li><a href="#关键字">关键字</a></li>
<li><a href="#变量">变量</a><ul>
<li><a href="#未初始化">未初始化</a></li>
<li><a href="#final与const关键字">Final与const关键字</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="前言">前言</span></h2><p>由于最近写的一个东西需要到Flutter，所以Dart语言也必须学好，不多说，现在立马就开始吧。由于是个人向的学习笔记，所以，默认是已经学过其他编程语言了，然后很多和其他类似的语法就不过多赘述，只是表达目前新的东西。</p>
<h2><span id="简单实例">简单实例</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个函数</span><br><span class="line">printInteger(int aNumber) &#123;</span><br><span class="line">  print(&apos;The number is $aNumber.&apos;); // Print to console.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 程序执行入口</span><br><span class="line">main() &#123;</span><br><span class="line">  var number = 42; // Declare and initialize a variable.</span><br><span class="line">  printInteger(number); // Call a function.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dart内置的类型包括int，string，list，bool。</strong></p>
<p>print()用于<strong>显示输出</strong>。</p>
<p>main()是一种特殊的，必须的顶级函数，应用程序就从这里<strong>开始执行</strong>。</p>
<h2><span id="重要概念">重要概念</span></h2><p>在变量中可以放置的所有东西都是<strong>对象</strong>，而每个对象都是类的实例。无论数字、函数和null都是对象。<strong>所有对象都继承自[Object]类。</strong><br>    尽管Dart是<strong>强类型的</strong>，但类型声明是可选的，因为Dart可以推断类型。 在上面的代码中，数字被推断为int类型。 <strong>如果要明确说明不需要任何类型，请使用[特殊类型dynamic]。</strong><br>    Dart支持<strong>通用类型</strong>，如List<int>(整数列表)或List<dynamic>(任何类型的对象列表)。<br>    Dart支持<strong>顶级函数</strong>(如main())，以及绑定到类或对象(分别是静态方法（static）和实例（instance）方法)的函数。您还可以在函数(嵌套或局部函数)中创建函数。<br>    Dart支持<strong>顶级变量</strong>，以及绑定到类或对象(静态和实例变量)的变量。<strong>实例变量有时被称为字段或属性</strong>。<br>    与Java不同，<strong>Dart没有公开、保护和私有的关键字</strong>。如果标识符以下划线(<em>)开头，则该标识符对其库是<strong>私有的</strong>。<br>    标识符可以以字母或下划线(</em>)开头，然后是这些字符加上数字的<strong>任何组合</strong>。<br>    有时候，某事物是<strong>一个表达（expression ）还是一个语句（statement）</strong>是很重要的，所以这两个词要准确。</dynamic></int></p>
<h2><span id="关键字">关键字</span></h2><p>这就是Dart里面所有的关键字：</p>
<p>(1)带有上标1的单词是<strong>内置标识符</strong>。避免使用内置标识符作为标识符。如果尝试为类或类型名使用内置标识符，则会发生编译时错误。<br>    (2)使用上标2的单词是在Dart的1.0版本之后添加的与异步支持相关的<strong>更新的、有限的保留字</strong>。在以async, async<em>, 或者 sync</em> 标记的任何函数体中，不能使用async, await, 或者 yield作为标识符。</p>
<p>关键字表中的所有其他词都是<strong>保留词</strong>。<strong>不能使用保留词作为标识符。</strong></p>
<p><img src="/2019/03/21/Dart学习笔记-一/关键字.jpg" alt=""></p>
<h2><span id="变量">变量</span></h2><h3><span id="未初始化">未初始化</span></h3><p><strong>未初始化的变量的初始值为null。</strong>甚至具有数字类型的变量最初也是null，因为数字——就像dart中的其他东西一样——是<strong>对象</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int lineCount;</span><br><span class="line">assert(lineCount == null);</span><br></pre></td></tr></table></figure>
<h3><span id="final与const关键字">Final与const关键字</span></h3><p><strong>最终变量只能设置一次</strong>，const变量是一个编译时常数。(Const变量是<strong>隐式最终变量</strong>。)最终的顶级或类变量在第一次使用时被初始化。</p>
<p>注意:<strong>实例变量可以是final，但不能是const。</strong>[实例变量定义在对象一级，它可以被类中的任何方法或者其他类中的方法访问，但是不能被<strong>静态方法</strong>访问。]</p>
<p>对于想要<strong>在编译时确定并且不再变</strong>的变量，使用const。如果const变量位于<strong>类级别</strong>，则将其标记为<strong>静态const</strong>。</p>
<p>const关键字<strong>不只是声明常量变量</strong>。还可以使用它来创建常量值，以及声明创建常量值的构造函数。<strong>任何变量都可以赋一个常量值。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/21/java基础-渐入佳境/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/java基础-渐入佳境/" itemprop="url">java基础-渐入佳境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T12:35:17+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#对象实例化过程">对象实例化过程</a></li>
<li><a href="#方法的覆盖">方法的覆盖</a><ul>
<li><a href="#定义">定义</a></li>
<li><a href="#特点">特点</a></li>
</ul>
</li>
<li><a href="#final关键字">final关键字</a><ul>
<li><a href="#数据">数据</a></li>
<li><a href="#类">类</a></li>
<li><a href="#方法">方法</a></li>
<li><a href="#空final">空final</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="前言">前言</span></h2><p>关于Java基础系列的学习路线，我已经在<a href="https://thbelief.coding.me/2019/02/26/android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%80%BB%E7%BB%93plus/">安卓学习路线总结plus</a>里面写到了，我是按照那个上面的路线来学习的，如果有不明白的地方的话，可以移步前往作为 参考，也可以当成是目录。</p>
<h2><span id="对象实例化过程">对象实例化过程</span></h2><p>1.检查类<strong>是否已经加载</strong>，如果没有加载的话就加载这个类，需要加载所有的父类。</p>
<p>2.在内存堆中分配对象空间，递归分配所有父类和子类属性空间.先父类型再子类型,属性<strong>默认自动初始化</strong>.自动初始化为”0”值。</p>
<p>3.进行属性的赋值。</p>
<p>4.递归调用父类的构造器（默认的是调用父类的无参数构造器）。</p>
<p>5.调用本类的构造器。</p>
<p><strong>注意：</strong></p>
<p>1）静态初始化是指执行静态初始化块儿里面的内容。</p>
<p>2）实例初始化是指执行实例初始化块儿里面的内容。</p>
<p>3）构造方法：一个名称跟类的名称一样的方法，特殊在于不带返回值。</p>
<p><strong>实例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class TestInstanceInit &#123;</span><br><span class="line"></span><br><span class="line">public static int n = 0;// 静态变量</span><br><span class="line"></span><br><span class="line">static &#123;// 这是静态初始化块</span><br><span class="line">print();</span><br><span class="line">System.out.println(&quot;this is static block&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;// 实例初始化块</span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TestInstanceInit() &#123;// 构造方法</span><br><span class="line">System.out.println(&quot;this is TestInstanceInit&apos;s constructor~&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void print() &#123;// 静态方法</span><br><span class="line">System.out.println(&quot;this is static method~&quot;);</span><br><span class="line">System.out.println(n);</span><br><span class="line">n += 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new TestInstanceInit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this is static method~</span><br><span class="line">0</span><br><span class="line">this is static block</span><br><span class="line">1</span><br><span class="line">this is TestInstanceInit&apos;s constructor~</span><br></pre></td></tr></table></figure>
<p><strong>执行顺序：</strong></p>
<p><strong>(静态变量、静态初始化块)&gt;(变量、初始化快)&gt;构造器</strong>。</p>
<p>静态变量和静态初始化快/变量和初始化快的先后顺序取决于它们在类中出现的<strong>先后顺序</strong>。</p>
<p><a href="https://blog.csdn.net/avinegar/article/details/7749431" target="_blank" rel="noopener">参考链接</a></p>
<h2><span id="方法的覆盖">方法的覆盖</span></h2><h3><span id="定义">定义</span></h3><p>如果在子类中定义一个方法，其名称、返回类型及参数签名正好与父类中某个方法的名称、返回类型及参数签名相<strong>匹配</strong>，那么可以说，子类的方法覆盖了父类的方法。</p>
<h3><span id="特点">特点</span></h3><p> 子类的方法名称返回类型及参数签名 必须与父类的一致。<br>    子类方法不能缩小父类方法的访问权限。<br>    子类方法不能抛出比父类方法更多的异常。<br>    方法覆盖只存在于子类和父类之间，同一个类中只能重载。<br>    父类的静态方法不能被子类覆盖为非静态方法。<br>    子类可以定义于父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法（满足覆盖约束）， 而且Java虚拟机把静态方法和所属的类绑定，而把实例方法和所属的实例绑定。<br>    父类的非静态方法不能被子类覆盖为静态方法。<br>    父类的私有方法不能被子类覆盖。<br>    父类的抽象方法可以被子类通过两种途径覆盖（即实现和覆盖）。</p>
<p>父类的非抽象方法可以被覆盖为抽象方法。</p>
<h2><span id="final关键字">final关键字</span></h2><p>在Java中final关键字可以用来修饰数据，方法，参数以及类。</p>
<h3><span id="数据">数据</span></h3><p>final修饰的基本类型，在初始化之后就不能在赋值了，同理，修饰的对象一旦引用被初始化指向一个对象的话，就无法把它改指向另外一个对象。</p>
<p>但是要注意，被final修饰的对象引用，只是对象的应用不能修改，但是<strong>其自身却是可以修改的</strong>。</p>
<h3><span id="类">类</span></h3><p>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。</p>
<p>final类中的成员变量可以根据需要设为final，但是要注意final类中的所有<strong>成员方法</strong>都会被隐式地指定为<strong>final方法</strong>。</p>
<h3><span id="方法">方法</span></h3><p>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。</p>
<p><strong>注意:类的private方法会被隐式的指定为final方法。</strong></p>
<h3><span id="空final">空final</span></h3><p>谓的”空白final”是指被声明的为final但又为给定初值的对象引用或者基本数据。无论在什么情况下，编译器都会去确保final在使用前必须被初始化。若不进行初始化，会提示错误，这就意味着，必须在域的定义处或者每个构造器中使用表达式对final进行赋值，这正是final域在使用前被初始化的原因所在。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/20/JavaScript学习笔记-二/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/20/JavaScript学习笔记-二/" itemprop="url">JavaScript学习笔记(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-20T22:02:27+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#函数定义与调用">函数定义与调用</a><ul>
<li><a href="#定义函数">定义函数</a></li>
<li><a href="#调用函数">调用函数</a></li>
<li><a href="#特殊arguments">特殊arguments</a></li>
<li><a href="#rest参数">rest参数</a></li>
</ul>
</li>
<li><a href="#变量相关">变量相关</a><ul>
<li><a href="#变量提升">变量提升</a></li>
<li><a href="#全局作用域">全局作用域</a></li>
<li><a href="#名字空间">名字空间</a></li>
<li><a href="#局部作用域">局部作用域</a></li>
<li><a href="#常量">常量</a></li>
<li><a href="#解构赋值">解构赋值</a></li>
</ul>
</li>
<li><a href="#方法">方法</a><ul>
<li><a href="#apply">apply</a></li>
<li><a href="#装饰器">装饰器</a></li>
</ul>
</li>
<li><a href="#四个常用的高阶函数">四个常用的高阶函数</a><ul>
<li><a href="#map">map</a></li>
<li><a href="#reduce">reduce</a></li>
<li><a href="#filter">filter</a></li>
<li><a href="#sort">sort</a></li>
</ul>
</li>
<li><a href="#闭包">闭包</a><ul>
<li><a href="#函数作为返回值">函数作为返回值</a></li>
<li><a href="#箭头函数">箭头函数</a></li>
</ul>
</li>
<li><a href="#generator">generator</a><ul>
<li><a href="#优势">优势</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="函数定义与调用">函数定义与调用</span></h2><h3><span id="定义函数">定义函数</span></h3><p>第一种方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function hanshu()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.function指出这是一个<strong>函数定义</strong>；<br>    2.hanshu是<strong>函数的名称</strong>；<br>    3.(x)括号内列出函数的参数，多个参数<strong>以,分隔</strong>；<br>    4.{ … }之间的代码是<strong>函数体</strong>，可以包含若干语句，甚至可以没有任何语句。</p>
<p>第二种方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var hanshu = function (x) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>function (x) { … }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量hanshu，所以，通过变量hanshu就可以调用该函数。这两种其实是完全等价的，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。</p>
<h3><span id="调用函数">调用函数</span></h3><p>JS中有点儿特殊，主要就是特殊在JS中对于一个函数传进去的参数<strong>不做限制</strong>，传多了没有问题，只是在内部没有用而已，传少了的话计算结果会变成NaN。如果想保险一点儿的话，可以直接在函数里面对于传进来的参数做判断即可。</p>
<h3><span id="特殊arguments">特殊arguments</span></h3><p>在<strong>函数内部</strong>起作用，并且永远指向<strong>当前函数的调用者传入的所有参数</strong>。arguments类似Array但它不是一个Array。意思也就是，就算函数并没有定义任何的变量，也是可以拿到参数的值。</p>
<h3><span id="rest参数">rest参数</span></h3><p>（ES6引入）rest参数只能写在<strong>最后</strong>，前面用…标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments就获取了全部参数。</p>
<p>如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个<strong>空数组</strong>（注意<strong>不是undefined</strong>）。</p>
<p>特别注意:JS里面有一个<strong>自动在行末添加分号</strong>的性质，所以特别需要注意。</p>
<h2><span id="变量相关">变量相关</span></h2><p>注意，由于JS支持函数嵌套，在查找变量时从自身函数定义开始，<strong>从“内”向“外”</strong>查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“<strong>屏蔽</strong>”外部函数的变量。</p>
<h3><span id="变量提升">变量提升</span></h3><p>JS函数的特性，它执行前会扫描整个函数体，<strong>把所有声明的变量都放到顶部</strong>。但是要注意，它<strong>只是提升变量的声明，并没有提升变量的赋值</strong>。</p>
<p>所以为了避免有些错误，建议是在函数体内，<strong>把所有的变量声明都放到函数的开头</strong>。</p>
<h3><span id="全局作用域">全局作用域</span></h3><p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var bianliang=&apos;thbelief&apos;;</span><br><span class="line">function hanshu()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的话，访问bianliang与访问window.bianliang是完全一样的。</p>
<p>同时，第二种函数的定义方式其实也是一种全局的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var hanshu = function (x) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以，其实JS只有一个<strong>全局作用域</strong>。</p>
<h3><span id="名字空间">名字空间</span></h3><p>全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成<strong>命名冲突</strong>，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部<strong>绑定到一个全局变量中</strong>。</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 唯一的全局变量MYAPP:</span><br><span class="line">var MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 其他变量:</span><br><span class="line">MYAPP.name = &apos;myapp&apos;;</span><br><span class="line">MYAPP.version = 1.0;</span><br><span class="line"></span><br><span class="line">// 其他函数:</span><br><span class="line">MYAPP.foo = function () &#123;</span><br><span class="line">    return &apos;foo&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个其实是一个特别实用的方法，必须提倡。</p>
<h3><span id="局部作用域">局部作用域</span></h3><p>在循环中，一般使用let替代var声明次级作用域的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var sum = 0;</span><br><span class="line">    for (let i=0; i&lt;100; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    i += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="常量">常量</span></h3><p>ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域。但是需要注意，<strong>不是所有的地方都支持</strong>，因为ES6才引进。</p>
<h3><span id="解构赋值">解构赋值</span></h3><p>可以直接对多个变量同时赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">// 如果浏览器支持解构赋值就不会报错:</span><br><span class="line">var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;];</span><br></pre></td></tr></table></figure>
<p>注意，对数组元素进行解构赋值时，<strong>多个变量要用[…]括起来</strong>。</p>
<p>有些时候数组本身还有<strong>嵌套</strong>，也可以解构赋值，但是需要保持嵌套层次和位置的<strong>一致性</strong>。</p>
<p>解构赋值还有<strong>很多用法</strong>，这里就不一一阐述了，需要的时候直接去查就好啦。</p>
<h2><span id="方法">方法</span></h2><p>在一个对象中绑定函数，这就是这个对象的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var thbelief = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;,</span><br><span class="line">    birth: 1999,</span><br><span class="line">    age: function () &#123;</span><br><span class="line">        var y = new Date().getFullYear();</span><br><span class="line">        return y - this.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">thbelief.age; // function thbelief.age()</span><br><span class="line">thbelief.age();</span><br></pre></td></tr></table></figure>
<p>同时，this关键字在JS里面也有和C++同样的作用，可以直接调用本函数的方法。</p>
<p>但是一定要用对象的形式调用，这才是指向本函数里面的方法，不然的话就是对于整个全局作用域来说的。</p>
<p>解决的方法其实也有，就是<strong>var that = this;</strong>这条语句加上去在用的地方就可以了。</p>
<h3><span id="apply">apply</span></h3><p>虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，还是可以<strong>控制this的指向</strong>！</p>
<p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>用apply修复getAge()调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getAge() &#123;</span><br><span class="line">    var y = new Date().getFullYear();</span><br><span class="line">    return y - this.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var thbelief = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;,</span><br><span class="line">    birth: 1999,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">thbelief.age(); </span><br><span class="line">getAge.apply(thbelief, []);</span><br></pre></td></tr></table></figure>
<p>另一个与apply()类似的方法是<strong>call()</strong>，唯一<strong>区别</strong>是：</p>
<p>apply()把参数打包成Array再传入；</p>
<p>call()把参数按顺序传入。</p>
<p>比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max.apply(null, [3, 5, 4]); // 5</span><br><span class="line">Math.max.call(null, 3, 5, 4); // 5</span><br></pre></td></tr></table></figure>
<h3><span id="装饰器">装饰器</span></h3><p>利用apply()，我们还可以<strong>动态改变函数的行为</strong>。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以<strong>重新</strong>指向新的函数。</p>
<h2><span id="四个常用的高阶函数">四个常用的高阶函数</span></h2><h3><span id="map">map</span></h3><p>map可以传入任意的变量或者自己定义的相关函数，比如说做一个2的次方运算，相比较于我们傻乎乎的使用循环一层一层的套，map作为高阶函数无疑是更加具有实力的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">function pow(x) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure>
<h3><span id="reduce">reduce</span></h3><p>Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数<strong>必须接收两个参数</strong>，reduce()把结果继续和序列的下一个元素做累积计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 5, 7, 9];</span><br><span class="line">arr.reduce(function (x, y) &#123;</span><br><span class="line">    return x * 10 + y;</span><br><span class="line">&#125;); // 13579</span><br></pre></td></tr></table></figure>
<h3><span id="filter">filter</span></h3><p>其实有点儿类似于Android里面的过滤器。它的作用就是将Array里面的某些元素过滤掉，然后返回剩下的元素。</p>
<p>和map()类似，Array的filter()也接收<strong>一个函数</strong>。和map()不同的是，filter()把传入的函数<strong>依次</strong>作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, null, undefined, &apos;C&apos;, &apos;  &apos;];</span><br><span class="line">var r = arr.filter(function (s) &#123;</span><br><span class="line">    return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法</span><br><span class="line">&#125;);</span><br><span class="line">r; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br></pre></td></tr></table></figure>
<h3><span id="sort">sort</span></h3><p>需要注意的是，sort<strong>默认的排序</strong>不是简简单单的针对于数字进行排序。</p>
<p>它的默认把所有元素<strong>先转换为String</strong>再排序。</p>
<p>同时，作为一个函数，sort可以传入一个比较函数来作为依据。</p>
<p>比如说下面这个按照数字大小来进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var arr = [10, 20, 1, 2];</span><br><span class="line">arr.sort(function (x, y) &#123;</span><br><span class="line">    if (x &lt; y) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; y) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="闭包">闭包</span></h2><h3><span id="函数作为返回值">函数作为返回值</span></h3><p>高阶函数除了可以接受函数作为参数外，还可以<strong>把函数作为结果值</strong>返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function lazy_sum(arr) &#123;</span><br><span class="line">    var sum = function () &#123;</span><br><span class="line">        return arr.reduce(function (x, y) &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()</span><br></pre></td></tr></table></figure>
<p>调用函数f时，才真正计算求和的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(); // 15</span><br></pre></td></tr></table></figure>
<p>函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>返回闭包时牢记的一点就是：<strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong>。因为它只会锁定最后一个结果。如果一定要引用循环变量的话，方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的<strong>值不变</strong>。</p>
<p>闭包还有很多应用，这里只是阐述基本概念，相关的使用要用的时候自己查即可。</p>
<h3><span id="箭头函数">箭头函数</span></h3><p>是在ES6之后推出的，<strong>只支持ES6之后的版本</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x * x;</span><br><span class="line">//两者完全等价</span><br><span class="line">function (x) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数相当于<strong>匿名函数</strong>，并且<strong>简化了函数定义</strong>。</p>
<p>箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。</p>
<p>还有一种可以包含多条语句，这时候就<strong>不能省略{ … }和return</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    if (x &gt; 0) &#123;</span><br><span class="line">        return x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return - x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 两个参数:</span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line"></span><br><span class="line">// 无参数:</span><br><span class="line">() =&gt; 3.14</span><br><span class="line"></span><br><span class="line">// 可变参数:</span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    var i, sum = x + y;</span><br><span class="line">    for (i=0; i&lt;rest.length; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要返回一个对象，并且是单表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ok:</span><br><span class="line">x =&gt; (&#123; foo: x &#125;)</span><br></pre></td></tr></table></figure>
<p><strong>this：</strong></p>
<p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。由于this在箭头函数中已经被绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略…</p>
<h2><span id="generator">generator</span></h2><p>generator（生成器）是ES6新引入的新的数据类型。<strong>一个generator看上去像一个函数，但可以返回多次</strong>。</p>
<p>定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function* foo(x) &#123;</span><br><span class="line">    yield x + 1;</span><br><span class="line">    yield x + 2;</span><br><span class="line">    return x + 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>generator和函数不同的是，generator由function<em>定义（注意多出的</em>号），并且，除了return语句，还可以用yield返回多次。</p>
<h3><span id="优势">优势</span></h3><p>1.因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就<strong>可以实现需要用面向对象才能实现的功能</strong>。</p>
<p>2.把异步回调代码变成“同步”代码。（深）</p>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">参考链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/19/Auto-js-Script开发-一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/Auto-js-Script开发-一/" itemprop="url">Auto.js Script开发(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T10:20:57+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/" itemprop="url" rel="index">
                    <span itemprop="name">移动端开发</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/Auto-js/" itemprop="url" rel="index">
                    <span itemprop="name">Auto.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#正文">正文</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#下个版本">下个版本</a></li>
</ul>
<!-- tocstop -->
<h2><span id="简介">简介</span></h2><p>Auto.js使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">JavaScript</a>作为脚本语言，目前使用<a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/Rhino" target="_blank" rel="noopener">Rhino 1.7.7.2</a>作为脚本引擎，支持ES5与部分ES6特性。</p>
<p>最开始接触Auto.js只是单纯的想写一个I西科自动签到的脚本，接触后才发现，写这样一个脚本其实简单的不行，然后了解了Auto.js的相关特性之后，我决定好好的学习一下这个工具，毕竟，它实在是太简约了，不像其他的脚本语言那么复杂，虽然…有点儿bug，毕竟开发者自己也只是一个大学生，不能指望有多完善，但是这种自动化脚本编辑实在是太有魅力了。</p>
<h2><span id="正文">正文</span></h2><p>最近正在开发的<strong>Script</strong>，主要目的是借用Auto.js自带的UI模块儿集成一个个人向的脚本库。</p>
<p>这个版本的展示图：</p>
<p><img src="/2019/03/19/Auto-js-Script开发-一/菜单.png" alt=""></p>
<p><img src="/2019/03/19/Auto-js-Script开发-一/自动签到.png" alt=""></p>
<p><img src="/2019/03/19/Auto-js-Script开发-一/自动回复.jpg" alt=""></p>
<p>目前代码展示如下，由于太简单，懒得上传到Github了，直接贴代码（后期如果有升级或者说是改良，会在下一个博客继续写）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&quot;ui&quot;;</span><br><span class="line">//下面就是主界面</span><br><span class="line">ui.layout(</span><br><span class="line">    &lt;vertical&gt;</span><br><span class="line">        &lt;horizontal&gt;</span><br><span class="line">            &lt;text text=&quot;菜单&quot; w=&quot;*&quot; h=&quot;*&quot; layout_weight=&quot;1&quot; gravity=&quot;center&quot; textSize=&quot;30sp&quot; color=&quot;#000000&quot;/&gt;</span><br><span class="line">        &lt;/horizontal&gt;</span><br><span class="line">        &lt;horizontal&gt;</span><br><span class="line">            &lt;button id=&quot;autoReply&quot; text=&quot;QQ自动回复&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">            &lt;button id=&quot;autoReplyClose&quot; text=&quot;关闭&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;/horizontal&gt;</span><br><span class="line">        &lt;horizontal&gt;</span><br><span class="line">            &lt;button id=&quot;autoSignIn&quot; text=&quot;i西科自动签到&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">            &lt;button id=&quot;autoSignInClose&quot; text=&quot;关闭&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;/horizontal&gt;</span><br><span class="line">    &lt;/vertical&gt;</span><br><span class="line">);</span><br><span class="line">//封装的回复方法</span><br><span class="line">function WhatReply(notificationText)&#123;</span><br><span class="line">    if(notificationText==&apos;A&apos;)&#123;</span><br><span class="line">        return(&quot;您好，我是主人正在开发的人工智障robot001.\n   ——robot001欢喜的答道。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(notificationText==&apos;B&apos;)&#123;</span><br><span class="line">        return(&quot;好的，我马上联系主人...\n   ——robot001郑重的答道。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return &quot;主人在忙呢！\n有问题请回复下列单个字母：\n A.robot是谁？\n B.有要事迅速联系thbelief. \n   ——robot001如此回答道。&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//先封装一个自动回复的方法</span><br><span class="line">function autoReplyFunction()&#123;</span><br><span class="line">    auto();//检查是否开启了无障碍服务权限</span><br><span class="line">    events.observeNotification();//监听消息</span><br><span class="line">    events.onNotification(function(notification)&#123;</span><br><span class="line">        var string1=&quot;com.tencent.mobileqq&quot;;//如果是QQ消息的话</span><br><span class="line">        if(string1==notification.getPackageName())&#123;</span><br><span class="line">            notification.click();//点击直接进入对应的聊天界面</span><br><span class="line">            //跳转必须要用startActivity</span><br><span class="line">            waitForPackage(&quot;com.tencent.mobileqq&quot;);</span><br><span class="line">            var t=className(&quot;android.widget.EditText&quot;).id(&quot;input&quot;).findOnce();//找到聊天输入控件</span><br><span class="line">            t.setText(WhatReply(notification.getText()));//这里加入回复的方法</span><br><span class="line">            className(&quot;android.widget.Button&quot;).id(&quot;fun_btn&quot;).findOnce().click();//发送即可</span><br><span class="line">            home();//直接返回桌面</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">//自动签到的方法</span><br><span class="line">function autoSignInFunction()&#123;</span><br><span class="line">    auto();</span><br><span class="line">    //打开i西科</span><br><span class="line">    launchApp(&quot;i西科&quot;);</span><br><span class="line">    //跳转到相应的界面</span><br><span class="line">    waitForPackage(&quot;org.weixvn.frame&quot;);</span><br><span class="line">    //找到首页上签到的按钮，点击进去</span><br><span class="line">    id(&quot;it_sign_in&quot;).clickable().findOne().click();</span><br><span class="line">    waitForActivity(&quot;com.example.z.iswust.view.activity.impl.SignInActivity&quot;);</span><br><span class="line">    //点击签到</span><br><span class="line">    if(id(&quot;btn_signin&quot;).clickable().findOne().click())&#123;</span><br><span class="line">        //完成任务后返回桌面</span><br><span class="line">        home();</span><br><span class="line">        toast(&quot;签到成功了哟，亲~~~&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">//自动回复按钮的点击事件</span><br><span class="line">ui.autoReply.click(()=&gt;&#123;</span><br><span class="line">    //UI模式的情况下必须用Promise形式或者回调模式</span><br><span class="line">    confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123;</span><br><span class="line">        if(sure)&#123;</span><br><span class="line">            //修改控件信息必须更改线程</span><br><span class="line">            threads.start(function()&#123;</span><br><span class="line">                autoReplyFunction();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">//自动回复按钮的关闭点击事件</span><br><span class="line">ui.autoReplyClose.click(()=&gt;&#123;</span><br><span class="line">    //这里由于只有一个脚本，我就直接把所有的脚本都关闭了，如果是很多脚本的话必须改</span><br><span class="line">    engines.stopAll();</span><br><span class="line">    toast(&quot;自动回复脚本已经关闭了哦，亲~&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//i西科自动签到的点击事件</span><br><span class="line">ui.autoSignIn.click(()=&gt;&#123;</span><br><span class="line">    confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123;</span><br><span class="line">        if(sure)&#123;</span><br><span class="line">            //修改控件信息必须更改线程</span><br><span class="line">            threads.start(function()&#123;</span><br><span class="line">                //自动签到的方法</span><br><span class="line">                autoSignInFunction();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="总结">总结</span></h2><p>1.一定要判断是否开启了<strong>无障碍服务权限</strong>以及<strong>通知使用权</strong>。</p>
<p>2.无论是不是用intent跳转页面或者应用，都应该用<strong>waitForActivity或者waitForPackage</strong>来跳转，不然容易出错。</p>
<p>3.基于控件的操作的时候，一定要注意寻找的依据，<strong>尽量使用不重复的依据</strong>，例如desc或者说id这种，提高兼容性。</p>
<p>4.方法的封装应该是根据<strong>功能</strong>来的，这一点本版本还没有做完善。</p>
<p>5.提示信息一定要做到位，该Toast的地方就一定要毫不犹豫的<strong>Toast</strong>.</p>
<p>6.如果想进入某个界面做某事，可以直接在外面套个if，这样出错的几率会小很多，比如说本版本的<strong>autoSignInFunction</strong>函数里面的点击签到。</p>
<p>7.UI模式情况下必须使用<strong>Promise形式</strong>或者说是<strong>回调模式</strong>。</p>
<p>8.还有就是，运行多个脚本的时候，都要使用<strong>多线程</strong>。</p>
<h2><span id="下个版本">下个版本</span></h2><p>1.UI界面做的是真的丑，下个版本尽量修复。</p>
<p>2.添加检查更新的功能，直接app内检查更新并更新到最新版本。</p>
<p>3.添加更多的脚本选项。</p>
<p>4.定时运行，比如说，定时自启之类的，例如本版本的i西科自动签到功能，定时启动签到。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/18/JavaScript学习笔记-一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/18/JavaScript学习笔记-一/" itemprop="url">JavaScript学习笔记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T21:06:35+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#入门">入门</a><ul>
<li><a href="#基本语法">基本语法</a></li>
<li><a href="#数据类型">数据类型</a><ul>
<li><a href="#number">Number</a></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#布尔值">布尔值</a></li>
<li><a href="#比较运算符">比较运算符</a></li>
<li><a href="#null和undefined">null和undefined</a></li>
<li><a href="#数组">数组</a></li>
<li><a href="#对象">对象</a></li>
<li><a href="#变量">变量</a></li>
<li><a href="#strict模式">strict模式</a></li>
</ul>
</li>
<li><a href="#字符串-1">字符串</a></li>
<li><a href="#数组-1">数组</a><ul>
<li><a href="#length">length</a></li>
<li><a href="#indexof">indexOf</a></li>
<li><a href="#slice">slice</a></li>
<li><a href="#push和pop">push和pop</a></li>
<li><a href="#unshift和shift">unshift和shift</a></li>
<li><a href="#sort">sort</a></li>
<li><a href="#reverse">reverse</a></li>
<li><a href="#splice">splice</a></li>
<li><a href="#concat">concat</a></li>
<li><a href="#join">join</a></li>
<li><a href="#多维数组">多维数组</a></li>
</ul>
</li>
<li><a href="#对象-1">对象</a></li>
<li><a href="#条件判断">条件判断</a></li>
<li><a href="#循环">循环</a><ul>
<li><a href="#forin">for…in</a></li>
<li><a href="#while">while</a></li>
<li><a href="#do-while">do while</a></li>
</ul>
</li>
<li><a href="#map和set">Map和Set</a></li>
<li><a href="#iterable">iterable</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="入门">入门</span></h2><h3><span id="基本语法">基本语法</span></h3><p>每个语句以<code>;</code>结束，语句块用<code>{...}</code>。但是，JavaScript并不强制要求在每个语句的结尾加<code>;</code>，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上<code>;</code>。</p>
<h3><span id="数据类型">数据类型</span></h3><h4><span id="number">Number</span></h4><p>JS里面不区分整数和浮点数，都是用Number统一表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123; // 整数123</span><br><span class="line">0.456; // 浮点数0.456</span><br><span class="line">1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5</span><br><span class="line">-99; // 负数</span><br><span class="line">NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示</span><br><span class="line">Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span><br></pre></td></tr></table></figure>
<h4><span id="字符串">字符串</span></h4><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分。</p>
<h4><span id="布尔值">布尔值</span></h4><p>只表示true或者false。和C++与Java中完全类似，这里不过多赘述。</p>
<h4><span id="比较运算符">比较运算符</span></h4><p>注意，JavaScript允许对任意数据类型做比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false == 0; // true</span><br><span class="line">false === 0; // false</span><br></pre></td></tr></table></figure>
<p>特别要注意上述两种格式。</p>
<p>第一种是<code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</p>
<p>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</p>
<p>这是JS自身设计的缺陷，大佬们都是推荐的是<em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</p>
<p>还要注意一点是，NaN这个特殊的Number与所有值都不相等，包括它自己。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN === NaN; // false</span><br></pre></td></tr></table></figure>
<p>唯一能够判断NaN的方法就是isNaN()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN); // true</span><br></pre></td></tr></table></figure>
<p>最后，浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true</span><br></pre></td></tr></table></figure>
<h4><span id="null和undefined">null和undefined</span></h4><p>null表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。</p>
<p>JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用<strong>null</strong>。undefined仅仅在判断函数参数是否传递的情况下有用。</p>
<h4><span id="数组">数组</span></h4><p>数组是一组按<strong>顺序</strong>排列的集合，集合的每个值称为元素。JavaScript的数组可以包括<strong>任意数据类型</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3.14, &apos;HelloWorld&apos;, null, true];</span><br></pre></td></tr></table></figure>
<p>创建数组的另一个方法是Array()函数来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Array(1, 2, 3); // 创建了数组[1, 2, 3]</span><br></pre></td></tr></table></figure>
<h4><span id="对象">对象</span></h4><p>JavaScript的对象是一组由键-值组成的无序集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;thbeleif&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    tags: [&apos;js&apos;, &apos;web&apos;, &apos;mobile&apos;],</span><br><span class="line">    city: &apos;mianyang&apos;,</span><br><span class="line">    hasCar: false,</span><br><span class="line">    zipcode: null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性。</p>
<p>要获取一个对象的属性，需要用对象变量.属性名的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.name; // &apos;thbelief&apos;</span><br><span class="line">person.zipcode; // null</span><br></pre></td></tr></table></figure>
<h4><span id="变量">变量</span></h4><p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且<strong>不能用数字开头</strong>。变量名也不能是JavaScript的关键字，如if、while等。</p>
<p>在Chrome浏览器里面使用JS的时候，可以直接使用<strong>console.log(x)</strong>来打印变量的值。</p>
<p>相比较于alert()的对话框，前者看起来无疑是更舒心的。</p>
<h4><span id="strict模式">strict模式</span></h4><p>在JS设计之初，如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为<strong>全局变量</strong>。</p>
<p>后面有了改良，在<strong>strict模式</strong>下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</p>
<p>启用strict模式的方法是在JavaScript代码的第一行写上即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br></pre></td></tr></table></figure>
<h3><span id="字符串">字符串</span></h3><p>如果字符串内部既包含’又包含”可以用转义字符\来标识。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;I\&apos;m \&quot;OK\&quot;!&apos;;</span><br></pre></td></tr></table></figure>
<p>ASCII字符可以以<code>\x##</code>形式的十六进制表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;\x41&apos;; // 完全等同于 &apos;A&apos;</span><br></pre></td></tr></table></figure>
<p>还可以用<code>\u####</code>表示一个Unicode字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;\u4e2d\u6587&apos;; // 完全等同于 &apos;中文&apos;</span><br></pre></td></tr></table></figure>
<p>由于多行字符串用<code>\n</code>写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 <em>`</em> … <em>`</em> 也可以表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`这是一个</span><br><span class="line">多行</span><br><span class="line">字符串`;</span><br></pre></td></tr></table></figure>
<p>要把多个字符串连接起来，可以用+号连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;小明&apos;;</span><br><span class="line">var age = 20;</span><br><span class="line">var message = &apos;你好, &apos; + name + &apos;, 你今年&apos; + age + &apos;岁了!&apos;;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
<p>字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果。JS对于字符串提供了许多的方法，但是调用这些方法只会返回一个新的字符串，而不会改变原有的字符串内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toUpperCase()把一个字符串全部变为大写。</span><br><span class="line">indexOf()会搜索指定字符串出现的位置。</span><br><span class="line">substring()返回指定索引区间的子串。</span><br></pre></td></tr></table></figure>
<h3><span id="数组">数组</span></h3><h4><span id="length">length</span></h4><p>JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。</p>
<p>Array可以通过length属性来取得长度。</p>
<p>同时，直接给Array的length赋一个新的值会导致Array大小的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.length; // 3</span><br><span class="line">arr.length = 6;</span><br><span class="line">arr; // arr变为[1, 2, 3, undefined, undefined, undefined]</span><br><span class="line">arr.length = 2;</span><br><span class="line">arr; // arr变为[1, 2]</span><br></pre></td></tr></table></figure>
<p>Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array。</p>
<p>如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr[5] = &apos;x&apos;;</span><br><span class="line">arr; // arr变为[1, 2, 3, undefined, undefined, &apos;x&apos;]</span><br></pre></td></tr></table></figure>
<h4><span id="indexof">indexOf</span></h4><p>Array也可以通过indexOf()来搜索一个指定的元素的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [10, 20, &apos;30&apos;, &apos;xyz&apos;];</span><br><span class="line">arr.indexOf(10); // 元素10的索引为0</span><br><span class="line">arr.indexOf(20); // 元素20的索引为1</span><br><span class="line">arr.indexOf(30); // 元素30没有找到，返回-1</span><br><span class="line">arr.indexOf(&apos;30&apos;); // 元素&apos;30&apos;的索引为2</span><br></pre></td></tr></table></figure>
<h4><span id="slice">slice</span></h4><p>slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];</span><br><span class="line">arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br><span class="line">arr.slice(3); // 从索引3开始到结束: [&apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]</span><br></pre></td></tr></table></figure>
<p>注意到<code>slice()</code>的起止参数包括开始索引，<strong>不包括结束索引</strong>。</p>
<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];</span><br><span class="line">var aCopy = arr.slice();</span><br><span class="line">aCopy; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]</span><br><span class="line">aCopy === arr; // false</span><br></pre></td></tr></table></figure>
<h4><span id="push和pop">push和pop</span></h4><p>push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉。</p>
<h4><span id="unshift和shift">unshift和shift</span></h4><p>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉。</p>
<h4><span id="sort">sort</span></h4><p>按照默认顺序进行排序，也可以自定义顺序。</p>
<h4><span id="reverse">reverse</span></h4><p>翻转整个Array，把元素顺序翻转过来。</p>
<h4><span id="splice">splice</span></h4><p>从指定的索引开始删除若干元素，然后再从该位置添加若干元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];</span><br><span class="line">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</span><br><span class="line">// 只删除,不添加:</span><br><span class="line">arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]</span><br><span class="line">// 只添加,不删除:</span><br><span class="line">arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</span><br></pre></td></tr></table></figure>
<h4><span id="concat">concat</span></h4><p>把当前的Array和另一个Array连接起来，并返回一个新的Array。</p>
<p>值得注意的是，concat()方法并没有修改当前Array，而是返回了一个新的Array。</p>
<h4><span id="join">join</span></h4><p>把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。如果Array的元素不是字符串，将自动转换为字符串后再连接。</p>
<h4><span id="多维数组">多维数组</span></h4><p>如果数组的某个元素又是一个Array，则可以形成多维数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [[1, 2, 3], [400, 500, 600], &apos;-&apos;];</span><br></pre></td></tr></table></figure>
<h3><span id="对象">对象</span></h3><p>JS的对象是一种无序的集合数据类型，它由若干键值对组成。</p>
<p>JS用一个{…}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,。</p>
<p>访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用’’括起来。</p>
<p><strong>JavaScript规定，访问不存在的属性不报错，而是返回undefined。</strong></p>
<p>由于JavaScript的对象是<strong>动态类型</strong>，可以自由地给一个对象添加或删除属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var thbelief = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; // undefined</span><br><span class="line">xiaoming.age = 18; // 新增一个age属性</span><br><span class="line">xiaoming.age; // 18</span><br><span class="line">delete xiaoming.age; // 删除age属性</span><br><span class="line">xiaoming.age; // undefined</span><br><span class="line">delete xiaoming[&apos;name&apos;]; // 删除name属性</span><br><span class="line">xiaoming.name; // undefined</span><br><span class="line">delete xiaoming.school; // 删除一个不存在的school属性也不会报错</span><br></pre></td></tr></table></figure>
<p>果我们要检测thbelief是否拥有某一属性，可以用in操作符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;name&apos; in thbelief; // true</span><br></pre></td></tr></table></figure>
<p>另外，如果in判断一个属性存在，这个属性不一定是thbelief的，它可能是thbelief继承得到的。</p>
<p>要判断一个属性是否是thbelief自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var thbelief = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;</span><br><span class="line">&#125;;</span><br><span class="line">thbelief.hasOwnProperty(&apos;name&apos;); // true</span><br><span class="line">thbelief.hasOwnProperty(&apos;toString&apos;); // false</span><br></pre></td></tr></table></figure>
<h3><span id="条件判断">条件判断</span></h3><p>JavaScript可以使用if () { … } else { … }来进行条件判断。</p>
<p>同时，也可以像C++中一样进行多重的嵌套。</p>
<h3><span id="循环">循环</span></h3><p>熟悉的是单独的For循环，但是还包括了其他的不熟悉的循环方式。</p>
<h4><span id="forin">for…in</span></h4><p>它可以把一个对象的所有属性依次循环出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    city: &apos;mianyang&apos;</span><br><span class="line">&#125;;</span><br><span class="line">for (var key in o) &#123;</span><br><span class="line">    console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要过滤掉对象继承的属性，用hasOwnProperty()来实现。（前文对象中曾经提到）</p>
<p>值得注意的是，for … in对Array的循环得到的是String而不是Number。</p>
<h4><span id="while">while</span></h4><p>与C++中类似。</p>
<h4><span id="do-while">do while</span></h4><p>与C++中类似。</p>
<h3><span id="map和set">Map和Set</span></h3><p>Map是一组键值对的结构，具有极快的查找速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;); // 95</span><br></pre></td></tr></table></figure>
<p>初始化Map需要一个<strong>二维数组</strong>，或者直接初始化一个<strong>空Map</strong>。Map具有以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map(); // 空Map</span><br><span class="line">m.set(&apos;Adam&apos;, 67); // 添加新的key-value</span><br><span class="line">m.set(&apos;Bob&apos;, 59);</span><br><span class="line">m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: true</span><br><span class="line">m.get(&apos;Adam&apos;); // 67</span><br><span class="line">m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;</span><br><span class="line">m.get(&apos;Adam&apos;); // undefined</span><br></pre></td></tr></table></figure>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line">m.set(&apos;Adam&apos;, 67);</span><br><span class="line">m.set(&apos;Adam&apos;, 88);</span><br><span class="line">m.get(&apos;Adam&apos;); // 88</span><br></pre></td></tr></table></figure>
<p>Set和Map类似，也是一组key的集合，但<strong>不存储value</strong>。由于key不能重复，所以，在Set中，没有重复的key。</p>
<p>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s1 = new Set(); // 空Set</span><br><span class="line">var s2 = new Set([1, 2, 3]); // 含1, 2, 3</span><br></pre></td></tr></table></figure>
<p>通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果。</p>
<p>同样的，通过delete(key)方法可以删除元素。</p>
<h3><span id="iterable">iterable</span></h3><p>具有iterable类型的集合可以通过新的for … of循环来遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);</span><br><span class="line">var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);</span><br><span class="line">for (var x of a) &#123; // 遍历Array</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">for (var x of s) &#123; // 遍历Set</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">for (var x of m) &#123; // 遍历Map</span><br><span class="line">    console.log(x[0] + &apos;=&apos; + x[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for … in循环遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。如果手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">a.name = &apos;Hello&apos;;</span><br><span class="line">for (var x in a) &#123;</span><br><span class="line">    console.log(x); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;name&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>for … in</strong>循环将把name包括在内，但Array的length属性却不包括在内。</p>
<p><strong>for … of</strong>循环则完全修复了这些问题，它只循环<strong>集合本身的元素</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">a.name = &apos;Hello&apos;;</span><br><span class="line">for (var x of a) &#123;</span><br><span class="line">    console.log(x); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">参考链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/09/java番外-多线程编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/java番外-多线程编程/" itemprop="url">java番外-多线程编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-09T15:49:38+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#1线程与进程的异同">1.线程与进程的异同：</a></li>
<li><a href="#2线程的生命周期">2.线程的生命周期：</a><ul>
<li><a href="#新建状态">新建状态：</a></li>
<li><a href="#就绪状态">就绪状态：</a></li>
<li><a href="#运行状态">运行状态：</a></li>
<li><a href="#阻塞状态">阻塞状态：</a></li>
<li><a href="#死亡状态">死亡状态：</a></li>
</ul>
</li>
<li><a href="#3线程的优先级">3.线程的优先级：</a></li>
<li><a href="#4创建线程的三种方式">4.创建线程的三种方式：</a><ul>
<li><a href="#通过runnable接口创建线程">通过Runnable接口创建线程：</a></li>
<li><a href="#通过集成thread类来创建线程">通过集成Thread类来创建线程：</a></li>
<li><a href="#通过callable和future创建线程">通过Callable和Future创建线程：</a></li>
<li><a href="#三种方式的对比">三种方式的对比：</a></li>
</ul>
</li>
<li><a href="#线程的几个重要的概念">线程的几个重要的概念：</a></li>
</ul>
<!-- tocstop -->
<h2><span id="1线程与进程的异同">1.线程与进程的异同：</span></h2><p><strong>线程</strong>：一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p><strong>进程</strong>：一个进程包括了由操作系统分配的内存空间，包含了一个或者多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。</p>
<h2><span id="2线程的生命周期">2.线程的生命周期：</span></h2><p><img src="/2019/03/09/java番外-多线程编程/D:/hexo/source/_posts/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt=""></p>
<p><strong>相关解释：</strong></p>
<h3><span id="新建状态">新建状态：</span></h3><p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>
<h3><span id="就绪状态">就绪状态：</span></h3><p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
<h3><span id="运行状态">运行状态：</span></h3><p>如果就绪状态的线程获取 CPU 资源，就可以执行 <strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
<h3><span id="阻塞状态">阻塞状态：</span></h3><p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p>
<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li>
</ul>
<h3><span id="死亡状态">死亡状态：</span></h3><p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>
<h2><span id="3线程的优先级">3.线程的优先级：</span></h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p>
<p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p>
<p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>
<p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p>
<h2><span id="4创建线程的三种方式">4.创建线程的三种方式：</span></h2><ul>
<li>通过实现 Runnable 接口；</li>
<li>通过继承 Thread 类本身；</li>
<li>通过 Callable 和 Future 创建线程。</li>
</ul>
<h3><span id="通过runnable接口创建线程">通过Runnable接口创建线程：</span></h3><p>实现Runnable是一个类只需要执行一个方法来调用run（）即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void run（）</span><br></pre></td></tr></table></figure>
<p>该方法可以重写，要理解的是run（）可以调用其他方法，使用其他的类，并且声明变量，就像主线程一样。</p>
<p>在创建一个实现Runnable接口的类之后，可以在类中实例化一个线程对象。</p>
<p>Thread中定义了几个构造方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable threadOb,String threadName);</span><br></pre></td></tr></table></figure>
<p>这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。</p>
<p>新线程创建之后，你调用它的 start() 方法它才会运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void start（）；</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class RunnableDemo implements Runnable &#123;</span><br><span class="line">   private Thread t;</span><br><span class="line">   private String threadName;</span><br><span class="line">   </span><br><span class="line">   RunnableDemo( String name) &#123;</span><br><span class="line">      threadName = name;</span><br><span class="line">      System.out.println(&quot;Creating &quot; +  threadName );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(&quot;Running &quot; +  threadName );</span><br><span class="line">      try &#123;</span><br><span class="line">         for(int i = 4; i &gt; 0; i--) &#123;</span><br><span class="line">            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);</span><br><span class="line">            // 让线程睡眠一会</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;catch (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void start () &#123;</span><br><span class="line">      System.out.println(&quot;Starting &quot; +  threadName );</span><br><span class="line">      if (t == null) &#123;</span><br><span class="line">         t = new Thread (this, threadName);</span><br><span class="line">         t.start ();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;);</span><br><span class="line">      R1.start();</span><br><span class="line">      </span><br><span class="line">      RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;);</span><br><span class="line">      R2.start();</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Creating Thread-1</span><br><span class="line">Starting Thread-1</span><br><span class="line">Creating Thread-2</span><br><span class="line">Starting Thread-2</span><br><span class="line">Running Thread-1</span><br><span class="line">Thread: Thread-1, 4</span><br><span class="line">Running Thread-2</span><br><span class="line">Thread: Thread-2, 4</span><br><span class="line">Thread: Thread-1, 3</span><br><span class="line">Thread: Thread-2, 3</span><br><span class="line">Thread: Thread-1, 2</span><br><span class="line">Thread: Thread-2, 2</span><br><span class="line">Thread: Thread-1, 1</span><br><span class="line">Thread: Thread-2, 1</span><br><span class="line">Thread Thread-1 exiting.</span><br><span class="line">Thread Thread-2 exiting.</span><br></pre></td></tr></table></figure>
<h3><span id="通过集成thread类来创建线程">通过集成Thread类来创建线程：</span></h3><p>该方法是创建一个新的类然后让这个类继承自Thread类，然后创建一个该类的实例即可。</p>
<p>继承类的时候必须重写run（）方法，该方法是新线程的入口点，它也必须调用start方法才可以执行。本质上也是实现了Runnable接口的一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class ThreadDemo extends Thread &#123;</span><br><span class="line">   private Thread t;</span><br><span class="line">   private String threadName;</span><br><span class="line">   </span><br><span class="line">   ThreadDemo( String name) &#123;</span><br><span class="line">      threadName = name;</span><br><span class="line">      System.out.println(&quot;Creating &quot; +  threadName );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(&quot;Running &quot; +  threadName );</span><br><span class="line">      try &#123;</span><br><span class="line">         for(int i = 4; i &gt; 0; i--) &#123;</span><br><span class="line">            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);</span><br><span class="line">            // 让线程睡眠一会</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;catch (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void start () &#123;</span><br><span class="line">      System.out.println(&quot;Starting &quot; +  threadName );</span><br><span class="line">      if (t == null) &#123;</span><br><span class="line">         t = new Thread (this, threadName);</span><br><span class="line">         t.start ();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;);</span><br><span class="line">      T1.start();</span><br><span class="line">      </span><br><span class="line">      ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;);</span><br><span class="line">      T2.start();</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Creating Thread-1</span><br><span class="line">Starting Thread-1</span><br><span class="line">Creating Thread-2</span><br><span class="line">Starting Thread-2</span><br><span class="line">Running Thread-1</span><br><span class="line">Thread: Thread-1, 4</span><br><span class="line">Running Thread-2</span><br><span class="line">Thread: Thread-2, 4</span><br><span class="line">Thread: Thread-1, 3</span><br><span class="line">Thread: Thread-2, 3</span><br><span class="line">Thread: Thread-1, 2</span><br><span class="line">Thread: Thread-2, 2</span><br><span class="line">Thread: Thread-1, 1</span><br><span class="line">Thread: Thread-2, 1</span><br><span class="line">Thread Thread-1 exiting.</span><br><span class="line">Thread Thread-2 exiting.</span><br></pre></td></tr></table></figure>
<p>下表列出了Thread类的一些重要方法：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public final void setPriority(int priority)</strong>  更改线程的优先级。</td>
</tr>
<tr>
<td>5</td>
<td><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td>
</tr>
<tr>
<td>6</td>
<td><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td>
</tr>
<tr>
<td>7</td>
<td><strong>public void interrupt()</strong> 中断线程。</td>
</tr>
<tr>
<td>8</td>
<td><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td>
</tr>
</tbody>
</table>
<p>测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>public static void yield()</strong> 暂停当前正在执行的线程对象，并执行其他线程。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public static void sleep(long millisec)</strong> 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public static boolean holdsLock(Object x)</strong> 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public static Thread currentThread()</strong> 返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr>
<td>5</td>
<td><strong>public static void dumpStack()</strong> 将当前线程的堆栈跟踪打印至标准错误流。</td>
</tr>
</tbody>
</table>
<p>实例：</p>
<p>如下的ThreadClassDemo 程序演示了Thread类的一些方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 : DisplayMessage.java</span><br><span class="line">// 通过实现 Runnable 接口创建线程</span><br><span class="line">public class DisplayMessage implements Runnable &#123;</span><br><span class="line">   private String message;</span><br><span class="line">   </span><br><span class="line">   public DisplayMessage(String message) &#123;</span><br><span class="line">      this.message = message;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      while(true) &#123;</span><br><span class="line">         System.out.println(message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 : GuessANumber.java</span><br><span class="line">// 通过继承 Thread 类创建线程</span><br><span class="line"> </span><br><span class="line">public class GuessANumber extends Thread &#123;</span><br><span class="line">   private int number;</span><br><span class="line">   public GuessANumber(int number) &#123;</span><br><span class="line">      this.number = number;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      int counter = 0;</span><br><span class="line">      int guess = 0;</span><br><span class="line">      do &#123;</span><br><span class="line">         guess = (int) (Math.random() * 100 + 1);</span><br><span class="line">         System.out.println(this.getName() + &quot; guesses &quot; + guess);</span><br><span class="line">         counter++;</span><br><span class="line">      &#125; while(guess != number);</span><br><span class="line">      System.out.println(&quot;** Correct!&quot; + this.getName() + &quot;in&quot; + counter + &quot;guesses.**&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 : ThreadClassDemo.java</span><br><span class="line">public class ThreadClassDemo &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String [] args) &#123;</span><br><span class="line">      Runnable hello = new DisplayMessage(&quot;Hello&quot;);</span><br><span class="line">      Thread thread1 = new Thread(hello);</span><br><span class="line">      thread1.setDaemon(true);</span><br><span class="line">      thread1.setName(&quot;hello&quot;);</span><br><span class="line">      System.out.println(&quot;Starting hello thread...&quot;);</span><br><span class="line">      thread1.start();</span><br><span class="line">      </span><br><span class="line">      Runnable bye = new DisplayMessage(&quot;Goodbye&quot;);</span><br><span class="line">      Thread thread2 = new Thread(bye);</span><br><span class="line">      thread2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">      thread2.setDaemon(true);</span><br><span class="line">      System.out.println(&quot;Starting goodbye thread...&quot;);</span><br><span class="line">      thread2.start();</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;Starting thread3...&quot;);</span><br><span class="line">      Thread thread3 = new GuessANumber(27);</span><br><span class="line">      thread3.start();</span><br><span class="line">      try &#123;</span><br><span class="line">         thread3.join();</span><br><span class="line">      &#125;catch(InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Starting thread4...&quot;);</span><br><span class="line">      Thread thread4 = new GuessANumber(75);</span><br><span class="line">      </span><br><span class="line">      thread4.start();</span><br><span class="line">      System.out.println(&quot;main() is ending...&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Starting hello thread...</span><br><span class="line">Starting goodbye thread...</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Goodbye</span><br><span class="line">Goodbye</span><br><span class="line">Goodbye</span><br><span class="line">Goodbye</span><br><span class="line">Goodbye</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<h3><span id="通过callable和future创建线程">通过Callable和Future创建线程：</span></h3><ul>
<li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
<li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>
<li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li>
</ul>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class CallableThreadTest implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        CallableThreadTest ctt = new CallableThreadTest();  </span><br><span class="line">        FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt);  </span><br><span class="line">        for(int i = 0;i &lt; 100;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);  </span><br><span class="line">            if(i==20)  </span><br><span class="line">            &#123;  </span><br><span class="line">                new Thread(ft,&quot;有返回值的线程&quot;).start();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        try  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(&quot;子线程的返回值：&quot;+ft.get());  </span><br><span class="line">        &#125; catch (InterruptedException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (ExecutionException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    @Override  </span><br><span class="line">    public Integer call() throws Exception  </span><br><span class="line">    &#123;  </span><br><span class="line">        int i = 0;  </span><br><span class="line">        for(;i&lt;100;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="三种方式的对比">三种方式的对比：</span></h3><ul>
<li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>
</ul>
<h2><span id="线程的几个重要的概念">线程的几个重要的概念：</span></h2><p>1）线程同步。</p>
<p>2）线程间通信。</p>
<p>3）线程死锁。</p>
<p>4）线程控制，包括挂起停止与恢复。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/07/java基础-融会贯通/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/java基础-融会贯通/" itemprop="url">java基础-融会贯通</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T08:27:11+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  34
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#1继承">1.继承：</a><ul>
<li><a href="#1概念">1）概念：</a></li>
<li><a href="#2格式">2）格式：</a></li>
<li><a href="#3类型">3）类型：</a></li>
<li><a href="#4特性">4）特性：</a></li>
<li><a href="#5关键字">5）关键字：</a><ul>
<li><a href="#extends关键字">extends关键字：</a></li>
<li><a href="#implements关键字">implements关键字：</a></li>
<li><a href="#super与this关键字">super与this关键字：</a></li>
<li><a href="#final关键字">final关键字：</a></li>
<li><a href="#注意">注意：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2重写与重载">2.重写与重载：</a><ul>
<li><a href="#1重写">1）重写：</a><ul>
<li><a href="#概念">概念：</a></li>
<li><a href="#super关键字的使用">Super关键字的使用：</a></li>
</ul>
</li>
<li><a href="#2重载">2）重载：</a><ul>
<li><a href="#规则">规则：</a></li>
</ul>
</li>
<li><a href="#3重载与重写的区别">3）重载与重写的区别：</a></li>
<li><a href="#4总结">4）总结：</a></li>
</ul>
</li>
<li><a href="#3多态">3.多态：</a><ul>
<li><a href="#1概念-1">1）概念：</a></li>
<li><a href="#2表现">2）表现：</a></li>
<li><a href="#3优点">3）优点：</a></li>
<li><a href="#4执行条件">4）执行条件：</a></li>
<li><a href="#5虚函数">5）虚函数：</a></li>
<li><a href="#6实现方式">6）实现方式：</a></li>
</ul>
</li>
<li><a href="#4抽象类">4.抽象类：</a><ul>
<li><a href="#1概念-2">1）概念：</a></li>
<li><a href="#2实例">2）实例：</a></li>
<li><a href="#3继承抽象类">3）继承抽象类：</a></li>
<li><a href="#4抽象方法">4）抽象方法：</a></li>
<li><a href="#5总结">5）总结：</a></li>
</ul>
</li>
<li><a href="#5封装">5.封装：</a><ul>
<li><a href="#1概念-3">1）概念：</a></li>
<li><a href="#2优点">2）优点：</a></li>
<li><a href="#3实现步骤">3）实现步骤：</a></li>
<li><a href="#4实例">4）实例：</a></li>
</ul>
</li>
<li><a href="#6接口">6.接口：</a><ul>
<li><a href="#1概念-4">1）概念：</a></li>
<li><a href="#2接口与类的相似点">2）接口与类的相似点：</a></li>
<li><a href="#3接口与类的区别">3）接口与类的区别：</a></li>
<li><a href="#4接口特性">4）接口特性：</a></li>
<li><a href="#5抽象类与接口的区别">5）抽象类与接口的区别：</a></li>
<li><a href="#6接口的声明">6）接口的声明：</a></li>
<li><a href="#7接口的实现">7）接口的实现：</a></li>
<li><a href="#8接口的继承">8）接口的继承：</a></li>
<li><a href="#9接口的多继承">9）接口的多继承：</a></li>
<li><a href="#10标记接口">10）标记接口：</a></li>
</ul>
</li>
<li><a href="#7包">7.包：</a><ul>
<li><a href="#1作用">1）作用：</a></li>
<li><a href="#2创建包">2）创建包：</a></li>
<li><a href="#3import关键字">3）import关键字：</a></li>
<li><a href="#4package目录结构">4）package目录结构：</a></li>
<li><a href="#5设置classpath系统变量">5）设置CLASSPATH系统变量：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="1继承">1.继承：</span></h2><h3><span id="1概念">1）概念：</span></h3><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<h3><span id="2格式">2）格式：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="3类型">3）类型：</span></h3><p>注意：java不支持多继承，但是支持多重继承。</p>
<p><img src="/2019/03/07/java基础-融会贯通/多重继承.png" alt=""></p>
<h3><span id="4特性">4）特性：</span></h3><p>子类拥有父类非 private 的属性、方法。</p>
<p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p>
<p>子类可以用自己的方式实现父类的方法。</p>
<p>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</p>
<p>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</p>
<h3><span id="5关键字">5）关键字：</span></h3><p>注意：继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 <strong>java.lang.Object</strong>，当一个类没有继承的两个关键字，则默认继承object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。</p>
<h4><span id="extends关键字">extends关键字：</span></h4><p>在java中，类的继承是单一的继承，也就是说，一个类只能拥有一个父类，所以extends只能继承一个类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123; </span><br><span class="line">    private String name;   </span><br><span class="line">    private int id; </span><br><span class="line">    public Animal(String myName, String myid) &#123; </span><br><span class="line">        //初始化属性值</span><br><span class="line">    &#125; </span><br><span class="line">    public void eat() &#123;  //吃的方法的具体实现  &#125; </span><br><span class="line">    public void sleep() &#123; //睡觉的方法的具体实现  &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public class Penguin  extends  Animal&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="implements关键字">implements关键字：</span></h4><p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface A &#123;</span><br><span class="line">    public void eat();</span><br><span class="line">    public void sleep();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public interface B &#123;</span><br><span class="line">    public void show();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class C implements A,B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="super与this关键字">super与this关键字：</span></h4><p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>
<p>this关键字：指向自己的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  void eat() &#123;</span><br><span class="line">    System.out.println(&quot;animal : eat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  void eat() &#123;</span><br><span class="line">    System.out.println(&quot;dog : eat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  void eatTest() &#123;</span><br><span class="line">    this.eat();   // this 调用自己的方法</span><br><span class="line">    super.eat();  // super 调用父类方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Animal a = new Animal();</span><br><span class="line">    a.eat();</span><br><span class="line">    Dog d = new Dog();</span><br><span class="line">    d.eatTest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="final关键字">final关键字：</span></h4><p>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。</p>
<p><strong>注</strong>:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">声明类：</span><br><span class="line"></span><br><span class="line">final class 类名 &#123;//类体&#125;</span><br><span class="line">声明方法：</span><br><span class="line"></span><br><span class="line">修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;//方法体&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="注意">注意：</span></h4><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</p>
<p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p>
<h2><span id="2重写与重载">2.重写与重载：</span></h2><h3><span id="1重写">1）重写：</span></h3><h4><span id="概念">概念：</span></h4><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写，<strong>返回值和形参都不能改变</strong>。其实就是<strong>外形不变，核心重写</strong>的意思。</p>
<p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">   public void move()&#123;</span><br><span class="line">      System.out.println(&quot;动物可以移动&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">   public void move()&#123;</span><br><span class="line">      System.out.println(&quot;狗可以跑和走&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestDog&#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      Animal a = new Animal(); // Animal 对象</span><br><span class="line">      Animal b = new Dog(); // Dog 对象</span><br><span class="line"> </span><br><span class="line">      a.move();// 执行 Animal 类的方法</span><br><span class="line"> </span><br><span class="line">      b.move();//执行 Dog 类的方法</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动物可以移动</span><br><span class="line">狗可以跑和走</span><br></pre></td></tr></table></figure>
<h4><span id="super关键字的使用">Super关键字的使用：</span></h4><p>当需要在子类中调用父类的被重写方法的时候，就必须使用super关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">   public void move()&#123;</span><br><span class="line">      System.out.println(&quot;动物可以移动&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">   public void move()&#123;</span><br><span class="line">      super.move(); // 应用super类的方法</span><br><span class="line">      System.out.println(&quot;狗可以跑和走&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestDog&#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line"> </span><br><span class="line">      Animal b = new Dog(); // Dog 对象</span><br><span class="line">      b.move(); //执行 Dog类的方法</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动物可以移动</span><br><span class="line">狗可以跑和走</span><br></pre></td></tr></table></figure>
<h3><span id="2重载">2）重载：</span></h3><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
<p>最常用的地方就是构造器的重载。</p>
<h4><span id="规则">规则：</span></h4><p>被重载的方法必须改变参数列表（参数的个数或者类型不一样）。</p>
<p>被重载的方法可以改变返回类型。</p>
<p>被重载的方法可以改变访问修饰符。</p>
<p>被重载的方法可以声明新的或者更广的检查异常。</p>
<p>方法能够在同一个类中或者在一个子类中被重载。</p>
<p>无法以返回值类型作为重载函数的区分标准。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Overloading &#123;</span><br><span class="line">    public int test()&#123;</span><br><span class="line">        System.out.println(&quot;test1&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void test(int a)&#123;</span><br><span class="line">        System.out.println(&quot;test2&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    //以下两个参数类型顺序不同</span><br><span class="line">    public String test(int a,String s)&#123;</span><br><span class="line">        System.out.println(&quot;test3&quot;);</span><br><span class="line">        return &quot;returntest3&quot;;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    public String test(String s,int a)&#123;</span><br><span class="line">        System.out.println(&quot;test4&quot;);</span><br><span class="line">        return &quot;returntest4&quot;;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Overloading o = new Overloading();</span><br><span class="line">        System.out.println(o.test());</span><br><span class="line">        o.test(1);</span><br><span class="line">        System.out.println(o.test(1,&quot;test3&quot;));</span><br><span class="line">        System.out.println(o.test(&quot;test4&quot;,1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="3重载与重写的区别">3）重载与重写的区别：</span></h3><p><img src="/2019/03/07/java基础-融会贯通/区别.jpg" alt=""></p>
<h3><span id="4总结">4）总结：</span></h3><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<ul>
<li>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li>
<li>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li>
<li>(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li>
</ul>
<p><img src="/2019/03/07/java基础-融会贯通/总结.jpg" alt=""></p>
<h2><span id="3多态">3.多态：</span></h2><h3><span id="1概念">1）概念：</span></h3><p>多态就是同一个行为具有多个不同表现形式或者形态的能力。</p>
<p>（同一个接口，使用不同的实例而执行不同的操作）</p>
<h3><span id="2表现">2）表现：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">现实中，比如我们按下 F1 键这个动作：</span><br><span class="line"></span><br><span class="line">如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；</span><br><span class="line">如果当前在 Word 下弹出的就是 Word 帮助；</span><br><span class="line">在 Windows 下弹出的就是 Windows 帮助和支持。</span><br><span class="line"></span><br><span class="line">同一个事件发生在不同的对象上会产生不同的结果。</span><br></pre></td></tr></table></figure>
<h3><span id="3优点">3）优点：</span></h3><ul>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ul>
<h3><span id="4执行条件">4）执行条件：</span></h3><ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent p = new Child();</span><br></pre></td></tr></table></figure>
<p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p>
<p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      show(new Cat());  // 以 Cat 对象调用 show 方法</span><br><span class="line">      show(new Dog());  // 以 Dog 对象调用 show 方法</span><br><span class="line">                </span><br><span class="line">      Animal a = new Cat();  // 向上转型  </span><br><span class="line">      a.eat();               // 调用的是 Cat 的 eat</span><br><span class="line">      Cat c = (Cat)a;        // 向下转型  </span><br><span class="line">      c.work();        // 调用的是 Cat 的 work</span><br><span class="line">  &#125;  </span><br><span class="line">            </span><br><span class="line">    public static void show(Animal a)  &#123;</span><br><span class="line">      a.eat();  </span><br><span class="line">        // 类型判断</span><br><span class="line">        if (a instanceof Cat)  &#123;  // 猫做的事</span><br><span class="line">            Cat c = (Cat)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125; else if (a instanceof Dog) &#123; // 狗做的事</span><br><span class="line">            Dog c = (Dog)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">abstract class Animal &#123;  </span><br><span class="line">    abstract void eat();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Cat extends Animal &#123;  </span><br><span class="line">    public void eat() &#123;  </span><br><span class="line">        System.out.println(&quot;吃鱼&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void work() &#123;  </span><br><span class="line">        System.out.println(&quot;抓老鼠&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Dog extends Animal &#123;  </span><br><span class="line">    public void eat() &#123;  </span><br><span class="line">        System.out.println(&quot;吃骨头&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void work() &#123;  </span><br><span class="line">        System.out.println(&quot;看家&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">吃鱼</span><br><span class="line">抓老鼠</span><br><span class="line">吃骨头</span><br><span class="line">看家</span><br><span class="line">吃鱼</span><br><span class="line">抓老鼠</span><br></pre></td></tr></table></figure>
<h3><span id="5虚函数">5）虚函数：</span></h3><p><strong>虚函数的存在是为了多态</strong>。</p>
<p>Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p>
<h3><span id="6实现方式">6）实现方式：</span></h3><p>三种方式，包括：<strong>重写，接口，抽象类和抽象方法</strong>。</p>
<h2><span id="4抽象类">4.抽象类：</span></h2><h3><span id="1概念">1）概念：</span></h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<h3><span id="2实例">2）实例：</span></h3><p>在java中使用abstract class来定义抽象类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : Employee.java */</span><br><span class="line">public abstract class Employee</span><br><span class="line">&#123;</span><br><span class="line">   private String name;</span><br><span class="line">   private String address;</span><br><span class="line">   private int number;</span><br><span class="line">   public Employee(String name, String address, int number)</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(&quot;Constructing an Employee&quot;);</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.address = address;</span><br><span class="line">      this.number = number;</span><br><span class="line">   &#125;</span><br><span class="line">   public double computePay()</span><br><span class="line">   &#123;</span><br><span class="line">     System.out.println(&quot;Inside Employee computePay&quot;);</span><br><span class="line">     return 0.0;</span><br><span class="line">   &#125;</span><br><span class="line">   public void mailCheck()</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(&quot;Mailing a check to &quot; + this.name</span><br><span class="line">       + &quot; &quot; + this.address);</span><br><span class="line">   &#125;</span><br><span class="line">   public String toString()</span><br><span class="line">   &#123;</span><br><span class="line">      return name + &quot; &quot; + address + &quot; &quot; + number;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getName()</span><br><span class="line">   &#123;</span><br><span class="line">      return name;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getAddress()</span><br><span class="line">   &#123;</span><br><span class="line">      return address;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setAddress(String newAddress)</span><br><span class="line">   &#123;</span><br><span class="line">      address = newAddress;</span><br><span class="line">   &#125;</span><br><span class="line">   public int getNumber()</span><br><span class="line">   &#123;</span><br><span class="line">     return number;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果尝试以下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : AbstractDemo.java */</span><br><span class="line">public class AbstractDemo</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String [] args)</span><br><span class="line">   &#123;</span><br><span class="line">      /* 以下是不允许的，会引发错误 */</span><br><span class="line">      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;);</span><br><span class="line">      e.mailCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时会显示以下的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee.java:46: Employee is abstract; cannot be instantiated</span><br><span class="line">      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);</span><br><span class="line">                   ^</span><br><span class="line">1 error</span><br></pre></td></tr></table></figure>
<h3><span id="3继承抽象类">3）继承抽象类：</span></h3><p>可以通过一般的方法直接继承Employee类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : Salary.java */</span><br><span class="line">public class Salary extends Employee</span><br><span class="line">&#123;</span><br><span class="line">   private double salary; //Annual salary</span><br><span class="line">   public Salary(String name, String address, int number, double</span><br><span class="line">      salary)</span><br><span class="line">   &#123;</span><br><span class="line">       super(name, address, number);</span><br><span class="line">       setSalary(salary);</span><br><span class="line">   &#125;</span><br><span class="line">   public void mailCheck()</span><br><span class="line">   &#123;</span><br><span class="line">       System.out.println(&quot;Within mailCheck of Salary class &quot;);</span><br><span class="line">       System.out.println(&quot;Mailing check to &quot; + getName()</span><br><span class="line">       + &quot; with salary &quot; + salary);</span><br><span class="line">   &#125;</span><br><span class="line">   public double getSalary()</span><br><span class="line">   &#123;</span><br><span class="line">       return salary;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setSalary(double newSalary)</span><br><span class="line">   &#123;</span><br><span class="line">       if(newSalary &gt;= 0.0)</span><br><span class="line">       &#123;</span><br><span class="line">          salary = newSalary;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public double computePay()</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(&quot;Computing salary pay for &quot; + getName());</span><br><span class="line">      return salary/52;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : AbstractDemo.java */</span><br><span class="line">public class AbstractDemo</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String [] args)</span><br><span class="line">   &#123;</span><br><span class="line">      Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00);</span><br><span class="line">      Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00);</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;Call mailCheck using Salary reference --&quot;);</span><br><span class="line">      s.mailCheck();</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;);</span><br><span class="line">      e.mailCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Constructing an Employee</span><br><span class="line">Constructing an Employee</span><br><span class="line">Call mailCheck using  Salary reference --</span><br><span class="line">Within mailCheck of Salary class</span><br><span class="line">Mailing check to Mohd Mohtashim with salary 3600.0</span><br><span class="line"></span><br><span class="line">Call mailCheck using Employee reference--</span><br><span class="line">Within mailCheck of Salary class</span><br><span class="line">Mailing check to John Adams with salary 2400.</span><br></pre></td></tr></table></figure>
<h3><span id="4抽象方法">4）抽象方法：</span></h3><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Employee</span><br><span class="line">&#123;</span><br><span class="line">   private String name;</span><br><span class="line">   private String address;</span><br><span class="line">   private int number;</span><br><span class="line">   </span><br><span class="line">   public abstract double computePay();</span><br><span class="line">   </span><br><span class="line">   //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>如果一个类包含抽象方法，那么该类必须是抽象类。</li>
<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li>
</ul>
<p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p>
<p>如果Salary类继承了Employee类，那么它必须实现computePay()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : Salary.java */</span><br><span class="line">public class Salary extends Employee</span><br><span class="line">&#123;</span><br><span class="line">   private double salary; // Annual salary</span><br><span class="line">  </span><br><span class="line">   public double computePay()</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(&quot;Computing salary pay for &quot; + getName());</span><br><span class="line">      return salary/52;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="5总结">5）总结：</span></h3><ul>
<li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
</ul>
<h2><span id="5封装">5.封装：</span></h2><h3><span id="1概念">1）概念：</span></h3><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<h3><span id="2优点">2）优点：</span></h3><ul>
<li>良好的封装能够减少耦合。</li>
<li>类内部的结构可以自由修改。</li>
<li>可以对成员变量进行更精确的控制。</li>
<li>隐藏信息，实现细节。</li>
</ul>
<h3><span id="3实现步骤">3）实现步骤：</span></h3><p>修改属性的可见性来限制属性的访问（一般限制为private），例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，将 <strong>name</strong> 和 <strong>age</strong> 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p>
<p> 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">​</span><br><span class="line">    public int getAge()&#123;</span><br><span class="line">      return age;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">      return name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    public void setAge(int age)&#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以采用this关键字是为了解决实例变量和局部变量之间发生的同名冲突。</p>
<h3><span id="4实例">4）实例：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名: EncapTest.java */</span><br><span class="line">public class EncapTest&#123;</span><br><span class="line"> </span><br><span class="line">   private String name;</span><br><span class="line">   private String idNum;</span><br><span class="line">   private int age;</span><br><span class="line"> </span><br><span class="line">   public int getAge()&#123;</span><br><span class="line">      return age;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getName()&#123;</span><br><span class="line">      return name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getIdNum()&#123;</span><br><span class="line">      return idNum;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setAge( int newAge)&#123;</span><br><span class="line">      age = newAge;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setName(String newName)&#123;</span><br><span class="line">      name = newName;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setIdNum( String newId)&#123;</span><br><span class="line">      idNum = newId;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例中public方法是外部类访问该类成员变量的入口。</p>
<p>通常情况下，这些方法被称为getter和setter方法。</p>
<p>因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。</p>
<p>通过如下的例子说明EncapTest类的变量怎样被访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* F文件名 : RunEncap.java */</span><br><span class="line">public class RunEncap&#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      EncapTest encap = new EncapTest();</span><br><span class="line">      encap.setName(&quot;James&quot;);</span><br><span class="line">      encap.setAge(20);</span><br><span class="line">      encap.setIdNum(&quot;12343ms&quot;);</span><br><span class="line"> </span><br><span class="line">      System.out.print(&quot;Name : &quot; + encap.getName()+ </span><br><span class="line">                             &quot; Age : &quot;+ encap.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name : James Age : 20</span><br></pre></td></tr></table></figure>
<h2><span id="6接口">6.接口：</span></h2><h3><span id="1概念">1）概念：</span></h3><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<h3><span id="2接口与类的相似点">2）接口与类的相似点：</span></h3><ul>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li>
<li>接口的字节码文件保存在 .class 结尾的文件中。</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ul>
<h3><span id="3接口与类的区别">3）接口与类的区别：</span></h3><ul>
<li>接口不能用于实例化对象。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
</ul>
<h3><span id="4接口特性">4）接口特性：</span></h3><ul>
<li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li>
</ul>
<h3><span id="5抽象类与接口的区别">5）抽象类与接口的区别：</span></h3><ul>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<h3><span id="6接口的声明">6）接口的声明：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名名] &#123;</span><br><span class="line">        // 声明变量</span><br><span class="line">        // 抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interface关键字用来声明一个接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : NameOfInterface.java */</span><br><span class="line">import java.lang.*;</span><br><span class="line">//引入包</span><br><span class="line"> </span><br><span class="line">public interface NameOfInterface</span><br><span class="line">&#123;</span><br><span class="line">   //任何类型 final, static 字段</span><br><span class="line">   //抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口有如下特性：</p>
<ul>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong>abstract</strong>关键字。</li>
<li>接口中的方法都是公有的。</li>
</ul>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : Animal.java */</span><br><span class="line">interface Animal &#123;</span><br><span class="line">   public void eat();</span><br><span class="line">   public void travel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="7接口的实现">7）接口的实现：</span></h3><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p>
<p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。</p>
<p>实现一个接口的语法，可以使用这个公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : MammalInt.java */</span><br><span class="line">public class MammalInt implements Animal&#123;</span><br><span class="line"> </span><br><span class="line">   public void eat()&#123;</span><br><span class="line">      System.out.println(&quot;Mammal eats&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void travel()&#123;</span><br><span class="line">      System.out.println(&quot;Mammal travels&quot;);</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public int noOfLegs()&#123;</span><br><span class="line">      return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      MammalInt m = new MammalInt();</span><br><span class="line">      m.eat();</span><br><span class="line">      m.travel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mammal eats</span><br><span class="line">Mammal travels</span><br></pre></td></tr></table></figure>
<p>重写接口中声明的方法时，需要注意以下规则：</p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li>
<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li>
</ul>
<p>在实现接口的时候，也要注意一些规则：</p>
<ul>
<li>一个类可以同时实现多个接口。</li>
<li>一个类只能继承一个类，但是能实现多个接口。</li>
<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>
</ul>
<h3><span id="8接口的继承">8）接口的继承：</span></h3><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p>
<p>下面的Sports接口被Hockey和Football接口继承：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 文件名: Sports.java</span><br><span class="line">public interface Sports</span><br><span class="line">&#123;</span><br><span class="line">   public void setHomeTeam(String name);</span><br><span class="line">   public void setVisitingTeam(String name);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 文件名: Football.java</span><br><span class="line">public interface Football extends Sports</span><br><span class="line">&#123;</span><br><span class="line">   public void homeTeamScored(int points);</span><br><span class="line">   public void visitingTeamScored(int points);</span><br><span class="line">   public void endOfQuarter(int quarter);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 文件名: Hockey.java</span><br><span class="line">public interface Hockey extends Sports</span><br><span class="line">&#123;</span><br><span class="line">   public void homeGoalScored();</span><br><span class="line">   public void visitingGoalScored();</span><br><span class="line">   public void endOfPeriod(int period);</span><br><span class="line">   public void overtimePeriod(int ot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。</p>
<p>相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。</p>
<h3><span id="9接口的多继承">9）接口的多继承：</span></h3><p>在Java中，类的多继承是不合法，但接口允许多继承。</p>
<p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface Hockey extends Sports, Event</span><br></pre></td></tr></table></figure>
<p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法。</p>
<h3><span id="10标记接口">10）标记接口：</span></h3><p>最常用的继承接口是没有包含任何方法的接口。</p>
<p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p>
<p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package java.util;</span><br><span class="line">public interface EventListener</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>
<ul>
<li><p>建立一个公共的父接口：</p>
<p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</li>
<li><p>向一个类添加数据类型：</p>
<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>
</li>
</ul>
<h2><span id="7包">7.包：</span></h2><p>为了更好的组织类，包就产生了，主要是用来区别类名的命名空间。</p>
<h3><span id="1作用">1）作用：</span></h3><ul>
<li>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>
<li>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>
<li>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ul>
<p>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。</p>
<p>包语句的语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package pkg1[．pkg2[．pkg3…]];</span><br></pre></td></tr></table></figure>
<p>例如,一个Something.java 文件它的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package net.java.util;</span><br><span class="line">public class Something&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么它的路径应该是 <strong>net/java/util/Something.java</strong> 这样保存的。 package(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。</p>
<p>一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。</p>
<p>以下是一些 Java 中的包：</p>
<ul>
<li><strong>java.lang</strong>-打包基础的类</li>
<li><strong>java.io</strong>-包含输入输出功能的函数</li>
</ul>
<p>开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。</p>
<p>由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。</p>
<h3><span id="2创建包">2）创建包：</span></h3><p>创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。</p>
<p>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。</p>
<p>如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。</p>
<p>例子：</p>
<p>让我们来看一个例子，这个例子创建了一个叫做animals的包。通常使用小写的字母来命名避免与类、接口名字的冲突。</p>
<p>在 animals 包中加入一个接口（interface）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名: Animal.java */</span><br><span class="line">package animals;</span><br><span class="line"> </span><br><span class="line">interface Animal &#123;</span><br><span class="line">   public void eat();</span><br><span class="line">   public void travel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在同一个包中加入该接口的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package animals;</span><br><span class="line"> </span><br><span class="line">/* 文件名 : MammalInt.java */</span><br><span class="line">public class MammalInt implements Animal&#123;</span><br><span class="line"> </span><br><span class="line">   public void eat()&#123;</span><br><span class="line">      System.out.println(&quot;Mammal eats&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void travel()&#123;</span><br><span class="line">      System.out.println(&quot;Mammal travels&quot;);</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public int noOfLegs()&#123;</span><br><span class="line">      return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      MammalInt m = new MammalInt();</span><br><span class="line">      m.eat();</span><br><span class="line">      m.travel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，编译这两个文件，并把他们放在一个叫做animals的子目录中。 用下面的命令来运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir animals</span><br><span class="line">$ cp Animal.class  MammalInt.class animals</span><br><span class="line">$ java animals/MammalInt</span><br><span class="line">Mammal eats</span><br><span class="line">Mammal travel</span><br></pre></td></tr></table></figure>
<h3><span id="3import关键字">3）import关键字：</span></h3><p>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。</p>
<p>在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import package1[.package2…].(classname|*);</span><br></pre></td></tr></table></figure>
<p>如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。</p>
<p>例子：</p>
<p>下面的 payroll 包已经包含了 Employee 类，接下来向 payroll 包中添加一个 Boss 类。Boss 类引用 Employee 类的时候可以不用使用 payroll 前缀，Boss类的实例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package payroll;</span><br><span class="line"> </span><br><span class="line">public class Boss</span><br><span class="line">&#123;</span><br><span class="line">   public void payEmployee(Employee e)</span><br><span class="line">   &#123;</span><br><span class="line">      e.mailCheck();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Boss 类不在 payroll 包中又会怎样？Boss 类必须使用下面几种方法之一来引用其他包中的类。</p>
<p>使用类全名描述，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payroll.Employee</span><br></pre></td></tr></table></figure>
<p>用 <strong>import</strong> 关键字引入，使用通配符 “*”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import payroll.*;</span><br></pre></td></tr></table></figure>
<p>使用 <strong>import</strong> 关键字引入 Employee 类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import payroll.Employee;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。</p>
<h3><span id="4package目录结构">4）package目录结构：</span></h3><p>类放在包中会有两种主要的结果：</p>
<ul>
<li>包名成为类名的一部分，正如我们前面讨论的一样。</li>
<li>包名必须与相应的字节码所在的目录结构相吻合。</li>
</ul>
<p>下面是管理你自己 java 中文件的一种简单方式：</p>
<p>将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 :  Car.java</span><br><span class="line"> </span><br><span class="line">package vehicle;</span><br><span class="line"> </span><br><span class="line">public class Car &#123;</span><br><span class="line">   // 类实现  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....\vehicle\Car.java</span><br></pre></td></tr></table></figure>
<p>现在，正确的类名和路径将会是如下样子：</p>
<ul>
<li>类名 -&gt; vehicle.Car</li>
<li>路径名 -&gt; vehicle\Car.java (在 windows 系统中)</li>
</ul>
<p>通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。</p>
<p>例如：有一个 <strong>com.runoob.test</strong> 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....\com\runoob\test\Runoob.java</span><br></pre></td></tr></table></figure>
<p>编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 文件名: Runoob.java</span><br><span class="line"> </span><br><span class="line">package com.runoob.test;</span><br><span class="line">public class Runoob &#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">class Google &#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们用-d选项来编译这个文件，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$javac -d . Runoob.java</span><br></pre></td></tr></table></figure>
<p>这样会像下面这样放置编译了的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.\com\runoob\test\Runoob.class</span><br><span class="line">.\com\runoob\test\Google.class</span><br></pre></td></tr></table></figure>
<p>你可以像下面这样来导入所有 <strong>\com\runoob\test\</strong> 中定义的类、接口等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import com.runoob.test.*;</span><br></pre></td></tr></table></figure>
<p>编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;path-one&gt;\sources\com\runoob\test\Runoob.java</span><br><span class="line">&lt;path-two&gt;\classes\com\runoob\test\Google.class</span><br></pre></td></tr></table></figure>
<p>这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。</p>
<p>类目录的绝对路径叫做 <strong>class path</strong>。设置在系统变量 <strong>CLASSPATH</strong> 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。</p>
<p>一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。</p>
<h3><span id="5设置classpath系统变量">5）设置CLASSPATH系统变量：</span></h3><p>用下面的命令显示当前的CLASSPATH变量：</p>
<ul>
<li>Windows 平台（DOS 命令行下）：C:> set CLASSPATH</li>
<li>UNIX 平台（Bourne shell 下）：# echo $CLASSPATH</li>
</ul>
<p>删除当前CLASSPATH变量内容：</p>
<ul>
<li>Windows 平台（DOS 命令行下）：C:> set CLASSPATH=</li>
<li>UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH</li>
</ul>
<p>设置CLASSPATH变量:</p>
<ul>
<li>Windows 平台（DOS 命令行下）： C:> set CLASSPATH=C:\users\jack\java\classes</li>
<li>UNIX 平台（Bourne shell 下）：# CLASSPATH=/home/jack/java/classes; export CLASSPATH</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/04/C-中STL用法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/04/C-中STL用法/" itemprop="url">C++中STL用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-04T20:47:42+08:00">
                2019-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#11stl的含义">1.1STL的含义：</a></li>
<li><a href="#12stl六大组件">1.2STL六大组件：</a></li>
<li><a href="#13容器">1.3容器：</a></li>
<li><a href="#14stl迭代器">1.4STL迭代器：</a></li>
<li><a href="#15算法">1.5算法：</a><ul>
<li><a href="#一查找算法13个判断容器中是否包含某个值">&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值</a></li>
<li><a href="#二排序和通用算法14个提供元素排序策略">&lt;二&gt;排序和通用算法(14个)：提供元素排序策略</a></li>
<li><a href="#三删除和替换算法15个">&lt;三&gt;删除和替换算法(15个)</a></li>
<li><a href="#四排列组合算法2个提供计算给定集合按一定顺序的所有可能排列组合">&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合</a></li>
<li><a href="#五算术算法4个">&lt;五&gt;算术算法(4个)</a></li>
<li><a href="#六生成和异变算法6个">&lt;六&gt;生成和异变算法(6个)</a></li>
<li><a href="#七关系算法8个">&lt;七&gt;关系算法(8个)</a></li>
<li><a href="#八集合算法4个">&lt;八&gt;集合算法(4个)</a></li>
<li><a href="#九堆算法4个">&lt;九&gt;堆算法(4个)</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="11stl的含义">1.1STL的含义：</span></h2><p>STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。</p>
<p>STL的一个重要的特点就是数据结构和算法的分离。例如：由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组。</p>
<p>STL另外的一个特点就是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。</p>
<h2><span id="12stl六大组件">1.2STL六大组件：</span></h2><p>1）容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；</p>
<p>2）迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；</p>
<p>3）算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；</p>
<p>4）仿函数（Function object）</p>
<p>5）迭代适配器（Adaptor）</p>
<p>6）空间配制器（allocator）</p>
<h2><span id="13容器">1.3容器：</span></h2><p>STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。<br>　　（1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；<br>Vectors：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；<br>Deques：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；<br>Lists：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；<br>    （2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap；<br>Sets/Multisets：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；<br>Maps/Multimaps：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找；</p>
<p>容器类自动申请和释放内存，无需new和delete操作。vector基于模板实现，需包含头文件vector。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//1.定义和初始化</span><br><span class="line">    vector&lt;int&gt; vec1;    //默认初始化，vec1为空</span><br><span class="line">    vector&lt;int&gt; vec2(vec1);  //使用vec1初始化vec2</span><br><span class="line">    vector&lt;int&gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2</span><br><span class="line">    vector&lt;int&gt; vec4(10);    //10个值为的元素</span><br><span class="line">    vector&lt;int&gt; vec5(10,4);  //10个值为的元素</span><br><span class="line">//2.常用操作方法</span><br><span class="line">    vec1.push_back(100);            //添加元素</span><br><span class="line">    int size = vec1.size();         //元素个数</span><br><span class="line">    bool isEmpty = vec1.empty();    //判断是否为空</span><br><span class="line">    cout&lt;&lt;vec1[0]&lt;&lt;endl;        //取得第一个元素</span><br><span class="line">    vec1.insert(vec1.end(),5,3);    //从vec1.back位置插入个值为的元素</span><br><span class="line">    vec1.pop_back();              //删除末尾元素</span><br><span class="line">    vec1.erase(vec1.begin(),vec1.end());//删除之间的元素，其他元素前移</span><br><span class="line">    cout&lt;&lt;(vec1==vec2)?true:false;  //判断是否相等==、！=、&gt;=、&lt;=...</span><br><span class="line">    vector&lt;int&gt;::iterator iter = vec1.begin();    //获取迭代器首地址</span><br><span class="line">    vec1.clear();                 //清空元素</span><br><span class="line">//3.遍历</span><br><span class="line">    //下标法</span><br><span class="line">    int length = vec1.size();</span><br><span class="line">    for(int i=0;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;vec1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    //迭代器法</span><br><span class="line">    vector&lt;int&gt;::const_iterator iterator = vec1.begin();</span><br><span class="line">    for(;iterator != vec1.end();iterator++)</span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;*iterator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2><span id="14stl迭代器">1.4STL迭代器：</span></h2><p>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p>迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator,实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    v.push_back(3);  //数组尾部插入3</span><br><span class="line">    v.push_back(2);</span><br><span class="line">    v.push_back(1);</span><br><span class="line">    v.push_back(0);</span><br><span class="line">    cout &lt;&lt; &quot; 下标 &quot; &lt;&lt; v[3] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot; 迭代器 &quot; &lt;&lt; endl;</span><br><span class="line">    for(vector&lt;int&gt;::iterator i = v.begin();i!= v.end();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    //在第一个元素之前插入111  insert begin+n是在第n个元素之前插入</span><br><span class="line">    v.insert(v.begin(),111);</span><br><span class="line">    //在最后一个元素之后插入222 insert end + n 是在n个元素之后插入</span><br><span class="line">    v.insert(v.end(),222);</span><br><span class="line">    for(vector&lt;int&gt;::iterator i = v.begin();i!= v.end();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    vector&lt;int&gt; arr(10);</span><br><span class="line">    for(int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    //删除 同insert</span><br><span class="line">    arr.erase(arr.begin());</span><br><span class="line">    for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i)</span><br><span class="line">     &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot; ;</span><br><span class="line">     &#125;</span><br><span class="line">    cout &lt;&lt; endl ;</span><br><span class="line">    arr.erase(arr.begin(),arr.begin()+5);</span><br><span class="line">    for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl ;</span><br><span class="line">    return 0 ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>数组转置：</p>
<p> reverse(v.begin(),v.end())</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    for(int i = 0; i &lt; 10; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    reverse(v.begin(),v.end());</span><br><span class="line">    for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="15算法">1.5算法：</span></h2><p>算法部分主要由头文件<strong>algorithm</strong>，<strong>numeric</strong>和<strong>functional</strong>组成。<br>    <strong>algorithm</strong>是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<br>    <strong>numeric</strong>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<br>    <strong>functional</strong>中则定义了一些模板类，用以声明函数对象。<br>STL中算法大致分为四类：<br>    1）非可变序列算法：指不直接修改其所操作的容器内容的算法。</p>
<p>2）可变序列算法：指可以修改它们所操作的容器内容的算法。</p>
<p>3）排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。</p>
<p>4）数值算法：对容器内容进行数值计算。</p>
<h3><span id="lt一gt查找算法13个判断容器中是否包含某个值">&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值</span></h3><p>adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。<br>    binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。<br>    count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。<br>    count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。<br>    equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示                upper_bound。<br>    find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。<br>    find_end: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代替等于操作。<br>    find_first_of: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。<br>    find_if: 使用输入的函数代替等于操作符执行find。<br>    lower_bound: 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。<br>    upper_bound: 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。<br>    search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。<br>    search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。</p>
<h3><span id="lt二gt排序和通用算法14个提供元素排序策略">&lt;二&gt;排序和通用算法(14个)：提供元素排序策略</span></h3><p>inplace_merge: 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。<br>    merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。<br>    nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。<br>    partial_sort: 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。<br>    partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。<br>    partition: 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。<br>    random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。<br>    reverse: 将指定范围内元素重新反序排序。<br>    reverse_copy: 与reverse类似，不过将结果写入另一个容器。<br>    rotate: 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。<br>    rotate_copy: 与rotate类似，不过将结果写入另一个容器。<br>    sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。<br>    stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。<br>    stable_partition: 与partition类似，不过不保证保留容器中的相对顺序。</p>
<h3><span id="lt三gt删除和替换算法15个">&lt;三&gt;删除和替换算法(15个)</span></h3><p>copy: 复制序列<br>    copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。<br>    iter_swap: 交换两个ForwardIterator的值。<br>    remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。<br>    remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。<br>    remove_if: 删除指定范围内输入操作结果为true的所有元素。<br>    remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。<br>    replace: 将指定范围内所有等于vold的元素都用vnew代替。<br>    replace_copy: 与replace类似，不过将结果写入另一个容器。<br>    replace_if: 将指定范围内所有操作结果为true的元素用新值代替。<br>    replace_copy_if: 与replace_if，不过将结果写入另一个容器。<br>    swap: 交换存储在两个对象中的值。<br>    swap_range: 将指定范围内的元素与另一个序列元素值进行交换。<br>    unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。<br>    unique_copy: 与unique类似，不过把结果输出到另一个容器。</p>
<h3><span id="lt四gt排列组合算法2个提供计算给定集合按一定顺序的所有可能排列组合">&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合</span></h3><p>next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。<br>    prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。</p>
<h3><span id="lt五gt算术算法4个">&lt;五&gt;算术算法(4个)</span></h3><p>accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。<br>    partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。<br>    inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。<br>    adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。</p>
<h3><span id="lt六gt生成和异变算法6个">&lt;六&gt;生成和异变算法(6个)</span></h3><p>fill: 将输入值赋给标志范围内的所有元素。<br>    fill_n: 将输入值赋给first到first+n范围内的所有元素。<br>    for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。<br>    generate: 连续调用输入的函数来填充指定的范围。<br>    generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。<br>    transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。</p>
<h3><span id="lt七gt关系算法8个">&lt;七&gt;关系算法(8个)</span></h3><p>equal: 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。<br>    includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。<br>    lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。<br>    max: 返回两个元素中较大一个。重载版本使用自定义比较操作。<br>    max_element: 返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。<br>    min: 返回两个元素中较小一个。重载版本使用自定义比较操作。<br>    min_element: 返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。<br>    mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。</p>
<h3><span id="lt八gt集合算法4个">&lt;八&gt;集合算法(4个)</span></h3><p>set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。<br>    set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。<br>    set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。<br>    set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。</p>
<h3><span id="lt九gt堆算法4个">&lt;九&gt;堆算法(4个)</span></h3><p>make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。<br>    pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。<br>    push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。<br>    sort_heap: 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。</p>
<p>……</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/zhangguoron.jpg" alt="THBELIEF">
            
              <p class="site-author-name" itemprop="name">THBELIEF</p>
              <p class="site-description motion-element" itemprop="description">我这个人只是英俊 潇洒了些许~</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">99</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">153</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/thbelief" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2465749045@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/thbelief" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">THBELIEF</span>

  
</div>


  <!--<div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>
-->



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共128.3k字</span>
</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":125,"height":150},"mobile":{"show":false},"log":false,"tagMode":false});</script></body>
</html>
