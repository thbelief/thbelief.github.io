<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="我这个人只是英俊 潇洒了些许~">
<meta property="og:type" content="website">
<meta property="og:title" content="THBELIEF">
<meta property="og:url" content="http://thbelief.coding.me/page/6/index.html">
<meta property="og:site_name" content="THBELIEF">
<meta property="og:description" content="我这个人只是英俊 潇洒了些许~">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="THBELIEF">
<meta name="twitter:description" content="我这个人只是英俊 潇洒了些许~">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://thbelief.coding.me/page/6/">





  <title>THBELIEF</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">THBELIEF</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Thbelief's blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/18/JavaScript学习笔记-一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/18/JavaScript学习笔记-一/" itemprop="url">JavaScript学习笔记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T21:06:35+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#入门">入门</a><ul>
<li><a href="#基本语法">基本语法</a></li>
<li><a href="#数据类型">数据类型</a><ul>
<li><a href="#number">Number</a></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#布尔值">布尔值</a></li>
<li><a href="#比较运算符">比较运算符</a></li>
<li><a href="#null和undefined">null和undefined</a></li>
<li><a href="#数组">数组</a></li>
<li><a href="#对象">对象</a></li>
<li><a href="#变量">变量</a></li>
<li><a href="#strict模式">strict模式</a></li>
</ul>
</li>
<li><a href="#字符串-1">字符串</a></li>
<li><a href="#数组-1">数组</a><ul>
<li><a href="#length">length</a></li>
<li><a href="#indexof">indexOf</a></li>
<li><a href="#slice">slice</a></li>
<li><a href="#push和pop">push和pop</a></li>
<li><a href="#unshift和shift">unshift和shift</a></li>
<li><a href="#sort">sort</a></li>
<li><a href="#reverse">reverse</a></li>
<li><a href="#splice">splice</a></li>
<li><a href="#concat">concat</a></li>
<li><a href="#join">join</a></li>
<li><a href="#多维数组">多维数组</a></li>
</ul>
</li>
<li><a href="#对象-1">对象</a></li>
<li><a href="#条件判断">条件判断</a></li>
<li><a href="#循环">循环</a><ul>
<li><a href="#forin">for…in</a></li>
<li><a href="#while">while</a></li>
<li><a href="#do-while">do while</a></li>
</ul>
</li>
<li><a href="#map和set">Map和Set</a></li>
<li><a href="#iterable">iterable</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="入门">入门</span></h2><h3><span id="基本语法">基本语法</span></h3><p>每个语句以<code>;</code>结束，语句块用<code>{...}</code>。但是，JavaScript并不强制要求在每个语句的结尾加<code>;</code>，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上<code>;</code>。</p>
<h3><span id="数据类型">数据类型</span></h3><h4><span id="number">Number</span></h4><p>JS里面不区分整数和浮点数，都是用Number统一表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123; // 整数123</span><br><span class="line">0.456; // 浮点数0.456</span><br><span class="line">1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5</span><br><span class="line">-99; // 负数</span><br><span class="line">NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示</span><br><span class="line">Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span><br></pre></td></tr></table></figure>
<h4><span id="字符串">字符串</span></h4><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分。</p>
<h4><span id="布尔值">布尔值</span></h4><p>只表示true或者false。和C++与Java中完全类似，这里不过多赘述。</p>
<h4><span id="比较运算符">比较运算符</span></h4><p>注意，JavaScript允许对任意数据类型做比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false == 0; // true</span><br><span class="line">false === 0; // false</span><br></pre></td></tr></table></figure>
<p>特别要注意上述两种格式。</p>
<p>第一种是<code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</p>
<p>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</p>
<p>这是JS自身设计的缺陷，大佬们都是推荐的是<em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</p>
<p>还要注意一点是，NaN这个特殊的Number与所有值都不相等，包括它自己。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN === NaN; // false</span><br></pre></td></tr></table></figure>
<p>唯一能够判断NaN的方法就是isNaN()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN); // true</span><br></pre></td></tr></table></figure>
<p>最后，浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true</span><br></pre></td></tr></table></figure>
<h4><span id="null和undefined">null和undefined</span></h4><p>null表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。</p>
<p>JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用<strong>null</strong>。undefined仅仅在判断函数参数是否传递的情况下有用。</p>
<h4><span id="数组">数组</span></h4><p>数组是一组按<strong>顺序</strong>排列的集合，集合的每个值称为元素。JavaScript的数组可以包括<strong>任意数据类型</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3.14, &apos;HelloWorld&apos;, null, true];</span><br></pre></td></tr></table></figure>
<p>创建数组的另一个方法是Array()函数来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Array(1, 2, 3); // 创建了数组[1, 2, 3]</span><br></pre></td></tr></table></figure>
<h4><span id="对象">对象</span></h4><p>JavaScript的对象是一组由键-值组成的无序集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;thbeleif&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    tags: [&apos;js&apos;, &apos;web&apos;, &apos;mobile&apos;],</span><br><span class="line">    city: &apos;mianyang&apos;,</span><br><span class="line">    hasCar: false,</span><br><span class="line">    zipcode: null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性。</p>
<p>要获取一个对象的属性，需要用对象变量.属性名的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.name; // &apos;thbelief&apos;</span><br><span class="line">person.zipcode; // null</span><br></pre></td></tr></table></figure>
<h4><span id="变量">变量</span></h4><p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且<strong>不能用数字开头</strong>。变量名也不能是JavaScript的关键字，如if、while等。</p>
<p>在Chrome浏览器里面使用JS的时候，可以直接使用<strong>console.log(x)</strong>来打印变量的值。</p>
<p>相比较于alert()的对话框，前者看起来无疑是更舒心的。</p>
<h4><span id="strict模式">strict模式</span></h4><p>在JS设计之初，如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为<strong>全局变量</strong>。</p>
<p>后面有了改良，在<strong>strict模式</strong>下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</p>
<p>启用strict模式的方法是在JavaScript代码的第一行写上即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br></pre></td></tr></table></figure>
<h3><span id="字符串">字符串</span></h3><p>如果字符串内部既包含’又包含”可以用转义字符\来标识。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;I\&apos;m \&quot;OK\&quot;!&apos;;</span><br></pre></td></tr></table></figure>
<p>ASCII字符可以以<code>\x##</code>形式的十六进制表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;\x41&apos;; // 完全等同于 &apos;A&apos;</span><br></pre></td></tr></table></figure>
<p>还可以用<code>\u####</code>表示一个Unicode字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;\u4e2d\u6587&apos;; // 完全等同于 &apos;中文&apos;</span><br></pre></td></tr></table></figure>
<p>由于多行字符串用<code>\n</code>写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 <em>`</em> … <em>`</em> 也可以表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`这是一个</span><br><span class="line">多行</span><br><span class="line">字符串`;</span><br></pre></td></tr></table></figure>
<p>要把多个字符串连接起来，可以用+号连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;小明&apos;;</span><br><span class="line">var age = 20;</span><br><span class="line">var message = &apos;你好, &apos; + name + &apos;, 你今年&apos; + age + &apos;岁了!&apos;;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
<p>字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果。JS对于字符串提供了许多的方法，但是调用这些方法只会返回一个新的字符串，而不会改变原有的字符串内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toUpperCase()把一个字符串全部变为大写。</span><br><span class="line">indexOf()会搜索指定字符串出现的位置。</span><br><span class="line">substring()返回指定索引区间的子串。</span><br></pre></td></tr></table></figure>
<h3><span id="数组">数组</span></h3><h4><span id="length">length</span></h4><p>JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。</p>
<p>Array可以通过length属性来取得长度。</p>
<p>同时，直接给Array的length赋一个新的值会导致Array大小的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.length; // 3</span><br><span class="line">arr.length = 6;</span><br><span class="line">arr; // arr变为[1, 2, 3, undefined, undefined, undefined]</span><br><span class="line">arr.length = 2;</span><br><span class="line">arr; // arr变为[1, 2]</span><br></pre></td></tr></table></figure>
<p>Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array。</p>
<p>如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr[5] = &apos;x&apos;;</span><br><span class="line">arr; // arr变为[1, 2, 3, undefined, undefined, &apos;x&apos;]</span><br></pre></td></tr></table></figure>
<h4><span id="indexof">indexOf</span></h4><p>Array也可以通过indexOf()来搜索一个指定的元素的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [10, 20, &apos;30&apos;, &apos;xyz&apos;];</span><br><span class="line">arr.indexOf(10); // 元素10的索引为0</span><br><span class="line">arr.indexOf(20); // 元素20的索引为1</span><br><span class="line">arr.indexOf(30); // 元素30没有找到，返回-1</span><br><span class="line">arr.indexOf(&apos;30&apos;); // 元素&apos;30&apos;的索引为2</span><br></pre></td></tr></table></figure>
<h4><span id="slice">slice</span></h4><p>slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];</span><br><span class="line">arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br><span class="line">arr.slice(3); // 从索引3开始到结束: [&apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]</span><br></pre></td></tr></table></figure>
<p>注意到<code>slice()</code>的起止参数包括开始索引，<strong>不包括结束索引</strong>。</p>
<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];</span><br><span class="line">var aCopy = arr.slice();</span><br><span class="line">aCopy; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]</span><br><span class="line">aCopy === arr; // false</span><br></pre></td></tr></table></figure>
<h4><span id="push和pop">push和pop</span></h4><p>push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉。</p>
<h4><span id="unshift和shift">unshift和shift</span></h4><p>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉。</p>
<h4><span id="sort">sort</span></h4><p>按照默认顺序进行排序，也可以自定义顺序。</p>
<h4><span id="reverse">reverse</span></h4><p>翻转整个Array，把元素顺序翻转过来。</p>
<h4><span id="splice">splice</span></h4><p>从指定的索引开始删除若干元素，然后再从该位置添加若干元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];</span><br><span class="line">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</span><br><span class="line">// 只删除,不添加:</span><br><span class="line">arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]</span><br><span class="line">// 只添加,不删除:</span><br><span class="line">arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</span><br></pre></td></tr></table></figure>
<h4><span id="concat">concat</span></h4><p>把当前的Array和另一个Array连接起来，并返回一个新的Array。</p>
<p>值得注意的是，concat()方法并没有修改当前Array，而是返回了一个新的Array。</p>
<h4><span id="join">join</span></h4><p>把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。如果Array的元素不是字符串，将自动转换为字符串后再连接。</p>
<h4><span id="多维数组">多维数组</span></h4><p>如果数组的某个元素又是一个Array，则可以形成多维数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [[1, 2, 3], [400, 500, 600], &apos;-&apos;];</span><br></pre></td></tr></table></figure>
<h3><span id="对象">对象</span></h3><p>JS的对象是一种无序的集合数据类型，它由若干键值对组成。</p>
<p>JS用一个{…}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,。</p>
<p>访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用’’括起来。</p>
<p><strong>JavaScript规定，访问不存在的属性不报错，而是返回undefined。</strong></p>
<p>由于JavaScript的对象是<strong>动态类型</strong>，可以自由地给一个对象添加或删除属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var thbelief = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; // undefined</span><br><span class="line">xiaoming.age = 18; // 新增一个age属性</span><br><span class="line">xiaoming.age; // 18</span><br><span class="line">delete xiaoming.age; // 删除age属性</span><br><span class="line">xiaoming.age; // undefined</span><br><span class="line">delete xiaoming[&apos;name&apos;]; // 删除name属性</span><br><span class="line">xiaoming.name; // undefined</span><br><span class="line">delete xiaoming.school; // 删除一个不存在的school属性也不会报错</span><br></pre></td></tr></table></figure>
<p>果我们要检测thbelief是否拥有某一属性，可以用in操作符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;name&apos; in thbelief; // true</span><br></pre></td></tr></table></figure>
<p>另外，如果in判断一个属性存在，这个属性不一定是thbelief的，它可能是thbelief继承得到的。</p>
<p>要判断一个属性是否是thbelief自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var thbelief = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;</span><br><span class="line">&#125;;</span><br><span class="line">thbelief.hasOwnProperty(&apos;name&apos;); // true</span><br><span class="line">thbelief.hasOwnProperty(&apos;toString&apos;); // false</span><br></pre></td></tr></table></figure>
<h3><span id="条件判断">条件判断</span></h3><p>JavaScript可以使用if () { … } else { … }来进行条件判断。</p>
<p>同时，也可以像C++中一样进行多重的嵌套。</p>
<h3><span id="循环">循环</span></h3><p>熟悉的是单独的For循环，但是还包括了其他的不熟悉的循环方式。</p>
<h4><span id="forin">for…in</span></h4><p>它可以把一个对象的所有属性依次循环出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    city: &apos;mianyang&apos;</span><br><span class="line">&#125;;</span><br><span class="line">for (var key in o) &#123;</span><br><span class="line">    console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要过滤掉对象继承的属性，用hasOwnProperty()来实现。（前文对象中曾经提到）</p>
<p>值得注意的是，for … in对Array的循环得到的是String而不是Number。</p>
<h4><span id="while">while</span></h4><p>与C++中类似。</p>
<h4><span id="do-while">do while</span></h4><p>与C++中类似。</p>
<h3><span id="map和set">Map和Set</span></h3><p>Map是一组键值对的结构，具有极快的查找速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;); // 95</span><br></pre></td></tr></table></figure>
<p>初始化Map需要一个<strong>二维数组</strong>，或者直接初始化一个<strong>空Map</strong>。Map具有以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map(); // 空Map</span><br><span class="line">m.set(&apos;Adam&apos;, 67); // 添加新的key-value</span><br><span class="line">m.set(&apos;Bob&apos;, 59);</span><br><span class="line">m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: true</span><br><span class="line">m.get(&apos;Adam&apos;); // 67</span><br><span class="line">m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;</span><br><span class="line">m.get(&apos;Adam&apos;); // undefined</span><br></pre></td></tr></table></figure>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line">m.set(&apos;Adam&apos;, 67);</span><br><span class="line">m.set(&apos;Adam&apos;, 88);</span><br><span class="line">m.get(&apos;Adam&apos;); // 88</span><br></pre></td></tr></table></figure>
<p>Set和Map类似，也是一组key的集合，但<strong>不存储value</strong>。由于key不能重复，所以，在Set中，没有重复的key。</p>
<p>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s1 = new Set(); // 空Set</span><br><span class="line">var s2 = new Set([1, 2, 3]); // 含1, 2, 3</span><br></pre></td></tr></table></figure>
<p>通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果。</p>
<p>同样的，通过delete(key)方法可以删除元素。</p>
<h3><span id="iterable">iterable</span></h3><p>具有iterable类型的集合可以通过新的for … of循环来遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);</span><br><span class="line">var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);</span><br><span class="line">for (var x of a) &#123; // 遍历Array</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">for (var x of s) &#123; // 遍历Set</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">for (var x of m) &#123; // 遍历Map</span><br><span class="line">    console.log(x[0] + &apos;=&apos; + x[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for … in循环遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。如果手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">a.name = &apos;Hello&apos;;</span><br><span class="line">for (var x in a) &#123;</span><br><span class="line">    console.log(x); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;name&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>for … in</strong>循环将把name包括在内，但Array的length属性却不包括在内。</p>
<p><strong>for … of</strong>循环则完全修复了这些问题，它只循环<strong>集合本身的元素</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">a.name = &apos;Hello&apos;;</span><br><span class="line">for (var x of a) &#123;</span><br><span class="line">    console.log(x); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">参考链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/09/java番外-多线程编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/java番外-多线程编程/" itemprop="url">java番外-多线程编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-09T15:49:38+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#1线程与进程的异同">1.线程与进程的异同：</a></li>
<li><a href="#2线程的生命周期">2.线程的生命周期：</a><ul>
<li><a href="#新建状态">新建状态：</a></li>
<li><a href="#就绪状态">就绪状态：</a></li>
<li><a href="#运行状态">运行状态：</a></li>
<li><a href="#阻塞状态">阻塞状态：</a></li>
<li><a href="#死亡状态">死亡状态：</a></li>
</ul>
</li>
<li><a href="#3线程的优先级">3.线程的优先级：</a></li>
<li><a href="#4创建线程的三种方式">4.创建线程的三种方式：</a><ul>
<li><a href="#通过runnable接口创建线程">通过Runnable接口创建线程：</a></li>
<li><a href="#通过集成thread类来创建线程">通过集成Thread类来创建线程：</a></li>
<li><a href="#通过callable和future创建线程">通过Callable和Future创建线程：</a></li>
<li><a href="#三种方式的对比">三种方式的对比：</a></li>
</ul>
</li>
<li><a href="#线程的几个重要的概念">线程的几个重要的概念：</a></li>
</ul>
<!-- tocstop -->
<h2><span id="1线程与进程的异同">1.线程与进程的异同：</span></h2><p><strong>线程</strong>：一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p><strong>进程</strong>：一个进程包括了由操作系统分配的内存空间，包含了一个或者多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。</p>
<h2><span id="2线程的生命周期">2.线程的生命周期：</span></h2><p><img src="/2019/03/09/java番外-多线程编程/D:/hexo/source/_posts/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt=""></p>
<p><strong>相关解释：</strong></p>
<h3><span id="新建状态">新建状态：</span></h3><p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>
<h3><span id="就绪状态">就绪状态：</span></h3><p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
<h3><span id="运行状态">运行状态：</span></h3><p>如果就绪状态的线程获取 CPU 资源，就可以执行 <strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
<h3><span id="阻塞状态">阻塞状态：</span></h3><p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p>
<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li>
</ul>
<h3><span id="死亡状态">死亡状态：</span></h3><p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>
<h2><span id="3线程的优先级">3.线程的优先级：</span></h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p>
<p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p>
<p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>
<p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p>
<h2><span id="4创建线程的三种方式">4.创建线程的三种方式：</span></h2><ul>
<li>通过实现 Runnable 接口；</li>
<li>通过继承 Thread 类本身；</li>
<li>通过 Callable 和 Future 创建线程。</li>
</ul>
<h3><span id="通过runnable接口创建线程">通过Runnable接口创建线程：</span></h3><p>实现Runnable是一个类只需要执行一个方法来调用run（）即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void run（）</span><br></pre></td></tr></table></figure>
<p>该方法可以重写，要理解的是run（）可以调用其他方法，使用其他的类，并且声明变量，就像主线程一样。</p>
<p>在创建一个实现Runnable接口的类之后，可以在类中实例化一个线程对象。</p>
<p>Thread中定义了几个构造方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable threadOb,String threadName);</span><br></pre></td></tr></table></figure>
<p>这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。</p>
<p>新线程创建之后，你调用它的 start() 方法它才会运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void start（）；</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class RunnableDemo implements Runnable &#123;</span><br><span class="line">   private Thread t;</span><br><span class="line">   private String threadName;</span><br><span class="line">   </span><br><span class="line">   RunnableDemo( String name) &#123;</span><br><span class="line">      threadName = name;</span><br><span class="line">      System.out.println(&quot;Creating &quot; +  threadName );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(&quot;Running &quot; +  threadName );</span><br><span class="line">      try &#123;</span><br><span class="line">         for(int i = 4; i &gt; 0; i--) &#123;</span><br><span class="line">            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);</span><br><span class="line">            // 让线程睡眠一会</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;catch (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void start () &#123;</span><br><span class="line">      System.out.println(&quot;Starting &quot; +  threadName );</span><br><span class="line">      if (t == null) &#123;</span><br><span class="line">         t = new Thread (this, threadName);</span><br><span class="line">         t.start ();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;);</span><br><span class="line">      R1.start();</span><br><span class="line">      </span><br><span class="line">      RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;);</span><br><span class="line">      R2.start();</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Creating Thread-1</span><br><span class="line">Starting Thread-1</span><br><span class="line">Creating Thread-2</span><br><span class="line">Starting Thread-2</span><br><span class="line">Running Thread-1</span><br><span class="line">Thread: Thread-1, 4</span><br><span class="line">Running Thread-2</span><br><span class="line">Thread: Thread-2, 4</span><br><span class="line">Thread: Thread-1, 3</span><br><span class="line">Thread: Thread-2, 3</span><br><span class="line">Thread: Thread-1, 2</span><br><span class="line">Thread: Thread-2, 2</span><br><span class="line">Thread: Thread-1, 1</span><br><span class="line">Thread: Thread-2, 1</span><br><span class="line">Thread Thread-1 exiting.</span><br><span class="line">Thread Thread-2 exiting.</span><br></pre></td></tr></table></figure>
<h3><span id="通过集成thread类来创建线程">通过集成Thread类来创建线程：</span></h3><p>该方法是创建一个新的类然后让这个类继承自Thread类，然后创建一个该类的实例即可。</p>
<p>继承类的时候必须重写run（）方法，该方法是新线程的入口点，它也必须调用start方法才可以执行。本质上也是实现了Runnable接口的一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class ThreadDemo extends Thread &#123;</span><br><span class="line">   private Thread t;</span><br><span class="line">   private String threadName;</span><br><span class="line">   </span><br><span class="line">   ThreadDemo( String name) &#123;</span><br><span class="line">      threadName = name;</span><br><span class="line">      System.out.println(&quot;Creating &quot; +  threadName );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(&quot;Running &quot; +  threadName );</span><br><span class="line">      try &#123;</span><br><span class="line">         for(int i = 4; i &gt; 0; i--) &#123;</span><br><span class="line">            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);</span><br><span class="line">            // 让线程睡眠一会</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;catch (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void start () &#123;</span><br><span class="line">      System.out.println(&quot;Starting &quot; +  threadName );</span><br><span class="line">      if (t == null) &#123;</span><br><span class="line">         t = new Thread (this, threadName);</span><br><span class="line">         t.start ();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;);</span><br><span class="line">      T1.start();</span><br><span class="line">      </span><br><span class="line">      ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;);</span><br><span class="line">      T2.start();</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Creating Thread-1</span><br><span class="line">Starting Thread-1</span><br><span class="line">Creating Thread-2</span><br><span class="line">Starting Thread-2</span><br><span class="line">Running Thread-1</span><br><span class="line">Thread: Thread-1, 4</span><br><span class="line">Running Thread-2</span><br><span class="line">Thread: Thread-2, 4</span><br><span class="line">Thread: Thread-1, 3</span><br><span class="line">Thread: Thread-2, 3</span><br><span class="line">Thread: Thread-1, 2</span><br><span class="line">Thread: Thread-2, 2</span><br><span class="line">Thread: Thread-1, 1</span><br><span class="line">Thread: Thread-2, 1</span><br><span class="line">Thread Thread-1 exiting.</span><br><span class="line">Thread Thread-2 exiting.</span><br></pre></td></tr></table></figure>
<p>下表列出了Thread类的一些重要方法：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public final void setPriority(int priority)</strong>  更改线程的优先级。</td>
</tr>
<tr>
<td>5</td>
<td><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td>
</tr>
<tr>
<td>6</td>
<td><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td>
</tr>
<tr>
<td>7</td>
<td><strong>public void interrupt()</strong> 中断线程。</td>
</tr>
<tr>
<td>8</td>
<td><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td>
</tr>
</tbody>
</table>
<p>测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>public static void yield()</strong> 暂停当前正在执行的线程对象，并执行其他线程。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public static void sleep(long millisec)</strong> 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public static boolean holdsLock(Object x)</strong> 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public static Thread currentThread()</strong> 返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr>
<td>5</td>
<td><strong>public static void dumpStack()</strong> 将当前线程的堆栈跟踪打印至标准错误流。</td>
</tr>
</tbody>
</table>
<p>实例：</p>
<p>如下的ThreadClassDemo 程序演示了Thread类的一些方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 : DisplayMessage.java</span><br><span class="line">// 通过实现 Runnable 接口创建线程</span><br><span class="line">public class DisplayMessage implements Runnable &#123;</span><br><span class="line">   private String message;</span><br><span class="line">   </span><br><span class="line">   public DisplayMessage(String message) &#123;</span><br><span class="line">      this.message = message;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      while(true) &#123;</span><br><span class="line">         System.out.println(message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 : GuessANumber.java</span><br><span class="line">// 通过继承 Thread 类创建线程</span><br><span class="line"> </span><br><span class="line">public class GuessANumber extends Thread &#123;</span><br><span class="line">   private int number;</span><br><span class="line">   public GuessANumber(int number) &#123;</span><br><span class="line">      this.number = number;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      int counter = 0;</span><br><span class="line">      int guess = 0;</span><br><span class="line">      do &#123;</span><br><span class="line">         guess = (int) (Math.random() * 100 + 1);</span><br><span class="line">         System.out.println(this.getName() + &quot; guesses &quot; + guess);</span><br><span class="line">         counter++;</span><br><span class="line">      &#125; while(guess != number);</span><br><span class="line">      System.out.println(&quot;** Correct!&quot; + this.getName() + &quot;in&quot; + counter + &quot;guesses.**&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 : ThreadClassDemo.java</span><br><span class="line">public class ThreadClassDemo &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String [] args) &#123;</span><br><span class="line">      Runnable hello = new DisplayMessage(&quot;Hello&quot;);</span><br><span class="line">      Thread thread1 = new Thread(hello);</span><br><span class="line">      thread1.setDaemon(true);</span><br><span class="line">      thread1.setName(&quot;hello&quot;);</span><br><span class="line">      System.out.println(&quot;Starting hello thread...&quot;);</span><br><span class="line">      thread1.start();</span><br><span class="line">      </span><br><span class="line">      Runnable bye = new DisplayMessage(&quot;Goodbye&quot;);</span><br><span class="line">      Thread thread2 = new Thread(bye);</span><br><span class="line">      thread2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">      thread2.setDaemon(true);</span><br><span class="line">      System.out.println(&quot;Starting goodbye thread...&quot;);</span><br><span class="line">      thread2.start();</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;Starting thread3...&quot;);</span><br><span class="line">      Thread thread3 = new GuessANumber(27);</span><br><span class="line">      thread3.start();</span><br><span class="line">      try &#123;</span><br><span class="line">         thread3.join();</span><br><span class="line">      &#125;catch(InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Starting thread4...&quot;);</span><br><span class="line">      Thread thread4 = new GuessANumber(75);</span><br><span class="line">      </span><br><span class="line">      thread4.start();</span><br><span class="line">      System.out.println(&quot;main() is ending...&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Starting hello thread...</span><br><span class="line">Starting goodbye thread...</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Goodbye</span><br><span class="line">Goodbye</span><br><span class="line">Goodbye</span><br><span class="line">Goodbye</span><br><span class="line">Goodbye</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<h3><span id="通过callable和future创建线程">通过Callable和Future创建线程：</span></h3><ul>
<li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
<li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>
<li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li>
</ul>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class CallableThreadTest implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        CallableThreadTest ctt = new CallableThreadTest();  </span><br><span class="line">        FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt);  </span><br><span class="line">        for(int i = 0;i &lt; 100;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);  </span><br><span class="line">            if(i==20)  </span><br><span class="line">            &#123;  </span><br><span class="line">                new Thread(ft,&quot;有返回值的线程&quot;).start();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        try  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(&quot;子线程的返回值：&quot;+ft.get());  </span><br><span class="line">        &#125; catch (InterruptedException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (ExecutionException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    @Override  </span><br><span class="line">    public Integer call() throws Exception  </span><br><span class="line">    &#123;  </span><br><span class="line">        int i = 0;  </span><br><span class="line">        for(;i&lt;100;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="三种方式的对比">三种方式的对比：</span></h3><ul>
<li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>
</ul>
<h2><span id="线程的几个重要的概念">线程的几个重要的概念：</span></h2><p>1）线程同步。</p>
<p>2）线程间通信。</p>
<p>3）线程死锁。</p>
<p>4）线程控制，包括挂起停止与恢复。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/07/java基础-融会贯通/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/java基础-融会贯通/" itemprop="url">java基础-融会贯通</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T08:27:11+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  34
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#1继承">1.继承：</a><ul>
<li><a href="#1概念">1）概念：</a></li>
<li><a href="#2格式">2）格式：</a></li>
<li><a href="#3类型">3）类型：</a></li>
<li><a href="#4特性">4）特性：</a></li>
<li><a href="#5关键字">5）关键字：</a><ul>
<li><a href="#extends关键字">extends关键字：</a></li>
<li><a href="#implements关键字">implements关键字：</a></li>
<li><a href="#super与this关键字">super与this关键字：</a></li>
<li><a href="#final关键字">final关键字：</a></li>
<li><a href="#注意">注意：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2重写与重载">2.重写与重载：</a><ul>
<li><a href="#1重写">1）重写：</a><ul>
<li><a href="#概念">概念：</a></li>
<li><a href="#super关键字的使用">Super关键字的使用：</a></li>
</ul>
</li>
<li><a href="#2重载">2）重载：</a><ul>
<li><a href="#规则">规则：</a></li>
</ul>
</li>
<li><a href="#3重载与重写的区别">3）重载与重写的区别：</a></li>
<li><a href="#4总结">4）总结：</a></li>
</ul>
</li>
<li><a href="#3多态">3.多态：</a><ul>
<li><a href="#1概念-1">1）概念：</a></li>
<li><a href="#2表现">2）表现：</a></li>
<li><a href="#3优点">3）优点：</a></li>
<li><a href="#4执行条件">4）执行条件：</a></li>
<li><a href="#5虚函数">5）虚函数：</a></li>
<li><a href="#6实现方式">6）实现方式：</a></li>
</ul>
</li>
<li><a href="#4抽象类">4.抽象类：</a><ul>
<li><a href="#1概念-2">1）概念：</a></li>
<li><a href="#2实例">2）实例：</a></li>
<li><a href="#3继承抽象类">3）继承抽象类：</a></li>
<li><a href="#4抽象方法">4）抽象方法：</a></li>
<li><a href="#5总结">5）总结：</a></li>
</ul>
</li>
<li><a href="#5封装">5.封装：</a><ul>
<li><a href="#1概念-3">1）概念：</a></li>
<li><a href="#2优点">2）优点：</a></li>
<li><a href="#3实现步骤">3）实现步骤：</a></li>
<li><a href="#4实例">4）实例：</a></li>
</ul>
</li>
<li><a href="#6接口">6.接口：</a><ul>
<li><a href="#1概念-4">1）概念：</a></li>
<li><a href="#2接口与类的相似点">2）接口与类的相似点：</a></li>
<li><a href="#3接口与类的区别">3）接口与类的区别：</a></li>
<li><a href="#4接口特性">4）接口特性：</a></li>
<li><a href="#5抽象类与接口的区别">5）抽象类与接口的区别：</a></li>
<li><a href="#6接口的声明">6）接口的声明：</a></li>
<li><a href="#7接口的实现">7）接口的实现：</a></li>
<li><a href="#8接口的继承">8）接口的继承：</a></li>
<li><a href="#9接口的多继承">9）接口的多继承：</a></li>
<li><a href="#10标记接口">10）标记接口：</a></li>
</ul>
</li>
<li><a href="#7包">7.包：</a><ul>
<li><a href="#1作用">1）作用：</a></li>
<li><a href="#2创建包">2）创建包：</a></li>
<li><a href="#3import关键字">3）import关键字：</a></li>
<li><a href="#4package目录结构">4）package目录结构：</a></li>
<li><a href="#5设置classpath系统变量">5）设置CLASSPATH系统变量：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="1继承">1.继承：</span></h2><h3><span id="1概念">1）概念：</span></h3><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<h3><span id="2格式">2）格式：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="3类型">3）类型：</span></h3><p>注意：java不支持多继承，但是支持多重继承。</p>
<p><img src="/2019/03/07/java基础-融会贯通/多重继承.png" alt=""></p>
<h3><span id="4特性">4）特性：</span></h3><p>子类拥有父类非 private 的属性、方法。</p>
<p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p>
<p>子类可以用自己的方式实现父类的方法。</p>
<p>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</p>
<p>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</p>
<h3><span id="5关键字">5）关键字：</span></h3><p>注意：继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 <strong>java.lang.Object</strong>，当一个类没有继承的两个关键字，则默认继承object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。</p>
<h4><span id="extends关键字">extends关键字：</span></h4><p>在java中，类的继承是单一的继承，也就是说，一个类只能拥有一个父类，所以extends只能继承一个类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123; </span><br><span class="line">    private String name;   </span><br><span class="line">    private int id; </span><br><span class="line">    public Animal(String myName, String myid) &#123; </span><br><span class="line">        //初始化属性值</span><br><span class="line">    &#125; </span><br><span class="line">    public void eat() &#123;  //吃的方法的具体实现  &#125; </span><br><span class="line">    public void sleep() &#123; //睡觉的方法的具体实现  &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public class Penguin  extends  Animal&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="implements关键字">implements关键字：</span></h4><p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface A &#123;</span><br><span class="line">    public void eat();</span><br><span class="line">    public void sleep();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public interface B &#123;</span><br><span class="line">    public void show();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class C implements A,B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="super与this关键字">super与this关键字：</span></h4><p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>
<p>this关键字：指向自己的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  void eat() &#123;</span><br><span class="line">    System.out.println(&quot;animal : eat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  void eat() &#123;</span><br><span class="line">    System.out.println(&quot;dog : eat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  void eatTest() &#123;</span><br><span class="line">    this.eat();   // this 调用自己的方法</span><br><span class="line">    super.eat();  // super 调用父类方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Animal a = new Animal();</span><br><span class="line">    a.eat();</span><br><span class="line">    Dog d = new Dog();</span><br><span class="line">    d.eatTest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="final关键字">final关键字：</span></h4><p>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。</p>
<p><strong>注</strong>:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">声明类：</span><br><span class="line"></span><br><span class="line">final class 类名 &#123;//类体&#125;</span><br><span class="line">声明方法：</span><br><span class="line"></span><br><span class="line">修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;//方法体&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="注意">注意：</span></h4><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</p>
<p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p>
<h2><span id="2重写与重载">2.重写与重载：</span></h2><h3><span id="1重写">1）重写：</span></h3><h4><span id="概念">概念：</span></h4><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写，<strong>返回值和形参都不能改变</strong>。其实就是<strong>外形不变，核心重写</strong>的意思。</p>
<p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">   public void move()&#123;</span><br><span class="line">      System.out.println(&quot;动物可以移动&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">   public void move()&#123;</span><br><span class="line">      System.out.println(&quot;狗可以跑和走&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestDog&#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      Animal a = new Animal(); // Animal 对象</span><br><span class="line">      Animal b = new Dog(); // Dog 对象</span><br><span class="line"> </span><br><span class="line">      a.move();// 执行 Animal 类的方法</span><br><span class="line"> </span><br><span class="line">      b.move();//执行 Dog 类的方法</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动物可以移动</span><br><span class="line">狗可以跑和走</span><br></pre></td></tr></table></figure>
<h4><span id="super关键字的使用">Super关键字的使用：</span></h4><p>当需要在子类中调用父类的被重写方法的时候，就必须使用super关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">   public void move()&#123;</span><br><span class="line">      System.out.println(&quot;动物可以移动&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">   public void move()&#123;</span><br><span class="line">      super.move(); // 应用super类的方法</span><br><span class="line">      System.out.println(&quot;狗可以跑和走&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestDog&#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line"> </span><br><span class="line">      Animal b = new Dog(); // Dog 对象</span><br><span class="line">      b.move(); //执行 Dog类的方法</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动物可以移动</span><br><span class="line">狗可以跑和走</span><br></pre></td></tr></table></figure>
<h3><span id="2重载">2）重载：</span></h3><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
<p>最常用的地方就是构造器的重载。</p>
<h4><span id="规则">规则：</span></h4><p>被重载的方法必须改变参数列表（参数的个数或者类型不一样）。</p>
<p>被重载的方法可以改变返回类型。</p>
<p>被重载的方法可以改变访问修饰符。</p>
<p>被重载的方法可以声明新的或者更广的检查异常。</p>
<p>方法能够在同一个类中或者在一个子类中被重载。</p>
<p>无法以返回值类型作为重载函数的区分标准。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Overloading &#123;</span><br><span class="line">    public int test()&#123;</span><br><span class="line">        System.out.println(&quot;test1&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void test(int a)&#123;</span><br><span class="line">        System.out.println(&quot;test2&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    //以下两个参数类型顺序不同</span><br><span class="line">    public String test(int a,String s)&#123;</span><br><span class="line">        System.out.println(&quot;test3&quot;);</span><br><span class="line">        return &quot;returntest3&quot;;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    public String test(String s,int a)&#123;</span><br><span class="line">        System.out.println(&quot;test4&quot;);</span><br><span class="line">        return &quot;returntest4&quot;;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Overloading o = new Overloading();</span><br><span class="line">        System.out.println(o.test());</span><br><span class="line">        o.test(1);</span><br><span class="line">        System.out.println(o.test(1,&quot;test3&quot;));</span><br><span class="line">        System.out.println(o.test(&quot;test4&quot;,1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="3重载与重写的区别">3）重载与重写的区别：</span></h3><p><img src="/2019/03/07/java基础-融会贯通/区别.jpg" alt=""></p>
<h3><span id="4总结">4）总结：</span></h3><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<ul>
<li>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li>
<li>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li>
<li>(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li>
</ul>
<p><img src="/2019/03/07/java基础-融会贯通/总结.jpg" alt=""></p>
<h2><span id="3多态">3.多态：</span></h2><h3><span id="1概念">1）概念：</span></h3><p>多态就是同一个行为具有多个不同表现形式或者形态的能力。</p>
<p>（同一个接口，使用不同的实例而执行不同的操作）</p>
<h3><span id="2表现">2）表现：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">现实中，比如我们按下 F1 键这个动作：</span><br><span class="line"></span><br><span class="line">如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；</span><br><span class="line">如果当前在 Word 下弹出的就是 Word 帮助；</span><br><span class="line">在 Windows 下弹出的就是 Windows 帮助和支持。</span><br><span class="line"></span><br><span class="line">同一个事件发生在不同的对象上会产生不同的结果。</span><br></pre></td></tr></table></figure>
<h3><span id="3优点">3）优点：</span></h3><ul>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ul>
<h3><span id="4执行条件">4）执行条件：</span></h3><ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent p = new Child();</span><br></pre></td></tr></table></figure>
<p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p>
<p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      show(new Cat());  // 以 Cat 对象调用 show 方法</span><br><span class="line">      show(new Dog());  // 以 Dog 对象调用 show 方法</span><br><span class="line">                </span><br><span class="line">      Animal a = new Cat();  // 向上转型  </span><br><span class="line">      a.eat();               // 调用的是 Cat 的 eat</span><br><span class="line">      Cat c = (Cat)a;        // 向下转型  </span><br><span class="line">      c.work();        // 调用的是 Cat 的 work</span><br><span class="line">  &#125;  </span><br><span class="line">            </span><br><span class="line">    public static void show(Animal a)  &#123;</span><br><span class="line">      a.eat();  </span><br><span class="line">        // 类型判断</span><br><span class="line">        if (a instanceof Cat)  &#123;  // 猫做的事</span><br><span class="line">            Cat c = (Cat)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125; else if (a instanceof Dog) &#123; // 狗做的事</span><br><span class="line">            Dog c = (Dog)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">abstract class Animal &#123;  </span><br><span class="line">    abstract void eat();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Cat extends Animal &#123;  </span><br><span class="line">    public void eat() &#123;  </span><br><span class="line">        System.out.println(&quot;吃鱼&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void work() &#123;  </span><br><span class="line">        System.out.println(&quot;抓老鼠&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">class Dog extends Animal &#123;  </span><br><span class="line">    public void eat() &#123;  </span><br><span class="line">        System.out.println(&quot;吃骨头&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void work() &#123;  </span><br><span class="line">        System.out.println(&quot;看家&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">吃鱼</span><br><span class="line">抓老鼠</span><br><span class="line">吃骨头</span><br><span class="line">看家</span><br><span class="line">吃鱼</span><br><span class="line">抓老鼠</span><br></pre></td></tr></table></figure>
<h3><span id="5虚函数">5）虚函数：</span></h3><p><strong>虚函数的存在是为了多态</strong>。</p>
<p>Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p>
<h3><span id="6实现方式">6）实现方式：</span></h3><p>三种方式，包括：<strong>重写，接口，抽象类和抽象方法</strong>。</p>
<h2><span id="4抽象类">4.抽象类：</span></h2><h3><span id="1概念">1）概念：</span></h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<h3><span id="2实例">2）实例：</span></h3><p>在java中使用abstract class来定义抽象类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : Employee.java */</span><br><span class="line">public abstract class Employee</span><br><span class="line">&#123;</span><br><span class="line">   private String name;</span><br><span class="line">   private String address;</span><br><span class="line">   private int number;</span><br><span class="line">   public Employee(String name, String address, int number)</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(&quot;Constructing an Employee&quot;);</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.address = address;</span><br><span class="line">      this.number = number;</span><br><span class="line">   &#125;</span><br><span class="line">   public double computePay()</span><br><span class="line">   &#123;</span><br><span class="line">     System.out.println(&quot;Inside Employee computePay&quot;);</span><br><span class="line">     return 0.0;</span><br><span class="line">   &#125;</span><br><span class="line">   public void mailCheck()</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(&quot;Mailing a check to &quot; + this.name</span><br><span class="line">       + &quot; &quot; + this.address);</span><br><span class="line">   &#125;</span><br><span class="line">   public String toString()</span><br><span class="line">   &#123;</span><br><span class="line">      return name + &quot; &quot; + address + &quot; &quot; + number;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getName()</span><br><span class="line">   &#123;</span><br><span class="line">      return name;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getAddress()</span><br><span class="line">   &#123;</span><br><span class="line">      return address;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setAddress(String newAddress)</span><br><span class="line">   &#123;</span><br><span class="line">      address = newAddress;</span><br><span class="line">   &#125;</span><br><span class="line">   public int getNumber()</span><br><span class="line">   &#123;</span><br><span class="line">     return number;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果尝试以下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : AbstractDemo.java */</span><br><span class="line">public class AbstractDemo</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String [] args)</span><br><span class="line">   &#123;</span><br><span class="line">      /* 以下是不允许的，会引发错误 */</span><br><span class="line">      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;);</span><br><span class="line">      e.mailCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时会显示以下的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee.java:46: Employee is abstract; cannot be instantiated</span><br><span class="line">      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);</span><br><span class="line">                   ^</span><br><span class="line">1 error</span><br></pre></td></tr></table></figure>
<h3><span id="3继承抽象类">3）继承抽象类：</span></h3><p>可以通过一般的方法直接继承Employee类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : Salary.java */</span><br><span class="line">public class Salary extends Employee</span><br><span class="line">&#123;</span><br><span class="line">   private double salary; //Annual salary</span><br><span class="line">   public Salary(String name, String address, int number, double</span><br><span class="line">      salary)</span><br><span class="line">   &#123;</span><br><span class="line">       super(name, address, number);</span><br><span class="line">       setSalary(salary);</span><br><span class="line">   &#125;</span><br><span class="line">   public void mailCheck()</span><br><span class="line">   &#123;</span><br><span class="line">       System.out.println(&quot;Within mailCheck of Salary class &quot;);</span><br><span class="line">       System.out.println(&quot;Mailing check to &quot; + getName()</span><br><span class="line">       + &quot; with salary &quot; + salary);</span><br><span class="line">   &#125;</span><br><span class="line">   public double getSalary()</span><br><span class="line">   &#123;</span><br><span class="line">       return salary;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setSalary(double newSalary)</span><br><span class="line">   &#123;</span><br><span class="line">       if(newSalary &gt;= 0.0)</span><br><span class="line">       &#123;</span><br><span class="line">          salary = newSalary;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public double computePay()</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(&quot;Computing salary pay for &quot; + getName());</span><br><span class="line">      return salary/52;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : AbstractDemo.java */</span><br><span class="line">public class AbstractDemo</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String [] args)</span><br><span class="line">   &#123;</span><br><span class="line">      Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00);</span><br><span class="line">      Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00);</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;Call mailCheck using Salary reference --&quot;);</span><br><span class="line">      s.mailCheck();</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;);</span><br><span class="line">      e.mailCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Constructing an Employee</span><br><span class="line">Constructing an Employee</span><br><span class="line">Call mailCheck using  Salary reference --</span><br><span class="line">Within mailCheck of Salary class</span><br><span class="line">Mailing check to Mohd Mohtashim with salary 3600.0</span><br><span class="line"></span><br><span class="line">Call mailCheck using Employee reference--</span><br><span class="line">Within mailCheck of Salary class</span><br><span class="line">Mailing check to John Adams with salary 2400.</span><br></pre></td></tr></table></figure>
<h3><span id="4抽象方法">4）抽象方法：</span></h3><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Employee</span><br><span class="line">&#123;</span><br><span class="line">   private String name;</span><br><span class="line">   private String address;</span><br><span class="line">   private int number;</span><br><span class="line">   </span><br><span class="line">   public abstract double computePay();</span><br><span class="line">   </span><br><span class="line">   //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>如果一个类包含抽象方法，那么该类必须是抽象类。</li>
<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li>
</ul>
<p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p>
<p>如果Salary类继承了Employee类，那么它必须实现computePay()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : Salary.java */</span><br><span class="line">public class Salary extends Employee</span><br><span class="line">&#123;</span><br><span class="line">   private double salary; // Annual salary</span><br><span class="line">  </span><br><span class="line">   public double computePay()</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(&quot;Computing salary pay for &quot; + getName());</span><br><span class="line">      return salary/52;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="5总结">5）总结：</span></h3><ul>
<li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
</ul>
<h2><span id="5封装">5.封装：</span></h2><h3><span id="1概念">1）概念：</span></h3><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<h3><span id="2优点">2）优点：</span></h3><ul>
<li>良好的封装能够减少耦合。</li>
<li>类内部的结构可以自由修改。</li>
<li>可以对成员变量进行更精确的控制。</li>
<li>隐藏信息，实现细节。</li>
</ul>
<h3><span id="3实现步骤">3）实现步骤：</span></h3><p>修改属性的可见性来限制属性的访问（一般限制为private），例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，将 <strong>name</strong> 和 <strong>age</strong> 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p>
<p> 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">​</span><br><span class="line">    public int getAge()&#123;</span><br><span class="line">      return age;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    public String getName()&#123;</span><br><span class="line">      return name;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    public void setAge(int age)&#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    public void setName(String name)&#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以采用this关键字是为了解决实例变量和局部变量之间发生的同名冲突。</p>
<h3><span id="4实例">4）实例：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名: EncapTest.java */</span><br><span class="line">public class EncapTest&#123;</span><br><span class="line"> </span><br><span class="line">   private String name;</span><br><span class="line">   private String idNum;</span><br><span class="line">   private int age;</span><br><span class="line"> </span><br><span class="line">   public int getAge()&#123;</span><br><span class="line">      return age;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getName()&#123;</span><br><span class="line">      return name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getIdNum()&#123;</span><br><span class="line">      return idNum;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setAge( int newAge)&#123;</span><br><span class="line">      age = newAge;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setName(String newName)&#123;</span><br><span class="line">      name = newName;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setIdNum( String newId)&#123;</span><br><span class="line">      idNum = newId;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例中public方法是外部类访问该类成员变量的入口。</p>
<p>通常情况下，这些方法被称为getter和setter方法。</p>
<p>因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。</p>
<p>通过如下的例子说明EncapTest类的变量怎样被访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* F文件名 : RunEncap.java */</span><br><span class="line">public class RunEncap&#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      EncapTest encap = new EncapTest();</span><br><span class="line">      encap.setName(&quot;James&quot;);</span><br><span class="line">      encap.setAge(20);</span><br><span class="line">      encap.setIdNum(&quot;12343ms&quot;);</span><br><span class="line"> </span><br><span class="line">      System.out.print(&quot;Name : &quot; + encap.getName()+ </span><br><span class="line">                             &quot; Age : &quot;+ encap.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name : James Age : 20</span><br></pre></td></tr></table></figure>
<h2><span id="6接口">6.接口：</span></h2><h3><span id="1概念">1）概念：</span></h3><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<h3><span id="2接口与类的相似点">2）接口与类的相似点：</span></h3><ul>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li>
<li>接口的字节码文件保存在 .class 结尾的文件中。</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ul>
<h3><span id="3接口与类的区别">3）接口与类的区别：</span></h3><ul>
<li>接口不能用于实例化对象。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
</ul>
<h3><span id="4接口特性">4）接口特性：</span></h3><ul>
<li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li>
</ul>
<h3><span id="5抽象类与接口的区别">5）抽象类与接口的区别：</span></h3><ul>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<h3><span id="6接口的声明">6）接口的声明：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名名] &#123;</span><br><span class="line">        // 声明变量</span><br><span class="line">        // 抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interface关键字用来声明一个接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : NameOfInterface.java */</span><br><span class="line">import java.lang.*;</span><br><span class="line">//引入包</span><br><span class="line"> </span><br><span class="line">public interface NameOfInterface</span><br><span class="line">&#123;</span><br><span class="line">   //任何类型 final, static 字段</span><br><span class="line">   //抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口有如下特性：</p>
<ul>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong>abstract</strong>关键字。</li>
<li>接口中的方法都是公有的。</li>
</ul>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : Animal.java */</span><br><span class="line">interface Animal &#123;</span><br><span class="line">   public void eat();</span><br><span class="line">   public void travel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="7接口的实现">7）接口的实现：</span></h3><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p>
<p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。</p>
<p>实现一个接口的语法，可以使用这个公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名 : MammalInt.java */</span><br><span class="line">public class MammalInt implements Animal&#123;</span><br><span class="line"> </span><br><span class="line">   public void eat()&#123;</span><br><span class="line">      System.out.println(&quot;Mammal eats&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void travel()&#123;</span><br><span class="line">      System.out.println(&quot;Mammal travels&quot;);</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public int noOfLegs()&#123;</span><br><span class="line">      return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      MammalInt m = new MammalInt();</span><br><span class="line">      m.eat();</span><br><span class="line">      m.travel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mammal eats</span><br><span class="line">Mammal travels</span><br></pre></td></tr></table></figure>
<p>重写接口中声明的方法时，需要注意以下规则：</p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li>
<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li>
</ul>
<p>在实现接口的时候，也要注意一些规则：</p>
<ul>
<li>一个类可以同时实现多个接口。</li>
<li>一个类只能继承一个类，但是能实现多个接口。</li>
<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>
</ul>
<h3><span id="8接口的继承">8）接口的继承：</span></h3><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p>
<p>下面的Sports接口被Hockey和Football接口继承：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 文件名: Sports.java</span><br><span class="line">public interface Sports</span><br><span class="line">&#123;</span><br><span class="line">   public void setHomeTeam(String name);</span><br><span class="line">   public void setVisitingTeam(String name);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 文件名: Football.java</span><br><span class="line">public interface Football extends Sports</span><br><span class="line">&#123;</span><br><span class="line">   public void homeTeamScored(int points);</span><br><span class="line">   public void visitingTeamScored(int points);</span><br><span class="line">   public void endOfQuarter(int quarter);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 文件名: Hockey.java</span><br><span class="line">public interface Hockey extends Sports</span><br><span class="line">&#123;</span><br><span class="line">   public void homeGoalScored();</span><br><span class="line">   public void visitingGoalScored();</span><br><span class="line">   public void endOfPeriod(int period);</span><br><span class="line">   public void overtimePeriod(int ot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。</p>
<p>相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。</p>
<h3><span id="9接口的多继承">9）接口的多继承：</span></h3><p>在Java中，类的多继承是不合法，但接口允许多继承。</p>
<p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface Hockey extends Sports, Event</span><br></pre></td></tr></table></figure>
<p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法。</p>
<h3><span id="10标记接口">10）标记接口：</span></h3><p>最常用的继承接口是没有包含任何方法的接口。</p>
<p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p>
<p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package java.util;</span><br><span class="line">public interface EventListener</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>
<ul>
<li><p>建立一个公共的父接口：</p>
<p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</li>
<li><p>向一个类添加数据类型：</p>
<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>
</li>
</ul>
<h2><span id="7包">7.包：</span></h2><p>为了更好的组织类，包就产生了，主要是用来区别类名的命名空间。</p>
<h3><span id="1作用">1）作用：</span></h3><ul>
<li>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>
<li>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>
<li>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ul>
<p>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。</p>
<p>包语句的语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package pkg1[．pkg2[．pkg3…]];</span><br></pre></td></tr></table></figure>
<p>例如,一个Something.java 文件它的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package net.java.util;</span><br><span class="line">public class Something&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么它的路径应该是 <strong>net/java/util/Something.java</strong> 这样保存的。 package(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。</p>
<p>一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。</p>
<p>以下是一些 Java 中的包：</p>
<ul>
<li><strong>java.lang</strong>-打包基础的类</li>
<li><strong>java.io</strong>-包含输入输出功能的函数</li>
</ul>
<p>开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。</p>
<p>由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。</p>
<h3><span id="2创建包">2）创建包：</span></h3><p>创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。</p>
<p>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。</p>
<p>如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。</p>
<p>例子：</p>
<p>让我们来看一个例子，这个例子创建了一个叫做animals的包。通常使用小写的字母来命名避免与类、接口名字的冲突。</p>
<p>在 animals 包中加入一个接口（interface）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 文件名: Animal.java */</span><br><span class="line">package animals;</span><br><span class="line"> </span><br><span class="line">interface Animal &#123;</span><br><span class="line">   public void eat();</span><br><span class="line">   public void travel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在同一个包中加入该接口的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package animals;</span><br><span class="line"> </span><br><span class="line">/* 文件名 : MammalInt.java */</span><br><span class="line">public class MammalInt implements Animal&#123;</span><br><span class="line"> </span><br><span class="line">   public void eat()&#123;</span><br><span class="line">      System.out.println(&quot;Mammal eats&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void travel()&#123;</span><br><span class="line">      System.out.println(&quot;Mammal travels&quot;);</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   public int noOfLegs()&#123;</span><br><span class="line">      return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      MammalInt m = new MammalInt();</span><br><span class="line">      m.eat();</span><br><span class="line">      m.travel();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，编译这两个文件，并把他们放在一个叫做animals的子目录中。 用下面的命令来运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir animals</span><br><span class="line">$ cp Animal.class  MammalInt.class animals</span><br><span class="line">$ java animals/MammalInt</span><br><span class="line">Mammal eats</span><br><span class="line">Mammal travel</span><br></pre></td></tr></table></figure>
<h3><span id="3import关键字">3）import关键字：</span></h3><p>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。</p>
<p>在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import package1[.package2…].(classname|*);</span><br></pre></td></tr></table></figure>
<p>如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。</p>
<p>例子：</p>
<p>下面的 payroll 包已经包含了 Employee 类，接下来向 payroll 包中添加一个 Boss 类。Boss 类引用 Employee 类的时候可以不用使用 payroll 前缀，Boss类的实例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package payroll;</span><br><span class="line"> </span><br><span class="line">public class Boss</span><br><span class="line">&#123;</span><br><span class="line">   public void payEmployee(Employee e)</span><br><span class="line">   &#123;</span><br><span class="line">      e.mailCheck();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Boss 类不在 payroll 包中又会怎样？Boss 类必须使用下面几种方法之一来引用其他包中的类。</p>
<p>使用类全名描述，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payroll.Employee</span><br></pre></td></tr></table></figure>
<p>用 <strong>import</strong> 关键字引入，使用通配符 “*”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import payroll.*;</span><br></pre></td></tr></table></figure>
<p>使用 <strong>import</strong> 关键字引入 Employee 类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import payroll.Employee;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。</p>
<h3><span id="4package目录结构">4）package目录结构：</span></h3><p>类放在包中会有两种主要的结果：</p>
<ul>
<li>包名成为类名的一部分，正如我们前面讨论的一样。</li>
<li>包名必须与相应的字节码所在的目录结构相吻合。</li>
</ul>
<p>下面是管理你自己 java 中文件的一种简单方式：</p>
<p>将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 :  Car.java</span><br><span class="line"> </span><br><span class="line">package vehicle;</span><br><span class="line"> </span><br><span class="line">public class Car &#123;</span><br><span class="line">   // 类实现  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....\vehicle\Car.java</span><br></pre></td></tr></table></figure>
<p>现在，正确的类名和路径将会是如下样子：</p>
<ul>
<li>类名 -&gt; vehicle.Car</li>
<li>路径名 -&gt; vehicle\Car.java (在 windows 系统中)</li>
</ul>
<p>通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。</p>
<p>例如：有一个 <strong>com.runoob.test</strong> 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....\com\runoob\test\Runoob.java</span><br></pre></td></tr></table></figure>
<p>编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 文件名: Runoob.java</span><br><span class="line"> </span><br><span class="line">package com.runoob.test;</span><br><span class="line">public class Runoob &#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">class Google &#123;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们用-d选项来编译这个文件，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$javac -d . Runoob.java</span><br></pre></td></tr></table></figure>
<p>这样会像下面这样放置编译了的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.\com\runoob\test\Runoob.class</span><br><span class="line">.\com\runoob\test\Google.class</span><br></pre></td></tr></table></figure>
<p>你可以像下面这样来导入所有 <strong>\com\runoob\test\</strong> 中定义的类、接口等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import com.runoob.test.*;</span><br></pre></td></tr></table></figure>
<p>编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;path-one&gt;\sources\com\runoob\test\Runoob.java</span><br><span class="line">&lt;path-two&gt;\classes\com\runoob\test\Google.class</span><br></pre></td></tr></table></figure>
<p>这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。</p>
<p>类目录的绝对路径叫做 <strong>class path</strong>。设置在系统变量 <strong>CLASSPATH</strong> 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。</p>
<p>一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。</p>
<h3><span id="5设置classpath系统变量">5）设置CLASSPATH系统变量：</span></h3><p>用下面的命令显示当前的CLASSPATH变量：</p>
<ul>
<li>Windows 平台（DOS 命令行下）：C:> set CLASSPATH</li>
<li>UNIX 平台（Bourne shell 下）：# echo $CLASSPATH</li>
</ul>
<p>删除当前CLASSPATH变量内容：</p>
<ul>
<li>Windows 平台（DOS 命令行下）：C:> set CLASSPATH=</li>
<li>UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH</li>
</ul>
<p>设置CLASSPATH变量:</p>
<ul>
<li>Windows 平台（DOS 命令行下）： C:> set CLASSPATH=C:\users\jack\java\classes</li>
<li>UNIX 平台（Bourne shell 下）：# CLASSPATH=/home/jack/java/classes; export CLASSPATH</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/04/C-中STL用法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/04/C-中STL用法/" itemprop="url">C++中STL用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-04T20:47:42+08:00">
                2019-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#11stl的含义">1.1STL的含义：</a></li>
<li><a href="#12stl六大组件">1.2STL六大组件：</a></li>
<li><a href="#13容器">1.3容器：</a></li>
<li><a href="#14stl迭代器">1.4STL迭代器：</a></li>
<li><a href="#15算法">1.5算法：</a><ul>
<li><a href="#一查找算法13个判断容器中是否包含某个值">&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值</a></li>
<li><a href="#二排序和通用算法14个提供元素排序策略">&lt;二&gt;排序和通用算法(14个)：提供元素排序策略</a></li>
<li><a href="#三删除和替换算法15个">&lt;三&gt;删除和替换算法(15个)</a></li>
<li><a href="#四排列组合算法2个提供计算给定集合按一定顺序的所有可能排列组合">&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合</a></li>
<li><a href="#五算术算法4个">&lt;五&gt;算术算法(4个)</a></li>
<li><a href="#六生成和异变算法6个">&lt;六&gt;生成和异变算法(6个)</a></li>
<li><a href="#七关系算法8个">&lt;七&gt;关系算法(8个)</a></li>
<li><a href="#八集合算法4个">&lt;八&gt;集合算法(4个)</a></li>
<li><a href="#九堆算法4个">&lt;九&gt;堆算法(4个)</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="11stl的含义">1.1STL的含义：</span></h2><p>STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。</p>
<p>STL的一个重要的特点就是数据结构和算法的分离。例如：由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组。</p>
<p>STL另外的一个特点就是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。</p>
<h2><span id="12stl六大组件">1.2STL六大组件：</span></h2><p>1）容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；</p>
<p>2）迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；</p>
<p>3）算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；</p>
<p>4）仿函数（Function object）</p>
<p>5）迭代适配器（Adaptor）</p>
<p>6）空间配制器（allocator）</p>
<h2><span id="13容器">1.3容器：</span></h2><p>STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。<br>　　（1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；<br>Vectors：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；<br>Deques：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；<br>Lists：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；<br>    （2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap；<br>Sets/Multisets：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；<br>Maps/Multimaps：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找；</p>
<p>容器类自动申请和释放内存，无需new和delete操作。vector基于模板实现，需包含头文件vector。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//1.定义和初始化</span><br><span class="line">    vector&lt;int&gt; vec1;    //默认初始化，vec1为空</span><br><span class="line">    vector&lt;int&gt; vec2(vec1);  //使用vec1初始化vec2</span><br><span class="line">    vector&lt;int&gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2</span><br><span class="line">    vector&lt;int&gt; vec4(10);    //10个值为的元素</span><br><span class="line">    vector&lt;int&gt; vec5(10,4);  //10个值为的元素</span><br><span class="line">//2.常用操作方法</span><br><span class="line">    vec1.push_back(100);            //添加元素</span><br><span class="line">    int size = vec1.size();         //元素个数</span><br><span class="line">    bool isEmpty = vec1.empty();    //判断是否为空</span><br><span class="line">    cout&lt;&lt;vec1[0]&lt;&lt;endl;        //取得第一个元素</span><br><span class="line">    vec1.insert(vec1.end(),5,3);    //从vec1.back位置插入个值为的元素</span><br><span class="line">    vec1.pop_back();              //删除末尾元素</span><br><span class="line">    vec1.erase(vec1.begin(),vec1.end());//删除之间的元素，其他元素前移</span><br><span class="line">    cout&lt;&lt;(vec1==vec2)?true:false;  //判断是否相等==、！=、&gt;=、&lt;=...</span><br><span class="line">    vector&lt;int&gt;::iterator iter = vec1.begin();    //获取迭代器首地址</span><br><span class="line">    vec1.clear();                 //清空元素</span><br><span class="line">//3.遍历</span><br><span class="line">    //下标法</span><br><span class="line">    int length = vec1.size();</span><br><span class="line">    for(int i=0;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;vec1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    //迭代器法</span><br><span class="line">    vector&lt;int&gt;::const_iterator iterator = vec1.begin();</span><br><span class="line">    for(;iterator != vec1.end();iterator++)</span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;*iterator;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2><span id="14stl迭代器">1.4STL迭代器：</span></h2><p>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p>迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator,实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    v.push_back(3);  //数组尾部插入3</span><br><span class="line">    v.push_back(2);</span><br><span class="line">    v.push_back(1);</span><br><span class="line">    v.push_back(0);</span><br><span class="line">    cout &lt;&lt; &quot; 下标 &quot; &lt;&lt; v[3] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot; 迭代器 &quot; &lt;&lt; endl;</span><br><span class="line">    for(vector&lt;int&gt;::iterator i = v.begin();i!= v.end();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    //在第一个元素之前插入111  insert begin+n是在第n个元素之前插入</span><br><span class="line">    v.insert(v.begin(),111);</span><br><span class="line">    //在最后一个元素之后插入222 insert end + n 是在n个元素之后插入</span><br><span class="line">    v.insert(v.end(),222);</span><br><span class="line">    for(vector&lt;int&gt;::iterator i = v.begin();i!= v.end();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    vector&lt;int&gt; arr(10);</span><br><span class="line">    for(int i = 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    //删除 同insert</span><br><span class="line">    arr.erase(arr.begin());</span><br><span class="line">    for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i)</span><br><span class="line">     &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot; ;</span><br><span class="line">     &#125;</span><br><span class="line">    cout &lt;&lt; endl ;</span><br><span class="line">    arr.erase(arr.begin(),arr.begin()+5);</span><br><span class="line">    for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl ;</span><br><span class="line">    return 0 ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>数组转置：</p>
<p> reverse(v.begin(),v.end())</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    for(int i = 0; i &lt; 10; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    reverse(v.begin(),v.end());</span><br><span class="line">    for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="15算法">1.5算法：</span></h2><p>算法部分主要由头文件<strong>algorithm</strong>，<strong>numeric</strong>和<strong>functional</strong>组成。<br>    <strong>algorithm</strong>是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<br>    <strong>numeric</strong>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<br>    <strong>functional</strong>中则定义了一些模板类，用以声明函数对象。<br>STL中算法大致分为四类：<br>    1）非可变序列算法：指不直接修改其所操作的容器内容的算法。</p>
<p>2）可变序列算法：指可以修改它们所操作的容器内容的算法。</p>
<p>3）排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。</p>
<p>4）数值算法：对容器内容进行数值计算。</p>
<h3><span id="lt一gt查找算法13个判断容器中是否包含某个值">&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值</span></h3><p>adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。<br>    binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。<br>    count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。<br>    count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。<br>    equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示                upper_bound。<br>    find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。<br>    find_end: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代替等于操作。<br>    find_first_of: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。<br>    find_if: 使用输入的函数代替等于操作符执行find。<br>    lower_bound: 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。<br>    upper_bound: 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。<br>    search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。<br>    search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。</p>
<h3><span id="lt二gt排序和通用算法14个提供元素排序策略">&lt;二&gt;排序和通用算法(14个)：提供元素排序策略</span></h3><p>inplace_merge: 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。<br>    merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。<br>    nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。<br>    partial_sort: 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。<br>    partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。<br>    partition: 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。<br>    random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。<br>    reverse: 将指定范围内元素重新反序排序。<br>    reverse_copy: 与reverse类似，不过将结果写入另一个容器。<br>    rotate: 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。<br>    rotate_copy: 与rotate类似，不过将结果写入另一个容器。<br>    sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。<br>    stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。<br>    stable_partition: 与partition类似，不过不保证保留容器中的相对顺序。</p>
<h3><span id="lt三gt删除和替换算法15个">&lt;三&gt;删除和替换算法(15个)</span></h3><p>copy: 复制序列<br>    copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。<br>    iter_swap: 交换两个ForwardIterator的值。<br>    remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。<br>    remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。<br>    remove_if: 删除指定范围内输入操作结果为true的所有元素。<br>    remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。<br>    replace: 将指定范围内所有等于vold的元素都用vnew代替。<br>    replace_copy: 与replace类似，不过将结果写入另一个容器。<br>    replace_if: 将指定范围内所有操作结果为true的元素用新值代替。<br>    replace_copy_if: 与replace_if，不过将结果写入另一个容器。<br>    swap: 交换存储在两个对象中的值。<br>    swap_range: 将指定范围内的元素与另一个序列元素值进行交换。<br>    unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。<br>    unique_copy: 与unique类似，不过把结果输出到另一个容器。</p>
<h3><span id="lt四gt排列组合算法2个提供计算给定集合按一定顺序的所有可能排列组合">&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合</span></h3><p>next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。<br>    prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。</p>
<h3><span id="lt五gt算术算法4个">&lt;五&gt;算术算法(4个)</span></h3><p>accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。<br>    partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。<br>    inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。<br>    adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。</p>
<h3><span id="lt六gt生成和异变算法6个">&lt;六&gt;生成和异变算法(6个)</span></h3><p>fill: 将输入值赋给标志范围内的所有元素。<br>    fill_n: 将输入值赋给first到first+n范围内的所有元素。<br>    for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。<br>    generate: 连续调用输入的函数来填充指定的范围。<br>    generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。<br>    transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。</p>
<h3><span id="lt七gt关系算法8个">&lt;七&gt;关系算法(8个)</span></h3><p>equal: 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。<br>    includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。<br>    lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。<br>    max: 返回两个元素中较大一个。重载版本使用自定义比较操作。<br>    max_element: 返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。<br>    min: 返回两个元素中较小一个。重载版本使用自定义比较操作。<br>    min_element: 返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。<br>    mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。</p>
<h3><span id="lt八gt集合算法4个">&lt;八&gt;集合算法(4个)</span></h3><p>set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。<br>    set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。<br>    set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。<br>    set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。</p>
<h3><span id="lt九gt堆算法4个">&lt;九&gt;堆算法(4个)</span></h3><p>make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。<br>    pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。<br>    push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。<br>    sort_heap: 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。</p>
<p>……</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/02/27/Java基础-初窥门径/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/Java基础-初窥门径/" itemprop="url">Java基础 初窥门径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-27T19:26:55+08:00">
                2019-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#1java的基本数据类型">1.Java的基本数据类型：</a><ul>
<li><a href="#对应的包装类">对应的包装类：</a></li>
<li><a href="#基本数据类型的默认值">基本数据类型的默认值：</a></li>
</ul>
</li>
<li><a href="#2java分支循环">2.Java分支循环：</a><ul>
<li><a href="#分支语句">分支语句：</a><ul>
<li><a href="#if语句">if语句：</a></li>
<li><a href="#switch语句">switch语句：</a></li>
<li><a href="#三目运算符">三目运算符：</a></li>
<li><a href="#转义符">转义符：</a></li>
</ul>
</li>
<li><a href="#循环语句">循环语句：</a><ul>
<li><a href="#for循环">for循环：</a></li>
<li><a href="#while语句">while语句：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3string-stringbuffer-stringbuilder">3.String、StringBuffer、StringBuilder：</a><ul>
<li><a href="#区别">区别：</a></li>
<li><a href="#string对象">String对象：</a><ul>
<li><a href="#string本质">String本质：</a></li>
<li><a href="#常量池">常量池：</a></li>
<li><a href="#实例">实例：</a></li>
</ul>
</li>
<li><a href="#stringbuffer字符串变量线程安全是一个容器最终会通过tostring方法变成字符串">StringBuffer字符串变量（线程安全）是一个容器，最终会通过toString方法变成字符串：</a></li>
<li><a href="#stringbuilder-字符串变量非线程安全">StringBuilder 字符串变量（非线程安全）：</a></li>
<li><a href="#string与stringbuffer区别">String与StringBuffer区别：</a><ul>
<li><a href="#在修改的时候对象自身是否改变">在修改的时候对象自身是否改变：</a></li>
<li><a href="#是否可变测试">是否可变测试：</a></li>
<li><a href="#初始化区别">初始化区别：</a></li>
<li><a href="#stringbuffer对象和string对象之间的互转">StringBuffer对象和String对象之间的互转:</a></li>
<li><a href="#偏重">偏重：</a></li>
<li><a href="#总结">总结：</a></li>
</ul>
</li>
<li><a href="#stringbuffer与stringbuilder区别">StringBuffer与StringBuilder区别：</a></li>
</ul>
</li>
<li><a href="#4正则表达式">4.正则表达式：</a><ul>
<li><a href="#11正则表达式的含义">1.1正则表达式的含义：</a></li>
<li><a href="#12具体实例">1.2具体实例：</a></li>
<li><a href="#13常见的匹配符号">1.3常见的匹配符号：</a></li>
<li><a href="#14元字符">1.4元字符：</a></li>
<li><a href="#15限定符">1.5限定符：</a></li>
<li><a href="#16分组和反向引用">1.6分组和反向引用：</a></li>
<li><a href="#17仅分组却无反向引用">1.7仅分组却无反向引用：</a></li>
<li><a href="#18分组的反向引用副本">1.8分组的反向引用副本：</a></li>
<li><a href="#19否定先行断言">1.9否定先行断言：</a></li>
<li><a href="#110指定正则表达式的模式">1.10指定正则表达式的模式：</a></li>
<li><a href="#111java中的反斜杠">1.11java中的反斜杠：</a></li>
<li><a href="#112易错">1.12易错：</a></li>
<li><a href="#113内置的字符串正则处理方法">1.13内置的字符串正则处理方法：</a></li>
<li><a href="#114模式和匹配">1.14：模式和匹配：</a></li>
<li><a href="#115几个常用的例子">1.15：几个常用的例子：</a><ul>
<li><a href="#1中文的匹配">1）中文的匹配：</a></li>
<li><a href="#2数字范围的匹配">2）数字范围的匹配：</a></li>
<li><a href="#3img标签的匹配">3）img标签的匹配：</a></li>
<li><a href="#4贪婪与非贪婪模式的匹配">4）贪婪与非贪婪模式的匹配：</a></li>
</ul>
</li>
<li><a href="#116在线正则工具">1.16：在线正则工具：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="1java的基本数据类型">1.Java的基本数据类型：</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">整型 byte（字节型） short（短整型） int long（长整型）</span><br><span class="line"></span><br><span class="line">浮点型 float（单精度浮点型） double（双精度浮点型）</span><br><span class="line"></span><br><span class="line">逻辑型 boolean(它只有两个值可取 true false)</span><br><span class="line"></span><br><span class="line">字符型 char</span><br></pre></td></tr></table></figure>
<h3><span id="对应的包装类">对应的包装类：</span></h3><p>java.lang.Byte、java.lang.Short、java.lang.Integer、java.lang.Long、java.lang.Float、java.lang.Double、java.lang.Boolean、java.lang.Character.</p>
<h3><span id="基本数据类型的默认值">基本数据类型的默认值：</span></h3><p><img src="/2019/02/27/Java基础-初窥门径/基本数据类型默认值.jpg" alt=""></p>
<h2><span id="2java分支循环">2.Java分支循环：</span></h2><h3><span id="分支语句">分支语句：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">顺序语句</span><br><span class="line">分支语句</span><br><span class="line">循环语句</span><br></pre></td></tr></table></figure>
<h4><span id="if语句">if语句：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(boolean类型表达式)&#123;</span><br><span class="line"></span><br><span class="line">         语句1</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">         语句2</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="switch语句">switch语句：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">switch(变量)&#123;</span><br><span class="line"></span><br><span class="line">         case常量1:语句1;break;</span><br><span class="line"></span><br><span class="line">         case常量2:语句2;break;</span><br><span class="line"></span><br><span class="line">         case常量3:</span><br><span class="line"></span><br><span class="line">                   语句3;</span><br><span class="line"></span><br><span class="line">                   break;</span><br><span class="line"></span><br><span class="line">         default:</span><br><span class="line"></span><br><span class="line">                   语句0;</span><br><span class="line"></span><br><span class="line">                   break;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">注：default可以忽略掉~</span><br></pre></td></tr></table></figure>
<h4><span id="三目运算符">三目运算符：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表达式1?表达式2:表达式3</span><br><span class="line"></span><br><span class="line">表达式1是布尔类型的，右边的问号表示判断它是true还是false，如果是true，整个表达式返回表达式2，如果是false整个表达式返回表达式3</span><br></pre></td></tr></table></figure>
<h4><span id="转义符">转义符：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">回车(return)  &apos;\r&apos;    13</span><br><span class="line"></span><br><span class="line">换行(nextLine)  &apos;\n&apos;  10</span><br><span class="line"></span><br><span class="line">(在windows中执行换行动作用\r\n；在linux中执行换行动作用\n)</span><br><span class="line"></span><br><span class="line">制表(tab)     &apos;\t&apos; (可以用来对齐打印的文字)</span><br><span class="line"></span><br><span class="line">双引号        &apos;\&quot;&apos; (反斜杠+双引号表示双引号字符)</span><br><span class="line"></span><br><span class="line">单引号        &apos;\&apos;&apos; (反斜杠+单引号表示单引号字符)</span><br><span class="line"></span><br><span class="line">反斜杠        &apos;\\&apos; (两个反斜杠表示一个反斜杠)</span><br></pre></td></tr></table></figure>
<h3><span id="循环语句">循环语句：</span></h3><h4><span id="for循环">for循环：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for(表达式1;表达式2;表达式3)&#123;</span><br><span class="line"></span><br><span class="line">         语句</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">表达式1  在循环开始前执行一次，一般用于初始化</span><br><span class="line"></span><br><span class="line">表达式2  循环条件，一般为boolean类型，为true则循环继续，为false则循环终止(不写则表示一直为true)</span><br><span class="line"></span><br><span class="line">表达式3  每次循环在语句执行完后执行，一般用于对循环条件进行变更</span><br></pre></td></tr></table></figure>
<h4><span id="while语句">while语句：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">while(条件)&#123;</span><br><span class="line"></span><br><span class="line">         语句</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当条件为true时，不停地执行语句</span><br><span class="line"></span><br><span class="line">do...while语句</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line"></span><br><span class="line">         语句</span><br><span class="line"></span><br><span class="line">&#125;while(条件);</span><br><span class="line"></span><br><span class="line">和while逻辑一样，但是会先执行语句，再判断。</span><br><span class="line"></span><br><span class="line">do...while在任何情况下至少执行一次语句。</span><br></pre></td></tr></table></figure>
<h2><span id="3string-stringbuffer-stringbuilder">3.String、StringBuffer、StringBuilder：</span></h2><h3><span id="区别">区别：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String对象是常量，它的值不能被创建后改变，StringBuffer和StringBuilder可以可变；</span><br><span class="line">StringBuilder非线程安全（单线程使用），String与StringBuffer线程安全（多线程使用）；</span><br><span class="line">如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。</span><br></pre></td></tr></table></figure>
<h3><span id="string对象">String对象：</span></h3><h4><span id="string本质">String本质：</span></h4><p>String是<strong>值不可变的常量</strong>，是<strong>线程安全</strong>的。</p>
<p>String类使用了final修饰符，String类是<strong>不可继承的</strong>。</p>
<h4><span id="常量池">常量池：</span></h4><p>常量池是一个内存空间，不同于使用new关键字创建的对象所在的堆空间。</p>
<p> 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复创建相等变量时节省了很多时间。</p>
<p>在编译期被确定，并被保存在已编译的.class文件中的一些数据，包括类、方法、接口等中的常量和字符串常量。常量池还具备动态性，运行期间可以将新的常量放入池中。java中基本类型的包装类的大部分都实现了常量池技术， 即Byte,Short,Integer,Long,Character,Boolean；</p>
<h4><span id="实例">实例：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;s1&quot;) ; </span><br><span class="line">String s2 = new String(&quot;s1&quot;) ;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 3个，编译期在常量池中创建1个，即“s1”常量对象；运行期堆中创建2个，即s1和s2对象。</span><br><span class="line">String s1 = &quot;s1&quot;;  </span><br><span class="line">String s2 = s1;  </span><br><span class="line">s2 = &quot;s2&quot;;</span><br></pre></td></tr></table></figure>
<h3><span id="stringbuffer字符串变量线程安全是一个容器最终会通过tostring方法变成字符串">StringBuffer字符串变量（线程安全）是一个容器，最终会通过toString方法变成字符串：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuffer extends AbstractStringBuilder implements Serializable, Appendable, CharSequence &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Constructs a string buffer with no characters in it and an initial capacity of 16 characters.</span><br><span class="line">     */</span><br><span class="line">    public StringBuffer() &#123;</span><br><span class="line">        super(16);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized StringBuffer append(int i) &#123;</span><br><span class="line">        super.append(i);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized StringBuffer delete(int start, int end) &#123;</span><br><span class="line">        super.delete(start, end);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="stringbuilder-字符串变量非线程安全">StringBuilder 字符串变量（非线程安全）：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, Appendable, CharSequence &#123;</span><br><span class="line">   public StringBuilder() &#123;</span><br><span class="line">        super(16);</span><br><span class="line">   &#125;</span><br><span class="line">   public StringBuilder append(String str) &#123;</span><br><span class="line">        super.append(str);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">	public StringBuilder delete(int start, int end) &#123;</span><br><span class="line">        super.delete(start, end);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="string与stringbuffer区别">String与StringBuffer区别：</span></h3><h4><span id="在修改的时候对象自身是否改变">在修改的时候对象自身是否改变：</span></h4><p>（1） String在修改时不会改变对象自身<br>　　在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;abc&quot;;//地址str1</span><br><span class="line">str = &quot;def&quot;;//地址str2</span><br></pre></td></tr></table></figure>
<p>（2） StringBuffer在修改时会改变对象自身<br>　　每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。StringBuffer 上的主要操作是 append 和 insert 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer strBuffer = new StringBuffer(&quot;abc&quot;);//地址strBuffer,值是abc</span><br><span class="line">strBuffer.append(&quot;def&quot;);//地址strBuffer,值是abcdef</span><br></pre></td></tr></table></figure>
<h4><span id="是否可变测试">是否可变测试：</span></h4><p>String的地址已改变，对象已经改变为另一个；StringBuffer地址不变，还是同样的对象。</p>
<h4><span id="初始化区别">初始化区别：</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String：</span><br><span class="line">StringBuffer s = null;   </span><br><span class="line">StringBuffer s = “abc”;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer：</span><br><span class="line">StringBuffer s = null; //结果警告：Null pointer access: The variable result can only be null at this location</span><br><span class="line">StringBuffer s = new StringBuffer();//StringBuffer对象是一个空的对象</span><br><span class="line">StringBuffer s = new StringBuffer(“abc”);//创建带有内容的StringBuffer对象,对象的内容就是字符串”abc”</span><br></pre></td></tr></table></figure>
<h4><span id="stringbuffer对象和string对象之间的互转">StringBuffer对象和String对象之间的互转:</span></h4><p>他们属于不同的类型，不能直接进行强制类型转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = “abc”;</span><br><span class="line">StringBuffer sb1 = new StringBuffer(“123”);</span><br><span class="line">StringBuffer sb2 = new StringBuffer(s);   //String转换为StringBuffer</span><br><span class="line">String s1 = sb1.toString();              //StringBuffer转换为String</span><br></pre></td></tr></table></figure>
<h4><span id="偏重">偏重：</span></h4><p>StringBuffer类中的方法主要偏重于对于字符串的变化，例如追加、插入和删除等，常用方法有：append方法、insert方法、deleteCharAt方法、reverse方法等。</p>
<h4><span id="总结">总结：</span></h4><p>（1）如果要操作少量的数据用 String；<br>       （2）（多线程下）经常需要对一个字符串进行修改，例如追加、插入和删除等操作，使用StringBuffer要更加适合一些。</p>
<h3><span id="stringbuffer与stringbuilder区别">StringBuffer与StringBuilder区别：</span></h3><p>1.StringBuilder是一个可变的对象，是5.0新增的，提供一个与StringBuffer兼容的API，但不保证同步，主要是用在字符串缓冲区被单个线程使用的时候。</p>
<p>2.线程安全性：</p>
<p>​    StringBuffer：线程安全。</p>
<p>​    StringBuilder：线程非安全。</p>
<p>3.大部分情况下：StringBuffer&gt;String</p>
<p>同时由于String对象不可变，重复新建对象：StringBuffer对象可变。</p>
<p>4.StringBuilder&gt;StringBuffer</p>
<p>当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的。</p>
<p>5.特殊情况下，String&gt;StringBuffer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//String效率是远要比StringBuffer快的：</span><br><span class="line">String S1 = “This is only a” + “ simple” + “ test”;</span><br><span class="line">StringBuffer Sb = new StringBuilder(“This is only a”).append(“simple”).append(“ test”);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//String速度是非常慢的：</span><br><span class="line">String S2 = “This is only a”;</span><br><span class="line">String S3 = “ simple”;</span><br><span class="line">String S4 = “ test”;</span><br><span class="line">String S1 = S2 +S3 + S4;</span><br></pre></td></tr></table></figure>
<p>6.总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）如果要操作少量的数据用 String；</span><br><span class="line">（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；</span><br><span class="line">（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/chenliguan/article/details/51911906" target="_blank" rel="noopener">参考链接</a></p>
<h2><span id="4正则表达式">4.正则表达式：</span></h2><h3><span id="11正则表达式的含义">1.1正则表达式的含义：</span></h3><p>定义一个搜索模式的字符串。</p>
<p>正则表达式可以用于搜索、编辑和操作文本。</p>
<p>分析过程：首先正则表达式应用的是文本字符串（text/string），它会以定义的模式从左到右匹配文本，每个源字符只匹配一次。</p>
<h3><span id="12具体实例">1.2具体实例：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this is text	精确匹配字符串 &quot;this is text&quot;</span><br><span class="line">this\s+is\s+text	匹配单词 &quot;this&quot; 后跟一个或多个空格字符，后跟词 &quot;is&quot; 后跟一个或多个空格字符，后跟词 &quot;text&quot;</span><br><span class="line">^\d+(\.\d+)?	^ 定义模式必须匹配字符串的开始，d+ 匹配一个或多个数字，? 表明小括号内的语句是可选的，\. 匹配 &quot;.&quot;，小括号表示分组。例如匹配：&quot;5&quot;、&quot;1.5&quot; 和 &quot;2.21&quot;</span><br></pre></td></tr></table></figure>
<h3><span id="13常见的匹配符号">1.3常见的匹配符号：</span></h3><table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>匹配所有单个字符，除了换行符（Linux 中换行是 <code>\n</code>，Windows 中换行是 <code>\r\n</code>）</td>
</tr>
<tr>
<td><code>^regex</code></td>
<td>正则必须匹配字符串开头</td>
</tr>
<tr>
<td><code>regex$</code></td>
<td>正则必须匹配字符串结尾</td>
</tr>
<tr>
<td><code>[abc]</code></td>
<td>复选集定义，匹配字母 a 或 b 或 c</td>
</tr>
<tr>
<td><code>[abc][vz]</code></td>
<td>复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z</td>
</tr>
<tr>
<td><code>[^abc]</code></td>
<td>当插入符 <code>^</code> 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c</td>
</tr>
<tr>
<td><code>[a-d1-7]</code></td>
<td>范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间，但不匹配 d1</td>
</tr>
<tr>
<td><code>XZ</code></td>
<td>匹配 X 后直接跟着 Z</td>
</tr>
<tr>
<td>X\</td>
<td>Z</td>
<td>匹配 X 或 Z</td>
</tr>
</tbody>
</table>
<h3><span id="14元字符">1.4元字符：</span></h3><table>
<thead>
<tr>
<th>正则表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\d</code></td>
<td>匹配一个数字，是 <code>[0-9]</code> 的简写</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配一个非数字，是 <code>[^0-9]</code> 的简写</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配一个空格，是 <code>[ \t\n\x0b\r\f]</code> 的简写</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配一个非空格</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配一个单词字符（大小写字母、数字、下划线），是 <code>[a-zA-Z_0-9]</code> 的简写</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 <code>[^\w]</code></td>
</tr>
</tbody>
</table>
<h3><span id="15限定符">1.5限定符：</span></h3><p>限定符定义了一个元素可以发生的频率。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>正则表达式</td>
<td>描述</td>
<td>举例</td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配 &gt;=0 个，是 <code>{0,}</code> 的简写</td>
<td><code>X*</code> 表示匹配零个或多个字母 X，<code>.*</code>表示匹配任何字符串</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配 &gt;=1 个，是 <code>{1,}</code> 的简写</td>
<td><code>X+</code> 表示匹配一个或多个字母 X</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配 1 个或 0 个，是 <code>{0,1}</code> 的简写</td>
<td><code>X?</code> 表示匹配 0 个或 1 个字母 X</td>
</tr>
<tr>
<td><code>{X}</code></td>
<td>只匹配 X 个字符</td>
<td><code>\d{3}</code> 表示匹配 3 个数字，<code>.{10}</code>表示匹配任何长度是 10 的字符串</td>
</tr>
<tr>
<td><code>{X,Y}</code></td>
<td>匹配 &gt;=X 且 &lt;=Y 个</td>
<td><code>\d{1,4}</code> 表示匹配至少 1 个最多 4 个数字</td>
</tr>
<tr>
<td><code>*?</code></td>
<td>如果 <code>?</code> 是限定符 <code>*</code> 或 <code>+</code> 或 <code>?</code> 或 <code>{}</code> 后面的第一个字符，那么表示<strong>非贪婪模式</strong>（尽可能少的匹配字符），而不是默认的<strong>贪婪模式</strong></td>
</tr>
</tbody>
</table>
<h3><span id="16分组和反向引用">1.6分组和反向引用：</span></h3><p>小括号 <code>()</code> 可以达到对正则表达式进行分组的效果。</p>
<p>模式分组后会在正则表达式中创建<strong>反向引用</strong>。反向引用会保存匹配模式分组的字符串片断，这使得我们可以获取并使用这个字符串片断。</p>
<p>在以正则表达式替换字符串的语法中，是通过 <code>$</code> 来引用分组的反向引用，<code>$0</code> 是匹配完整模式的字符串（注意在 JavaScript 中是用 <code>$&amp;</code> 表示）；<code>$1</code> 是第一个分组的反向引用；<code>$2</code> 是第二个分组的反向引用，以此类推。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.wuxianjiezh.demo.regex;</span><br><span class="line"></span><br><span class="line">public class RegexTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 去除单词与 , 和 . 之间的空格</span><br><span class="line">        String Str = &quot;Hello , World .&quot;;</span><br><span class="line">        String pattern = &quot;(\\w)(\\s+)([.,])&quot;;</span><br><span class="line">        // $0 匹配 `(\w)(\s+)([.,])` 结果为 `o空格,` 和 `d空格.`</span><br><span class="line">        // $1 匹配 `(\w)` 结果为 `o` 和 `d`</span><br><span class="line">        // $2 匹配 `(\s+)` 结果为 `空格` 和 `空格`</span><br><span class="line">        // $3 匹配 `([.,])` 结果为 `,` 和 `.`</span><br><span class="line">        System.out.println(Str.replaceAll(pattern, &quot;$1$3&quot;)); // Hello, World.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们使用了 <code>[.]</code> 来匹配普通字符 <code>.</code> 而不需要使用 <code>[\\.]</code>。因为正则对于 <code>[]</code> 中的 <code>.</code>，会自动处理为 <code>[\.]</code>，即普通字符 <code>.</code> 进行匹配。</p>
<h3><span id="17仅分组却无反向引用">1.7仅分组却无反向引用：</span></h3><p>当我们在小括号 <code>()</code> 内的模式开头加入 <code>?:</code>，那么表示这个模式仅分组，但不创建反向引用。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.wuxianjiezh.regex;</span><br><span class="line"></span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class RegexTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = &quot;img.jpg&quot;;</span><br><span class="line">        // 分组且创建反向引用</span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;(jpg|png)&quot;);</span><br><span class="line">        Matcher matcher = pattern.matcher(str);</span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">            System.out.println(matcher.group(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jpg</span><br><span class="line">jpg</span><br></pre></td></tr></table></figure>
<p>若源码改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.wuxianjiezh.regex;</span><br><span class="line"></span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class RegexTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = &quot;img.jpg&quot;;</span><br><span class="line">        // 分组但不创建反向引用</span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;(?:jpg|png)&quot;);</span><br><span class="line">        Matcher matcher = pattern.matcher(str);</span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">            System.out.println(matcher.group(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jpg</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: No group 1</span><br><span class="line">    at java.util.regex.Matcher.group(Matcher.java:538)</span><br><span class="line">    at com.wuxianjiezh.regex.RegexTest.main(RegexTest.java:15)</span><br></pre></td></tr></table></figure>
<h3><span id="18分组的反向引用副本">1.8分组的反向引用副本：</span></h3><p>Java 中可以在小括号中使用 <code>?&lt;name&gt;</code> 将小括号中匹配的内容保存为一个名字为 name 的副本。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.wuxianjiezh.regex;</span><br><span class="line"></span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class RegexTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = &quot;@wxj 你好啊&quot;;</span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;@(?&lt;first&gt;\\w+\\s)&quot;); // 保存一个副本</span><br><span class="line">        Matcher matcher = pattern.matcher(str);</span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">            System.out.println(matcher.group(1));</span><br><span class="line">            System.out.println(matcher.group(&quot;first&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@wxj </span><br><span class="line">wxj </span><br><span class="line">wxj</span><br></pre></td></tr></table></figure>
<h3><span id="19否定先行断言">1.9否定先行断言：</span></h3><p>我们可以创建否定先行断言模式的匹配，即某个字符串后面不包含另一个字符串的匹配模式。</p>
<p>否定先行断言模式通过 <code>(?!pattern)</code> 定义。比如，我们匹配后面不是跟着 “b” 的 “a”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(?!b)</span><br></pre></td></tr></table></figure>
<h3><span id="110指定正则表达式的模式">1.10指定正则表达式的模式：</span></h3><p>可以在正则的<strong>开头</strong>指定模式修饰符。</p>
<ul>
<li><code>(?i)</code> 使正则忽略大小写。</li>
<li><code>(?s)</code> 表示<em>单行模式</em>（”single line mode”）使正则的 <code>.</code> 匹配所有字符，包括换行符。</li>
<li><code>(?m)</code> 表示<em>多行模式</em>（”multi-line mode”），使正则的 <code>^</code> 和 <code>$</code> 匹配字符串中每行的开始和结束。</li>
</ul>
<h3><span id="111java中的反斜杠">1.11java中的反斜杠：</span></h3><p>反斜杠 <code>\</code> 在 Java 中表示转义字符，这意味着 <code>\</code> 在 Java 拥有预定义的含义。</p>
<p>这里例举两个特别重要的用法：</p>
<ul>
<li>在匹配 <code>.</code> 或 <code>{</code> 或 <code>[</code> 或 <code>(</code> 或 <code>?</code> 或 <code>$</code> 或 <code>^</code> 或 <code>*</code> 这些特殊字符时，需要在前面加上 <code>\\</code>，比如匹配 <code>.</code> 时，Java 中要写为 <code>\\.</code>，但对于正则表达式来说就是 <code>\.</code>。</li>
<li>在匹配 <code>\</code> 时，Java 中要写为 <code>\\\\</code>，但对于正则表达式来说就是 <code>\\</code>。</li>
</ul>
<p><strong>注意</strong>：Java 中的正则表达式字符串有两层含义，首先 Java 字符串转义出符合正则表达式语法的字符串，然后再由转义后的正则表达式进行模式匹配。</p>
<h3><span id="112易错">1.12易错：</span></h3><ul>
<li><code>[jpg|png]</code> 代表匹配 <code>j</code> 或 <code>p</code> 或 <code>g</code> 或 <code>p</code> 或 <code>n</code> 或 <code>g</code> 中的任意一个字符。</li>
<li><code>(jpg|png)</code> 代表匹配 <code>jpg</code> 或 <code>png</code>。</li>
</ul>
<h3><span id="113内置的字符串正则处理方法">1.13内置的字符串正则处理方法：</span></h3><p>在 Java 中有四个内置的运行正则表达式的方法，分别是 <code>matches()</code>、<code>split())</code>、<code>replaceFirst()</code>、<code>replaceAll()</code>。注意 <code>replace()</code> 方法不支持正则表达式。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s.matches(&quot;regex&quot;)</code></td>
<td>当仅且当正则匹配整个字符串时返回 <code>true</code></td>
</tr>
<tr>
<td><code>s.split(&quot;regex&quot;)</code></td>
<td>按匹配的正则表达式切片字符串</td>
</tr>
<tr>
<td><code>s.replaceFirst(&quot;regex&quot;, &quot;replacement&quot;)</code></td>
<td>替换首次匹配的字符串片段</td>
</tr>
<tr>
<td><code>s.replaceAll(&quot;regex&quot;, &quot;replacement&quot;)</code></td>
<td>替换所有匹配的字符</td>
</tr>
</tbody>
</table>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.wuxianjiezh.regex;</span><br><span class="line"></span><br><span class="line">public class RegexTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;wxj&quot;.matches(&quot;wxj&quot;));</span><br><span class="line">        System.out.println(&quot;----------&quot;);</span><br><span class="line"></span><br><span class="line">        String[] array = &quot;w x j&quot;.split(&quot;\\s&quot;);</span><br><span class="line">        for (String item : array) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;----------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;w x j&quot;.replaceFirst(&quot;\\s&quot;, &quot;-&quot;));</span><br><span class="line">        System.out.println(&quot;----------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;w x j&quot;.replaceAll(&quot;\\s&quot;, &quot;-&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">----------</span><br><span class="line">w</span><br><span class="line">x</span><br><span class="line">j</span><br><span class="line">----------</span><br><span class="line">w-x j</span><br><span class="line">----------</span><br><span class="line">w-x-j</span><br></pre></td></tr></table></figure>
<h3><span id="114模式和匹配">1.14：模式和匹配：</span></h3><p>Java 中使用正则表达式需要用到两个类，分别为 <code>java.util.regex.Pattern</code> 和 <code>java.util.regex.Matcher</code>。</p>
<p>第一步，通过正则表达式创建模式对象 <code>Pattern</code>。</p>
<p>第二步，通过模式对象 <code>Pattern</code>，根据指定字符串创建匹配对象 <code>Matcher</code>。</p>
<p>第三步，通过匹配对象 <code>Matcher</code>，根据正则表达式操作字符串。</p>
<p>来个例子，加深理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.wuxianjiezh.regex;</span><br><span class="line"></span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class RegexTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String text = &quot;Hello Regex!&quot;;</span><br><span class="line"></span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;\\w+&quot;);</span><br><span class="line">        // Java 中忽略大小写，有两种写法：</span><br><span class="line">        // Pattern pattern = Pattern.compile(&quot;\\w+&quot;, Pattern.CASE_INSENSITIVE);</span><br><span class="line">        // Pattern pattern = Pattern.compile(&quot;(?i)\\w+&quot;); // 推荐写法</span><br><span class="line">        Matcher matcher = pattern.matcher(text);</span><br><span class="line">        // 遍例所有匹配的序列</span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            System.out.print(&quot;Start index: &quot; + matcher.start());</span><br><span class="line">            System.out.print(&quot; End index: &quot; + matcher.end() + &quot; &quot;);</span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建第两个模式，将空格替换为 tab</span><br><span class="line">        Pattern replace = Pattern.compile(&quot;\\s+&quot;);</span><br><span class="line">        Matcher matcher2 = replace.matcher(text);</span><br><span class="line">        System.out.println(matcher2.replaceAll(&quot;\t&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Start index: 0 End index: 5 Hello</span><br><span class="line">Start index: 6 End index: 11 Regex</span><br><span class="line">Hello    Regex!</span><br></pre></td></tr></table></figure>
<h3><span id="115几个常用的例子">1.15：几个常用的例子：</span></h3><h4><span id="1中文的匹配">1）中文的匹配：</span></h4><p><code>[\u4e00-\u9fa5]+</code> 代表匹配中文字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.wuxianjiezh.regex;</span><br><span class="line"></span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class RegexTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = &quot;閑人到人间&quot;;</span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;[\\u4e00-\\u9fa5]+&quot;);</span><br><span class="line">        Matcher matcher = pattern.matcher(str);</span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">閑人到人间</span><br></pre></td></tr></table></figure>
<h4><span id="2数字范围的匹配">2）数字范围的匹配：</span></h4><p>比如，匹配 1990 到 2017。</p>
<p><strong>注意：</strong>这里有个新手易范的错误，就是正则 <code>[1990-2017]</code>，实际这个正则只匹配 <code>0</code> 或 <code>1</code> 或 <code>2</code> 或 <code>7</code> 或 <code>9</code> 中的任一个字符。</p>
<p>正则表达式匹配数字范围时，首先要确定最大值与最小值，最后写中间值。</p>
<p>正确的匹配方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.wuxianjiezh.regex;</span><br><span class="line"></span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class RegexTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = &quot;1990\n2010\n2017&quot;;</span><br><span class="line">        // 这里应用了 (?m) 的多行匹配模式，只为方便我们测试输出</span><br><span class="line">        // &quot;^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$&quot; 为判断 1990-2017 正确的正则表达式</span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;(?m)^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$&quot;);</span><br><span class="line">        Matcher matcher = pattern.matcher(str);</span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1990</span><br><span class="line">2010</span><br><span class="line">2017</span><br></pre></td></tr></table></figure>
<h4><span id="3img标签的匹配">3）img标签的匹配：</span></h4><p>比如，获取图片文件内容，这里我们考虑了一些不规范的 img 标签写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.wuxianjiezh.regex;</span><br><span class="line"></span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class RegexTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = &quot;&lt;img  src=&apos;aaa.jpg&apos; /&gt;&lt;img src=bbb.png/&gt;&lt;img src=\&quot;ccc.png\&quot;/&gt;&quot; +</span><br><span class="line">                &quot;&lt;img src=&apos;ddd.exe&apos;/&gt;&lt;img src=&apos;eee.jpn&apos;/&gt;&quot;;</span><br><span class="line">        // 这里我们考虑了一些不规范的 img 标签写法，比如：空格、引号</span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;&lt;img\\s+src=(?:[&apos;\&quot;])?(?&lt;src&gt;\\w+.(jpg|png))(?:[&apos;\&quot;])?\\s*/&gt;&quot;);</span><br><span class="line">        Matcher matcher = pattern.matcher(str);</span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group(&quot;src&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaa.jpg</span><br><span class="line">bbb.png</span><br><span class="line">ccc.png</span><br></pre></td></tr></table></figure>
<h4><span id="4贪婪与非贪婪模式的匹配">4）贪婪与非贪婪模式的匹配：</span></h4><p>比如，获取 div 标签中的文本内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.wuxianjiezh.regex;</span><br><span class="line"></span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class RegexTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = &quot;&lt;div&gt;文章标题&lt;/div&gt;&lt;div&gt;发布时间&lt;/div&gt;&quot;;</span><br><span class="line">        // 贪婪模式</span><br><span class="line">        Pattern pattern = Pattern.compile(&quot;&lt;div&gt;(?&lt;title&gt;.+)&lt;/div&gt;&quot;);</span><br><span class="line">        Matcher matcher = pattern.matcher(str);</span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group(&quot;title&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------------&quot;);</span><br><span class="line"></span><br><span class="line">        // 非贪婪模式</span><br><span class="line">        pattern = Pattern.compile(&quot;&lt;div&gt;(?&lt;title&gt;.+?)&lt;/div&gt;&quot;);</span><br><span class="line">        matcher = pattern.matcher(str);</span><br><span class="line">        while (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group(&quot;title&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文章标题&lt;/div&gt;&lt;div&gt;发布时间</span><br><span class="line">--------------</span><br><span class="line">文章标题</span><br><span class="line">发布时间</span><br></pre></td></tr></table></figure>
<h3><span id="116在线正则工具">1.16：在线正则工具：</span></h3><p><a href="https://regex101.com/" target="_blank" rel="noopener">JavaScript、Python在线表达工具</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/02/26/hexo常用指令（个人向）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/26/hexo常用指令（个人向）/" itemprop="url">hexo常用指令（个人向）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T09:54:55+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/搭建博客/" itemprop="url" rel="index">
                    <span itemprop="name">搭建博客</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  643
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#hexo的常用指令">Hexo的常用指令：</a><ul>
<li><a href="#1新建文章">1.新建文章：</a></li>
<li><a href="#2新建页面">2.新建页面：</a></li>
<li><a href="#3生成静态页面">3.生成静态页面：</a></li>
<li><a href="#4开启本地服务器的端口">4.开启本地服务器的端口：</a></li>
<li><a href="#5部署到网页上">5.部署到网页上：</a></li>
<li><a href="#6清除文件">6.清除文件：</a></li>
<li><a href="#7查看hexo版本">7.查看hexo版本：</a></li>
<li><a href="#8复合指令">8.复合指令：</a></li>
<li><a href="#9卸载hexo">9.卸载hexo：</a></li>
<li><a href="#10如何安装旧版本hexo">10.如何安装旧版本hexo：</a></li>
<li><a href="#特殊操作hexo支持目录">特殊操作：Hexo支持目录：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="hexo的常用指令">Hexo的常用指令：</span></h2><h3><span id="1新建文章">1.新建文章：</span></h3><p>如果文章名包含空格必须加双引号，如果没有则可以不加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;articleName&quot;</span><br></pre></td></tr></table></figure>
<h3><span id="2新建页面">2.新建页面：</span></h3><p>新建一个题为“pageName”的页面，此时会在/source/目录下生成一个名为pageName的文件夹，其中包含一份 index 的md文件；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page &quot;pageName&quot;</span><br></pre></td></tr></table></figure>
<h3><span id="3生成静态页面">3.生成静态页面：</span></h3><p>主要是为了方便调试自己的博客，在未发布之前检查是否有问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<h3><span id="4开启本地服务器的端口">4.开启本地服务器的端口：</span></h3><p>开启预览访问的端口，默认端口为4000。<br>关闭server使用 ctrl + c。</p>
<p>本地网址如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost：4000</span><br></pre></td></tr></table></figure>
<p>命令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>在使用hexo server 可能会遇到端口被占用的情况，不妨使用以下指令来更改端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server -p 4001</span><br></pre></td></tr></table></figure>
<h3><span id="5部署到网页上">5.部署到网页上：</span></h3><p>将目录下的 .deploy_git 文件夹部署到Github。<br>部署前需要预先 hexo generate 生成静态文件。</p>
<p>关闭server使用 ctrl + c。</p>
<p>“INFO Deploy done: git”时即表示部署已经完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<h3><span id="6清除文件">6.清除文件：</span></h3><p>清除目录下的缓存文件（db.json）和已经生成的静态文件（public）文件。<br>网页正常情况下可以忽略此条命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<h3><span id="7查看hexo版本">7.查看hexo版本：</span></h3><p>查看当前使用的hexo的版本号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure>
<h3><span id="8复合指令">8.复合指令：</span></h3><p>hexo g -d # 等价于 hexo generate –deploy ：生成静态文件并部署。<br>hexo s -d # 等价于 hexo deploy –generate ：开启预览并部署到Github。</p>
<p>简写形式<br>hexo n #等价于 hexo new<br>hexo g #等价于 hexo generate<br>hexo s #等价于 hexo server<br>hexo d #等价于 hexo deploy<br>hexo v #等价于 hexo version</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br><span class="line">$ hexo s -d</span><br></pre></td></tr></table></figure>
<h3><span id="9卸载hexo">9.卸载hexo：</span></h3><p>3.0.0版本执行npm uninstall hexo-cli -g，之前版本执行npm uninstall hexo -g.</p>
<h3><span id="10如何安装旧版本hexo">10.如何安装旧版本hexo：</span></h3><p>先卸载当前版本，以2.8.3为例，执行npm install <a href="mailto:hexo@2.8.3" target="_blank" rel="noopener">hexo@2.8.3</a> -g，再初始化并安装依赖和插件。</p>
<h3><span id="特殊操作hexo支持目录">特殊操作：Hexo支持目录：</span></h3><p>1.安装hexo-toc插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-toc --save</span><br></pre></td></tr></table></figure>
<p>2.配置站点配置文件_config.yml：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toc:</span><br><span class="line">  maxdepth: 5</span><br></pre></td></tr></table></figure>
<p>3.使用：</p>
<p>在markdown文章中加入TOC占位符即可自动生成目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- toc --&gt;</span><br></pre></td></tr></table></figure>
<p>4.效果：</p>
<p><img src="/2019/02/26/hexo常用指令（个人向）/效果.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/02/26/android学习路线总结plus/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/26/android学习路线总结plus/" itemprop="url">android学习路线总结plus</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T09:35:42+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/" itemprop="url" rel="index">
                    <span itemprop="name">移动端开发</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#1java-se基础">1.java se基础：</a></li>
<li><a href="#2android-ui编程">2.android UI编程：</a><ul>
<li><a href="#1android初级控件的使用">1）android初级控件的使用：</a></li>
<li><a href="#2android高级控件的使用">2）android高级控件的使用：</a></li>
<li><a href="#3对话框与菜单的使用">3）对话框与菜单的使用：</a></li>
<li><a href="#4控件的布局方法">4）控件的布局方法：</a></li>
<li><a href="#5多activity的管理">5）多activity的管理：</a></li>
<li><a href="#6自定义控件的实现方法">6）自定义控件的实现方法：</a></li>
</ul>
</li>
<li><a href="#3android网络编程以及数据储存">3.android网络编程以及数据储存：</a><ul>
<li><a href="#1基于android平台的http通讯">1）基于android平台的http通讯：</a></li>
<li><a href="#2android数据储存技术">2）android数据储存技术：</a></li>
</ul>
</li>
<li><a href="#4进阶之路">4.进阶之路：</a><ul>
<li><a href="#初级工程师">初级工程师：</a></li>
<li><a href="#中级工程师">中级工程师：</a></li>
<li><a href="#高级工程师">高级工程师：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="1java-se基础">1.java se基础：</span></h2><p>1).Java基本数据类型与表达式，分支循环。<br>2).String和StringBuffer的使用、正则表达式。<br>3).面向对象的抽象，封装，继承，多态，类与对象，对象初始化和回收；构造函数、this关键字、方法和方法的参数传递过程、static关键字、内部类。<br>4).对象实例化过程、方法的覆盖、final关键字、抽象类、接口、继承的优点和缺点剖析；对象的多态性：子类和父类之间的转换、抽象类和接口在多态中的应用、多态带来的好处。<br>5).Java异常处理，异常的机制原理。<br>6).常用的设计模式：Singleton、Template、Strategy模式。<br>7).JavaAPI介绍：种基本数据类型包装类，System和Runtime类，Date和DateFomat类等。<br>8).Java集合介绍：Collection、Set、List、ArrayList、LinkedList、Hashset、Map、HashMap、Iterator等常用集合类API。<br>9).JavaI/O输入输出流：File和FileRandomAccess类，字节流InputStream和OutputStream，字符流Reader和Writer，以及相应实现类，IO性能分析，字节和字符的转化流，包装流的概念，以及常用包装类，计算机编码。<br>10).Java高级特性：反射和泛型。<br>11).多线程原理：如何在程序中创建多线程(Thread、Runnable)，线程安全问题，线程的同步，线程之间的通讯、死锁。</p>
<h2><span id="2android-ui编程">2.android UI编程：</span></h2><h3><span id="1android初级控件的使用">1）android初级控件的使用：</span></h3><p>TextView控件的使用<br>Button控件的使用方法<br>EditText控件的使用方法<br>ImageView的使用方法<br>RadioButton的使用方法<br>Checkbox的使用方法<br>Menu的使用方法</p>
<h3><span id="2android高级控件的使用">2）android高级控件的使用：</span></h3><p>ListView的使用方法<br>GridView的使用方法<br>Adapter的使用方法<br>Spinner的使用方法<br>Gallary的使用方法<br>ScrollView的使用方法<br>RecyclerView</p>
<h3><span id="3对话框与菜单的使用">3）对话框与菜单的使用：</span></h3><p>Dialog的基本概念<br>BlockquoteAlertDialog的使用方法<br>DatePickerDialog的使用方法<br>Menu的使用方法<br>自定义Menu的实现方法</p>
<h3><span id="4控件的布局方法">4）控件的布局方法：</span></h3><p>线性布局的使用方法<br>相对布局的使用方法</p>
<h3><span id="5多activity的管理">5）多activity的管理：</span></h3><p>AndroidManifest.xml文件的作用<br>Intent的使用方法<br>使用Intent传递数据的方法<br>启动Activity的方法<br>IntentFilter的使用方法<br>Activity Group的使用方法</p>
<h3><span id="6自定义控件的实现方法">6）自定义控件的实现方法：</span></h3><p>自定义ListView的实现方法<br>可折叠ListView的使用方法<br>自定义Adapter的实现方法<br>自定义View的实现方法<br>动态控件布局的上实现方法<br>上拉刷新下拉加载更多</p>
<h2><span id="3android网络编程以及数据储存">3.android网络编程以及数据储存：</span></h2><h3><span id="1基于android平台的http通讯">1）基于android平台的http通讯：</span></h3><p>Http协议回顾<br>使用Get方法向服务器提交数据的方法<br>使用POST方法向服务器提交数据的实现方法<br>使用Http协议实现多线程下载<br>使用Http协议实现断点续传</p>
<h3><span id="2android数据储存技术">2）android数据储存技术：</span></h3><p>SQLite3数据库简介<br>SQL语句回顾<br>SQLite3编程接口介绍<br>SQLite3事务管理<br>SQLite3游标使用方法<br>SQLite3性能分析<br>访问SDCard的方法<br>访问SharedPreferences的方法</p>
<h2><span id="4进阶之路">4.进阶之路：</span></h2><h3><span id="初级工程师">初级工程师：</span></h3><ul>
<li>基本知识点<br>比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术</li>
<li>书籍推荐<br>《第一行代码 Android》、《疯狂Android》</li>
</ul>
<h3><span id="中级工程师">中级工程师：</span></h3><ul>
<li>AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别；</li>
<li>Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用；</li>
<li>多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等；</li>
<li>事件分发：弹性滑动、滑动冲突等；</li>
<li>玩转View：View的绘制原理、各种自定义View；</li>
<li>动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理；</li>
<li>懂性能优化、熟悉mat等工具</li>
<li>懂点常见的设计模式</li>
<li>书籍推荐<br>《Android开发艺术探索》、《Android群英传》</li>
</ul>
<h3><span id="高级工程师">高级工程师：</span></h3><ul>
<li>继续加深理解”稍微深入的知识点“中所定义的内容</li>
<li>了解系统核心机制：</li>
</ul>
<ol>
<li>了解SystemServer的启动过程</li>
<li>了解主线程的消息循环模型</li>
<li>了解AMS和PMS的工作原理</li>
<li>能够回答问题”一个应用存在多少个Window？“</li>
<li>了解四大组件的大概工作流程</li>
<li>…</li>
</ol>
<ul>
<li>基本知识点的细节</li>
</ul>
<ol>
<li>Activity的启动模式以及异常情况下不同Activity的表现</li>
<li>Service的onBind和onReBind的关联</li>
<li>onServiceDisconnected(ComponentName className)和binderDied()的区别</li>
<li>AsyncTask在不同版本上的表现细节</li>
<li>线程池的细节和参数配置</li>
<li>…</li>
</ol>
<ul>
<li>熟悉设计模式，有架构意识学习方法</li>
<li>书籍推荐<br>《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》</li>
</ul>
<p><a href="https://www.cnblogs.com/yishaochu/p/5436094.html" target="_blank" rel="noopener">参考链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/01/14/Android学习路线总结（个人向）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/Android学习路线总结（个人向）/" itemprop="url">Android学习路线总结（个人向）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T12:29:30+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/" itemprop="url" rel="index">
                    <span itemprop="name">移动端开发</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#java基础">Java基础：</a></li>
<li><a href="#java高阶">Java高阶：</a></li>
<li><a href="#数据结构及算法">数据结构及算法：</a><ul>
<li><a href="#数据结构">数据结构：</a></li>
<li><a href="#算法">算法：</a></li>
</ul>
</li>
<li><a href="#android基础">Android基础：</a><ul>
<li><a href="#android技术难点">Android技术难点</a></li>
<li><a href="#android框架层源码掌握">Android框架层源码掌握</a></li>
<li><a href="#各种原理经典第三方库源码系列">各种原理，经典第三方库源码系列</a></li>
<li><a href="#android进程通信以及多进程开发">Android进程通信以及多进程开发</a></li>
<li><a href="#android动画机制">Android动画机制</a></li>
<li><a href="#android绘图原理">Android绘图原理</a></li>
<li><a href="#android页面恢复">Android页面恢复</a></li>
<li><a href="#混合开发及android-webview应用">混合开发及Android WebView应用</a></li>
<li><a href="#gradle自动化构建持续集成相关">Gradle，自动化构建，持续集成相关</a></li>
</ul>
</li>
<li><a href="#android系统">Android系统</a><ul>
<li><a href="#android-studio编译过程">Android Studio编译过程</a></li>
</ul>
</li>
<li><a href="#android架构">Android架构：</a></li>
<li><a href="#android优化">Android优化：</a></li>
<li><a href="#移动开发外围">移动开发外围</a><ul>
<li><a href="#服务器开发相关">服务器开发相关</a></li>
<li><a href="#前端开发相关">前端开发相关</a></li>
<li><a href="#开发调试各种工具">开发调试各种工具</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="java基础">Java基础：</span></h2><p>Java Object类方法</p>
<p>HashMap原理，Hash冲突，并发集合，线程安全集合及实现原理</p>
<p>HashMap 和 HashTable 区别</p>
<p>HashCode 作用，如何重载hashCode方法</p>
<p>ArrayList与LinkList区别与联系</p>
<p>GC机制</p>
<p>Java反射机制，Java代理模式</p>
<p>Java泛型</p>
<p>Synchronized原理</p>
<p>Volatile实现原理</p>
<p>方法锁、对象锁、类锁的意义和区别</p>
<p>线程同步的方法：Synchronized、lock、reentrantLock分析</p>
<p>Java锁的种类: 公平锁、乐观锁、互斥锁、分段锁、偏向锁、自旋锁等</p>
<p>ThreadLocal的原理和用法</p>
<p>ThreadPool的用法和示例</p>
<p>wait()和sleep()的区别</p>
<h2><span id="java高阶">Java高阶：</span></h2><p>Java虚拟机，Java运行，Java GC机制（可达性分析法，引用计数法）</p>
<p>Java对象的完整生命周期</p>
<p>JVM内存模型</p>
<p>进程间通信，线程间通信</p>
<p>JVM类加载机制</p>
<p>Java引用类型</p>
<p>设计模式：除常用设计模式之外，特别的，反射机制，代理模式</p>
<p>HTTP协议和HTTPS协议</p>
<p>Socket协议，Socket实现长连接</p>
<p>TCP和UDP协议</p>
<p>HTTP协议中GET和POST的具体实现</p>
<p>序列化和反序列化</p>
<p>线程池的实现原理</p>
<p>数据库基础知识：多表查询、索引、数据库事务</p>
<h2><span id="数据结构及算法">数据结构及算法：</span></h2><h3><span id="数据结构">数据结构：</span></h3><p>栈和队列</p>
<p>数组和链表，自定义一个动态数组</p>
<p>Hash表，及Hash冲突的解决</p>
<p>二叉树</p>
<p>B+ B-树</p>
<p>基础排序算法：重点  快排、归并排序、堆排序（大根堆、小根堆）</p>
<p>快排的优化</p>
<p>二分查找与变种二分查找</p>
<p>哈夫曼树、红黑树</p>
<p>字符串操作，字符串查找，KMP算法</p>
<p>图的BFS、DFS、prim、Dijkstra算法（高阶技能）</p>
<p>经典问题：海量数据的处理  （10亿个数中找出最大的10000个数 TOP K问题）</p>
<h3><span id="算法">算法：</span></h3><p>分治算法</p>
<p>动态规划</p>
<p>贪心算法</p>
<p>分支限界法</p>
<h2><span id="android基础">Android基础：</span></h2><p>Application生命周期</p>
<p>Android Activity生命周期</p>
<p>Android Service、IntentService，Service和组件间通信</p>
<p>Activity的onNewIntent</p>
<p>Fragment的懒加载实现，参数传递与保存</p>
<p>ContentProvider实例详解</p>
<p>BroadcastReceiver使用总结</p>
<p>Android消息机制</p>
<p>Binder机制，共享内存实现原理</p>
<p>Android 事件分发机制</p>
<p>Android 多线程的实现：Thread、HandlerThread、AsyncTask、IntentService、RxJava</p>
<p>ActivityThread工作原理</p>
<p>嵌套滑动实现原理</p>
<p>RecyclerView与ListView(缓存原理，区别联系，优缺点)</p>
<p>View的绘制原理，自定义View，自定义ViewGroup</p>
<p>View、SurfaceView 与 TextureView</p>
<p>主线程Looper.loop为什么不会造成死循环</p>
<p>ViewPager的缓存实现</p>
<p>requestLayout，invalidate，postInvalidate区别与联系</p>
<p>AndroidP新特性</p>
<p>Android两种虚拟机</p>
<p>ADB常用命令</p>
<p>Asset目录与res目录的区别</p>
<p>Android SQLite的使用入门</p>
<p>Android开发高级：</p>
<p>附：一般Android高级工程师招聘要求：</p>
<ol>
<li>熟悉Android SDK，熟悉Android UI，熟悉Android各种调试工具；</li>
<li>有丰富的Android应用架构能力，能够独立主导并架构App；3. </li>
<li>Mobile Web 开发经验；具备各种复合技能：熟悉iOS、H5、Python、.NET等多种开发语言的优先考虑；</li>
<li>对Android性能优化，安全，软件加固，自动化测试有深刻认识;</li>
<li>博客，开源项目</li>
</ol>
<h4><span id="android技术难点">Android技术难点</span></h4><p>AIDL、Binder、多进程、View的绘制流程、事件分发、消息队列等。这类知识对于定位自己为高级Android工程师的人来说是必须掌握的，同时他也是能鉴别高级和初中级工程师的一块试金石，其中binder是Android系统进程间通信最重要的手段之一，现阶段app的发展离不开多进程的运用，经常会启动例如定位、推送等需要在后台开启动的进程来来保证主进程的内存运行；所以合理的使用多进程也是十分必要的；view的绘制是我们自定义控件的理论基础，只有掌握了view是如何绘制的才能个性化的自定义控件；事件分发一直是Android开发的难点之一，也是必须掌握的；关于handler机制也是android的一块难点，因为包括Asynctask、系统启动、Intentservice等底层都是通过handler来实现的，所以掌握后handler机制不仅能提高你的实战开发能力，更能让你系统的了解整个android系统运作的情况。</p>
<h4><span id="android框架层源码掌握">Android框架层源码掌握</span></h4><p>Android框架层有很多东西，以下几个是高级程序员必须要掌握的：</p>
<ol>
<li>Android包管理机制，核心PackageManagerService</li>
<li>Window管理，核心WindowManagerService</li>
<li>Android Activity启动和管理，核心ActivityManagerService</li>
<li>根Activity工作流程</li>
<li>Context关联类</li>
</ol>
<h4><span id="各种原理经典第三方库源码系列">各种原理，经典第三方库源码系列</span></h4><ul>
<li>自定义LayoutManager，RecyclerView中如何自定义LayoutManager</li>
<li>VLayout实现原理，即如何自定义LayoutManager</li>
<li>Glide加载原理，缓存方案，LRU算法</li>
<li>Retrofit的实现与原理</li>
<li>OKHttp3的使用，网络请求中的Intercept</li>
<li>EventBus实现原理</li>
<li>ButterKnife实现原理</li>
<li>RxJava实现原理</li>
<li>Dagger依赖注入</li>
<li>热修复实现原理，解决方案</li>
<li>组件化原理和解决方案</li>
</ul>
<h4><span id="android进程通信以及多进程开发">Android进程通信以及多进程开发</span></h4><p>Android 多进程和Application关系</p>
<p>经典解决方案：<a href="https://mp.weixin.qq.com/s/PZs1wss3PizqSE8U2RGXYw" target="_blank" rel="noopener">多进程通信解决方案：Andromeda</a></p>
<h4><span id="android动画机制">Android动画机制</span></h4><p>经典学习资料：<a href="http://hencoder.com/?utm_source=gank&amp;utm_medium=website&amp;utm_campaign=rxjava" target="_blank" rel="noopener">HenCoder: 给高级Android工程师的进阶手册</a></p>
<h4><span id="android绘图原理">Android绘图原理</span></h4><p>经典学习资料：<a href="http://hencoder.com/?utm_source=gank&amp;utm_medium=website&amp;utm_campaign=rxjava" target="_blank" rel="noopener">HenCoder: 给高级Android工程师的进阶手册</a></p>
<h4><span id="android页面恢复">Android页面恢复</span></h4><p>Android的页面恢复采用以下两个方法：</p>
<p>onSaveInstanceState(Bundle outState)</p>
<p>onRestoreInstanceState(Bundle savedInstanceState)</p>
<p>onSaveInstanceState: 当Activity容易被系统销毁时，会触发该方法。具体的说</p>
<ol>
<li>用户点击Home键</li>
<li>用户点击Home键，切换到其他应用程序</li>
<li>有电话来了等附加操作</li>
</ol>
<h4><span id="混合开发及android-webview应用">混合开发及Android WebView应用</span></h4><p>混合开发涉及到的知识点主要包括：</p>
<ol>
<li>APP调用WebView加载url</li>
<li>掌握WebView的封装，了解所有的WebSettings配置，掌握WebViewClient、WebChromeClient</li>
<li>掌握WebView和Native双向通信机制，会自己封装双向通信中间件</li>
</ol>
<p>对WebView的封装可参考：<a href="https://github.com/Justson/AgentWeb" target="_blank" rel="noopener">GitHub: AgentWeb</a></p>
<p>对通信中间件原理理解：<a href="https://github.com/xudjx/webprogress" target="_blank" rel="noopener">GitHub：webprogress</a></p>
<h4><span id="gradle自动化构建持续集成相关">Gradle，自动化构建，持续集成相关</span></h4><h2><span id="android系统">Android系统</span></h2><h4><span id="android-studio编译过程">Android Studio编译过程</span></h4><p>其中使用到的编译工具：<br> aapt、aidl、Java Compiler、dex、 zipalign</p>
<p>主要步骤描述：</p>
<ol>
<li>通过aapt打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样）</li>
<li>处理.aidl文件，生成对应的Java接口文件</li>
<li>通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件</li>
<li>通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex</li>
<li>通过apkbuilder工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk</li>
<li>通过Jarsigner工具，对上面的apk进行debug或release签名</li>
<li>通过zipalign工具，将签名后的apk进行对齐处理。</li>
</ol>
<h2><span id="android架构">Android架构：</span></h2><ul>
<li>MVC模式</li>
<li>MVP模式</li>
<li>MVVM模式</li>
<li>CLEAN模式</li>
<li>组件化开发</li>
<li>跨平台开发：Flutter、ReactNative（RN未来要黄，了解一下就好）</li>
</ul>
<h2><span id="android优化">Android优化：</span></h2><p><img src="/2019/01/14/Android学习路线总结（个人向）/android优化.jpg" alt=""></p>
<h2><span id="移动开发外围">移动开发外围</span></h2><h4><span id="服务器开发相关">服务器开发相关</span></h4><ul>
<li>SpringBoot技术</li>
<li>Restful API开发</li>
<li>网络协议理解：TCP/IP、HTTP/HTTPS、OSI七层协议</li>
<li>授权认证协议：  OAuth2.0 等</li>
<li>基本的数据库技术</li>
<li>数据缓存技术：Memcached、Redis，Web缓存原理</li>
<li>消息队列技术</li>
<li>监控、日志分析技术</li>
</ul>
<h4><span id="前端开发相关">前端开发相关</span></h4><p>前端开发知识很多，框架层出不穷，本质的东西却只有以下这些。</p>
<ul>
<li>核心必备：HTML、CSS、JavaScript</li>
<li>入门提高：浏览器兼容性、自定义UI和动效</li>
<li>中级技能：框架层出不穷，当前以vue.js、react.js 为核心</li>
<li>协作开发技能：包管理、模块化，工具采用 npm、webpack等</li>
<li>高级技能：框架原理源码研究</li>
</ul>
<h4><span id="开发调试各种工具">开发调试各种工具</span></h4><ul>
<li>性能分析工具：Memory Monitor</li>
<li>性能追踪及方法执行分析： TraceView</li>
<li>视图分析：Hierarchy Viewer</li>
<li>ApkTool- 用于反向工程Android Apk文件的工具</li>
<li>Lint- Android lint工具是一个静态代码分析工具</li>
<li>Dex2Jar- 使用android .dex和java .class文件的工具</li>
</ul>
<p><a href="https://www.jianshu.com/p/88e32ef66ef2" target="_blank" rel="noopener">参考链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/01/12/Markdown常用语法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/12/Markdown常用语法/" itemprop="url">Markdown常用语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-12T21:47:26+08:00">
                2019-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/其它/" itemprop="url" rel="index">
                    <span itemprop="name">其它</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  850
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#一标题">一.标题</a></li>
<li><a href="#二字体">二.字体</a></li>
<li><a href="#三引用">三.引用</a></li>
<li><a href="#四分割线">四.分割线</a></li>
<li><a href="#五图片">五.图片</a></li>
<li><a href="#六超链接">六.超链接</a></li>
<li><a href="#七列表">七.列表</a></li>
<li><a href="#八表格">八.表格</a></li>
<li><a href="#九代码">九.代码</a></li>
<li><a href="#十流程图">十.流程图</a></li>
</ul>
<!-- tocstop -->
<h2><span id="前言">前言</span></h2><p>​    Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<h2><span id="一标题">一.标题</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>
<p>注意：这里的标准语法是必须#结束后再加上一个空格再加上想要写的文字。（但是有些地方貌似不加空格也可以，例如简书。但是最好还是按照标准的语法来写）</p>
<h2><span id="二字体">二.字体</span></h2><p><strong>加粗</strong></p>
<p>要加粗的文字左右分别用两个*号包起来</p>
<p><strong>斜体</strong></p>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<p><strong>斜体加粗</strong></p>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<p><strong>删除线</strong></p>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>
<h2><span id="三引用">三.引用</span></h2><p>在引用的文字前面加上&gt;即可。引用也可以嵌套，比如说两个&gt;&gt;三个&gt;&gt;&gt;之类的，貌似可以一直加下去，但是好像没什么用…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>
<h2><span id="四分割线">四.分割线</span></h2><p>三个或者三个以上的-或者*都可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>
<h2><span id="五图片">五.图片</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>
<h2><span id="六超链接">六.超链接</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure>
<h2><span id="七列表">七.列表</span></h2><p>无序列表用-+*任何一种都可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>
<p>有序列表数字加点即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>
<p>列表嵌套：上一级和下一级之间敲上三个空格即可。</p>
<h2><span id="八表格">八.表格</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure>
<h2><span id="九代码">九.代码</span></h2><p>单行代码直接代码之间分别用一个反引号包起来即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure>
<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure>
<h2><span id="十流程图">十.流程图</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">​```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure>
<p><code>`</code></p>
<p>参考文章：<a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">Markdown基本语法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/01/12/关于Android6-0以上部分权限的动态获取/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/12/关于Android6-0以上部分权限的动态获取/" itemprop="url">关于Android6.0以上部分权限的动态获取</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-12T18:13:39+08:00">
                2019-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/" itemprop="url" rel="index">
                    <span itemprop="name">移动端开发</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  421
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>普通权限暂且不表，下面只列举Android6.0以后必须进行动态申请的权限。</p>
<p><img src="/2019/01/12/关于Android6-0以上部分权限的动态获取/权限.jpg" alt=""></p>
<p>下面以SD卡读取权限作为例子（如果实在不懂的话可以直接复制粘贴，只需要改一下权限的名称即可）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求授权</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestPermission</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> checkCallPhonePermission = ContextCompat.checkSelfPermission</span><br><span class="line">                    (<span class="keyword">this</span>, Manifest.permission.READ_EXTERNAL_STORAGE);</span><br><span class="line">            <span class="keyword">if</span> (checkCallPhonePermission != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="comment">//在String[]中传入需要申请的权限</span></span><br><span class="line">                ActivityCompat.requestPermissions(<span class="keyword">this</span>,</span><br><span class="line">                        <span class="keyword">new</span> String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//sendHomework();</span></span><br><span class="line">                <span class="comment">//已经拥有了权限</span></span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>,<span class="string">"已经获取读SD卡权限"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//低版本</span></span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>,<span class="string">"已经获取读SD卡权限"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, String[] permissions,<span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    <span class="comment">//sendHomework();</span></span><br><span class="line">                    <span class="comment">//获取权限成功后的处理</span></span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>,<span class="string">"已经成功获取读SD卡权限"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//showToast("fail");</span></span><br><span class="line">                    <span class="comment">//获取权限失败的处理</span></span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>,<span class="string">"获取读SD卡权限失败"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>对于新手来说，需要注意的是，如果你想要使用这个动态权限，除了上面这段代码之外，你还需要在项目的Manifest中注册你想要获取的权限（一般来说，只要不是危险权限，无论Android6.0前后，只要注册之后就可以直接使用了，但是危险权限，除了注册之外还需要手动的动态申请）。</p>
<p>另外，除了上面这段代码和注册之外，还需要在初始化之前在MainActivity中写上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestPermission()</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>来调用下面写的动态申请。</p>
<p>参考文章：<a href="https://blog.csdn.net/qq_38520096/article/details/78697744" target="_blank" rel="noopener">Android6.0动态权限</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/zhangguoron.jpg" alt="THBELIEF">
            
              <p class="site-author-name" itemprop="name">THBELIEF</p>
              <p class="site-description motion-element" itemprop="description">我这个人只是英俊 潇洒了些许~</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:thbelief520@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">THBELIEF</span>

  
</div>


  <!--<div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>
-->



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共93.5k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
