<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="我这个人只是英俊 潇洒了些许~">
<meta property="og:type" content="website">
<meta property="og:title" content="THBELIEF">
<meta property="og:url" content="http://thbelief.coding.me/page/3/index.html">
<meta property="og:site_name" content="THBELIEF">
<meta property="og:description" content="我这个人只是英俊 潇洒了些许~">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="THBELIEF">
<meta name="twitter:description" content="我这个人只是英俊 潇洒了些许~">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://thbelief.coding.me/page/3/">





  <title>THBELIEF</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">THBELIEF</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Thbelief's blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/24/递归递推与试除法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/24/递归递推与试除法/" itemprop="url">递归递推与试除法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T20:49:36+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#递推">递推</a></li>
<li><a href="#递归">递归</a><ul>
<li><a href="#1联系">1.联系</a></li>
<li><a href="#2区别">2.区别</a></li>
</ul>
</li>
<li><a href="#试除法求解素数">试除法（求解素数）</a></li>
</ul>
<!-- tocstop -->
<h2><span id="递推">递推</span></h2><p>递推是一种经常被使用的简单算法，定义是<strong>一种用若干步可重复的简单运算来描述复杂问题的方法。</strong></p>
<p>递推的特点在于，<strong>每一项都和他前面的若干项由一定的关联</strong>，这种关联一般可以通过<strong>递推关系式</strong>来表示，可以通过其前面若干项得出某项的数据。</p>
<p>对于递推问题的求解一般从初始的一个或若干个数据项出发，<strong>通过递推关系式逐步推进，从而得出想要的结果，</strong>这种求解问题的方法叫<strong>递推法</strong>。其中，初始的若干数据项称为<strong>边界</strong>。</p>
<p>简单实例如下：</p>
<p>喜欢西游记的同学肯定都知道悟空偷吃蟠桃的故事，你们一定都觉得这猴子太闹腾了，其实你们是有所不知：悟空是在研究一个数学问题！<br>    什么问题？他研究的问题是蟠桃一共有多少个！<br>    不过，到最后，他还是没能解决这个难题，呵呵^-^<br>    当时的情况是这样的：<br>    第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？</p>
<p>Input<br>    输入数据有多组，每组占一行，包含一个正整数n（1&lt;n&lt;30），表示只剩下一个桃子的时候是在第n天发生的。</p>
<p>Output<br>    对于每组输入数据，输出第一天开始吃的时候桃子的总数，每个测试实例占一行。</p>
<p>Sample Input<br>    2 4</p>
<p>Sample Output</p>
<p>4 22</p>
<p><strong>分析：</strong></p>
<p>这其实就是一个<strong>递推问题</strong>，需要注意的是，<strong>一般而言递推的计算效率要大于递归</strong>。由题意得f(n) = 2 * ( f(n-1) + 1 )，另外f(1)=1。这就可以求解出相应的答案了，由于题目太简单，这里只写思路。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int peach(int n) &#123;//这里就是递推</span><br><span class="line">    if(n == 1)</span><br><span class="line">        return 1;</span><br><span class="line">    else &#123;</span><br><span class="line">        long res = 1L;</span><br><span class="line">        while(--n)</span><br><span class="line">            res = 2 * (res + 1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line"> </span><br><span class="line">    while(scanf(&quot;%d&quot;, &amp;n) != EOF)</span><br><span class="line">        printf(&quot;%d\n&quot;, peach(n));</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="递归">递归</span></h2><p>上面说到，一般来说，递推的计算效率是高于递归的，那么递归与递推有什么区别和联系呢？</p>
<h3><span id="1联系">1.联系</span></h3><p>递归和递推有一定的相似性。<br>    这两个问题都可以描述为以下形式：<br>    <strong>f(n)=g(f(n-1)，…，f(0))</strong><br>    这是二者的共同特点。</p>
<h3><span id="2区别">2.区别</span></h3><p>1）递归表现出来的是<strong>自己调用自己</strong>，递推则没有这样的形式。</p>
<p>2）递归是从问题的<strong>最终目标</strong>出发，将问题<strong>简单化</strong>，这就是<strong>逆向的</strong>求解。</p>
<p>递推则是从<strong>简单问题</strong>出发，<strong>正向的</strong>解决问题。</p>
<p>3）递归中，<strong>n是已知的</strong>。递推则可以是在计算中知道，不需要提前知道。</p>
<p>4）一般来说，<strong>递推的效率是大于递归的。</strong></p>
<h2><span id="试除法求解素数">试除法（求解素数）</span></h2><p>一般来说，求解素数的话，要用到两种方式，<strong>一个是试除法一个是筛选法</strong>，<a href="https://thbelief.coding.me/2019/03/21/%E5%88%86%E6%8B%86%E7%B4%A0%E6%95%B0%E5%92%8C/">这篇博客</a>里面就写到了Eratosthenes筛选法，这里的话就介绍一下另外一种方法，试除法。试除法其实一般有很多种，这里只介绍一点。大致知道算法就行，现场写也可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">/*</span><br><span class="line">质数：一个自然数，如果只有1和它本身两个约数，这个数叫做质数（也称素数）．</span><br><span class="line">对于一个整数n，只需用小于等于√n所有素数去除，所以本算法的时间复杂度为O(√)的。</span><br><span class="line">*/</span><br><span class="line">bool IsPrime(int n,int prime[],int length)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for(i = 2; (long long)i*i &lt;= n&amp;&amp;prime[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(n %i == 0)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/23/java基础-略知一二/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/23/java基础-略知一二/" itemprop="url">java基础-略知一二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-23T17:45:45+08:00">
                2019-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#collection">Collection</a></li>
<li><a href="#set">Set</a><ul>
<li><a href="#hashset">HashSet</a></li>
<li><a href="#linkedhashset">LinkedHashSet</a></li>
<li><a href="#sortedset">SortedSet</a></li>
<li><a href="#treeset">TreeSet</a></li>
</ul>
</li>
<li><a href="#list">List</a></li>
<li><a href="#arraylist">ArrayList</a><ul>
<li><a href="#构造方法">构造方法</a></li>
</ul>
</li>
<li><a href="#linkedlist">LinkedList</a><ul>
<li><a href="#构造方法-1">构造方法</a></li>
</ul>
</li>
<li><a href="#map">Map</a><ul>
<li><a href="#特性">特性</a></li>
<li><a href="#方法">方法</a></li>
</ul>
</li>
<li><a href="#hashmap">HashMap</a><ul>
<li><a href="#常用操作">常用操作</a></li>
</ul>
</li>
<li><a href="#iterator">Iterator</a></li>
</ul>
<!-- tocstop -->
<h2><span id="collection">Collection</span></h2><p><strong>集合中只能放置对象的引用，不能放置原生数据类型。</strong></p>
<p>常用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 将所有元素从一个列表复制到另一个列表</span><br><span class="line">Collections.copy(new ArrayList(), new ArrayList());</span><br><span class="line">// 如果两个指定collection中没有相同的元素,则返回 true</span><br><span class="line">Collections.disjoint(new ArrayList(), new ArrayList());</span><br><span class="line">// 使用指定元素替换指定列表中的所有元素</span><br><span class="line">Collections.fill(new ArrayList(), new Object());</span><br><span class="line">// 返回指定 collection 中等于指定对象的元素数</span><br><span class="line">Collections.frequency(new ArrayList(), new Object());</span><br><span class="line">// 返回指定源列表中第一次出现指定目标列表的起始位置,如果没有出现这样的列表,则返回 -1</span><br><span class="line">Collections.indexOfSubList(new ArrayList(), new ArrayList());</span><br><span class="line">// 根据元素的自然顺序，返回给定 collection 的最大元素</span><br><span class="line">Collections.max(new ArrayList());</span><br><span class="line">// //根据元素的自然顺序，返回给定 collection 的最大元素</span><br><span class="line">Collections.min(new ArrayList());</span><br><span class="line">// 使用另一个值替换列表中出现的所有某一指定值</span><br><span class="line">Collections.replaceAll(new ArrayList(), &quot;oldVal&quot;, &quot;newVal&quot;);</span><br><span class="line">// 反转指定列表中元素的顺序</span><br><span class="line">Collections.reverse(new ArrayList());</span><br><span class="line">// 返回一个比较器,它强行反转</span><br><span class="line">Collections.reverseOrder();</span><br><span class="line">// 返回一个比较器,它强行反转指定比较器的顺序</span><br><span class="line">Collections.reverseOrder(new Comparator() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public int compare(Object o1, Object o2) &#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 使用默认随机源随机更改指定列表的序列</span><br><span class="line">Collections.shuffle(new ArrayList());</span><br><span class="line">// 根据元素的自然顺序对指定列表按升序进行排序</span><br><span class="line">Collections.sort(new ArrayList());</span><br><span class="line">// 根据元素的自然顺序对指定列表按降序进行排序</span><br><span class="line">Collections.sort(new ArrayList(), Collections.reverseOrder());</span><br><span class="line">// 在指定列表的指定位置处交换元素</span><br><span class="line">Collections.swap(new ArrayList(), 1, 2);</span><br></pre></td></tr></table></figure>
<h2><span id="set">Set</span></h2><p><strong>实现类：HashSet,LinkedHashSet.</strong></p>
<p><strong>子接口：SortSet，TreeSet.</strong></p>
<p>不包含重复元素，最多包含一个null，元素没有顺序。</p>
<h3><span id="hashset">HashSet</span></h3><p>HashSet不是Ordered也不是Sorted,存储对象引用时是按照<strong>哈希策略</strong>来实现的,<br>    HashSet中是否存在一个对象是通过<strong>equals()</strong>和<strong>hashCode()</strong>协同判断，不保证顺序。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashSet()  </span><br><span class="line">public HashSet(int initialCapacity)  </span><br><span class="line">public HashSet(Collection c)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public HashSet(Collection c)</span><br></pre></td></tr></table></figure>
<p>HashSet底层是使用<strong>HashMap</strong>实现的<br>HashSet的add()方法详解:<br>    <strong>判断已经存储在集合中的对象hashCode值是否与增加对象的hashCode值一致。</strong><br>    如果不一致,直接加进去。<br>    如果一致,再进行equals()比较，如果equals()返回true,对象已经存在不增加进去，如果equals()返回false,把对象增加进去。</p>
<h3><span id="linkedhashset">LinkedHashSet</span></h3><p>LinkedHashSet是Ordered,采用<strong>双链表</strong>实现的，有<strong>固定顺序</strong>,也就是插入顺序。<br>LinkedHashSet底层是使用<strong>LinkedHashMap</strong>实现的。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashSet()  </span><br><span class="line">public LinkedHashSet(int initialCapacity)  </span><br><span class="line">public LinkedHashSet(Collection c)</span><br></pre></td></tr></table></figure>
<h3><span id="sortedset">SortedSet</span></h3><p><strong>保证迭代器按照元素递增顺序遍历的集合,可以按照元素的自然顺序进行排序。</strong></p>
<p><strong>常用方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object first()</span><br><span class="line">		 返回此有序集合中当前第一个(最小的)元素</span><br><span class="line">	Object last()</span><br><span class="line">		返回此有序集合中最后一个(最大的)元素</span><br><span class="line">	SortedSet headSet(Object toElement)</span><br><span class="line">		返回此有序集合的部分视图,其元素严格小于toElement</span><br><span class="line">	SortedSet tailSet(Object fromElement)</span><br><span class="line">		返回此有序集合的部分视图,其元素大于或等于fromElement</span><br><span class="line">	SortedSet subSet(Object fromElement,Object toElement)</span><br><span class="line">		返回此有序集合的部分视图,元素范围从fromElement(包括)到toElement(不包括)</span><br><span class="line">	Comparator comparator()</span><br><span class="line">		返回与此有序集合关联的比较器,如果使用元素的自然顺序,则返回 null</span><br></pre></td></tr></table></figure>
<h3><span id="treeset">TreeSet</span></h3><p>TreeSet是SortedSet接口的实现,<strong>元素不论以什么元素插入,在遍历的时候,都会以天然顺序遍历</strong>。因为它是自带排序的，所以如果想要增加自定义类型就必须指定排序的规则。<br>TreeSet底层是使用<strong>TreeMap</strong>实现的。</p>
<p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public TreeSet()</span><br><span class="line">public TreeSet(SortedSet s)  </span><br><span class="line">public TreeSet(int initialCapacity)</span><br><span class="line">public TreeSet(Comparator&lt;? super E&gt;)</span><br><span class="line">public TreeSet(Collection c)</span><br></pre></td></tr></table></figure>
<h2><span id="list">List</span></h2><p>具有<strong>列表</strong>的功能,元素顺序均是<strong>按添加的先后进行排列的,</strong>允许<strong>重复的</strong>元素,允许多个null元素。</p>
<p><strong>常用方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">// 向列表的尾部追加指定的元素</span><br><span class="line">list.add(&quot;lwc&quot;);</span><br><span class="line">// 在列表的指定位置插入指定元素</span><br><span class="line">list.add(1, &quot;nxj&quot;);</span><br><span class="line">// 追加指定 collection 中的所有元素到此列表的结尾</span><br><span class="line">list.addAll(new ArrayList());</span><br><span class="line">// 从列表中移除所有元素</span><br><span class="line">list.clear();</span><br><span class="line">// 如果列表包含指定的元素,则返回true</span><br><span class="line">list.contains(&quot;nxj&quot;);</span><br><span class="line">// 如果列表包含指定 collection 的所有元素,则返回 true</span><br><span class="line">list.containsAll(new ArrayList());</span><br><span class="line">// 比较指定的对象与列表是否相等</span><br><span class="line">list.equals(new ArrayList());</span><br><span class="line">// 返回列表中指定位置的元素</span><br><span class="line">list.get(0);</span><br><span class="line">// 返回列表的哈希码值</span><br><span class="line">list.hashCode();</span><br><span class="line">// 返回列表中首次出现指定元素的索引,如果列表不包含此元素,则返回 -1</span><br><span class="line">list.indexOf(&quot;lwc&quot;);</span><br><span class="line">// 返回列表中最后出现指定元素的索引,如果列表不包含此元素,则返回 -1</span><br><span class="line">list.lastIndexOf(&quot;lwc&quot;);</span><br><span class="line">// 如果列表不包含元素,则返回 true</span><br><span class="line">list.isEmpty();</span><br><span class="line">// 移除列表中指定位置的元素</span><br><span class="line">list.remove(0);</span><br><span class="line">// 移除列表中出现的首个指定元素</span><br><span class="line">list.remove(&quot;lwc&quot;);</span><br><span class="line">// 从列表中移除指定 collection 中包含的所有元素</span><br><span class="line">list.removeAll(new ArrayList());</span><br><span class="line">// 用指定元素替换列表中指定位置的元素</span><br><span class="line">list.set(0, &quot;lp&quot;);</span><br><span class="line">// 返回列表中的元素数</span><br><span class="line">list.size();</span><br><span class="line">// 返回列表中指定的fromIndex(包括)和toIndex(不包括)之间的部分视图</span><br><span class="line">list.subList(1, 2);</span><br><span class="line">// 返回以正确顺序包含列表中的所有元素的数组</span><br><span class="line">list.toArray();</span><br><span class="line">// 返回以正确顺序包含列表中所有元素的数组</span><br><span class="line">list.toArray(new String[] &#123; &quot;a&quot;, &quot;b&quot; &#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="arraylist">ArrayList</span></h2><h3><span id="构造方法">构造方法</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList()</span><br><span class="line">public ArrayList(int initialCapacity)</span><br><span class="line">public ArrayList(Collection c)</span><br></pre></td></tr></table></figure>
<p> ArrayList依赖于<strong>数组</strong>实现的,初始长度为10的Object[],并且可随需要而增加的<strong>动态数组</strong>。<br>    当元素超过10,那么ArrayList底层会<strong>新生成一个数组,</strong>长度为原来的1.5倍+1,然后将原数组内容复制到新数组中,并且后续增加的内容会放到新数组中,当新数组无法容纳增加的元素,重复该过程即可。</p>
<h2><span id="linkedlist">LinkedList</span></h2><p>LinkedList功能与ArrayList,Vector相同,内部是<strong>依赖双链表实现</strong>的,因此有很好的插入和删除性能,但随机访问元素的性能很差。</p>
<h3><span id="构造方法">构造方法</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList()</span><br><span class="line">public LinkedList(Collection c)</span><br></pre></td></tr></table></figure>
<p>LinkedList类中有一个<strong>Entry内部类</strong>,Entry内部类包含3个部分<strong>向前的引用,向后的引用,数据</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header.next = header.previous = header;</span><br></pre></td></tr></table></figure>
<h2><span id="map">Map</span></h2><p><strong>Map接口中键和值一一映射. 可以通过键来获取值.</strong></p>
<h3><span id="特性">特性</span></h3><ul>
<li>给定一个键和一个值，你可以将该值存储在一个Map对象. 之后，你可以通过键来访问对应的值。</li>
<li>当访问的值不存在的时候，方法就会抛出一个NoSuchElementException异常。</li>
<li>当对象的类型和Map里元素类型不兼容的时候，就会抛出一个 ClassCastException异常。</li>
<li>当在不允许使用Null对象的Map中使用Null对象，会抛出一个NullPointerException 异常。</li>
<li>当尝试修改一个只读的Map时，会抛出一个UnsupportedOperationException异常。</li>
</ul>
<h3><span id="方法">方法</span></h3><table>
<thead>
<tr>
<th>1</th>
<th>void clear( )  从此映射中移除所有映射关系（可选操作）。</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>boolean containsKey(Object k) 如果此映射包含指定键的映射关系，则返回 true。</td>
</tr>
<tr>
<td>3</td>
<td>boolean containsValue(Object v) 如果此映射将一个或多个键映射到指定值，则返回 true。</td>
</tr>
<tr>
<td>4</td>
<td>Set entrySet( ) 返回此映射中包含的映射关系的 Set 视图。</td>
</tr>
<tr>
<td>5</td>
<td>boolean equals(Object obj) 比较指定的对象与此映射是否相等。</td>
</tr>
<tr>
<td>6</td>
<td>Object get(Object k) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</td>
</tr>
<tr>
<td>7</td>
<td>int hashCode( ) 返回此映射的哈希码值。</td>
</tr>
<tr>
<td>8</td>
<td>boolean isEmpty( ) 如果此映射未包含键-值映射关系，则返回 true。</td>
</tr>
<tr>
<td>9</td>
<td>Set keySet( ) 返回此映射中包含的键的 Set 视图。</td>
</tr>
<tr>
<td>10</td>
<td>Object put(Object k, Object v) 将指定的值与此映射中的指定键关联（可选操作）。</td>
</tr>
<tr>
<td>11</td>
<td>void putAll(Map m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。</td>
</tr>
<tr>
<td>12</td>
<td>Object remove(Object k) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</td>
</tr>
<tr>
<td>13</td>
<td>int size( ) 返回此映射中的键-值映射关系数。</td>
</tr>
<tr>
<td>14</td>
<td>Collection values( ) 返回此映射中包含的值的 Collection 视图。</td>
</tr>
</tbody>
</table>
<h2><span id="hashmap">HashMap</span></h2><h3><span id="常用操作">常用操作</span></h3><p>1.第一步就是给HashMap里面put一些<strong>键值对</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		hashMap.put(5, 2);</span><br><span class="line">		hashMap.put(9, 2);</span><br><span class="line">		hashMap.put(8, 1);</span><br><span class="line">		hashMap.put(7, 3);</span><br><span class="line">		hashMap.put(16, 1);</span><br><span class="line">		hashMap.put(10, 2);</span><br><span class="line">		hashMap.put(6, 2);</span><br><span class="line">		//下面两个键值对是没有存的，因为key存过的不会重复存储，只会覆盖之前的vlue</span><br><span class="line">		hashMap.put(5, 2);</span><br><span class="line">		hashMap.put(5, 3);</span><br></pre></td></tr></table></figure>
<p>2.containsKey(Object key)方法，返回值为boolean，用于<strong>判断当前HashMap中是否包含key对应的key-value</strong>。</p>
<p>3.containsValue(Object value)方法，返回值为boolean，用于<strong>判断当前HashMap中是否包含value对应的key-value</strong>。</p>
<p>4.遍历HashMap的两种方式：</p>
<p>1）利用haspmap.entrySet().iterator()：利用迭代器，从Entry中取出键、取出值，推荐使用这种方式进行遍历，效率较高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Entry&lt;Integer, Integer&gt;&gt; iterator = hashMap.entrySet().iterator();</span><br><span class="line">		while (iterator.hasNext()) &#123;</span><br><span class="line">			Entry&lt;Integer, Integer&gt; entry = iterator.next();</span><br><span class="line">			Integer key = entry.getKey();</span><br><span class="line">			Integer value = entry.getValue();</span><br><span class="line">			System.out.print(key + &quot;---&gt;&quot; + value);</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>2）利用hashmap.keySet().iterator()：利用键的迭代器，每次取出一个键，再根据键，从HashMap中取出值，这种方式的效率不高，不推荐使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator2 = hashMap.keySet().iterator();</span><br><span class="line">		while (iterator2.hasNext()) &#123;</span><br><span class="line">			Integer key = iterator2.next();</span><br><span class="line">			Integer value = hashMap.get(key);</span><br><span class="line">			System.out.print(key + &quot;---&quot; + value);</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/u013398759/article/details/77679632" target="_blank" rel="noopener">参考链接</a></p>
<h2><span id="iterator">Iterator</span></h2><p> 在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：<strong>对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。</strong>迭代器与枚举有两点不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。</span><br><span class="line"></span><br><span class="line">2、方法名称得到了改进。</span><br></pre></td></tr></table></figure>
<p><strong>接口定义：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line">　　boolean hasNext();</span><br><span class="line">　　Object next();</span><br><span class="line">　　void remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Object next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型。</p>
<p>boolean hasNext()：判断容器内是否还有可供访问的元素。</p>
<p>void remove()：删除迭代器刚越过的元素。</p>
<p><strong>未完待续~~~</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/22/java基础-略有小成/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/22/java基础-略有小成/" itemprop="url">java基础-略有小成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-22T22:00:24+08:00">
                2019-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#基本数据类型">基本数据类型</a><ul>
<li><a href="#种类">种类</a></li>
<li><a href="#占用空间">占用空间</a></li>
<li><a href="#类型转换">类型转换</a></li>
</ul>
</li>
<li><a href="#包装类">包装类</a><ul>
<li><a href="#类型转换方法">类型转换方法</a></li>
<li><a href="#引用问题">引用问题</a></li>
</ul>
</li>
<li><a href="#system类">System类</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#成员变量">成员变量</a></li>
<li><a href="#成员方法">成员方法</a></li>
</ul>
</li>
<li><a href="#runtime类">RunTime类</a></li>
<li><a href="#date与dateformat">Date与DateFormat</a><ul>
<li><a href="#构造函数">构造函数</a></li>
<li><a href="#方法">方法</a></li>
<li><a href="#日期比较">日期比较</a></li>
<li><a href="#simpledateformat格式化日期">SimpleDateFormat格式化日期</a></li>
<li><a href="#格式化编码">格式化编码</a></li>
<li><a href="#printf格式化日期">printf格式化日期</a></li>
<li><a href="#解析字符串">解析字符串</a></li>
<li><a href="#sleep">sleep</a></li>
</ul>
</li>
<li><a href="#calendar类与gregoriancalendar类">Calendar类与GregorianCalendar类</a></li>
</ul>
<!-- tocstop -->
<h2><span id="基本数据类型">基本数据类型</span></h2><h3><span id="种类">种类</span></h3><p><img src="/2019/03/22/java基础-略有小成/基本数据类型.jpg" alt=""></p>
<p>讲到基本类型的话，不可避免的就是<strong>字面量值</strong>，其实它的意思就是<strong>表面上的值。</strong></p>
<p>byte、short、int、long类型变量都可以赋予整型字面量值，譬如byte a = 10、short b = 0x45都是合法的赋值操作。Java编译器在编译是会检查字面量值所表示的数字大小是否处于变量类型的合法范围内，如果不在，则无法通过编译。如果多种数值类型的数据进行数学运算时，计算结果的类型是其中这些数值中<strong>最高等级或者其更高等级类型。</strong></p>
<h3><span id="占用空间">占用空间</span></h3><p>byte（字节）用<strong>无符号的8位</strong>表示，它的取值范围是[-2^7, 2^7-1]。它是最小的整型类型，默认值是0。<br>    short（短整型）用<strong>有符号的16位</strong>表示，它的取值范围是[-2^15, 2^15-1]。默认值是0。<br>    int（整型）用有符号的32位表示，它的取值范围是[-2^31, 2^31-1]，计算机中用存放的是整型数值的<strong>二进制补码</strong>。默认值是0。<br>    long（长整型）用<strong>有符号的64位</strong>表示，它的取值范围是[-2^63, 2^63-1]。它的字面量表示以l或者L结束，如 long a = 45454L。默认值是0L。<br>    float（单精度浮点型）用<strong>32位</strong>表示，float类型字面量值通常以f或者F结束。由于整型可以自动转换为float类型，所以，也可以将整型字面量值直接赋予float类型变量。默认值是<strong>0F</strong>。<br>    double（双精度浮点型）用<strong>64位</strong>表示，遵循IEEE 754规范。它能表示比float更高精度的数值。double是Java基本类型中能达到的最高精度，如果还不能满足要求，可以使用Java中的<strong>BigDecimal</strong>类。默认值是0.0。<br>    char（字符）用<strong>无符号的16位</strong>表示，它的取值范围是[0, 2^16-1]。Java中使用<strong>Unicode字符集</strong>来表示字符，Unicode将人类语言的所有已知字符映射成16位数字，所以Java中的char是16位的。默认值是\u00000。</p>
<p>boolean（ 布尔型）只要<strong>true和false</strong>两个字面量值，可用于逻辑判断。boolean只能表示1位的信息量，但是它的大小并没有精确地定义。</p>
<h3><span id="类型转换">类型转换</span></h3><p>在JAVA里面除了boolean类型之外，其他7中类型相互之间可以<strong>进行转换</strong>。转换分为<strong>自动转换</strong>和<strong>强制转换</strong>。对于自动转换（隐式），无需任何操作，而强制类型转换需要<strong>显式转换</strong>，即使用转换操作符（type）。</p>
<p>占用空间大小进行排序：<strong>byte &lt;（short=char）&lt; int &lt; long &lt; float &lt; double</strong></p>
<p>类型转换的总则是：<strong>小可直接转大、大转小会失去精度</strong>。小转大是Java帮我们自动进行转换的，与正常的赋值操作完全一样；大转小需要进行强制转换操作，其语法是<strong>target-type var =（target-type） value</strong>。</p>
<p><strong>特别注意：大转小有可能在某些情况下产生不可预估的问题。</strong></p>
<h2><span id="包装类">包装类</span></h2><p>Java里面的每一种<strong>基本类型</strong>都会对应一个<strong>唯一的</strong>包装类，基本类型与其包装类都可以通过包装类中的<strong>静态</strong>或者<strong>成员方法</strong>进行转换。所有的包装类都是<strong>final</strong>修饰的，也就是它们都是<strong>无法被继承和重写</strong>的。</p>
<p><img src="/2019/03/22/java基础-略有小成/包装类.jpg" alt=""></p>
<p><strong>基础类型和包装类型都可以通过赋值语法赋值给对立的变量类型。</strong></p>
<h3><span id="类型转换方法">类型转换方法</span></h3><p><img src="/2019/03/22/java基础-略有小成/类型转换方法.jpg" alt=""></p>
<h3><span id="引用问题">引用问题</span></h3><p>在Java中，“==”符号判断的<strong>内存地址</strong>所对应的值的<strong>相等性</strong>，具体来说，<strong>基本类型判断值是否相等</strong>，<strong>引用类型判断其指向的地址是否相等。</strong></p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a1 = 1;</span><br><span class="line">Integer a2 = 1;</span><br><span class="line">System.out.println(a1 == a2); // true</span><br><span class="line"></span><br><span class="line">Integer b1 = 222;</span><br><span class="line">Integer b2 = 222;</span><br><span class="line">System.out.println(b1 == b2); // false</span><br></pre></td></tr></table></figure>
<p>这是为什么呢？</p>
<p>如果打开Integer类中的valueOf()方法会发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) // 判断实参是否在可缓存范围内，默认为[-128, 127]</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)]; // 如果在，则取出初始化的Integer对象</span><br><span class="line">    return new Integer(i); // 如果不在，则创建一个新的Integer对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于1属于[-128, 127]集合范围内，所以valueOf()每次都会取出<strong>同一个Integer对象</strong>，故第一个“==”判断结果为true；</p>
<p>而222不属于[-128, 127]集合范围内，所以valueOf()每次都会创建一个<strong>新的Integer对象</strong>，由于两个新创建的对象的地址不一样，故第一个“==”判断结果为false。</p>
<p><a href="https://blog.csdn.net/xialei199023/article/details/63251295" target="_blank" rel="noopener">参考链接</a></p>
<h2><span id="system类">System类</span></h2><h3><span id="简介">简介</span></h3><p>system类在java中的作用其实就是类似于<strong>系统</strong>的作用，它的内部包含了很多系统级别的<strong>属性以及控制方法</strong>。</p>
<h3><span id="成员变量">成员变量</span></h3><p>主要就是包含了<strong>in（标准输入流，键盘输入），out（标准输出流，显示器）以及err（标准错误输出流）。</strong></p>
<p><strong>out与err的差别</strong></p>
<p>System.out在JVM和操作系统都具有缓存功能，其实就是输出的数据<strong>不一定实时输出</strong>，有时候会积攒到一定数量才会输出；System.err会<strong>实时输出</strong>。</p>
<h3><span id="成员方法">成员方法</span></h3><p>1.static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</p>
<p>该方法的作用是<strong>数组拷贝</strong>，src为被拷贝的数组，srcPos为src要拷贝的初始位置，dest为目的数组，目的数组dest放置拷贝数据的初始位置，length为从src拷贝到的数据长度。</p>
<p>2.static long currentTimeMillis()<br>    该方法的作用是<strong>返回当前的计算机时间</strong>，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
<p>3.static void exit(int status)<br>    该方法的作用是<strong>退出程序</strong>。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
<p>4.static void gc()<br>    请求系统进行<strong>垃圾回收</strong>。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p>
<p>5.static Properties getProperties()<br>    <strong>获取系统的属性信息</strong>，并存储到Properties集合中。Properties集合中存储的都是String类型的键值对。</p>
<p>6.static String getProperty(String key)</p>
<p><strong>获得系统中属性名为key的属性对应的值</strong>。系统中常见的属性名以及属性的作用如下表所示：</p>
<p><img src="/2019/03/22/java基础-略有小成/属性.jpg" alt=""></p>
<p>7.static String setProperty(String key, String value)<br>    给系统<strong>设置一些属性信息</strong>，这些信息是全局的，其他程序都可以使用。</p>
<h2><span id="runtime类">RunTime类</span></h2><p>Runtime类<strong>封装了运行时的环境</strong>。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。该类<strong>无法创建对象</strong>。</p>
<p><strong>常用方法</strong><br>    <strong>static Runtime getRuntime() 返回一个Runtime实例</strong>。<br>    <strong>Process exec(String command) 指定某个exe文件并返回该程序进程，参数command为本地exe文件路径。</strong></p>
<p><strong>long freeMemory() 返回Java虚拟机中的空闲内存量，以字节为单位</strong><br>    <strong>long maxMemory() 返回Java虚拟机试图使用的最大内存量</strong></p>
<p><strong>long totalMemory() 返回Java虚拟机中的内存总量</strong></p>
<h2><span id="date与dateformat">Date与DateFormat</span></h2><p>Date是Java中提供来<strong>封装当前的日期与时间</strong>的类。</p>
<h3><span id="构造函数">构造函数</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date( );//使用当前日期和时间来初始化对象。</span><br><span class="line">Date(long millisec);//接收一个参数，该参数是从1970年1月1日起的毫秒数。</span><br></pre></td></tr></table></figure>
<h3><span id="方法">方法</span></h3><p><img src="/2019/03/22/java基础-略有小成/方法.jpg" alt=""></p>
<h3><span id="日期比较">日期比较</span></h3><p> 使用 <strong>getTime()</strong> 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。<br>    使用方法 <strong>before()，after() 和 equals()</strong>。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。<br>    使用 <strong>compareTo()</strong> 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。</p>
<h3><span id="simpledateformat格式化日期">SimpleDateFormat格式化日期</span></h3><p>SimpleDateFormat 允许用户选择<strong>任何自定义日期时间格式</strong>来运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import  java.util.*;</span><br><span class="line">import java.text.*;</span><br><span class="line"> </span><br><span class="line">public class DateDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line"> </span><br><span class="line">      Date dNow = new Date( );</span><br><span class="line">      /*这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。*/</span><br><span class="line">      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;);</span><br><span class="line">      System.out.println(&quot;当前时间为: &quot; + ft.format(dNow));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="格式化编码">格式化编码</span></h3><table>
<thead>
<tr>
<th><strong>字母</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>纪元标记</td>
<td>AD</td>
</tr>
<tr>
<td>y</td>
<td>四位年份</td>
<td>2001</td>
</tr>
<tr>
<td>M</td>
<td>月份</td>
<td>July or 07</td>
</tr>
<tr>
<td>d</td>
<td>一个月的日期</td>
<td>10</td>
</tr>
<tr>
<td>h</td>
<td>A.M./P.M. (1~12)格式小时</td>
<td>12</td>
</tr>
<tr>
<td>H</td>
<td>一天中的小时 (0~23)</td>
<td>22</td>
</tr>
<tr>
<td>m</td>
<td>分钟数</td>
<td>30</td>
</tr>
<tr>
<td>s</td>
<td>秒数</td>
<td>55</td>
</tr>
<tr>
<td>S</td>
<td>毫秒数</td>
<td>234</td>
</tr>
<tr>
<td>E</td>
<td>星期几</td>
<td>Tuesday</td>
</tr>
<tr>
<td>D</td>
<td>一年中的日子</td>
<td>360</td>
</tr>
<tr>
<td>F</td>
<td>一个月中第几周的周几</td>
<td>2 (second Wed. in July)</td>
</tr>
<tr>
<td>w</td>
<td>一年中第几周</td>
<td>40</td>
</tr>
<tr>
<td>W</td>
<td>一个月中第几周</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>A.M./P.M. 标记</td>
<td>PM</td>
</tr>
<tr>
<td>k</td>
<td>一天中的小时(1~24)</td>
<td>24</td>
</tr>
<tr>
<td>K</td>
<td>A.M./P.M. (0~11)格式小时</td>
<td>10</td>
</tr>
<tr>
<td>z</td>
<td>时区</td>
<td>Eastern Standard Time</td>
</tr>
<tr>
<td>‘</td>
<td>文字定界符</td>
<td>Delimiter</td>
</tr>
<tr>
<td>“</td>
<td>单引号</td>
<td>`</td>
</tr>
</tbody>
</table>
<h3><span id="printf格式化日期">printf格式化日期</span></h3><p>printf 方法可以很轻松地格式化时间和日期。使用<strong>两个字母</strong>格式，它以 <strong>%t</strong> 开头并且以下面表格中的一个字母结尾。</p>
<table>
<thead>
<tr>
<th>转  换  符</th>
<th>说    明</th>
<th>示    例</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>包括全部日期和时间信息</td>
<td>星期六 十月 27 14:21:20 CST 2007</td>
</tr>
<tr>
<td>F</td>
<td>“年-月-日”格式</td>
<td>2007-10-27</td>
</tr>
<tr>
<td>D</td>
<td>“月/日/年”格式</td>
<td>10/27/07</td>
</tr>
<tr>
<td>r</td>
<td>“HH:MM:SS PM”格式（12时制）</td>
<td>02:25:51 下午</td>
</tr>
<tr>
<td>T</td>
<td>“HH:MM:SS”格式（24时制）</td>
<td>14:28:16</td>
</tr>
<tr>
<td>R</td>
<td>“HH:MM”格式（24时制）</td>
<td>14:28</td>
</tr>
</tbody>
</table>
<h3><span id="解析字符串">解析字符串</span></h3><p><strong>SimpleDateFormat 类的parse()方法来按照对应的格式化存储来解析字符串。</strong></p>
<h3><span id="sleep">sleep</span></h3><p>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(1000);   // 休眠1秒</span><br></pre></td></tr></table></figure>
<h2><span id="calendar类与gregoriancalendar类">Calendar类与GregorianCalendar类</span></h2><p>略…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/21/分拆素数和/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/分拆素数和/" itemprop="url">分拆素数和</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T15:27:21+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  922
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#题目内容">题目内容</a></li>
<li><a href="#题目分析">题目分析</a></li>
<li><a href="#eratosthenes筛选法">Eratosthenes筛选法</a></li>
<li><a href="#试探法回溯法">试探法（回溯法）</a></li>
<li><a href="#代码详解">代码详解</a></li>
</ul>
<!-- tocstop -->
<h2><span id="题目内容">题目内容</span></h2><p><img src="/2019/03/21/分拆素数和/题目.jpg" alt=""></p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2098" target="_blank" rel="noopener">原题链接</a></p>
<h2><span id="题目分析">题目分析</span></h2><p>很明显，本题的要求是要求解<strong>分解的个数</strong>，主要思路就是利用Eratosthenes筛选法来求必要的素数，然后用试探法来求分解的个数。</p>
<p><strong>原理：对于任何一个可以分解为两个素数之和的偶数，其中一个必然是小于或者等于1/2的。</strong></p>
<h2><span id="eratosthenes筛选法">Eratosthenes筛选法</span></h2><p><strong>筛选法又称筛法</strong>，具体做法是：先把N个自然数按次序排列起来。1不是质数，也不是合数，要划去。第二个数2是质数留下来，而把2后面所有能被2整除的数都划去。2后面第一个没划去的数是3，把3留下，再把3后面所有能被3整除的数都划去。3后面第一个没划去的数是5，把5留下，再把5后面所有能被5整除的数都划去。<strong>这样一直做下去，就会把不超过N的全部合数都筛掉，留下的就是不超过N的全部质数。</strong></p>
<p>（合数：一个正整数，除了1和它本身以外，还能被其他正整数整除，这个数就叫做合数。）</p>
<p>（质数（prime number）又称<a href="https://baike.baidu.com/item/%E7%B4%A0%E6%95%B0/115069" target="_blank" rel="noopener">素数</a>，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他<a href="https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0/9539111" target="_blank" rel="noopener">因数</a>。）</p>
<p><strong>埃拉托斯特尼筛选法</strong>是最为知名的产生素数的筛选法，适用于产生<strong>最小的N个素数</strong>。</p>
<p>该方法的唯一缺点是使用的存储空间大，可以进一步改进。</p>
<p>另外，该算法也<strong>不适用于计算某个范围内的全部素数</strong>。</p>
<h2><span id="试探法回溯法">试探法（回溯法）</span></h2><p>先选择某一种可能的情况进行试探，在试探过程中，一旦发现此选择的假设是错误的，就退回一步重新选择，继续向前试探，如此反复进行，直到证明解或者无解。</p>
<h2><span id="代码详解">代码详解</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define Max 10000</span><br><span class="line">using namespace std;</span><br><span class="line">//Eratosthenes筛选法</span><br><span class="line">void eratosthenesFunction(int num[],int n)</span><br><span class="line">&#123;</span><br><span class="line">	//两个参数一个是筛选的数组，一个是筛选的最大值</span><br><span class="line">	//由于数组在函数中修改的值类似于取址赋值，这里直接里面修改外面也修改了</span><br><span class="line">	num[0]=num[1]=0;</span><br><span class="line">	num[2]=1;//从2开始的质数才算进去</span><br><span class="line">	//首先先初始化，把所有质数序号的数组值赋值为1</span><br><span class="line">	for(int i=3;i&lt;=n;i++)</span><br><span class="line">	&#123; </span><br><span class="line">		num[i]=1;</span><br><span class="line">		i++; </span><br><span class="line">		num[i]=0;	</span><br><span class="line">	&#125; </span><br><span class="line">	int max=sqrt(n);</span><br><span class="line">	for(int i=3;i&lt;=max;i++) </span><br><span class="line">	&#123;</span><br><span class="line">		//下面就开始筛选了，把所有的之前出现过的质数的倍数给去掉 </span><br><span class="line">		if(num[i])&#123;</span><br><span class="line">			for(int j=i+i;j&lt;n;j+=i)&#123;</span><br><span class="line">				num[j]=0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int num[Max+1]=&#123;0&#125;;//因为我们算的都是正数，意思是没有用到下标为0的 </span><br><span class="line">	int sum,count;//依次表示的是输入的正数和拆分个数</span><br><span class="line">	eratosthenesFunction(num,Max);//送进去筛选</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		cin&gt;&gt;sum;</span><br><span class="line">		if(sum==0) break;//要先判断是否是终止条件</span><br><span class="line">		count=0;//这个是必须的，在循环中每一次循环都是不同的数字，必须重置</span><br><span class="line">		for(int i=2;i&lt;sum/2;i++)&#123;</span><br><span class="line">			//对于任何一个可以分解为两个素数之和的偶数，其中一个必然是小于或者等于1/2的。</span><br><span class="line">			if(num[i]&amp;&amp;num[sum-i])&#123;</span><br><span class="line">				//这里就是判断是否是两个质数</span><br><span class="line">				if(i!=sum-i)&#123;</span><br><span class="line">					count++; </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后结果：</p>
<p><img src="/2019/03/21/分拆素数和/accept.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/21/Dart学习笔记-一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/Dart学习笔记-一/" itemprop="url">Dart学习笔记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T13:29:36+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/Dart/" itemprop="url" rel="index">
                    <span itemprop="name">Dart</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  980
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#简单实例">简单实例</a></li>
<li><a href="#重要概念">重要概念</a></li>
<li><a href="#关键字">关键字</a></li>
<li><a href="#变量">变量</a><ul>
<li><a href="#未初始化">未初始化</a></li>
<li><a href="#final与const关键字">Final与const关键字</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="前言">前言</span></h2><p>由于最近写的一个东西需要到Flutter，所以Dart语言也必须学好，不多说，现在立马就开始吧。由于是个人向的学习笔记，所以，默认是已经学过其他编程语言了，然后很多和其他类似的语法就不过多赘述，只是表达目前新的东西。</p>
<h2><span id="简单实例">简单实例</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个函数</span><br><span class="line">printInteger(int aNumber) &#123;</span><br><span class="line">  print(&apos;The number is $aNumber.&apos;); // Print to console.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 程序执行入口</span><br><span class="line">main() &#123;</span><br><span class="line">  var number = 42; // Declare and initialize a variable.</span><br><span class="line">  printInteger(number); // Call a function.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dart内置的类型包括int，string，list，bool。</strong></p>
<p>print()用于<strong>显示输出</strong>。</p>
<p>main()是一种特殊的，必须的顶级函数，应用程序就从这里<strong>开始执行</strong>。</p>
<h2><span id="重要概念">重要概念</span></h2><p>在变量中可以放置的所有东西都是<strong>对象</strong>，而每个对象都是类的实例。无论数字、函数和null都是对象。<strong>所有对象都继承自[Object]类。</strong><br>    尽管Dart是<strong>强类型的</strong>，但类型声明是可选的，因为Dart可以推断类型。 在上面的代码中，数字被推断为int类型。 <strong>如果要明确说明不需要任何类型，请使用[特殊类型dynamic]。</strong><br>    Dart支持<strong>通用类型</strong>，如List<int>(整数列表)或List<dynamic>(任何类型的对象列表)。<br>    Dart支持<strong>顶级函数</strong>(如main())，以及绑定到类或对象(分别是静态方法（static）和实例（instance）方法)的函数。您还可以在函数(嵌套或局部函数)中创建函数。<br>    Dart支持<strong>顶级变量</strong>，以及绑定到类或对象(静态和实例变量)的变量。<strong>实例变量有时被称为字段或属性</strong>。<br>    与Java不同，<strong>Dart没有公开、保护和私有的关键字</strong>。如果标识符以下划线(<em>)开头，则该标识符对其库是<strong>私有的</strong>。<br>    标识符可以以字母或下划线(</em>)开头，然后是这些字符加上数字的<strong>任何组合</strong>。<br>    有时候，某事物是<strong>一个表达（expression ）还是一个语句（statement）</strong>是很重要的，所以这两个词要准确。</dynamic></int></p>
<h2><span id="关键字">关键字</span></h2><p>这就是Dart里面所有的关键字：</p>
<p>(1)带有上标1的单词是<strong>内置标识符</strong>。避免使用内置标识符作为标识符。如果尝试为类或类型名使用内置标识符，则会发生编译时错误。<br>    (2)使用上标2的单词是在Dart的1.0版本之后添加的与异步支持相关的<strong>更新的、有限的保留字</strong>。在以async, async<em>, 或者 sync</em> 标记的任何函数体中，不能使用async, await, 或者 yield作为标识符。</p>
<p>关键字表中的所有其他词都是<strong>保留词</strong>。<strong>不能使用保留词作为标识符。</strong></p>
<p><img src="/2019/03/21/Dart学习笔记-一/关键字.jpg" alt=""></p>
<h2><span id="变量">变量</span></h2><h3><span id="未初始化">未初始化</span></h3><p><strong>未初始化的变量的初始值为null。</strong>甚至具有数字类型的变量最初也是null，因为数字——就像dart中的其他东西一样——是<strong>对象</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int lineCount;</span><br><span class="line">assert(lineCount == null);</span><br></pre></td></tr></table></figure>
<h3><span id="final与const关键字">Final与const关键字</span></h3><p><strong>最终变量只能设置一次</strong>，const变量是一个编译时常数。(Const变量是<strong>隐式最终变量</strong>。)最终的顶级或类变量在第一次使用时被初始化。</p>
<p>注意:<strong>实例变量可以是final，但不能是const。</strong>[实例变量定义在对象一级，它可以被类中的任何方法或者其他类中的方法访问，但是不能被<strong>静态方法</strong>访问。]</p>
<p>对于想要<strong>在编译时确定并且不再变</strong>的变量，使用const。如果const变量位于<strong>类级别</strong>，则将其标记为<strong>静态const</strong>。</p>
<p>const关键字<strong>不只是声明常量变量</strong>。还可以使用它来创建常量值，以及声明创建常量值的构造函数。<strong>任何变量都可以赋一个常量值。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/21/java基础-渐入佳境/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/java基础-渐入佳境/" itemprop="url">java基础-渐入佳境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T12:35:17+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#前言">前言</a></li>
<li><a href="#对象实例化过程">对象实例化过程</a></li>
<li><a href="#方法的覆盖">方法的覆盖</a><ul>
<li><a href="#定义">定义</a></li>
<li><a href="#特点">特点</a></li>
</ul>
</li>
<li><a href="#final关键字">final关键字</a><ul>
<li><a href="#数据">数据</a></li>
<li><a href="#类">类</a></li>
<li><a href="#方法">方法</a></li>
<li><a href="#空final">空final</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="前言">前言</span></h2><p>关于Java基础系列的学习路线，我已经在<a href="https://thbelief.coding.me/2019/02/26/android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%80%BB%E7%BB%93plus/">安卓学习路线总结plus</a>里面写到了，我是按照那个上面的路线来学习的，如果有不明白的地方的话，可以移步前往作为 参考，也可以当成是目录。</p>
<h2><span id="对象实例化过程">对象实例化过程</span></h2><p>1.检查类<strong>是否已经加载</strong>，如果没有加载的话就加载这个类，需要加载所有的父类。</p>
<p>2.在内存堆中分配对象空间，递归分配所有父类和子类属性空间.先父类型再子类型,属性<strong>默认自动初始化</strong>.自动初始化为”0”值。</p>
<p>3.进行属性的赋值。</p>
<p>4.递归调用父类的构造器（默认的是调用父类的无参数构造器）。</p>
<p>5.调用本类的构造器。</p>
<p><strong>注意：</strong></p>
<p>1）静态初始化是指执行静态初始化块儿里面的内容。</p>
<p>2）实例初始化是指执行实例初始化块儿里面的内容。</p>
<p>3）构造方法：一个名称跟类的名称一样的方法，特殊在于不带返回值。</p>
<p><strong>实例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class TestInstanceInit &#123;</span><br><span class="line"></span><br><span class="line">public static int n = 0;// 静态变量</span><br><span class="line"></span><br><span class="line">static &#123;// 这是静态初始化块</span><br><span class="line">print();</span><br><span class="line">System.out.println(&quot;this is static block&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;// 实例初始化块</span><br><span class="line">System.out.println(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TestInstanceInit() &#123;// 构造方法</span><br><span class="line">System.out.println(&quot;this is TestInstanceInit&apos;s constructor~&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void print() &#123;// 静态方法</span><br><span class="line">System.out.println(&quot;this is static method~&quot;);</span><br><span class="line">System.out.println(n);</span><br><span class="line">n += 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new TestInstanceInit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this is static method~</span><br><span class="line">0</span><br><span class="line">this is static block</span><br><span class="line">1</span><br><span class="line">this is TestInstanceInit&apos;s constructor~</span><br></pre></td></tr></table></figure>
<p><strong>执行顺序：</strong></p>
<p><strong>(静态变量、静态初始化块)&gt;(变量、初始化快)&gt;构造器</strong>。</p>
<p>静态变量和静态初始化快/变量和初始化快的先后顺序取决于它们在类中出现的<strong>先后顺序</strong>。</p>
<p><a href="https://blog.csdn.net/avinegar/article/details/7749431" target="_blank" rel="noopener">参考链接</a></p>
<h2><span id="方法的覆盖">方法的覆盖</span></h2><h3><span id="定义">定义</span></h3><p>如果在子类中定义一个方法，其名称、返回类型及参数签名正好与父类中某个方法的名称、返回类型及参数签名相<strong>匹配</strong>，那么可以说，子类的方法覆盖了父类的方法。</p>
<h3><span id="特点">特点</span></h3><p> 子类的方法名称返回类型及参数签名 必须与父类的一致。<br>    子类方法不能缩小父类方法的访问权限。<br>    子类方法不能抛出比父类方法更多的异常。<br>    方法覆盖只存在于子类和父类之间，同一个类中只能重载。<br>    父类的静态方法不能被子类覆盖为非静态方法。<br>    子类可以定义于父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法（满足覆盖约束）， 而且Java虚拟机把静态方法和所属的类绑定，而把实例方法和所属的实例绑定。<br>    父类的非静态方法不能被子类覆盖为静态方法。<br>    父类的私有方法不能被子类覆盖。<br>    父类的抽象方法可以被子类通过两种途径覆盖（即实现和覆盖）。</p>
<p>父类的非抽象方法可以被覆盖为抽象方法。</p>
<h2><span id="final关键字">final关键字</span></h2><p>在Java中final关键字可以用来修饰数据，方法，参数以及类。</p>
<h3><span id="数据">数据</span></h3><p>final修饰的基本类型，在初始化之后就不能在赋值了，同理，修饰的对象一旦引用被初始化指向一个对象的话，就无法把它改指向另外一个对象。</p>
<p>但是要注意，被final修饰的对象引用，只是对象的应用不能修改，但是<strong>其自身却是可以修改的</strong>。</p>
<h3><span id="类">类</span></h3><p>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。</p>
<p>final类中的成员变量可以根据需要设为final，但是要注意final类中的所有<strong>成员方法</strong>都会被隐式地指定为<strong>final方法</strong>。</p>
<h3><span id="方法">方法</span></h3><p>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。</p>
<p><strong>注意:类的private方法会被隐式的指定为final方法。</strong></p>
<h3><span id="空final">空final</span></h3><p>谓的”空白final”是指被声明的为final但又为给定初值的对象引用或者基本数据。无论在什么情况下，编译器都会去确保final在使用前必须被初始化。若不进行初始化，会提示错误，这就意味着，必须在域的定义处或者每个构造器中使用表达式对final进行赋值，这正是final域在使用前被初始化的原因所在。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/20/JavaScript学习笔记-二/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/20/JavaScript学习笔记-二/" itemprop="url">JavaScript学习笔记(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-20T22:02:27+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#函数定义与调用">函数定义与调用</a><ul>
<li><a href="#定义函数">定义函数</a></li>
<li><a href="#调用函数">调用函数</a></li>
<li><a href="#特殊arguments">特殊arguments</a></li>
<li><a href="#rest参数">rest参数</a></li>
</ul>
</li>
<li><a href="#变量相关">变量相关</a><ul>
<li><a href="#变量提升">变量提升</a></li>
<li><a href="#全局作用域">全局作用域</a></li>
<li><a href="#名字空间">名字空间</a></li>
<li><a href="#局部作用域">局部作用域</a></li>
<li><a href="#常量">常量</a></li>
<li><a href="#解构赋值">解构赋值</a></li>
</ul>
</li>
<li><a href="#方法">方法</a><ul>
<li><a href="#apply">apply</a></li>
<li><a href="#装饰器">装饰器</a></li>
</ul>
</li>
<li><a href="#四个常用的高阶函数">四个常用的高阶函数</a><ul>
<li><a href="#map">map</a></li>
<li><a href="#reduce">reduce</a></li>
<li><a href="#filter">filter</a></li>
<li><a href="#sort">sort</a></li>
</ul>
</li>
<li><a href="#闭包">闭包</a><ul>
<li><a href="#函数作为返回值">函数作为返回值</a></li>
<li><a href="#箭头函数">箭头函数</a></li>
</ul>
</li>
<li><a href="#generator">generator</a><ul>
<li><a href="#优势">优势</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="函数定义与调用">函数定义与调用</span></h2><h3><span id="定义函数">定义函数</span></h3><p>第一种方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function hanshu()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.function指出这是一个<strong>函数定义</strong>；<br>    2.hanshu是<strong>函数的名称</strong>；<br>    3.(x)括号内列出函数的参数，多个参数<strong>以,分隔</strong>；<br>    4.{ … }之间的代码是<strong>函数体</strong>，可以包含若干语句，甚至可以没有任何语句。</p>
<p>第二种方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var hanshu = function (x) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>function (x) { … }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量hanshu，所以，通过变量hanshu就可以调用该函数。这两种其实是完全等价的，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。</p>
<h3><span id="调用函数">调用函数</span></h3><p>JS中有点儿特殊，主要就是特殊在JS中对于一个函数传进去的参数<strong>不做限制</strong>，传多了没有问题，只是在内部没有用而已，传少了的话计算结果会变成NaN。如果想保险一点儿的话，可以直接在函数里面对于传进来的参数做判断即可。</p>
<h3><span id="特殊arguments">特殊arguments</span></h3><p>在<strong>函数内部</strong>起作用，并且永远指向<strong>当前函数的调用者传入的所有参数</strong>。arguments类似Array但它不是一个Array。意思也就是，就算函数并没有定义任何的变量，也是可以拿到参数的值。</p>
<h3><span id="rest参数">rest参数</span></h3><p>（ES6引入）rest参数只能写在<strong>最后</strong>，前面用…标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments就获取了全部参数。</p>
<p>如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个<strong>空数组</strong>（注意<strong>不是undefined</strong>）。</p>
<p>特别注意:JS里面有一个<strong>自动在行末添加分号</strong>的性质，所以特别需要注意。</p>
<h2><span id="变量相关">变量相关</span></h2><p>注意，由于JS支持函数嵌套，在查找变量时从自身函数定义开始，<strong>从“内”向“外”</strong>查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“<strong>屏蔽</strong>”外部函数的变量。</p>
<h3><span id="变量提升">变量提升</span></h3><p>JS函数的特性，它执行前会扫描整个函数体，<strong>把所有声明的变量都放到顶部</strong>。但是要注意，它<strong>只是提升变量的声明，并没有提升变量的赋值</strong>。</p>
<p>所以为了避免有些错误，建议是在函数体内，<strong>把所有的变量声明都放到函数的开头</strong>。</p>
<h3><span id="全局作用域">全局作用域</span></h3><p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var bianliang=&apos;thbelief&apos;;</span><br><span class="line">function hanshu()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的话，访问bianliang与访问window.bianliang是完全一样的。</p>
<p>同时，第二种函数的定义方式其实也是一种全局的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var hanshu = function (x) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以，其实JS只有一个<strong>全局作用域</strong>。</p>
<h3><span id="名字空间">名字空间</span></h3><p>全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成<strong>命名冲突</strong>，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部<strong>绑定到一个全局变量中</strong>。</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 唯一的全局变量MYAPP:</span><br><span class="line">var MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 其他变量:</span><br><span class="line">MYAPP.name = &apos;myapp&apos;;</span><br><span class="line">MYAPP.version = 1.0;</span><br><span class="line"></span><br><span class="line">// 其他函数:</span><br><span class="line">MYAPP.foo = function () &#123;</span><br><span class="line">    return &apos;foo&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个其实是一个特别实用的方法，必须提倡。</p>
<h3><span id="局部作用域">局部作用域</span></h3><p>在循环中，一般使用let替代var声明次级作用域的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    var sum = 0;</span><br><span class="line">    for (let i=0; i&lt;100; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    i += 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="常量">常量</span></h3><p>ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域。但是需要注意，<strong>不是所有的地方都支持</strong>，因为ES6才引进。</p>
<h3><span id="解构赋值">解构赋值</span></h3><p>可以直接对多个变量同时赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">// 如果浏览器支持解构赋值就不会报错:</span><br><span class="line">var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;];</span><br></pre></td></tr></table></figure>
<p>注意，对数组元素进行解构赋值时，<strong>多个变量要用[…]括起来</strong>。</p>
<p>有些时候数组本身还有<strong>嵌套</strong>，也可以解构赋值，但是需要保持嵌套层次和位置的<strong>一致性</strong>。</p>
<p>解构赋值还有<strong>很多用法</strong>，这里就不一一阐述了，需要的时候直接去查就好啦。</p>
<h2><span id="方法">方法</span></h2><p>在一个对象中绑定函数，这就是这个对象的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var thbelief = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;,</span><br><span class="line">    birth: 1999,</span><br><span class="line">    age: function () &#123;</span><br><span class="line">        var y = new Date().getFullYear();</span><br><span class="line">        return y - this.birth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">thbelief.age; // function thbelief.age()</span><br><span class="line">thbelief.age();</span><br></pre></td></tr></table></figure>
<p>同时，this关键字在JS里面也有和C++同样的作用，可以直接调用本函数的方法。</p>
<p>但是一定要用对象的形式调用，这才是指向本函数里面的方法，不然的话就是对于整个全局作用域来说的。</p>
<p>解决的方法其实也有，就是<strong>var that = this;</strong>这条语句加上去在用的地方就可以了。</p>
<h3><span id="apply">apply</span></h3><p>虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，还是可以<strong>控制this的指向</strong>！</p>
<p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>用apply修复getAge()调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getAge() &#123;</span><br><span class="line">    var y = new Date().getFullYear();</span><br><span class="line">    return y - this.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var thbelief = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;,</span><br><span class="line">    birth: 1999,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">thbelief.age(); </span><br><span class="line">getAge.apply(thbelief, []);</span><br></pre></td></tr></table></figure>
<p>另一个与apply()类似的方法是<strong>call()</strong>，唯一<strong>区别</strong>是：</p>
<p>apply()把参数打包成Array再传入；</p>
<p>call()把参数按顺序传入。</p>
<p>比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max.apply(null, [3, 5, 4]); // 5</span><br><span class="line">Math.max.call(null, 3, 5, 4); // 5</span><br></pre></td></tr></table></figure>
<h3><span id="装饰器">装饰器</span></h3><p>利用apply()，我们还可以<strong>动态改变函数的行为</strong>。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以<strong>重新</strong>指向新的函数。</p>
<h2><span id="四个常用的高阶函数">四个常用的高阶函数</span></h2><h3><span id="map">map</span></h3><p>map可以传入任意的变量或者自己定义的相关函数，比如说做一个2的次方运算，相比较于我们傻乎乎的使用循环一层一层的套，map作为高阶函数无疑是更加具有实力的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">function pow(x) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure>
<h3><span id="reduce">reduce</span></h3><p>Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数<strong>必须接收两个参数</strong>，reduce()把结果继续和序列的下一个元素做累积计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 5, 7, 9];</span><br><span class="line">arr.reduce(function (x, y) &#123;</span><br><span class="line">    return x * 10 + y;</span><br><span class="line">&#125;); // 13579</span><br></pre></td></tr></table></figure>
<h3><span id="filter">filter</span></h3><p>其实有点儿类似于Android里面的过滤器。它的作用就是将Array里面的某些元素过滤掉，然后返回剩下的元素。</p>
<p>和map()类似，Array的filter()也接收<strong>一个函数</strong>。和map()不同的是，filter()把传入的函数<strong>依次</strong>作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, null, undefined, &apos;C&apos;, &apos;  &apos;];</span><br><span class="line">var r = arr.filter(function (s) &#123;</span><br><span class="line">    return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法</span><br><span class="line">&#125;);</span><br><span class="line">r; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br></pre></td></tr></table></figure>
<h3><span id="sort">sort</span></h3><p>需要注意的是，sort<strong>默认的排序</strong>不是简简单单的针对于数字进行排序。</p>
<p>它的默认把所有元素<strong>先转换为String</strong>再排序。</p>
<p>同时，作为一个函数，sort可以传入一个比较函数来作为依据。</p>
<p>比如说下面这个按照数字大小来进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var arr = [10, 20, 1, 2];</span><br><span class="line">arr.sort(function (x, y) &#123;</span><br><span class="line">    if (x &lt; y) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; y) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="闭包">闭包</span></h2><h3><span id="函数作为返回值">函数作为返回值</span></h3><p>高阶函数除了可以接受函数作为参数外，还可以<strong>把函数作为结果值</strong>返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function lazy_sum(arr) &#123;</span><br><span class="line">    var sum = function () &#123;</span><br><span class="line">        return arr.reduce(function (x, y) &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()</span><br></pre></td></tr></table></figure>
<p>调用函数f时，才真正计算求和的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(); // 15</span><br></pre></td></tr></table></figure>
<p>函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>返回闭包时牢记的一点就是：<strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量</strong>。因为它只会锁定最后一个结果。如果一定要引用循环变量的话，方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的<strong>值不变</strong>。</p>
<p>闭包还有很多应用，这里只是阐述基本概念，相关的使用要用的时候自己查即可。</p>
<h3><span id="箭头函数">箭头函数</span></h3><p>是在ES6之后推出的，<strong>只支持ES6之后的版本</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x * x;</span><br><span class="line">//两者完全等价</span><br><span class="line">function (x) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数相当于<strong>匿名函数</strong>，并且<strong>简化了函数定义</strong>。</p>
<p>箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。</p>
<p>还有一种可以包含多条语句，这时候就<strong>不能省略{ … }和return</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">    if (x &gt; 0) &#123;</span><br><span class="line">        return x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return - x * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 两个参数:</span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line"></span><br><span class="line">// 无参数:</span><br><span class="line">() =&gt; 3.14</span><br><span class="line"></span><br><span class="line">// 可变参数:</span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    var i, sum = x + y;</span><br><span class="line">    for (i=0; i&lt;rest.length; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要返回一个对象，并且是单表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ok:</span><br><span class="line">x =&gt; (&#123; foo: x &#125;)</span><br></pre></td></tr></table></figure>
<p><strong>this：</strong></p>
<p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。由于this在箭头函数中已经被绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略…</p>
<h2><span id="generator">generator</span></h2><p>generator（生成器）是ES6新引入的新的数据类型。<strong>一个generator看上去像一个函数，但可以返回多次</strong>。</p>
<p>定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function* foo(x) &#123;</span><br><span class="line">    yield x + 1;</span><br><span class="line">    yield x + 2;</span><br><span class="line">    return x + 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>generator和函数不同的是，generator由function<em>定义（注意多出的</em>号），并且，除了return语句，还可以用yield返回多次。</p>
<h3><span id="优势">优势</span></h3><p>1.因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就<strong>可以实现需要用面向对象才能实现的功能</strong>。</p>
<p>2.把异步回调代码变成“同步”代码。（深）</p>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">参考链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/19/Auto-js-Script开发-一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/19/Auto-js-Script开发-一/" itemprop="url">Auto.js Script开发(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-19T10:20:57+08:00">
                2019-03-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/" itemprop="url" rel="index">
                    <span itemprop="name">移动端开发</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端开发/Auto-js/" itemprop="url" rel="index">
                    <span itemprop="name">Auto.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#正文">正文</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#下个版本">下个版本</a></li>
</ul>
<!-- tocstop -->
<h2><span id="简介">简介</span></h2><p>Auto.js使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">JavaScript</a>作为脚本语言，目前使用<a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/Rhino" target="_blank" rel="noopener">Rhino 1.7.7.2</a>作为脚本引擎，支持ES5与部分ES6特性。</p>
<p>最开始接触Auto.js只是单纯的想写一个I西科自动签到的脚本，接触后才发现，写这样一个脚本其实简单的不行，然后了解了Auto.js的相关特性之后，我决定好好的学习一下这个工具，毕竟，它实在是太简约了，不像其他的脚本语言那么复杂，虽然…有点儿bug，毕竟开发者自己也只是一个大学生，不能指望有多完善，但是这种自动化脚本编辑实在是太有魅力了。</p>
<h2><span id="正文">正文</span></h2><p>最近正在开发的<strong>Script</strong>，主要目的是借用Auto.js自带的UI模块儿集成一个个人向的脚本库。</p>
<p>这个版本的展示图：</p>
<p><img src="/2019/03/19/Auto-js-Script开发-一/菜单.png" alt=""></p>
<p><img src="/2019/03/19/Auto-js-Script开发-一/自动签到.png" alt=""></p>
<p><img src="/2019/03/19/Auto-js-Script开发-一/自动回复.jpg" alt=""></p>
<p>目前代码展示如下，由于太简单，懒得上传到Github了，直接贴代码（后期如果有升级或者说是改良，会在下一个博客继续写）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&quot;ui&quot;;</span><br><span class="line">//下面就是主界面</span><br><span class="line">ui.layout(</span><br><span class="line">    &lt;vertical&gt;</span><br><span class="line">        &lt;horizontal&gt;</span><br><span class="line">            &lt;text text=&quot;菜单&quot; w=&quot;*&quot; h=&quot;*&quot; layout_weight=&quot;1&quot; gravity=&quot;center&quot; textSize=&quot;30sp&quot; color=&quot;#000000&quot;/&gt;</span><br><span class="line">        &lt;/horizontal&gt;</span><br><span class="line">        &lt;horizontal&gt;</span><br><span class="line">            &lt;button id=&quot;autoReply&quot; text=&quot;QQ自动回复&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">            &lt;button id=&quot;autoReplyClose&quot; text=&quot;关闭&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;/horizontal&gt;</span><br><span class="line">        &lt;horizontal&gt;</span><br><span class="line">            &lt;button id=&quot;autoSignIn&quot; text=&quot;i西科自动签到&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">            &lt;button id=&quot;autoSignInClose&quot; text=&quot;关闭&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;/horizontal&gt;</span><br><span class="line">    &lt;/vertical&gt;</span><br><span class="line">);</span><br><span class="line">//封装的回复方法</span><br><span class="line">function WhatReply(notificationText)&#123;</span><br><span class="line">    if(notificationText==&apos;A&apos;)&#123;</span><br><span class="line">        return(&quot;您好，我是主人正在开发的人工智障robot001.\n   ——robot001欢喜的答道。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(notificationText==&apos;B&apos;)&#123;</span><br><span class="line">        return(&quot;好的，我马上联系主人...\n   ——robot001郑重的答道。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return &quot;主人在忙呢！\n有问题请回复下列单个字母：\n A.robot是谁？\n B.有要事迅速联系thbelief. \n   ——robot001如此回答道。&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//先封装一个自动回复的方法</span><br><span class="line">function autoReplyFunction()&#123;</span><br><span class="line">    auto();//检查是否开启了无障碍服务权限</span><br><span class="line">    events.observeNotification();//监听消息</span><br><span class="line">    events.onNotification(function(notification)&#123;</span><br><span class="line">        var string1=&quot;com.tencent.mobileqq&quot;;//如果是QQ消息的话</span><br><span class="line">        if(string1==notification.getPackageName())&#123;</span><br><span class="line">            notification.click();//点击直接进入对应的聊天界面</span><br><span class="line">            //跳转必须要用startActivity</span><br><span class="line">            waitForPackage(&quot;com.tencent.mobileqq&quot;);</span><br><span class="line">            var t=className(&quot;android.widget.EditText&quot;).id(&quot;input&quot;).findOnce();//找到聊天输入控件</span><br><span class="line">            t.setText(WhatReply(notification.getText()));//这里加入回复的方法</span><br><span class="line">            className(&quot;android.widget.Button&quot;).id(&quot;fun_btn&quot;).findOnce().click();//发送即可</span><br><span class="line">            home();//直接返回桌面</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">//自动签到的方法</span><br><span class="line">function autoSignInFunction()&#123;</span><br><span class="line">    auto();</span><br><span class="line">    //打开i西科</span><br><span class="line">    launchApp(&quot;i西科&quot;);</span><br><span class="line">    //跳转到相应的界面</span><br><span class="line">    waitForPackage(&quot;org.weixvn.frame&quot;);</span><br><span class="line">    //找到首页上签到的按钮，点击进去</span><br><span class="line">    id(&quot;it_sign_in&quot;).clickable().findOne().click();</span><br><span class="line">    waitForActivity(&quot;com.example.z.iswust.view.activity.impl.SignInActivity&quot;);</span><br><span class="line">    //点击签到</span><br><span class="line">    if(id(&quot;btn_signin&quot;).clickable().findOne().click())&#123;</span><br><span class="line">        //完成任务后返回桌面</span><br><span class="line">        home();</span><br><span class="line">        toast(&quot;签到成功了哟，亲~~~&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">//自动回复按钮的点击事件</span><br><span class="line">ui.autoReply.click(()=&gt;&#123;</span><br><span class="line">    //UI模式的情况下必须用Promise形式或者回调模式</span><br><span class="line">    confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123;</span><br><span class="line">        if(sure)&#123;</span><br><span class="line">            //修改控件信息必须更改线程</span><br><span class="line">            threads.start(function()&#123;</span><br><span class="line">                autoReplyFunction();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">//自动回复按钮的关闭点击事件</span><br><span class="line">ui.autoReplyClose.click(()=&gt;&#123;</span><br><span class="line">    //这里由于只有一个脚本，我就直接把所有的脚本都关闭了，如果是很多脚本的话必须改</span><br><span class="line">    engines.stopAll();</span><br><span class="line">    toast(&quot;自动回复脚本已经关闭了哦，亲~&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//i西科自动签到的点击事件</span><br><span class="line">ui.autoSignIn.click(()=&gt;&#123;</span><br><span class="line">    confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123;</span><br><span class="line">        if(sure)&#123;</span><br><span class="line">            //修改控件信息必须更改线程</span><br><span class="line">            threads.start(function()&#123;</span><br><span class="line">                //自动签到的方法</span><br><span class="line">                autoSignInFunction();</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2><span id="总结">总结</span></h2><p>1.一定要判断是否开启了<strong>无障碍服务权限</strong>以及<strong>通知使用权</strong>。</p>
<p>2.无论是不是用intent跳转页面或者应用，都应该用<strong>waitForActivity或者waitForPackage</strong>来跳转，不然容易出错。</p>
<p>3.基于控件的操作的时候，一定要注意寻找的依据，<strong>尽量使用不重复的依据</strong>，例如desc或者说id这种，提高兼容性。</p>
<p>4.方法的封装应该是根据<strong>功能</strong>来的，这一点本版本还没有做完善。</p>
<p>5.提示信息一定要做到位，该Toast的地方就一定要毫不犹豫的<strong>Toast</strong>.</p>
<p>6.如果想进入某个界面做某事，可以直接在外面套个if，这样出错的几率会小很多，比如说本版本的<strong>autoSignInFunction</strong>函数里面的点击签到。</p>
<p>7.UI模式情况下必须使用<strong>Promise形式</strong>或者说是<strong>回调模式</strong>。</p>
<p>8.还有就是，运行多个脚本的时候，都要使用<strong>多线程</strong>。</p>
<h2><span id="下个版本">下个版本</span></h2><p>1.UI界面做的是真的丑，下个版本尽量修复。</p>
<p>2.添加检查更新的功能，直接app内检查更新并更新到最新版本。</p>
<p>3.添加更多的脚本选项。</p>
<p>4.定时运行，比如说，定时自启之类的，例如本版本的i西科自动签到功能，定时启动签到。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/18/JavaScript学习笔记-一/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/18/JavaScript学习笔记-一/" itemprop="url">JavaScript学习笔记(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T21:06:35+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#入门">入门</a><ul>
<li><a href="#基本语法">基本语法</a></li>
<li><a href="#数据类型">数据类型</a><ul>
<li><a href="#number">Number</a></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#布尔值">布尔值</a></li>
<li><a href="#比较运算符">比较运算符</a></li>
<li><a href="#null和undefined">null和undefined</a></li>
<li><a href="#数组">数组</a></li>
<li><a href="#对象">对象</a></li>
<li><a href="#变量">变量</a></li>
<li><a href="#strict模式">strict模式</a></li>
</ul>
</li>
<li><a href="#字符串-1">字符串</a></li>
<li><a href="#数组-1">数组</a><ul>
<li><a href="#length">length</a></li>
<li><a href="#indexof">indexOf</a></li>
<li><a href="#slice">slice</a></li>
<li><a href="#push和pop">push和pop</a></li>
<li><a href="#unshift和shift">unshift和shift</a></li>
<li><a href="#sort">sort</a></li>
<li><a href="#reverse">reverse</a></li>
<li><a href="#splice">splice</a></li>
<li><a href="#concat">concat</a></li>
<li><a href="#join">join</a></li>
<li><a href="#多维数组">多维数组</a></li>
</ul>
</li>
<li><a href="#对象-1">对象</a></li>
<li><a href="#条件判断">条件判断</a></li>
<li><a href="#循环">循环</a><ul>
<li><a href="#forin">for…in</a></li>
<li><a href="#while">while</a></li>
<li><a href="#do-while">do while</a></li>
</ul>
</li>
<li><a href="#map和set">Map和Set</a></li>
<li><a href="#iterable">iterable</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h2><span id="入门">入门</span></h2><h3><span id="基本语法">基本语法</span></h3><p>每个语句以<code>;</code>结束，语句块用<code>{...}</code>。但是，JavaScript并不强制要求在每个语句的结尾加<code>;</code>，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上<code>;</code>。</p>
<h3><span id="数据类型">数据类型</span></h3><h4><span id="number">Number</span></h4><p>JS里面不区分整数和浮点数，都是用Number统一表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">123; // 整数123</span><br><span class="line">0.456; // 浮点数0.456</span><br><span class="line">1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5</span><br><span class="line">-99; // 负数</span><br><span class="line">NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示</span><br><span class="line">Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span><br></pre></td></tr></table></figure>
<h4><span id="字符串">字符串</span></h4><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分。</p>
<h4><span id="布尔值">布尔值</span></h4><p>只表示true或者false。和C++与Java中完全类似，这里不过多赘述。</p>
<h4><span id="比较运算符">比较运算符</span></h4><p>注意，JavaScript允许对任意数据类型做比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false == 0; // true</span><br><span class="line">false === 0; // false</span><br></pre></td></tr></table></figure>
<p>特别要注意上述两种格式。</p>
<p>第一种是<code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</p>
<p>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回<code>false</code>，如果一致，再比较。</p>
<p>这是JS自身设计的缺陷，大佬们都是推荐的是<em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较。</p>
<p>还要注意一点是，NaN这个特殊的Number与所有值都不相等，包括它自己。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN === NaN; // false</span><br></pre></td></tr></table></figure>
<p>唯一能够判断NaN的方法就是isNaN()函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN); // true</span><br></pre></td></tr></table></figure>
<p>最后，浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true</span><br></pre></td></tr></table></figure>
<h4><span id="null和undefined">null和undefined</span></h4><p>null表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。</p>
<p>JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用<strong>null</strong>。undefined仅仅在判断函数参数是否传递的情况下有用。</p>
<h4><span id="数组">数组</span></h4><p>数组是一组按<strong>顺序</strong>排列的集合，集合的每个值称为元素。JavaScript的数组可以包括<strong>任意数据类型</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3.14, &apos;HelloWorld&apos;, null, true];</span><br></pre></td></tr></table></figure>
<p>创建数组的另一个方法是Array()函数来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Array(1, 2, 3); // 创建了数组[1, 2, 3]</span><br></pre></td></tr></table></figure>
<h4><span id="对象">对象</span></h4><p>JavaScript的对象是一组由键-值组成的无序集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;thbeleif&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    tags: [&apos;js&apos;, &apos;web&apos;, &apos;mobile&apos;],</span><br><span class="line">    city: &apos;mianyang&apos;,</span><br><span class="line">    hasCar: false,</span><br><span class="line">    zipcode: null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性。</p>
<p>要获取一个对象的属性，需要用对象变量.属性名的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person.name; // &apos;thbelief&apos;</span><br><span class="line">person.zipcode; // null</span><br></pre></td></tr></table></figure>
<h4><span id="变量">变量</span></h4><p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且<strong>不能用数字开头</strong>。变量名也不能是JavaScript的关键字，如if、while等。</p>
<p>在Chrome浏览器里面使用JS的时候，可以直接使用<strong>console.log(x)</strong>来打印变量的值。</p>
<p>相比较于alert()的对话框，前者看起来无疑是更舒心的。</p>
<h4><span id="strict模式">strict模式</span></h4><p>在JS设计之初，如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为<strong>全局变量</strong>。</p>
<p>后面有了改良，在<strong>strict模式</strong>下运行的JavaScript代码，强制通过<code>var</code>申明变量，未使用<code>var</code>申明变量就使用的，将导致运行错误。</p>
<p>启用strict模式的方法是在JavaScript代码的第一行写上即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br></pre></td></tr></table></figure>
<h3><span id="字符串">字符串</span></h3><p>如果字符串内部既包含’又包含”可以用转义字符\来标识。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;I\&apos;m \&quot;OK\&quot;!&apos;;</span><br></pre></td></tr></table></figure>
<p>ASCII字符可以以<code>\x##</code>形式的十六进制表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;\x41&apos;; // 完全等同于 &apos;A&apos;</span><br></pre></td></tr></table></figure>
<p>还可以用<code>\u####</code>表示一个Unicode字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;\u4e2d\u6587&apos;; // 完全等同于 &apos;中文&apos;</span><br></pre></td></tr></table></figure>
<p>由于多行字符串用<code>\n</code>写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 <em>`</em> … <em>`</em> 也可以表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`这是一个</span><br><span class="line">多行</span><br><span class="line">字符串`;</span><br></pre></td></tr></table></figure>
<p>要把多个字符串连接起来，可以用+号连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;小明&apos;;</span><br><span class="line">var age = 20;</span><br><span class="line">var message = &apos;你好, &apos; + name + &apos;, 你今年&apos; + age + &apos;岁了!&apos;;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
<p>字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果。JS对于字符串提供了许多的方法，但是调用这些方法只会返回一个新的字符串，而不会改变原有的字符串内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toUpperCase()把一个字符串全部变为大写。</span><br><span class="line">indexOf()会搜索指定字符串出现的位置。</span><br><span class="line">substring()返回指定索引区间的子串。</span><br></pre></td></tr></table></figure>
<h3><span id="数组">数组</span></h3><h4><span id="length">length</span></h4><p>JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。</p>
<p>Array可以通过length属性来取得长度。</p>
<p>同时，直接给Array的length赋一个新的值会导致Array大小的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.length; // 3</span><br><span class="line">arr.length = 6;</span><br><span class="line">arr; // arr变为[1, 2, 3, undefined, undefined, undefined]</span><br><span class="line">arr.length = 2;</span><br><span class="line">arr; // arr变为[1, 2]</span><br></pre></td></tr></table></figure>
<p>Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array。</p>
<p>如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr[5] = &apos;x&apos;;</span><br><span class="line">arr; // arr变为[1, 2, 3, undefined, undefined, &apos;x&apos;]</span><br></pre></td></tr></table></figure>
<h4><span id="indexof">indexOf</span></h4><p>Array也可以通过indexOf()来搜索一个指定的元素的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [10, 20, &apos;30&apos;, &apos;xyz&apos;];</span><br><span class="line">arr.indexOf(10); // 元素10的索引为0</span><br><span class="line">arr.indexOf(20); // 元素20的索引为1</span><br><span class="line">arr.indexOf(30); // 元素30没有找到，返回-1</span><br><span class="line">arr.indexOf(&apos;30&apos;); // 元素&apos;30&apos;的索引为2</span><br></pre></td></tr></table></figure>
<h4><span id="slice">slice</span></h4><p>slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];</span><br><span class="line">arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br><span class="line">arr.slice(3); // 从索引3开始到结束: [&apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]</span><br></pre></td></tr></table></figure>
<p>注意到<code>slice()</code>的起止参数包括开始索引，<strong>不包括结束索引</strong>。</p>
<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];</span><br><span class="line">var aCopy = arr.slice();</span><br><span class="line">aCopy; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]</span><br><span class="line">aCopy === arr; // false</span><br></pre></td></tr></table></figure>
<h4><span id="push和pop">push和pop</span></h4><p>push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉。</p>
<h4><span id="unshift和shift">unshift和shift</span></h4><p>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉。</p>
<h4><span id="sort">sort</span></h4><p>按照默认顺序进行排序，也可以自定义顺序。</p>
<h4><span id="reverse">reverse</span></h4><p>翻转整个Array，把元素顺序翻转过来。</p>
<h4><span id="splice">splice</span></h4><p>从指定的索引开始删除若干元素，然后再从该位置添加若干元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];</span><br><span class="line">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</span><br><span class="line">// 只删除,不添加:</span><br><span class="line">arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]</span><br><span class="line">// 只添加,不删除:</span><br><span class="line">arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素</span><br><span class="line">arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]</span><br></pre></td></tr></table></figure>
<h4><span id="concat">concat</span></h4><p>把当前的Array和另一个Array连接起来，并返回一个新的Array。</p>
<p>值得注意的是，concat()方法并没有修改当前Array，而是返回了一个新的Array。</p>
<h4><span id="join">join</span></h4><p>把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。如果Array的元素不是字符串，将自动转换为字符串后再连接。</p>
<h4><span id="多维数组">多维数组</span></h4><p>如果数组的某个元素又是一个Array，则可以形成多维数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [[1, 2, 3], [400, 500, 600], &apos;-&apos;];</span><br></pre></td></tr></table></figure>
<h3><span id="对象">对象</span></h3><p>JS的对象是一种无序的集合数据类型，它由若干键值对组成。</p>
<p>JS用一个{…}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,。</p>
<p>访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用’’括起来。</p>
<p><strong>JavaScript规定，访问不存在的属性不报错，而是返回undefined。</strong></p>
<p>由于JavaScript的对象是<strong>动态类型</strong>，可以自由地给一个对象添加或删除属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var thbelief = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; // undefined</span><br><span class="line">xiaoming.age = 18; // 新增一个age属性</span><br><span class="line">xiaoming.age; // 18</span><br><span class="line">delete xiaoming.age; // 删除age属性</span><br><span class="line">xiaoming.age; // undefined</span><br><span class="line">delete xiaoming[&apos;name&apos;]; // 删除name属性</span><br><span class="line">xiaoming.name; // undefined</span><br><span class="line">delete xiaoming.school; // 删除一个不存在的school属性也不会报错</span><br></pre></td></tr></table></figure>
<p>果我们要检测thbelief是否拥有某一属性，可以用in操作符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;name&apos; in thbelief; // true</span><br></pre></td></tr></table></figure>
<p>另外，如果in判断一个属性存在，这个属性不一定是thbelief的，它可能是thbelief继承得到的。</p>
<p>要判断一个属性是否是thbelief自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var thbelief = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;</span><br><span class="line">&#125;;</span><br><span class="line">thbelief.hasOwnProperty(&apos;name&apos;); // true</span><br><span class="line">thbelief.hasOwnProperty(&apos;toString&apos;); // false</span><br></pre></td></tr></table></figure>
<h3><span id="条件判断">条件判断</span></h3><p>JavaScript可以使用if () { … } else { … }来进行条件判断。</p>
<p>同时，也可以像C++中一样进行多重的嵌套。</p>
<h3><span id="循环">循环</span></h3><p>熟悉的是单独的For循环，但是还包括了其他的不熟悉的循环方式。</p>
<h4><span id="forin">for…in</span></h4><p>它可以把一个对象的所有属性依次循环出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    name: &apos;thbelief&apos;,</span><br><span class="line">    age: 20,</span><br><span class="line">    city: &apos;mianyang&apos;</span><br><span class="line">&#125;;</span><br><span class="line">for (var key in o) &#123;</span><br><span class="line">    console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要过滤掉对象继承的属性，用hasOwnProperty()来实现。（前文对象中曾经提到）</p>
<p>值得注意的是，for … in对Array的循环得到的是String而不是Number。</p>
<h4><span id="while">while</span></h4><p>与C++中类似。</p>
<h4><span id="do-while">do while</span></h4><p>与C++中类似。</p>
<h3><span id="map和set">Map和Set</span></h3><p>Map是一组键值对的结构，具有极快的查找速度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;); // 95</span><br></pre></td></tr></table></figure>
<p>初始化Map需要一个<strong>二维数组</strong>，或者直接初始化一个<strong>空Map</strong>。Map具有以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map(); // 空Map</span><br><span class="line">m.set(&apos;Adam&apos;, 67); // 添加新的key-value</span><br><span class="line">m.set(&apos;Bob&apos;, 59);</span><br><span class="line">m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: true</span><br><span class="line">m.get(&apos;Adam&apos;); // 67</span><br><span class="line">m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;</span><br><span class="line">m.get(&apos;Adam&apos;); // undefined</span><br></pre></td></tr></table></figure>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line">m.set(&apos;Adam&apos;, 67);</span><br><span class="line">m.set(&apos;Adam&apos;, 88);</span><br><span class="line">m.get(&apos;Adam&apos;); // 88</span><br></pre></td></tr></table></figure>
<p>Set和Map类似，也是一组key的集合，但<strong>不存储value</strong>。由于key不能重复，所以，在Set中，没有重复的key。</p>
<p>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s1 = new Set(); // 空Set</span><br><span class="line">var s2 = new Set([1, 2, 3]); // 含1, 2, 3</span><br></pre></td></tr></table></figure>
<p>通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果。</p>
<p>同样的，通过delete(key)方法可以删除元素。</p>
<h3><span id="iterable">iterable</span></h3><p>具有iterable类型的集合可以通过新的for … of循环来遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);</span><br><span class="line">var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);</span><br><span class="line">for (var x of a) &#123; // 遍历Array</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">for (var x of s) &#123; // 遍历Set</span><br><span class="line">    console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">for (var x of m) &#123; // 遍历Map</span><br><span class="line">    console.log(x[0] + &apos;=&apos; + x[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for … in循环遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。如果手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">a.name = &apos;Hello&apos;;</span><br><span class="line">for (var x in a) &#123;</span><br><span class="line">    console.log(x); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;name&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>for … in</strong>循环将把name包括在内，但Array的length属性却不包括在内。</p>
<p><strong>for … of</strong>循环则完全修复了这些问题，它只循环<strong>集合本身的元素</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">a.name = &apos;Hello&apos;;</span><br><span class="line">for (var x of a) &#123;</span><br><span class="line">    console.log(x); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="noopener">参考链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://thbelief.coding.me/2019/03/09/java番外-多线程编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="THBELIEF">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/zhangguoron.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THBELIEF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/java番外-多线程编程/" itemprop="url">java番外-多线程编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-09T15:49:38+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="目录">目录：</span></h1><!-- toc -->
<ul>
<li><a href="#1线程与进程的异同">1.线程与进程的异同：</a></li>
<li><a href="#2线程的生命周期">2.线程的生命周期：</a><ul>
<li><a href="#新建状态">新建状态：</a></li>
<li><a href="#就绪状态">就绪状态：</a></li>
<li><a href="#运行状态">运行状态：</a></li>
<li><a href="#阻塞状态">阻塞状态：</a></li>
<li><a href="#死亡状态">死亡状态：</a></li>
</ul>
</li>
<li><a href="#3线程的优先级">3.线程的优先级：</a></li>
<li><a href="#4创建线程的三种方式">4.创建线程的三种方式：</a><ul>
<li><a href="#通过runnable接口创建线程">通过Runnable接口创建线程：</a></li>
<li><a href="#通过集成thread类来创建线程">通过集成Thread类来创建线程：</a></li>
<li><a href="#通过callable和future创建线程">通过Callable和Future创建线程：</a></li>
<li><a href="#三种方式的对比">三种方式的对比：</a></li>
</ul>
</li>
<li><a href="#线程的几个重要的概念">线程的几个重要的概念：</a></li>
</ul>
<!-- tocstop -->
<h2><span id="1线程与进程的异同">1.线程与进程的异同：</span></h2><p><strong>线程</strong>：一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p><strong>进程</strong>：一个进程包括了由操作系统分配的内存空间，包含了一个或者多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。</p>
<h2><span id="2线程的生命周期">2.线程的生命周期：</span></h2><p><img src="/2019/03/09/java番外-多线程编程/D:/hexo/source/_posts/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt=""></p>
<p><strong>相关解释：</strong></p>
<h3><span id="新建状态">新建状态：</span></h3><p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>
<h3><span id="就绪状态">就绪状态：</span></h3><p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
<h3><span id="运行状态">运行状态：</span></h3><p>如果就绪状态的线程获取 CPU 资源，就可以执行 <strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
<h3><span id="阻塞状态">阻塞状态：</span></h3><p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p>
<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li>
</ul>
<h3><span id="死亡状态">死亡状态：</span></h3><p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>
<h2><span id="3线程的优先级">3.线程的优先级：</span></h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p>
<p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p>
<p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>
<p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p>
<h2><span id="4创建线程的三种方式">4.创建线程的三种方式：</span></h2><ul>
<li>通过实现 Runnable 接口；</li>
<li>通过继承 Thread 类本身；</li>
<li>通过 Callable 和 Future 创建线程。</li>
</ul>
<h3><span id="通过runnable接口创建线程">通过Runnable接口创建线程：</span></h3><p>实现Runnable是一个类只需要执行一个方法来调用run（）即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void run（）</span><br></pre></td></tr></table></figure>
<p>该方法可以重写，要理解的是run（）可以调用其他方法，使用其他的类，并且声明变量，就像主线程一样。</p>
<p>在创建一个实现Runnable接口的类之后，可以在类中实例化一个线程对象。</p>
<p>Thread中定义了几个构造方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable threadOb,String threadName);</span><br></pre></td></tr></table></figure>
<p>这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。</p>
<p>新线程创建之后，你调用它的 start() 方法它才会运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void start（）；</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class RunnableDemo implements Runnable &#123;</span><br><span class="line">   private Thread t;</span><br><span class="line">   private String threadName;</span><br><span class="line">   </span><br><span class="line">   RunnableDemo( String name) &#123;</span><br><span class="line">      threadName = name;</span><br><span class="line">      System.out.println(&quot;Creating &quot; +  threadName );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(&quot;Running &quot; +  threadName );</span><br><span class="line">      try &#123;</span><br><span class="line">         for(int i = 4; i &gt; 0; i--) &#123;</span><br><span class="line">            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);</span><br><span class="line">            // 让线程睡眠一会</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;catch (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void start () &#123;</span><br><span class="line">      System.out.println(&quot;Starting &quot; +  threadName );</span><br><span class="line">      if (t == null) &#123;</span><br><span class="line">         t = new Thread (this, threadName);</span><br><span class="line">         t.start ();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;);</span><br><span class="line">      R1.start();</span><br><span class="line">      </span><br><span class="line">      RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;);</span><br><span class="line">      R2.start();</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Creating Thread-1</span><br><span class="line">Starting Thread-1</span><br><span class="line">Creating Thread-2</span><br><span class="line">Starting Thread-2</span><br><span class="line">Running Thread-1</span><br><span class="line">Thread: Thread-1, 4</span><br><span class="line">Running Thread-2</span><br><span class="line">Thread: Thread-2, 4</span><br><span class="line">Thread: Thread-1, 3</span><br><span class="line">Thread: Thread-2, 3</span><br><span class="line">Thread: Thread-1, 2</span><br><span class="line">Thread: Thread-2, 2</span><br><span class="line">Thread: Thread-1, 1</span><br><span class="line">Thread: Thread-2, 1</span><br><span class="line">Thread Thread-1 exiting.</span><br><span class="line">Thread Thread-2 exiting.</span><br></pre></td></tr></table></figure>
<h3><span id="通过集成thread类来创建线程">通过集成Thread类来创建线程：</span></h3><p>该方法是创建一个新的类然后让这个类继承自Thread类，然后创建一个该类的实例即可。</p>
<p>继承类的时候必须重写run（）方法，该方法是新线程的入口点，它也必须调用start方法才可以执行。本质上也是实现了Runnable接口的一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class ThreadDemo extends Thread &#123;</span><br><span class="line">   private Thread t;</span><br><span class="line">   private String threadName;</span><br><span class="line">   </span><br><span class="line">   ThreadDemo( String name) &#123;</span><br><span class="line">      threadName = name;</span><br><span class="line">      System.out.println(&quot;Creating &quot; +  threadName );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(&quot;Running &quot; +  threadName );</span><br><span class="line">      try &#123;</span><br><span class="line">         for(int i = 4; i &gt; 0; i--) &#123;</span><br><span class="line">            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);</span><br><span class="line">            // 让线程睡眠一会</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;catch (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void start () &#123;</span><br><span class="line">      System.out.println(&quot;Starting &quot; +  threadName );</span><br><span class="line">      if (t == null) &#123;</span><br><span class="line">         t = new Thread (this, threadName);</span><br><span class="line">         t.start ();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class TestThread &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;);</span><br><span class="line">      T1.start();</span><br><span class="line">      </span><br><span class="line">      ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;);</span><br><span class="line">      T2.start();</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Creating Thread-1</span><br><span class="line">Starting Thread-1</span><br><span class="line">Creating Thread-2</span><br><span class="line">Starting Thread-2</span><br><span class="line">Running Thread-1</span><br><span class="line">Thread: Thread-1, 4</span><br><span class="line">Running Thread-2</span><br><span class="line">Thread: Thread-2, 4</span><br><span class="line">Thread: Thread-1, 3</span><br><span class="line">Thread: Thread-2, 3</span><br><span class="line">Thread: Thread-1, 2</span><br><span class="line">Thread: Thread-2, 2</span><br><span class="line">Thread: Thread-1, 1</span><br><span class="line">Thread: Thread-2, 1</span><br><span class="line">Thread Thread-1 exiting.</span><br><span class="line">Thread Thread-2 exiting.</span><br></pre></td></tr></table></figure>
<p>下表列出了Thread类的一些重要方法：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public final void setPriority(int priority)</strong>  更改线程的优先级。</td>
</tr>
<tr>
<td>5</td>
<td><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td>
</tr>
<tr>
<td>6</td>
<td><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td>
</tr>
<tr>
<td>7</td>
<td><strong>public void interrupt()</strong> 中断线程。</td>
</tr>
<tr>
<td>8</td>
<td><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td>
</tr>
</tbody>
</table>
<p>测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>public static void yield()</strong> 暂停当前正在执行的线程对象，并执行其他线程。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public static void sleep(long millisec)</strong> 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public static boolean holdsLock(Object x)</strong> 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public static Thread currentThread()</strong> 返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr>
<td>5</td>
<td><strong>public static void dumpStack()</strong> 将当前线程的堆栈跟踪打印至标准错误流。</td>
</tr>
</tbody>
</table>
<p>实例：</p>
<p>如下的ThreadClassDemo 程序演示了Thread类的一些方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 : DisplayMessage.java</span><br><span class="line">// 通过实现 Runnable 接口创建线程</span><br><span class="line">public class DisplayMessage implements Runnable &#123;</span><br><span class="line">   private String message;</span><br><span class="line">   </span><br><span class="line">   public DisplayMessage(String message) &#123;</span><br><span class="line">      this.message = message;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      while(true) &#123;</span><br><span class="line">         System.out.println(message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 : GuessANumber.java</span><br><span class="line">// 通过继承 Thread 类创建线程</span><br><span class="line"> </span><br><span class="line">public class GuessANumber extends Thread &#123;</span><br><span class="line">   private int number;</span><br><span class="line">   public GuessANumber(int number) &#123;</span><br><span class="line">      this.number = number;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void run() &#123;</span><br><span class="line">      int counter = 0;</span><br><span class="line">      int guess = 0;</span><br><span class="line">      do &#123;</span><br><span class="line">         guess = (int) (Math.random() * 100 + 1);</span><br><span class="line">         System.out.println(this.getName() + &quot; guesses &quot; + guess);</span><br><span class="line">         counter++;</span><br><span class="line">      &#125; while(guess != number);</span><br><span class="line">      System.out.println(&quot;** Correct!&quot; + this.getName() + &quot;in&quot; + counter + &quot;guesses.**&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 : ThreadClassDemo.java</span><br><span class="line">public class ThreadClassDemo &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String [] args) &#123;</span><br><span class="line">      Runnable hello = new DisplayMessage(&quot;Hello&quot;);</span><br><span class="line">      Thread thread1 = new Thread(hello);</span><br><span class="line">      thread1.setDaemon(true);</span><br><span class="line">      thread1.setName(&quot;hello&quot;);</span><br><span class="line">      System.out.println(&quot;Starting hello thread...&quot;);</span><br><span class="line">      thread1.start();</span><br><span class="line">      </span><br><span class="line">      Runnable bye = new DisplayMessage(&quot;Goodbye&quot;);</span><br><span class="line">      Thread thread2 = new Thread(bye);</span><br><span class="line">      thread2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">      thread2.setDaemon(true);</span><br><span class="line">      System.out.println(&quot;Starting goodbye thread...&quot;);</span><br><span class="line">      thread2.start();</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;Starting thread3...&quot;);</span><br><span class="line">      Thread thread3 = new GuessANumber(27);</span><br><span class="line">      thread3.start();</span><br><span class="line">      try &#123;</span><br><span class="line">         thread3.join();</span><br><span class="line">      &#125;catch(InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;Thread interrupted.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Starting thread4...&quot;);</span><br><span class="line">      Thread thread4 = new GuessANumber(75);</span><br><span class="line">      </span><br><span class="line">      thread4.start();</span><br><span class="line">      System.out.println(&quot;main() is ending...&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Starting hello thread...</span><br><span class="line">Starting goodbye thread...</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br><span class="line">Goodbye</span><br><span class="line">Goodbye</span><br><span class="line">Goodbye</span><br><span class="line">Goodbye</span><br><span class="line">Goodbye</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<h3><span id="通过callable和future创建线程">通过Callable和Future创建线程：</span></h3><ul>
<li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
<li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>
<li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li>
</ul>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class CallableThreadTest implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">        CallableThreadTest ctt = new CallableThreadTest();  </span><br><span class="line">        FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt);  </span><br><span class="line">        for(int i = 0;i &lt; 100;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);  </span><br><span class="line">            if(i==20)  </span><br><span class="line">            &#123;  </span><br><span class="line">                new Thread(ft,&quot;有返回值的线程&quot;).start();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        try  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(&quot;子线程的返回值：&quot;+ft.get());  </span><br><span class="line">        &#125; catch (InterruptedException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; catch (ExecutionException e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    @Override  </span><br><span class="line">    public Integer call() throws Exception  </span><br><span class="line">    &#123;  </span><br><span class="line">        int i = 0;  </span><br><span class="line">        for(;i&lt;100;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return i;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="三种方式的对比">三种方式的对比：</span></h3><ul>
<li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>
</ul>
<h2><span id="线程的几个重要的概念">线程的几个重要的概念：</span></h2><p>1）线程同步。</p>
<p>2）线程间通信。</p>
<p>3）线程死锁。</p>
<p>4）线程控制，包括挂起停止与恢复。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/zhangguoron.jpg" alt="THBELIEF">
            
              <p class="site-author-name" itemprop="name">THBELIEF</p>
              <p class="site-description motion-element" itemprop="description">我这个人只是英俊 潇洒了些许~</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">78</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:thbelief520@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">THBELIEF</span>

  
</div>


  <!--<div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>
-->



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共69k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
