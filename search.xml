<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Auto.js Script开发(十二)]]></title>
    <url>%2F2019%2F04%2F19%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 截图取色 连续发送 个人信息界面 前言今天主要就是修复了一些BUG，优化了个人信息界面的升级系统（皮），加上新增了两个新的功能，包括截图取色以及连续发送的功能。 正文截图取色 这里借用的是一位大佬的框架。 主要的功能： 截图或者从相册中选择图像，然后可放缩显示的图像实现以方便的取色。 连续发送 主要实现的其实就是简单的聊天界面简简单单的连续发送。 可调整发送内容，发送频率以及可控停止。 关键代码如下： 123456789101112131415161718192021222324252627//4.19 连续发送function continuousTransmissionFunction()&#123; isKeyDown();//检测是否按下了音量下键 toast(&quot;请前往需要连续发送的聊天界面！&quot;); sleep(1000); var sendSpeed=rawInput(&quot;请输入发送的速度(每几秒发送一次):&quot;); var discourse=&quot;你好...&quot;; if(sendSpeed&gt;0)&#123; //只有输入的大于等于零才可以进入 floatingWindowDownGlide(&quot;发送内容&quot;,&quot;修改&quot;,modifyMessage); suspendButton(sendMessage); &#125;else&#123; toast(&quot;脚本启动失败，速度必须大于0！&quot;) &#125; function sendMessage()&#123; setInterval(()=&gt;&#123; className(&quot;android.widget.EditText&quot;).clickable().findOne().setText(discourse); sleep(1000); className(&quot;android.widget.Button&quot;).text(&quot;发送&quot;).findOnce().click();//发送即可 &#125;,sendSpeed*1000); &#125; function modifyMessage(input)&#123; discourse=input; &#125;&#125; 个人信息界面这个就纯粹是花里胡哨了。不实用，但是做的时候很开心。 关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function personalInformationUI()&#123; ui.layout( &lt;frame&gt; &lt;vertical&gt; &lt;horizontal&gt; &lt;button id=&quot;backMainUIBypersonalUI&quot; text=&quot;返回&quot; w=&quot;auto&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; /&gt; &lt;/horizontal&gt; &lt;vertical gravity=&quot;center&quot;&gt; &lt;img src=&quot;https://img.icons8.com/color/48/000000/joe-pineapples.png&quot; w=&quot;100&quot; h=&quot;100&quot; circle=&quot;true&quot; borderWidth=&quot;2dp&quot; borderColor=&quot;#202020&quot; gravity=&quot;center&quot; marginTop=&quot;100dp&quot;/&gt; &lt;text id=&quot;level&quot; text=&quot;等级: 普通会员(Min)&quot; gravity=&quot;center&quot; marginTop=&quot;20dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;horizontal gravity=&quot;center&quot;&gt; &lt;text id=&quot;progress_value&quot; text=&quot;经验值：0/100&quot; marginleft=&quot;10dp&quot; layout_weight=&quot;3&quot; gravity=&quot;center&quot; marginTop=&quot;10dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;progressbar id=&quot;progress&quot;layout_weight=&quot;6&quot; marginTop=&quot;10dp&quot; style=&quot;@style/Base.Widget.AppCompat.ProgressBar.Horizontal&quot;/&gt; &lt;button id=&quot;upgrade&quot; text=&quot;升级&quot; layout_weight=&quot;1&quot; marginTop=&quot;10dp&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; /&gt; &lt;/horizontal&gt; &lt;text id=&quot;username&quot; text=&quot;&quot; gravity=&quot;center&quot; marginTop=&quot;20dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text id=&quot;userpassword&quot; text=&quot;&quot; gravity=&quot;center&quot; marginTop=&quot;10dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;/vertical&gt; &lt;/vertical&gt; &lt;/frame&gt; ); if(storage.get(&quot;level&quot;)==&quot;至尊会员(Max)&quot;)&#123; ui.progress.setProgress(100); ui.level.setText(&quot;等级：&quot;+storage.get(&quot;level&quot;)); ui.progress_value.setText(&quot;经验值：100/100&quot;); &#125;else&#123; toast(&quot;请升级至至尊会员，升级不花一分钱，一键满级！&quot;); &#125; var isOverUpgrade = null; ui.upgrade.click(()=&gt;&#123; if(ui.progress.getProgress()==0)&#123; if(isOverUpgrade != null)&#123; stopDownload(); &#125;else&#123; startDownload(); &#125; &#125;else&#123; toast(&quot;升级失败，正在升级或者已经升至满级！&quot;); &#125; &#125;); function stopDownload()&#123; storage.remove(&quot;level&quot;); storage.put(&quot;level&quot;,&quot;至尊会员(Max)&quot;); toast(&quot;已经升级至最高等级！&quot;) clearInterval(isOverUpgrade); isOverUpgrade = null; &#125; function startDownload()&#123; if(ui.progress.getProgress() == 100)&#123; ui.progress.setProgress(0); &#125; isOverUpgrade = setInterval(()=&gt;&#123; var p = ui.progress.getProgress(); p++; if(p &gt; 100)&#123; ui.level.setText(&quot;等级: 至尊会员(Max)&quot;); alert(&quot;恭喜账号:&quot;+&quot;\n &quot;+storage.get(&quot;username&quot;)+&quot;您升至至尊会员！&quot;); stopDownload(); return; &#125; ui.progress.setProgress(p); ui.progress_value.setText(&quot;经验值：&quot;+p.toString()+&quot;/100&quot;); &#125;,50); &#125; ui.username.setText(&quot;用户名: &quot;+storage.get(&quot;username&quot;)); ui.userpassword.setText(&quot;密码: &quot;+storage.get(&quot;userpassword&quot;)); ui.backMainUIBypersonalUI.click(()=&gt;&#123; //退出之前必须先停掉 if(isOverUpgrade)&#123; clearInterval(isOverUpgrade); toast(&quot;升级尚未完成即退出，升级失败！&quot;); &#125; mainUI(); &#125;);&#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(三)]]></title>
    <url>%2F2019%2F04%2F18%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 JS三种输出方式 window.alert() console系列 document.write() JS标准对象 Date JSON 前言好久都没有更新JS的学习笔记了，现在有点儿空，就抽时间写篇博客记录一下。 正文JS三种输出方式这个其实是例外的，只是突然想在VSCode中调试JS程序，然后就专门的查了一下这个相关的。 window.alert()它会将括号内的内容以弹窗的方式展现出来。 console系列这个方式一般用于在编译器如VSCode之类的地方使用，很方便。 123console.log(&apos;控制台.日志()&apos;); console.warn(&apos;控制台.警告()&apos;); console.error(&apos;控制台.错误()&apos;); document.write()直接在页面上显示内容。 JS标准对象DateDate对象和Android中的一样都是用于获取日期与时间。 注意：这里只是获取本机的时间，不是网络时间，有些时候会出现问题。 常用方法： 1234567891011var now = new Date();now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)now.getFullYear(); // 2015, 年份now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月now.getDate(); // 24, 表示24号now.getDay(); // 3, 表示星期三now.getHours(); // 19, 24小时制now.getMinutes(); // 49, 分钟now.getSeconds(); // 22, 秒now.getMilliseconds(); // 875, 毫秒数now.getTime(); // 1435146562875, 以number形式表示的时间戳 示例： Date对象的创建 12var d = new Date(2015, 5, 19, 20, 15, 30, 123);//传入参数var d = Date.parse(&apos;2015-06-24T19:49:22.875+08:00&apos;);//ISO 8601格式分字符串 注意：传入参数创建的时候月份是0~11，意思是如果是六月的话需要传入的是5. JSON这个其实也是Android中遇到的朋友，很是熟悉了，这里就简单的说一下。 JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。 123456number：和JavaScript的number完全一致；boolean：就是JavaScript的true或false；string：就是JavaScript的string；null：就是JavaScript的null；array：就是JavaScript的Array表示方式——[]；object：就是JavaScript的&#123; ... &#125;表示方式。 注意：JSON还定死了字符集必须是UTF-8，为了统一解析，JSON的字符串规定必须用双引号””，Object的键也必须用双引号””。 另外，JSON.parse()可以把JSON字符串转变成一个JavaScript对象。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>学习</tag>
        <tag>JS输出</tag>
        <tag>Date</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(十一)]]></title>
    <url>%2F2019%2F04%2F18%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 前言今天就是更新了4.9.0的版本，新增了一个二维码生成的功能，准备下一次重构底层代码了，现在写起来有点儿小难受。 正文二维码生成功能页面： 目前有的规划： 二维码生成的关键代码： 1234567891011121314151617//网络请求图片然后保存到本地 //这里用的是type1，返回的是base64encode编码的字符串,type2返回的就是图片png格式 threads.start(function()&#123; var url=&quot;http://apis.juhe.cn/qrcode/api?key=684e3d257f6034ebdfd80a2bbeddeb18&amp;type=2&amp;fgcolor=&quot;+ui.backgroundColor.text()+&quot;&amp;w=&quot;+ui.size.text()+&quot;&amp;m=&quot;+ui.marginSize.text()+&quot;&amp;text=&quot;+ui.textContent.text(); var img=images.load(url); if(img!=null)&#123; toast(&quot;网络请求成功&quot;); //提示一下是不是要生成？ //在根目录下创建一个文件夹“THBELIEFScript二维码” files.create(&quot;/sdcard/THBELIEFScript二维码/&quot;); images.save(img,&quot;/sdcard/THBELIEFScript二维码/&quot;+ui.textContent.text()+&quot;.png&quot;,&quot;png&quot;,100); toast(&quot;该二维码图片保存在&quot;+&quot;/sdcard/THBELIEFScript二维码/&quot;+ui.textContent.text()+&quot;.png&quot;); log(&quot;该二维码图片保存在&quot;+&quot;/sdcard/THBELIEFScript二维码/&quot;+ui.textContent.text()+&quot;.png&quot;); &#125;else&#123;//网络请求失败 toast(&quot;网络请求失败!&quot;); &#125;; &#125;);]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(十)]]></title>
    <url>%2F2019%2F04%2F17%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%8D%81%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 前言乘着今天没事就更新一下THBELIEFScript。 4.8.0的更新内容： 具体的更新状态： 个人信息： 设备信息: 正文个人信息主要代码： 123456789101112131415161718192021222324//个人信息的展示页面function personalInformationUI()&#123; ui.layout( &lt;frame&gt; &lt;vertical&gt; &lt;horizontal&gt; &lt;button id=&quot;backMainUIBypersonalUI&quot; text=&quot;返回&quot; w=&quot;auto&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; /&gt; &lt;/horizontal&gt; &lt;vertical gravity=&quot;center&quot;&gt; &lt;img src=&quot;https://img.icons8.com/color/48/000000/joe-pineapples.png&quot; w=&quot;100&quot; h=&quot;100&quot; circle=&quot;true&quot; borderWidth=&quot;2dp&quot; borderColor=&quot;#202020&quot; gravity=&quot;center&quot; marginTop=&quot;100dp&quot;/&gt; &lt;text id=&quot;level&quot; text=&quot;等级: 至尊会员(MAX)&quot; gravity=&quot;center&quot; marginTop=&quot;20dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text id=&quot;username&quot; text=&quot;&quot; gravity=&quot;center&quot; marginTop=&quot;20dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text id=&quot;userpassword&quot; text=&quot;&quot; gravity=&quot;center&quot; marginTop=&quot;10dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;/vertical&gt; &lt;/vertical&gt; &lt;/frame&gt; ); ui.username.setText(&quot;用户名: &quot;+storage.get(&quot;username&quot;)); ui.userpassword.setText(&quot;密码: &quot;+storage.get(&quot;userpassword&quot;)); ui.backMainUIBypersonalUI.click(()=&gt;&#123; mainUI(); &#125;);&#125; 设备信息的主要代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function mainUI()&#123; ui.layout( &lt;frame&gt; &lt;vertical gravity=&quot;center&quot;&gt; &lt;text gravity=&quot;center&quot; text=&quot;设备信息&quot; textSize=&quot;30sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Width&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Height&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;BuildId&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Broad&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Brand&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Device&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Model&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Product&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Bootloader&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Hardware&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Fingerprint&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Serial&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;SdkInt&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Incremental&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Release&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;BaseOS&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;SecurityPatch&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Codename&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;GetAndroidId&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;GetMacAddress&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;GetTotalMem&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;GetAvailMem&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;/vertical&gt; &lt;/frame&gt; ); ui.Width.setText(&quot;设备宽度： &quot;+device.width); ui.Height.setText(&quot;设备高度： &quot;+device.height); ui.BuildId.setText(&quot;修订版本号： &quot;+device.buildId); ui.Broad.setText(&quot;主板型号： &quot;+device.broad); ui.Brand.setText(&quot;厂商品牌： &quot;+device.brand); ui.Device.setText(&quot;工业设计名称： &quot;+device.device); ui.Model.setText(&quot;设备型号： &quot;+device.model); ui.Product.setText(&quot;整个产品名称： &quot;+device.product); ui.Bootloader.setText(&quot;Bootloader版本： &quot;+device.bootloader); ui.Hardware.setText(&quot;硬件名称： &quot;+device.hardware); ui.Fingerprint.setText(&quot;唯一标识码： &quot;+device.fingerprint); ui.Serial.setText(&quot;硬件序列号： &quot;+device.serial); ui.SdkInt.setText(&quot;AndroidAPI版本： &quot;+device.sdkInt); ui.Incremental.setText(&quot;Incremental： &quot;+device.incremental); ui.Release.setText(&quot;Android系统版本号： &quot;+device.release); ui.BaseOS.setText(&quot;BaseOS： &quot;+device.baseOS); ui.SecurityPatch.setText(&quot;安全补丁程序级别： &quot;+device.securityPatch); ui.Codename.setText(&quot;开发代号： &quot;+device.codename); ui.GetAndroidId.setText(&quot;AndroidId： &quot;+device.getAndroidId()); ui.GetMacAddress.setText(&quot;Mac地址： &quot;+device.getMacAddress()); ui.GetTotalMem.setText(&quot;内存总量： &quot;+device.getTotalMem()); ui.GetAvailMem.setText(&quot;当前可用内存： &quot;+device.getAvailMem());&#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(九)]]></title>
    <url>%2F2019%2F04%2F16%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 前言今天早上没课，然后就随手修复了THBELIEFScript的一些BUG，然后增添了一个登陆的界面。 正文用的是免费的API。免费API集合。 用到的包括开发者注册拿到apikey，然后就是运用了用户的注册与登陆。 具体的情况如下： 然后就是写了一个登陆的界面，然后加上了逻辑。 关键代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213//界面function jiemian()&#123; ui.run(()=&gt;&#123; mainUI(); &#125;); checkHaveUpdate();&#125;//登录界面function LoginPageFunction()&#123; ui.statusBarColor(&quot;#000000&quot;) var kg, kg2, u = 1,op = 0; var stg = storages.create(&quot;user&quot;); var zh = stg.get(&quot;list&quot;, &#123;see: &quot;&quot;,name: &quot;&quot;,pass: &quot;&quot;&#125;); main(); function main()&#123; if (zh.see == &quot;1&quot;) &#123; denru(true,zh.name,zh.pass); &#125;else if (zh.see == &quot;2&quot;) &#123; jiemian(); &#125;else&#123; denru(); &#125; &#125; function denru(t,n,p)&#123; ui.layout( &lt;vertical bg=&quot;#708090&quot;&gt; &lt;vertical h=&quot;auto&quot; align=&quot;center&quot; marginTop=&quot;100&quot;&gt; &lt;img layout_gravity=&quot;center&quot; src=&quot;https://img.icons8.com/color/48/000000/joe-pineapples.png&quot; w=&quot;70&quot; h=&quot;70&quot; circle=&quot;true&quot;/&gt; &lt;/vertical&gt; &lt;card w=&quot;*&quot; h=&quot;250&quot; margin=&quot;20&quot; cardCornerRadius=&quot;15dp&quot; cardBackgroundColor=&quot;#b0c4de&quot; cardElevation=&quot;15dp&quot; gravity=&quot;bottom&quot; foreground=&quot;?selectableItemBackground&quot;&gt; &lt;vertical&gt; &lt;linear margin=&quot;0 40 0 0&quot;&gt; &lt;img w=&quot;30&quot; h=&quot;30&quot; src=&quot;@drawable/ic_person_black_48dp&quot;/&gt; &lt;input id=&quot;name&quot; w=&quot;*&quot; h=&quot;40&quot; hint=&quot;用户名&quot;/&gt; &lt;/linear&gt; &lt;linear&gt; &lt;img w=&quot;30&quot; h=&quot;30&quot; src=&quot;@drawable/ic_https_black_48dp&quot;/&gt; &lt;input id=&quot;password&quot; hint=&quot;密码&quot; w=&quot;*&quot; h=&quot;40&quot; inputType=&quot;textPassword&quot;/&gt; &lt;/linear&gt; &lt;linear gravity=&quot;center&quot;&gt; &lt;checkbox id=&quot;cb1&quot; text=&quot;记住密码&quot;/&gt; &lt;checkbox id=&quot;cb2&quot; text=&quot;自动登入&quot;/&gt; &lt;/linear&gt; &lt;linear gravity=&quot;center&quot;&gt; &lt;horizontal&gt; &lt;button id=&quot;login&quot; w=&quot;250&quot; h=&quot;*&quot; text=&quot;登录&quot; size=&quot;16&quot; style=&quot;Widget.AppCompat.Button.Colored&quot;/&gt; &lt;/horizontal&gt; &lt;/linear&gt; &lt;linear gravity=&quot;center&quot;&gt; &lt;text w=&quot;106&quot; gravity=&quot;center&quot; color=&quot;#111111&quot; size=&quot;16&quot;&gt;还没有账号？&lt;/text&gt; &lt;text id=&quot;register&quot; w=&quot;auto&quot; h=&quot;auto&quot; size=&quot;16&quot; text=&quot;注册&quot; paddingRight=&quot;15&quot;/&gt; &lt;text id=&quot;reg&quot; w=&quot;auto&quot; h=&quot;auto&quot; size=&quot;16&quot; paddingLeft=&quot;10&quot; text=&quot;忘记密码&quot;/&gt; &lt;/linear&gt; &lt;/vertical&gt; &lt;/card&gt; &lt;/vertical&gt; ); if (t) &#123;ui.name.setText(n);ui.password.setText(p);ui.cb1.setChecked(t);&#125; ui.login.on(&quot;click&quot;, () =&gt; &#123; threads.start(function() &#123; if (!ui.name.text()) &#123; toast(&quot;您还没有输入用户名!&quot;); return; &#125; if (!ui.password.text()) &#123; toast(&quot;还没有输入密码呢&quot;); return; &#125; var str = JSON.parse(http.get(&quot;https://api.apiopen.top/loginUser?apikey=d1cef6f3e25ab08f623bbb147f32bb5d&amp;name=&quot; + ui.name.text() + &quot;&amp;passwd=&quot; + ui.password.text()).body.string()); if (str.code !== 200) &#123; toast(str.message); return; &#125; else &#123; if (op == 1) &#123; stg.put(&quot;list&quot;, &#123;see: &quot;1&quot;,name: ui.name.text(),pass: ui.password.text()&#125;); toast(&quot;登入&quot; + str.message); jiemian(); &#125; else if (op == 2) &#123; stg.put(&quot;list&quot;, &#123;see: &quot;2&quot;,name: ui.name.text(),pass: ui.password.text()&#125;); toast(&quot;登入&quot; + str.message); jiemian(); &#125; else &#123; storages.remove(&quot;user&quot;); toast(&quot;登入&quot; + str.message); jiemian(); &#125; &#125; &#125;) &#125;); ui.emitter.on(&quot;back_pressed&quot;, e =&gt; &#123; if (!kg) &#123; kg = true; toast(&quot;再按一次退出&quot;); setTimeout(() =&gt; &#123; kg = false; &#125;, 250); e.consumed = true; &#125; else &#123; e.consumed = false; &#125;; &#125;); ui.register.on(&quot;click&quot;, () =&gt; &#123; zhuce(); &#125;); ui.reg.on(&quot;click&quot;, () =&gt; &#123; dialogs.confirm(null, &quot;抱歉，暂时没有找回密码功能，是否重新注册一个新账号?&quot;, (a) =&gt; &#123; if (a) &#123; zhuce(); &#125; &#125;) &#125;); ui.cb1.on(&quot;check&quot;, (checked) =&gt; &#123; if (checked) &#123; op = 1; &#125; else &#123; op = 0; u = 0; ui.cb2.setChecked(false); &#125; &#125;); ui.cb2.on(&quot;check&quot;, (checked) =&gt; &#123; if (checked) &#123; ui.cb1.setChecked(true); op = 2; u = 1; &#125; else &#123; if (u) &#123; op = 1; &#125; &#125; &#125;); &#125; function zhuce()&#123; ui.layout( &lt;vertical bg=&quot;#708090&quot;&gt; &lt;card w=&quot;*&quot; h=&quot;250&quot; margin=&quot;20 180 20 20&quot; cardCornerRadius=&quot;15dp&quot; cardBackgroundColor=&quot;#b0c4de&quot; cardElevation=&quot;15dp&quot; gravity=&quot;bottom&quot; foreground=&quot;?selectableItemBackground&quot;&gt; &lt;vertical&gt; &lt;vertical h=&quot;auto&quot; align=&quot;center&quot; margin=&quot;5 30 5 5&quot;&gt; &lt;linear&gt; &lt;img w=&quot;30&quot; h=&quot;30&quot; src=&quot;@drawable/ic_person_black_48dp&quot;/&gt; &lt;input id=&quot;name&quot; w=&quot;*&quot; h=&quot;40&quot; hint=&quot;输入用户名&quot; /&gt; &lt;/linear&gt; &lt;linear&gt; &lt;img w=&quot;30&quot; h=&quot;30&quot; src=&quot;@drawable/ic_https_black_48dp&quot;/&gt; &lt;input id=&quot;password&quot; hint=&quot;输入密码&quot; w=&quot;*&quot; h=&quot;40&quot; inputType=&quot;textPassword&quot;/&gt; &lt;/linear&gt; &lt;linear&gt; &lt;img w=&quot;30&quot; h=&quot;30&quot; src=&quot;@drawable/ic_https_black_48dp&quot;/&gt; &lt;input id=&quot;password2&quot; hint=&quot;再次输入密码&quot; w=&quot;*&quot; h=&quot;40&quot; inputType=&quot;textPassword&quot;/&gt; &lt;/linear&gt; &lt;linear gravity=&quot;center&quot;&gt; &lt;horizontal&gt; &lt;button id=&quot;login&quot; w=&quot;250&quot; h=&quot;*&quot; text=&quot;立即注册&quot; size=&quot;16&quot; style=&quot;Widget.AppCompat.Button.Colored&quot;/&gt; &lt;/horizontal&gt; &lt;/linear&gt; &lt;/vertical&gt; &lt;/vertical&gt; &lt;/card&gt; &lt;/vertical&gt; ); ui.emitter.on(&quot;back_pressed&quot;, e =&gt; &#123; if (!kg2) &#123; kg2 = true; denru(); setTimeout(() =&gt; &#123; kg2 = false; &#125;, 1000); e.consumed = true; &#125; else &#123; e.consumed = false; &#125;; &#125;); ui.login.on(&quot;click&quot;, () =&gt; &#123; threads.start(function() &#123; if (!ui.name.text()) &#123; toast(&quot;您还没有输入用户名!&quot;); return; &#125; if (!ui.password.text() &amp;&amp; !ui.password2.text()) &#123; toast(&quot;还没有输入密码呢&quot;); return; &#125; if (ui.password.text() !== ui.password2.text()) &#123; toast(&quot;您输入的两次密码不一样&quot;); &#125; else &#123; var str = JSON.parse(http.get(&quot;https://api.apiopen.top/registerUser?apikey=d1cef6f3e25ab08f623bbb147f32bb5d&amp;name=&quot; + ui.name.text() + &quot;&amp;passwd=&quot; + ui.password.text()).body.string()); if (str.code !== 200) &#123; toast(str.message); &#125; else &#123; dialogs.confirm(&quot;注册&quot; + str.message, &quot;您已经注册成为至尊会员！\n您的户名为：&quot; + ui.name.text() + &quot;\n密码为：&quot; + ui.password.text() + &quot;\n是否马上去登入?&quot;, (a) =&gt; &#123; if (a) &#123; denru(); &#125; else &#123; ui.finish(); &#125; &#125;) &#125; &#125; &#125;); &#125;); &#125;&#125; 备注： 准备抽个时间重构一下底层的代码，主js文件实在是写的太臃肿了。很不喜欢现在，都写了一千多行了main.js…]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米五刷机简述]]></title>
    <url>%2F2019%2F04%2F15%2F%E5%B0%8F%E7%B1%B3%E4%BA%94%E5%88%B7%E6%9C%BA%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 ADB工具 主要功能 ADB下载 OS下载 第三方rec的下载 小米手机解锁（小米手机必要） 安装REC 清理 安装OS 注意 收尾 ADB安装APK到手机 前言不久之前刚刚把我退役的小米五刷机刷成了Android原生的LineageOS系统，这里就记录一下过程吧。 正文ADB工具adb（Android Debug Bridge），安卓平台调试桥，是连接Android手机与PC端的桥梁，通过adb可以管理、操作模拟器和设备，如安装软件、查看设备软硬件参数、系统升级、运行shell命令等。 主要功能 1.运行设备的shell(命令行) 。 2.管理模拟器或设备的端口映射 。 3.计算机和设备之间上传/下载文件 。 4.将本地apk软件安装至模拟器或android设备。 ADB下载这里就不详细的写如何下载安装配置ADB工具了，百度即可，安装配置很简单，下面直接贴上官网的链接。 官网链接 OS下载进入LineageOS官网找到相对应的小米五的刷机包，直接下载最新的包就可以了。（一定要记住下载后放置的位置，并且不用解压）。 注意：要求在MIUI版本在8.8.30及以上，这个必须有，因为LineageOS要求固件支持。 第三方rec的下载REC即Recovery模式，也俗称卡刷。 这里用的是TWRP官网这个工具。 小米手机解锁（小米手机必要）注意：只有小米手机才需要！ 如果已经解锁的可以直接跳过。 如果没有解锁的话直接移步到小米官方解锁网站。上面有很详细的步骤，一步一步的跟着做就可以了。 安装REC1.关机状态按住音量下键+关机键。 用数据线连接电脑与手机，在电脑的cmd中输入下面的代码： 1adb reboot bootloader 2.输入命令把rec刷进去： 1fastboot flash recovery &quot;*****.img&quot; //*****是前面下载rec后放置的位置的路径+包的名字 3.运行rec： 1fastboot boot &quot;***.img&quot; //*****是前面下载rec后放置的位置的路径+包的名字 成功的状态： 12bootingFinished. Total time: 1.138s 清理进入界面之后先恢复出厂设置，然后格式化Data，然后选择高级选项，把cache和data清除掉，System不能更改。 安装OS把之前下载的OS包移动到sdcard路径下： 1adb push &quot;****.zip&quot; /sdcard/ 打开twrp里面的安装选项，找到sdcard目录，点击进去会发现一个zip包，这个就是移动进去的OS，然后点击安装即可。 注意有些时候如果提示没有权限或其他错误，先重启重启不是直接重启手机，是重新进入rec。可以在rec的首页面重启，也可以输入adb命令。 收尾需要值得注意的是，刷进去之后的浏览器由于某些众所周知的原因不能使用也就是说下载不了软件这些的，必须通过ADB工具将电脑上下载好的apk安装到手机上去。（还需要打开手机的开发者权限，打开ADB调试）。 ADB安装APK到手机1.电脑的命令行窗口输入下面的代码：（打开开发者权限的ADB调试之后才找得到设备） 1adb devices 2.安装apk： 123adb install (apk完整路径）//(安装)例如：adb install D:/THBELIEFScript.apk 参考链接]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>小米五</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编实验（一）]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 Debug命令 E命令 U命令 T命令 A命令 D命令 前言前不久刚开始上汇编实验，这里就用博客记录一下学习的过程，顺便也做备份，方便自己以后复习。 正文Debug命令1234567891011R命令：查看、修改CPU中寄存器的内容 D命令：查看内存中的内容 E命令：修改内存中的内容（可以写入数据、指令） U命令：将内存中的内容解释为机器指令和对应的汇编指令 T命令：执行CS:IP指向的内存单元处的指令 A命令：以汇编指令的形式向内存中写入指令 E命令用E命令将数据写入内存。 这里是先用E命令写入内存，再用D命令查看了内存的内容，可以看到确实是修改了的，然后再用E命令发现又可以修改了。 U命令查看内存中机器码的含义。 T命令单步执行内存中的机器码。 A命令将汇编指令写入内存中。 D命令查看内存中的内容。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(八)]]></title>
    <url>%2F2019%2F04%2F14%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 关键代码 前言今天的话主要就是修复了一下易班签到的BUG吧，然后就是下面贴一下代码，太累了，就不仔细的解释了，好了，下面开始~~~ 正文关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899function SignIn(signInAccount,signInPassword)&#123; var t=threads.start(function()&#123; //输入账号密码 id(&quot;login_account_et&quot;).findOne().setText(signInAccount); id(&quot;login_password_et&quot;).findOne().setText(signInPassword); sleep(1000); //登录按钮 id(&quot;login_btn&quot;).findOne().click(); //等待前往主页面活动 waitForActivity(&quot;com.yiban.app.activity.HomeActivity&quot;); sleep(1000); //去签到的页面 id(&quot;page_home_discover_tab_btn&quot;).findOne().click() id(&quot;page_explore_chenckin_layout&quot;).findOne().click(); sleep(1000); //判断是否有签到，签到了直接退出，没有签到就签到 if(text(&quot;奖励已经拿过咯~&quot;).exists())&#123; //已经签过到的页面 toast(signInAccount+&quot;已经签到过了!&quot;); accountSignInMessage.push(signInAccount+&quot;已经签到过了!&quot;); sleep(1000); id(&quot;widget_custom_titlebar_back_btn&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.HomeActivity&quot;); &#125;else if(text(&quot;下一步&quot;).exists())&#123; //检测是否打开自动同步开关 if(isShareButton)&#123; //如果打开了就直接勾选 id(&quot;sync_to_feed_check&quot;).clickable().find().click(); accountSignInMessage.push(signInAccount+&quot;签到已经同步至动态!&quot;); toast(&quot;已经勾选同步动态按钮，正在同步中...&quot;); &#125; //没有签过到的页面 sleep(1000); var t=className(&quot;android.widget.LinearLayout&quot;).clickable().find(); //默认选择第二个答案 t[2].click(); toast(signInAccount+&quot;签到完成了哦！&quot;); accountSignInMessage.push(signInAccount+&quot;签到完成了哦!&quot;); sleep(1000); text(&quot;下一步&quot;).findOne().click(); sleep(1000); id(&quot;positiveButton&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.HomeActivity&quot;); &#125;else&#123; toast(&quot;签到失败，未检索到&quot;); accountSignInMessage.push(signInAccount+&quot;签到失败，未检索到&quot;); sleep(1000); id(&quot;widget_custom_titlebar_back_btn&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.HomeActivity&quot;); &#125; if(isSendMessage)&#123; //如果打开了群聊冒泡的开关 toast(&quot;正在准备群聊冒泡...&quot;); id(&quot;page_home_contacts_tab_btn&quot;).clickable().find().click(); sleep(1000); id(&quot;l_groupchat&quot;).clickable().find().click(); waitForActivity(&quot;com.yiban.app.activity.GroupMergeActivity&quot;); sleep(1000) if(text(sendName).exists())&#123; toast(&quot;发现群聊:&quot;+sendName+&quot;!&quot;); sleep(1000); //本身返回的不是集合，还要找子控件集合 var t=className(&quot;android.widget.TextView&quot;).text(sendName).findOne().bounds(); click(t.centerX(),t.centerY()); waitForActivity(&quot;com.yiban.app.activity.ChatActivity&quot;); toast(&quot;已经打开群聊，准备冒泡...&quot;); sleep(1000); id(&quot;page_chat_message_et&quot;).findOne().setText(sendContent); sleep(1000); id(&quot;page_chat_message_send_btn&quot;).findOne().click(); toast(&quot;账号&quot;+signInAccount+&quot;发送&quot;+sendContent+&quot;在&quot;+sendName); accountSignInMessage.push(&quot;账号&quot;+signInAccount+&quot;发送&quot;+sendContent+&quot;在&quot;+sendName); id(&quot;widget_custom_titlebar_back_btn&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.GroupMergeActivity&quot;); &#125;else&#123; toast(&quot;未检索到群聊！&quot;); accountSignInMessage.push(&quot;账号&quot;+signInAccount+&quot;未检索到&quot;+sendName); &#125; sleep(1000); id(&quot;widget_custom_titlebar_back_btn&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.HomeActivity&quot;); &#125; //退出当前账号 id(&quot;widget_custom_head&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.UserInfoPageActivity&quot;); sleep(1000); id(&quot;r_setting&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.SettingMainActivity&quot;); sleep(1000); text(&quot;退出账号&quot;).findOne().click(); sleep(1000); id(&quot;positiveButton&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.LoginNew2Activity&quot;); toast(signInAccount+&quot;正常退出并正在销毁线程...&quot;); accountSignInMessage.push(&quot;账号&quot;+signInAccount+&quot;正常销毁线程！&quot;); t.interrupt(); &#125;);&#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Lottie动画库]]></title>
    <url>%2F2019%2F04%2F13%2FAndroid-Lottie%E5%8A%A8%E7%94%BB%E5%BA%93%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 Lottie效果展示 Lottie简单介绍 Lottie优势 Lottie劣势 Lottie简单示例 依赖 通过AE的插件导出的json文件 布局 代码 Lottie相关网址 Lottie在线json文件动画预览 LottieFiles 前言这两天在写一个自己的小东西，然后碰巧在github上看到一个动画库，感觉挺有意思的，就通过今天的博客记录下来。 正文Lottie效果展示 Lottie简单介绍Lottie是一个用于 Android和 iOS 的代码库，可以解析用Adobe After Effects 制作动画后通过Bodymovin 插件导出的 JSON 数据文件并在移动端原生渲染! Lottie优势 开发无需编写动画,只需加载。 Android, iOS, 和React Native多平台支持。 Path,flat等风格动画实现完美。 可手动设置进度,绑定手势,事件等。 可网络加载,动态控制播放速度等。 性能好,显示效果完。 不需要进行屏幕的适配，完全原生。 … Lottie劣势 能在AE中实现的效果非常有限。 对AE使用要求高一点, 动画更加依赖设计师。 使用位图后,资源消耗大。 …… Lottie简单示例依赖 通过AE的插件导出的json文件 布局 代码 Lottie相关网址Lottie在线json文件动画预览这个网址 LottieFiles这个网址]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Lottie</tag>
        <tag>动画库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(七)]]></title>
    <url>%2F2019%2F04%2F12%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 前言易班批量签到的脚本这两天基本已经完全的完善了。 今天还抽空把3.8.0做了一个开屏检测更新的动画效果，借助的是另外一个大佬的框架。 正文UI新增： 易班批量签到新增关键代码： 1234567//检测是否打开自动同步开关 if(isShareButton)&#123; //如果打开了就直接勾选 id(&quot;sync_to_feed_check&quot;).clickable().find().click(); accountSignInMessage.push(signInAccount+&quot;签到已经同步至动态!&quot;); toast(&quot;已经勾选同步动态按钮，正在同步中...&quot;); &#125; 123456789101112131415161718192021222324252627282930if(isSendMessage)&#123; //如果打开了群聊冒泡的开关 toast(&quot;正在准备群聊冒泡...&quot;); id(&quot;page_home_contacts_tab_btn&quot;).clickable().find().click(); sleep(1000); id(&quot;l_groupchat&quot;).clickable().find().click(); waitForActivity(&quot;com.yiban.app.activity.GroupMergeActivity&quot;); sleep(1000) if(text(sendName).exists())&#123; toast(&quot;发现群聊:&quot;+sendName+&quot;!&quot;); var t=className(&quot;android.widget.LinearLayout&quot;).findOne(); for(var i=0;i&lt;t.childCount();i++)&#123; if(t.child(i).text()==sendName)&#123; t.click(); waitForActivity(&quot;com.yiban.app.activity.ChatActivity&quot;); &#125; &#125; toast(&quot;已经打开群聊，准备冒泡...&quot;); id(&quot;page_chat_message_et&quot;).findOne().setText(sendContent); sleep(1000); id(&quot;page_chat_message_send_btn&quot;).findOne().click(); sleep(1000); toast(&quot;账号&quot;+signInAccount+&quot;发送&quot;+sendContent+&quot;在&quot;+sendName); accountSignInMessage.push(&quot;账号&quot;+signInAccount+&quot;发送&quot;+sendContent+&quot;在&quot;+sendName); id(&quot;widget_custom_titlebar_back_btn&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.GroupMergeActivity&quot;); &#125;else&#123; toast(&quot;未检索到群聊！&quot;); accountSignInMessage.push(&quot;账号&quot;+signInAccount+&quot;未检索到&quot;+sendName); &#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(六)]]></title>
    <url>%2F2019%2F04%2F11%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[目录： 前言 展示 帮助文档 常见问题 易班批量签到 前言这两天的话，对于这个软件的更新就包括了帮助文档，界面重构，常见问题，易班批量签到等等。 展示 帮助文档在主页面的viewpager中添加另外一个页面作为帮助文档的展示。 帮助文档其实也是直接拉的博客里面的。 123456789&lt;frame&gt; &lt;vertical&gt; &lt;ScrollView&gt; &lt;vertical&gt; &lt;webview id=&quot;webview&quot; h=&quot;*&quot; margin=&quot;0 16&quot;/&gt; &lt;/vertical&gt; &lt;/ScrollView&gt; &lt;/vertical&gt; &lt;/frame&gt; 具体实现： 12//获取帮助文档的网页 ui.webview.loadUrl(&quot;https://thbelief.github.io/2019/04/10/THBELIEFScript%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/&quot;); 常见问题和帮助文档差不多的布局。 123456789&lt;frame&gt; &lt;vertical&gt; &lt;list id=&quot;answerProblem&quot;&gt; &lt;horizontal&gt; &lt;text textColor=&quot;&#123;&#123;this.color&#125;&#125;&quot; w=&quot;*&quot; h=&quot;*&quot; textSize=&quot;20sp&quot; text=&quot;&#123;&#123;this.line&#125;&#125;&quot; /&gt; &lt;/horizontal&gt; &lt;/list&gt; &lt;/vertical&gt; &lt;/frame&gt; 代码： 123456789//先设置标题ui.viewpager.setTitles([&quot;可使用脚本&quot;, &quot;开发中脚本&quot;,&quot;常见问题&quot;,&quot;帮助文档&quot;]);//再填充数据 ui.answerProblem.setDataSource([ &#123; line: &quot;&quot;， color： “” &#125; ]); 易班批量签到关键代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&quot;ui&quot;;auto();//是否按下音量下键isKeyDown();//创建两个txt文件，一个是账号一个是密码，一一对应files.create(&quot;/sdcard/account.txt&quot;);files.create(&quot;/sdcard/password.txt&quot;);//本地键值对存储var storage=storages.create(&quot;易班批量签到速率&quot;);//先清除所有的本地数据，因为每次的默认值都是15s每次登陆storage.clear();storage.put(&quot;speed&quot;,15);//这个是界面的UIinterfaceUI(); function interfaceUI()&#123; ui.layout( &lt;frame&gt; &lt;vertical gravity=&quot;center&quot;&gt; &lt;horizontal&gt; &lt;img src=&quot;http://sowcar.com/t6/698/1554895620x1822614218.jpg&quot; w=&quot;*&quot; h=&quot;200&quot; scaleType=&quot;fitXY&quot; /&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;text text=&quot;基本设置&quot; h=&quot;*&quot; w=&quot;*&quot; gravity=&quot;center&quot; textSize=&quot;20dp&quot; textColor=&quot;red&quot;/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;list id=&quot;accountList&quot; layout_weight=&quot;1&quot; gravity=&quot;center&quot;&gt; &lt;vertical&gt; &lt;text textColor=&quot;black&quot; w=&quot;*&quot; h=&quot;*&quot; textSize=&quot;15dp&quot; text=&quot;&#123;&#123;this.title&#125;&#125;&quot; gravity=&quot;center&quot; singleLine=&quot;true&quot;/&gt; &lt;/vertical&gt; &lt;/list&gt; &lt;list id=&quot;passwordList&quot; layout_weight=&quot;1&quot; gravity=&quot;center&quot;&gt; &lt;vertical&gt; &lt;text textColor=&quot;black&quot; w=&quot;*&quot; h=&quot;*&quot; textSize=&quot;15dp&quot; text=&quot;&#123;&#123;this.title&#125;&#125;&quot; gravity=&quot;center&quot; singleLine=&quot;true&quot;/&gt; &lt;/vertical&gt; &lt;/list&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;addDeleteAccount&quot; text=&quot;账户编辑&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; gravity=&quot;center&quot; /&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;addDeletePassword&quot; text=&quot;密码编辑&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; gravity=&quot;center&quot; /&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;input id=&quot;SignInSpeed&quot; text=&quot;15&quot; hint=&quot;签到速率（默认15s）&quot; inputType=&quot;number&quot; layout_weight=&quot;1&quot;/&gt; &lt;text text=&quot;秒/登陆&quot; /&gt; &lt;button id=&quot;sureSpeed&quot; text=&quot;更改速率&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; gravity=&quot;center&quot; layout_weight=&quot;3&quot;/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;start&quot; text=&quot;开始运行&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; gravity=&quot;center&quot; /&gt; &lt;/horizontal&gt; &lt;/vertical&gt; &lt;/frame&gt; ); //增添的点击事件 ui.addDeleteAccount.click(()=&gt;&#123; toast(&quot;可以增添账号啦!~~~&quot;); app.viewFile(&quot;/sdcard/account.txt&quot;); &#125;); ui.addDeletePassword.click(()=&gt;&#123; toast(&quot;可以增添密码啦!~~~&quot;); app.viewFile(&quot;/sdcard/password.txt&quot;); &#125;); ui.sureSpeed.click(()=&gt;&#123; alert(&quot;登陆速率是根据自身手机流畅度调节的，默认是15s/每次登陆签到，如果出现一次登陆签到还没结束就提示了下一次登录的话，建议调大数值，放缓频率，反之亦然！&quot;); if(ui.SignInSpeed.text()&lt;5)&#123; toast(&quot;修改失败，不建议修改至5s以下。&quot;); &#125;else&#123; storage.remove(&quot;speed&quot;); storage.put(&quot;speed&quot;,ui.SignInSpeed.text()); toast(&quot;成功修改至:&quot;+storage.get(&quot;speed&quot;)); ui.SignInSpeed.setText(storage.get(&quot;speed&quot;)); &#125; &#125;); ui.start.click(()=&gt;&#123; var accountFile=open(&quot;/sdcard/account.txt&quot;,&quot;r&quot;); var passwordFile=open(&quot;/sdcard/password.txt&quot;,&quot;r&quot;); var count=1; //文件里面第一排必须排除 //accountFile.readline(); //passwordFile.readline(); //var accountFileArray=[]; //var passwordFileArray=[]; app.launchApp(&quot;易班&quot;); setInterval(function()&#123; var accountFileArray=accountFile.readline(); var passwordFileArray=passwordFile.readline(); log(&quot;第&quot;+count+&quot;个文件读取&quot;+accountFileArray+passwordFileArray); count++;//计数 if(accountFileArray==null)&#123; dialogs.build(&#123; title: &quot;友情提示&quot;, content: &quot;已经完成所有的签到了哦，亲~&quot;, positive: &quot;知道了&quot; &#125;).on(&quot;positive&quot;,()=&gt;&#123; toast(&quot;正在自动退出脚本...&quot;); exit();//跳出条件不登录 &#125;).show(); &#125;else&#123; toast(&quot;正在准备登录中，每一次登录签到约&quot;+storage.get(&quot;speed&quot;)+&quot;s~~~&quot;); &#125; log(&quot;登录&quot;+accountFileArray); toast(&quot;登录&quot;+accountFileArray); SignIn(accountFileArray,passwordFileArray); &#125;, 1000*storage.get(&quot;speed&quot;)); //SignIn(&quot;18227410387&quot;,&quot;13547296248tyty&quot;) &#125;); &#125;function SignIn(signInAccount,signInPassword)&#123; threads.start(function()&#123; //输入账号密码 id(&quot;login_account_et&quot;).findOne().setText(signInAccount); id(&quot;login_password_et&quot;).findOne().setText(signInPassword); sleep(1000); //登录按钮 id(&quot;login_btn&quot;).findOne().click(); sleep(1000); //去签到的页面 id(&quot;page_home_discover_tab_btn&quot;).findOne().click() id(&quot;page_explore_chenckin_layout&quot;).findOne().click(); sleep(1000); //判断是否有签到，签到了直接退出，没有签到就签到 if(text(&quot;奖励已经拿过咯~&quot;).exists())&#123; toast(&quot;已经签到过了&quot;); sleep(1000); back(); &#125;else&#123; //bounds(0,550,1080,642).findOne().click(); className(&quot;android.widget.LinearLayout&quot;).clickable().find().click(); sleep(500); text(&quot;下一步&quot;).findOne().click(); sleep(500); id(&quot;positiveButton&quot;).findOne().click(); &#125; //退出当前账号 id(&quot;widget_custom_head&quot;).findOne().click(); sleep(500); id(&quot;r_setting&quot;).findOne().click(); sleep(500); text(&quot;退出账号&quot;).findOne().click(); id(&quot;positiveButton&quot;).findOne().click(); &#125;);&#125;function isKeyDown()&#123; //监听音量下键是否按下，退出脚本 threads.start(function()&#123; events.setKeyInterceptionEnabled(&quot;volume_down&quot;,true); //监听按键 events.observeKey(); events.onKeyDown(&quot;volume_down&quot;, function(event)&#123; toast(&quot;已关闭易班批量签到脚本！&quot;); engines.myEngine().forceStop(); &#125;); &#125;);&#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[THBELIEFScript帮助文档]]></title>
    <url>%2F2019%2F04%2F10%2FTHBELIEFScript%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[目录： QQ名片自动点赞 I西科自动签到 蚂蚁森林一键收取能量 蚂蚁庄园星星球 重力传感器验证 连续点击 易班批量导入 准备工作 导入账号与密码 开始使用 注意 匀速上滑 设备信息 二维码生成 QQ名片自动点赞打开无障碍权限之后点击按钮就可以直接使用了，最新版本优化之后可以直接跳转至点赞的页面，不用手动的点击了。 I西科自动签到目前还只是一个鸡肋的脚本，因为之前一直在想着给它加上一个定时签到，但是一直没时间，就搁置了。 蚂蚁森林一键收取能量这个也是一个鸡肋目前，原因和I西科签到一样，没时间修改定时。 蚂蚁庄园星星球使用很简单，直接点击就可以了，有些时候会出现一些BUG，比如说到后期有可能会误触到炸弹导致失败。目前我测试的最高分达到了2500+。 重力传感器验证这个就只是简单的测试。 连续点击这个是以指定的时间连续点击相同的位置。 易班批量导入准备工作首先保持易班更新到最新版。 然后在批量导入之前打开易班登录，先进入签到页面，点击签到，再退回到登录页面。保持易班在后台运行，打开THBELIEFScript的脚本页面。 （这是为了提升效率，类似于机器学习） 完成上述活动之后准备就完成了。 导入账号与密码分别打开账号编辑与密码编辑的页面，输入一一对应的一行行数据。（推荐用WPS之类的文本编辑器打开，然后就是记住，不能用WPS的副本，不然存进去，存不到编辑页面去） 账号编辑页面如下： 开始使用使用之前还可以修改速率，这个和自身手机的流畅度有关。 然后就可以开始了。 注意1.账号和密码一一对应。 2.两个编辑页面的txt文档在内部存储器的根目录下，必须修改这个才有效，如WPS的副本之类的修改之后也无效。 3.两个文档里面的行数应该是一样的。 4.如果出现问题，重新来几次就可以了，道理和准备工作相同。 5.音量下键退出脚本。 6.脚本依托于无障碍服务权限，类似于模拟点击之类的，所以当前页面在脚本执行期间不能乱动，只建议在空闲时间使用。因为当脚本运行的时候，不能碰手机。否则，相当于两个人玩手机？ 匀速上滑这个就只是为了上课刷空间之类的设计的，有时间设置以及悬浮按钮，只是可能滑动的动作不够丝滑。 设备信息这个就是显示当前的设备的信息，有些可能出现null之类的提示，那是因为获取不到相应的信息，不影响。 二维码生成这个就是写来玩的，生成二维码。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Auto.js</tag>
        <tag>脚本</tag>
        <tag>THBELIEFScript</tag>
        <tag>帮助文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bomb使用（一）]]></title>
    <url>%2F2019%2F04%2F10%2FBomb%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 创建应用 SDK自动导入（AndroidStudio） 配置AndroidManifest.xml 基本使用 初始化 添加一行数据 添加数据 获取一行数据 修改一行数据 删除一行数据 创建应用 SDK自动导入（AndroidStudio）1.在project的build.gradle文件下添加Bomb的maven仓库地址： 1234567allprojects &#123; repositories &#123; jcenter() //Bmob的maven仓库地址--必填 maven &#123; url &quot;https://raw.github.com/bmob/bmob-android-sdk/master&quot; &#125; &#125; &#125; 2.在app的build.gradle中添加下列依赖项： 12345678dependencies &#123; implementation &apos;cn.bmob.android:bmob-sdk:3.7.2&apos; implementation &quot;io.reactivex.rxjava2:rxjava:2.2.2&quot; implementation &apos;io.reactivex.rxjava2:rxandroid:2.1.0&apos; implementation &apos;com.squareup.okio:okio:2.1.0&apos; implementation &apos;com.google.code.gson:gson:2.8.5&apos; implementation &apos;com.squareup.okhttp3:okhttp:3.12.0&apos; &#125; 配置AndroidManifest.xml权限： 123456789101112&lt;!--允许联网 --&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;!--获取GSM（2g）、WCDMA（联通3g）等网络状态的信息 --&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;!--获取wifi网络状态的信息 --&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;!--保持CPU 运转，屏幕和键盘灯有可能是关闭的,用于文件上传和下载 --&gt;&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; &lt;!--获取sd卡写的权限，用于文件上传和下载--&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;!--允许读取手机状态 用于创建BmobInstallation--&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; 配置contentprovider： 1234&lt;provider android:name=&quot;cn.bmob.v3.util.BmobContentProvider&quot; android:authorities=&quot;应用包名.BmobContentProvider&quot;&gt;&lt;/provider&gt; 如下： 基本使用初始化在MainActivity的oncreate方法中添加如下代码： 12//第一：默认初始化Bmob.initialize(this, &quot;Your Application ID&quot;); 添加一行数据首先创建的JavaBean（对应为Bmob后台的数据表，详细更解释的请查看的Android开发文档） 1234567891011121314151617public class Person extends BmobObject &#123; private String name; private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 添加数据12345678910111213Person p2 = new Person();p2.setName(&quot;lucky&quot;);p2.setAddress(&quot;北京海淀&quot;);p2.save(new SaveListener&lt;String&gt;() &#123; @Override public void done(String objectId,BmobException e) &#123; if(e==null)&#123; toast(&quot;添加数据成功，返回objectId为：&quot;+objectId); &#125;else&#123; toast(&quot;创建数据失败：&quot; + e.getMessage()); &#125; &#125;&#125;); 效果： 获取一行数据123456789101112//查找Person表里面id为6b6c11c537的数据BmobQuery&lt;Person&gt; bmobQuery = new BmobQuery&lt;Person&gt;();bmobQuery.getObject(&quot;6b6c11c537&quot;, new &gt;QueryListener&lt;Person&gt;() &#123; @Override public void done(Person object,BmobException e) &#123; if(e==null)&#123; toast(&quot;查询成功&quot;); &#125;else&#123; toast(&quot;查询失败：&quot; + e.getMessage()); &#125; &#125;&#125;); 修改一行数据123456789101112131415//更新Person表里面id为6b6c11c537的数据，address内容更新为“北京朝阳”Person p2 = new Person();p2.setAddress(&quot;北京朝阳&quot;);p2.update(&quot;6b6c11c537&quot;, new UpdateListener() &#123; @Override public void done(BmobException e) &#123; if(e==null)&#123; toast(&quot;更新成功:&quot;+p2.getUpdatedAt()); &#125;else&#123; toast(&quot;更新失败：&quot; + e.getMessage()); &#125; &#125;&#125;); 删除一行数据1234567891011121314Person p2 = new Person();p2.setObjectId(&quot;6b6c11c537&quot;);p2.delete(new UpdateListener() &#123; @Override public void done(BmobException e) &#123; if(e==null)&#123; toast(&quot;删除成功:&quot;+p2.getUpdatedAt()); &#125;else&#123; toast(&quot;删除失败：&quot; + e.getMessage()); &#125; &#125;&#125;);]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Bomb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-ListView与RecyclerView简述]]></title>
    <url>%2F2019%2F04%2F09%2FAndroid-ListView%E4%B8%8ERecyclerView%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录： ListView 简单使用 xml布局 mainActivity代码 定制界面 实体类Fruit 子项的布局 自定义适配器 MainActivity代码 RecyclerView 特性 添加依赖 xml布局 自定义适配器 子项布局 MainActivity 分割线 - ItemDecoration 布局 - LayoutManager 动画 - ItemAnimator 点击事件 下拉刷新 上拉加载更多 ListView简单使用xml布局在布局中加入ListView控件。 123456&lt;ListView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/list_view&quot; &gt; &lt;/ListView&gt; mainActivity代码12345678910111213public class MainActivity extends Activity &#123; private String[] data = &#123; &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Watermelon&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Pineapple&quot;, &quot;Strawberry&quot;, &quot;Cherry&quot;, &quot;Mango&quot; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;( MainActivity.this, android.R.layout.simple_list_item_1, data); //android.R.layout.simple_list_item_1是Android内置的布局文件，很简单，为了方便使用ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); &#125; &#125; ArrayAdapter adapter = new ArrayAdapter( MainActivity.this, android.R.layout.simple_list_item_1, data); 的意思是：创建一个数组适配器的代码，里面有三个参数，第一个参数是上下文，就是当前的Activity, 第二个参数是android sdk中自己内置的一个布局，它里面只有一个TextView，这个参数是表明我们数组中每一条数据的布局是这个view，就是将每一条数据都显示在这个 view上面；第三个参数就是我们要显示的数据。listView会根据这三个参数，遍历data里面的每一条数据，读出一条，显示到第二 个参数对应的布局中，这样就形成了我们看到的listView. 定制界面步骤如下： 1.ListView使用。 2.自定义Adapter适配器使用。 3.定义实体类作为泛型传给适配器。 4.为ListView的子项指定一个自定义的布局。（比如一段文字或者说再加上一张图片） 5.创建一个自定义的适配器，用来传数据，一般都是继承自ArrayAdapter，因为这个适配器能够传入泛型，比较方便，然后重写构造方法与GetView方法。 6.在MainActivity中修改相应的代码。 实体类Fruit1234567891011121314151617public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125;&#125; 子项的布局12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/fruit_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;TextView android:id=&quot;@+id/fruit_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_marginLeft=&quot;10dip&quot; /&gt;&lt;/LinearLayout&gt; 自定义适配器123456789101112131415161718public class FruitAdapter extends ArrayAdapter&#123; private final int resourceId; public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = (Fruit) getItem(position); // 获取当前项的Fruit实例 View view = LayoutInflater.from(getContext()).inflate(resourceId, null);//实例化一个对象 ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);//获取该布局内的图片视图 TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);//获取该布局内的文本视图 fruitImage.setImageResource(fruit.getImageId());//为图片视图设置图片资源 fruitName.setText(fruit.getName());//为文本视图设置文本内容 return view; &#125;&#125; MainActivity代码123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends Activity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); // 初始化水果数据 FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); &#125; private void initFruits() &#123; Fruit apple = new Fruit(&quot;Apple&quot;, R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit(&quot;Banana&quot;, R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit(&quot;Orange&quot;, R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit(&quot;Watermelon&quot;, R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit(&quot;Pear&quot;, R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit(&quot;Grape&quot;, R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit(&quot;Pineapple&quot;, R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit(&quot;Strawberry&quot;, R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit(&quot;Cherry&quot;, R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit(&quot;Mango&quot;, R.drawable.mango_pic); fruitList.add(mango); &#125;&#125; RecyclerView在开发中，ListView是用的最多的控件之一，但是还是有很多不足的地方，比如说运行效率有些时候会显得非常的差劲，而且只能实现数据的纵向滚动的效果。这里就应运而生RecyclerView了。 特性插拔式体验，高度解耦合。 1234布局（显示方式）：可通过LayoutManager（LinearLayoutManager，GridLayoutManager，StaggeredGridLayoutManager ）设置；分割线：通过 ItemDecoration 实现Item 增删动画：通过 ItemAnimatorViewHolder 的创建和绑定：通过实现 Adapter 补充： 12345LayoutManager：RecyclerView 会根据 Layout Manager 提供的视图来填充自身，常用的布局管理器有LinearLayoutManager（线性布局管理器）、GridLayoutManager（网格布局管理器）、StaggeredGridLayoutManager （瀑布流布局管理器）等。ViewHolder：列表中的视图由 ViewHolder 实例展示。 ViewHolder 用于对控件的实例进行缓存，负责显示子项。例如，如果列表显示了音乐集合，那么每个 ViewHolder 可能代表一个专辑。Adapter：ViewHolder 对象由 Adapter 管理。Adapter 按需创建 ViewHolder，并为其绑定数据。绑定意味着根据 Adapter 中的位置为子视图填充对应的数据。 添加依赖由于和百分比布局一样都是新增的控件，所以需要添加support库的依赖。 项目的build.gradle中： 123dependencies &#123; implementation &apos;com.android.support:recyclerview-v7:27.1.1&apos;&#125; xml布局123456&lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:divider=&quot;#FFFF0000&quot; android:dividerHeight=&quot;10dp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 自定义适配器由于FruitAdapter是继承自RecyclerView.Adapter 的，那么就必须重写onCreateViewHolde r ()、onBindViewHolder()和getitemCount()这3个方法。 onCreateViewHolder()方法是用于创建ViewHolder实例的，在这个方法中将fruit_item 布局加载进来， 然后创建一个ViewHolder 实例， 并把加载出来的布局传入到构造函数当中， 最后将ViewHolder的实例返回。 onBindViewHolder()方法是用于对RecyclerView子项的数据进行赋值的，会在每个子项被滚动到屏幕内的时候执行，这里我们通过position参数得到当前项的类实例，然后再将数据设置到ViewHolder的ImageView和TextView当中即可。 getitemCount()方法就非常简单了，它用于告诉RecyclerView 一共有多少子项，直接返回数据源的长度就可以了。 12345678910111213141516171819202122232425262728293031323334353637public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; &#123; //数据源 private List&lt;String&gt; mList; public MyAdapter(List&lt;String&gt; list) &#123; mList = list; &#125; //返回item个数 @Override public int getItemCount() &#123; return mList.size() ; &#125; //创建ViewHolder实例 @NonNull @Override public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; return new NormalHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item, parent, false)); &#125; //填充视图 @Override public void onBindViewHolder(@NonNull final MyAdapter.ViewHolder holder, final int position) &#123; holder.mView.setText(mList.get(position)); &#125; public class ViewHolder extends RecyclerView.ViewHolder &#123; public TextView mView; public ViewHolder(View itemView) &#123; super(itemView); mView = itemView.findViewById(R.id.text_view); &#125; &#125;&#125; 子项布局123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/text_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;120dp&quot; android:gravity=&quot;center&quot; android:background=&quot;#c0c7c759&quot; android:textSize=&quot;20sp&quot; android:text=&quot;1&quot; /&gt;&lt;/FrameLayout&gt; MainActivityLayoutManager用于指定RecyclerView的布局方式，这里使用的LinearLayoutManager是线性布局的意思， 可以实现 和ListView类似的效果。 123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity &#123; private RecyclerView mRecyclerView; private MyAdapter mMyAdapter; private LinearLayoutManager mLayoutManager; private List&lt;String&gt; list; @Override protected void onCreate(final Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initData(); mRecyclerView = findViewById(R.id.recycler_view); mMyAdapter = new MyAdapter(list); mLayoutManager = new LinearLayoutManager(this); mRecyclerView.setLayoutManager(mLayoutManager); mRecyclerView.setAdapter(mMyAdapter); &#125; private void initData() &#123; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= 20; i++) &#123; list.add(&quot;Item &quot; + i); &#125; &#125;&#125; 效果： 分割线 - ItemDecoration可以通过RecyclerView.addItemDecoration()来实现。 略… 布局 - LayoutManagerLayoutManager 负责在 RecyclerView 中度量和定位 Item 视图，并确定何时回收用户不再可见的 Item 的策略。通过更改 LayoutManager，可以使用 RecyclerView 实现标准的垂直滚动列表、统一的网格、交错网格、水平滚动集合等。 几个实现类： 123LinearLayoutManager：LayoutManager 的子类，线性布局管理器，支持横向、纵向GridLayoutManager：LinearLayoutManager 的子类，网格布局管理器StaggeredGridLayoutManager：LayoutManager 的子类，瀑布流布局管理器 动画 - ItemAnimator动画也是 RecyclerView 很强大的一点，用户可以通过实现 ItemAnimator 这个抽象类来定制我们想要的动画。 官方为我们提供了一种默认的实现 DefaultItemAnimator ，借助这个类，我们就可以加入 Item 的添加和删除动画，实现起来很简单，只需要加入下面这一行代码即可： 1mRecyclerView.setItemAnimator(new DefaultItemAnimator()); 然后再具体更改自己的代码就行了，这里只是简单的介绍了一下关于动画的一点儿东西，还有很多好看的动画，可以参考一下这个链接。 点击事件12ListView 中点击事件只能针对子项，无法监听内部控件RecyclerView 按需对任意 View 设置点击监听，不存在点击不到的控件。 通过接口回调实现。 具体使用方法请面向百度编程。 下拉刷新SwipeRefreshLayout。 具体使用方法请面向百度编程。 上拉加载更多footerview。 具体使用方法请面向百度编程。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM打表与C/C++字符串输入]]></title>
    <url>%2F2019%2F04%2F08%2FACM%E6%89%93%E8%A1%A8%E4%B8%8EC-C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[目录： ACM打表方法 C/C++字符串输入方法 scanf gets getchar cin getline(cin,s) ACM打表方法众所周知，在ACM比赛中，对于代码的运行时间运行内存之类的东西是有要求的，很多时候为了提高速度，会采用打表的方法。 比如说ACM里面一道题让你求第n个质数，n&lt;=10000，如果第一个测试用例让你求第1000个，那么你可以将前1000个已经算好了的存起来，如果题目再问到小于1000的情况，前面已经计算过了，那么我们就可以直接输出，算出的结果继续存起来，以备下一次的实用，如此类推，这个存起来的过程就叫做打表。 C/C++字符串输入方法注意，不同的编译器头文件可能不一样，需要注意一下这个问题。 scanf遇到空格会终止。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define N 101010using namespace std;int main()&#123; char s[N],b[N]; cout&lt;&lt;&quot;请输入字符串：\n&quot;; while(~scanf(&quot;%s&quot;,s))&#123; int i = 0; while((b[i] = s[i])!=&apos;\0&apos;) i++; cout&lt;&lt;&quot;字符串复制如下：\n&quot;; puts(b); cout&lt;&lt;&quot;请输入字符串：\n&quot;; &#125; return 0;&#125; 结果如下： 12345678请输入字符串：DJHHJ DHJKSDH字符串复制如下：DJHHJ请输入字符串：字符串复制如下：DHJKSDH请输入字符串： 它自己会将其分为两个字符串。 gets包括空格，但是遇到’\n’会终止。 getchar终止的条件是自己定的，在终止之前可以读入所有的操作。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define N 101010using namespace std;int main()&#123; char s[N],b[N]; int i = 0; cout&lt;&lt;&quot;请输入字符串：\n&quot;;//这里就是遇到回车就结束了。 while((s[i] = getchar())!=&apos;\n&apos;)///模仿getline &#123; b[i] = s[i]; i++; &#125; cout&lt;&lt;&quot;字符串复制如下：\n&quot;; puts(b); return 0;&#125; cin这是C++的输入，和scanf类似。 getline(cin,s)这是string的特定输入法。可以读入空格，以”\n”结束。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define N 101010using namespace std;int main()&#123; //char s[N],b[N]; string s,b; cout&lt;&lt;&quot;请输入字符串：\n&quot;; while(getline(cin,s))&#123; b = s; cout&lt;&lt;&quot;字符串复制如下：\n&quot;; // puts(b); cout&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&quot;请输入字符串：\n&quot;; &#125; return 0;&#125; 参考链接]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>打表</tag>
        <tag>ACM</tag>
        <tag>字符串输入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-自定义控件简述]]></title>
    <url>%2F2019%2F04%2F07%2FAndroid-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录： 自定义控件要求 制作步骤 自定义控件两个方式 基本原理 1.）测量-Measure过程是计算视图大小，View measure过程相关方法主要有三个： 2.）布局-Layout过程用于设置视图在屏幕中显示的位置，View layout过程相关方法主要要三个： 3.)绘制-draw过程主要用于利用前两步得到的参数，将视图显示在屏幕上，到这里也就完成了整个的视图绘制工作。 自定义控件要求1.遵循Android标准的命名，可配置，事件处理。 2.在XML布局中可配置控件属性。 3.点击事件之类的交互行为。 4.兼容性，Android不同版本之间应该具有广泛的适用性。 制作步骤1.view工作原理。 2.编写view类。 3.为view类增添属性。 4.绘制UI。 5.与用户进行交互（响应）。 6.自定义回调函数。 自定义控件两个方式 继承ViewGroup ​ 例如：ViewGroup、LinearLayout、FrameLayout、RelativeLayout等。 继承View ​ 例如：View、TextView、ImageView、Button等。 基本原理View的绘制基本上由measure()、layout()、draw()这个三个函数完成。 1.）测量-Measure过程是计算视图大小，View measure过程相关方法主要有三个：123public final void measure(int widthMeasureSpec, int heightMeasureSpec) protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) measure调用onMeasure，onMeasure测量宽度、高度然后调用setMeasureDimension保存测量结果，measure，setMeasureDimension是final类型，view的子类不需要重写，onMeasure在view的子类中重写。 关于MeasureSpec： (1) UPSPECIFIED :父容器对于子容器没有任何限制,子容器想要多大就多大. (2) EXACTLY父容器已经为子容器设置了尺寸,子容器应当服从这些边界,不论子容器想要多大的空间. (3) AT_MOST子容器可以是声明大小内的任意大小. 2.）布局-Layout过程用于设置视图在屏幕中显示的位置，View layout过程相关方法主要要三个：123public void layout(int l, int t, int r, int b)protected boolean setFrame(int left, int top, int right, int bottom)protected void onLayout(boolean changed, int left, int top, int right, int bottom) layout通过调用setFrame（l,t,r,b），l,t,r,b即子视图在父视图中的具体位置，onLayout一般只会在自定义ViewGroup中才会使用。 3.)绘制-draw过程主要用于利用前两步得到的参数，将视图显示在屏幕上，到这里也就完成了整个的视图绘制工作。12public void draw(Canvas canvas)protected void onDraw(Canvas canvas) 通过调用draw函数进行视图绘制，在View类中onDraw函数是个空函数，最终的绘制需求需要在自定义的onDraw函数中进行实现，比如ImageView完成图片的绘制，如果自定义ViewGroup这个函数则不需要重载。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(五)]]></title>
    <url>%2F2019%2F04%2F06%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 fir下载 版本 展示 主要代码 增添一个脚本 更新一个版本 总结 前言经过多代版本的更迭，现在这个版本已经稳定下来了。能够自己开发一个这种APP，还是很有成就感的。 下面就是最近一个版本的更新信息： 12342.6.0修复后台BUG。增添蚂蚁森林一键收取能量，星星球以及重力传感器验证功能，同时增加内测IPV6聊天室功能。更改应用图标。 正文fir下载fir下载链接 版本 展示 主要代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//2019.4.5 悬浮按钮方法function suspendButton(qqSpaceLikeFunction)&#123; var window =floaty.window( &lt;frame&gt; &lt;button id=&quot;action&quot; text=&quot;载入脚本...&quot; textColor=&quot;#000000&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; w=&quot;100&quot; h=&quot;40&quot; bg=&quot;#77ffffff&quot;/&gt; &lt;/frame&gt; ); //计时器1s window.setPosition(device.width/2,device.height/2); setInterval(()=&gt;&#123;&#125;, 1000); for(i=3;i&gt;0;i--)&#123; sleep(1000); window.action.setText(i+&apos;s&apos;); &#125; sleep(1000); window.action.setText(&apos;停止运行&apos;); var execution = null; //记录按键被按下时的触摸坐标 var x = 0, y = 0; //记录按键被按下时的悬浮窗位置 var windowX, windowY; //记录按键被按下的时间以便判断长按等动作 var isWork=false; //当前点赞线程 var thread; window.action.setOnTouchListener(function(view, event)&#123; switch(event.getAction())&#123; case event.ACTION_DOWN: x = event.getRawX(); y = event.getRawY(); windowX = window.getX(); windowY = window.getY(); downTime = new Date().getTime(); return true; case event.ACTION_MOVE: //移动手指时调整悬浮窗位置 window.setPosition(windowX + (event.getRawX() - x), windowY + (event.getRawY() - y)); //如果按下的时间超过1.5秒判断为长按，退出脚本 if(new Date().getTime() - downTime &gt; 1500)&#123; exit(); &#125; return true; case event.ACTION_UP: //手指弹起时如果偏移很小则判断为点击 if(Math.abs(event.getRawY() - y) &lt; 5 &amp;&amp; Math.abs(event.getRawX() - x) &lt; 5)&#123; if(window.action.getText() == &apos;开始运行&apos;)&#123; window.action.setText(&apos;停止运行&apos;); toast(&quot;脚本停止运行&quot;); threads.shutDownAll(); &#125;else&#123; window.action.setText(&apos;开始运行&apos;); toast(&quot;脚本开始运行&quot;); thread=threads.start(function()&#123; qqSpaceLikeFunction(); &#125;); &#125; &#125; return true; &#125; return true; &#125;);&#125;//护眼模式点击事件的方法2019.4.6function antForestFunction()&#123; //内置音量下键关闭，故不做监测 //下面是其他js文件的载入路径 var path = &quot;./蚂蚁森林.js&quot;; toast(&quot;开始运行，音量下键结束运行...&quot;); sleep(1000); if(!files.exists(path))&#123; toast(&quot;蚂蚁森林相关文件缺失...&quot;); exit(); &#125; var execution=null; execution=engines.execScriptFile(path);&#125;//星星球点击事件的方法2019.4.6function starStarBallFunction()&#123; //内置音量下键关闭，故不做监测 //下面是其他js文件的载入路径 var path = &quot;./星星球.js&quot;; toast(&quot;开始运行，音量下键结束运行...&quot;); sleep(1000); if(!files.exists(path))&#123; toast(&quot;星星球相关文件缺失...&quot;); exit(); &#125; var execution=null; execution=engines.execScriptFile(path);&#125;//重力传感器方法function cubeAnimationFunction()&#123; //内置音量下键关闭，故不做监测 //下面是其他js文件的载入路径 var path = &quot;./立方体动画.js&quot;; toast(&quot;开始运行，音量下键结束运行...&quot;); sleep(1000); if(!files.exists(path))&#123; toast(&quot;重力传感器验证相关文件缺失...&quot;); exit(); &#125; var execution=null; execution=engines.execScriptFile(path);&#125;//IPV6聊天室方法function chatRoomFunction()&#123; //内置音量下键关闭，故不做监测 //下面是其他js文件的载入路径 var path = &quot;./ipv6聊天室.js&quot;; toast(&quot;开始运行，音量下键结束运行...&quot;); sleep(1000); if(!files.exists(path))&#123; toast(&quot;IPV6聊天室相关文件缺失...&quot;); exit(); &#125; var execution=null; execution=engines.execScriptFile(path);&#125; 增添一个脚本为了防止自己忘记，这里写一下增添一个脚本的常规步骤。 1.添加控件 主要就是在两个页面（开发中与可使用）添加对应的控件就可以了。 一般是两个，第一个是按钮，第二个是相关界面的跳转。 2.添加相关的点击事件。 点击事件指向的是“相关”的UI。 3.添加脚本的点击事件。 buttonClickEvent是自己创建的方法，主要是传进去一个控件的ID，然后传入需要执行的具体方法。 buttonClickEvent： 4.直接写具体实现方法。 一般是把具体实现方法写到另外一个js文件里面，再引入之后使用，免得main.js里面太多东西。 更新一个版本1.将VSCode里面的代码save到device上面去，记得放到同一个项目里面去（只能导入，不能直接从文件管理器剪切移动过去） 2.打包测试。没问题的话发给电脑。 3.电脑登录fir.im，更新版本。 4.写完版本更新内容的话复制粘贴到基本信息里面的应用描述。（开屏检查更新推送） 5.改写内置的版本号（每次更新必备） 、 总结1）下一次修复一下更新问题。 2）增添一个模块叫相关问题，把需要注意的地方都写上去。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-线程停止的三种方式]]></title>
    <url>%2F2019%2F04%2F05%2Fjava%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[目录： 前提 方式一 方式二 方式三 前提停止线程在多线程开发中很有必要，掌握线程的停止可以对线程的停止进行有效的处理。 方式一使用退出标志，使得线程正常的退出，也就是run方法之后进程终止。用flag来作为进程是否继续进行的条件。 12345public void run() &#123; while(flag)&#123; //do something &#125;&#125; 方式二使用stop强行中断线程，不推荐使用，暴力终止，可能使一些清理性的工作得不到完成。还可能对锁定的内容进行解锁，容易造成数据不同步的问题。 方式三使用interrupt方法中断线程。 java中有以下两个方法： this.interrupted():测试当前线程是否已经中断（静态方法）。如果连续调用该方法，则第二次调用将返回false。在api文档中说明interrupted()方法具有清除状态的功能。执行后具有将状态标识清除为false的功能。 this.isInterrupted():测试线程是否已经中断，但是不能清除状态标识。 抛异常法： 1234567891011121314151617181920public class MyThread4 extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; for (int i = 0; i &lt; 50000; i++) &#123; if (this.isInterrupted()) &#123; System.out.println( &quot;线程已经结束，我要退出&quot; );// return; throw new InterruptedException(); &#125; System.out.println( &quot;i=&quot; + (i + 1) ); &#125; System.out.println( &quot;我是for下面的语句，我被执行说明线程没有真正结束&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;进入MyThread.java类中run方法的catch异常了&quot; ); e.printStackTrace(); &#125; &#125;&#125; 沉睡停止法： 1234567891011121314151617181920212223 @Override public void run() &#123; super.run(); try &#123; System.out.println( &quot;begin run&quot; ); Thread.sleep( 500 ); System.out.println( &quot;begin end&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;在沉睡中终止&quot;); e.printStackTrace(); &#125; &#125;public static void main(String[] args) &#123; try &#123; MyThread5 thread5 = new MyThread5(); thread5.start(); Thread.sleep( 20 ); thread5.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;main catch&quot; ); e.printStackTrace(); &#125; &#125; 或者： 12345678910111213141516 try &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.println( &quot;i=&quot; +(i + 1) ); &#125; System.out.println( &quot;run begin&quot; ); Thread.sleep( 200 ); System.out.println( &quot;run end&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;先停止，后sleep&quot; ); e.printStackTrace(); &#125;public static void main(String[] args) &#123; MyThread5 thread5 = new MyThread5(); thread5.start(); thread5.interrupt(); &#125; 参考链接]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(四)]]></title>
    <url>%2F2019%2F04%2F04%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 总结 前言今天早上八点就起来改代码，现在终于把更新这个功能修改完了。等会儿还有事儿，唉，想睡午觉都不行了。 正文今天一天就更新了这么多版本，也是没谁了，主要是为了测试APP更新的功能。 下面是代码： 12345678910111213141516171819202122232425262728293031323334353637//2019.4.4 开屏进入检查是否有更新，有就提示，没有就不提示function checkHaveUpdate()&#123; threads.start(function()&#123; //网络请求必须更改线程，不能在主线程 //通过fir.im的API来进行版本查询 var url=&quot;http://api.fir.im/apps/latest/5ca40357548b7a65912fc02b?api_token=b44bd08868ab6ad1b1c02ca260c389b6&amp;type=android&quot;; var res =http.get(url); //下面必须用app.versionCode获取本地APP版本号，3.00是测试用的 if(res.statusCode == 200)&#123; //toast(&quot;请求成功&quot;); //先检测是否有版本号存储本地 var versionShortFromWeb=JSON.parse(res.body.string()).versionShort; if(storage.get(&quot;versionShort&quot;)==versionShortFromWeb)&#123; //如果版本短号一样则不更新 toast(&quot;欢迎回来，亲~~~&quot;); &#125; else&#123; //有更新 //或许这里可以给一个alert框显示一些更新内容 var allUpdateMessageUrl=&quot;http://api.fir.im/apps/5ca40357548b7a65912fc02b?api_token=b44bd08868ab6ad1b1c02ca260c389b6 &quot;; var allUpdateMessage =JSON.parse(http.get(allUpdateMessageUrl).body.string()); var showallUpdateMessage=&quot;更新内容： &quot;+&quot;\n&quot;+allUpdateMessage.desc; dialogs.build(&#123; title: &quot;发现新版本&quot;, content:showallUpdateMessage, positive: &quot;知道了&quot; &#125;).on(&quot;positive&quot;,()=&gt;&#123; toast(&quot;有更新，请前往菜单页面更新哦，~亲~&quot;); &#125;).show(); log(versionShortFromWeb+app.versionName); &#125; &#125;else&#123;//网络请求失败 toast(&quot;找不到网络呢，亲！&quot;); &#125;; &#125;);&#125; 主要是增添了开屏检查更新的功能： 总结遇到了很多的问题，总归还是很有收获，个人开发APP遇到这么多问题是我始料不及的，但是也很庆幸，因为学到了很多。 现在还有些问题没有解决，包括本地存储的versionShort版本号还是没有完善，只是默认点击了浏览器下载或者直接下载就会更改本地的versionShort为最新版本号，还有就是下载的问题，貌似302？测试不够多现在还不是很明确。 还有就是需要考虑一下在线数据存储器问题。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(三)]]></title>
    <url>%2F2019%2F04%2F03%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 代码 前言今天又是元气满满的一天，改了一天的代码，累死…主要就是在fir.im上面上传了代码，然后给应用添加了一个可以检查更新的功能，有关于网络请求方面有很多问题，不得不说！ 正文代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//2019.4.3检查是否有更新，有更新的话就下载function checkIsUpdata()&#123; threads.start(function()&#123; //网络请求必须更改线程，不能在主线程 //通过fir.im的API来进行版本查询 var url=&quot;http://api.fir.im/apps/latest/5ca40357548b7a65912fc02b?api_token=b44bd08868ab6ad1b1c02ca260c389b6&amp;type=android&quot;; var res =http.get(url); //下面必须用app.versionCode获取本地APP版本号，2.00是测试用的 var now_version=app.versionCode; if(res.statusCode == 200)&#123; //toast(&quot;请求成功&quot;); if(res.body.string().indexOf(now_version)&gt;0) &#123;//已经是最新版 toast(&quot;已经是最新版了哦，亲~~~&quot;); &#125; else &#123;//有新版 //弹出选择框 updataApp(url); &#125; log(res.body.string().indexOf(now_version)); &#125;else&#123;//网络请求失败 toast(&quot;请求失败:&quot; + res.statusMessage); &#125;; &#125;);&#125;;//更新的具体方法function updataApp(url)&#123; //Json.stringify是将Json对象美化,parse是把它变成JSON对象 updateMessage=JSON.parse(http.get(url).body.string()); var updateContent=&quot;名称: &quot;+updateMessage.name+&quot;\n&quot;+&quot;版本号: &quot;+updateMessage.version+&quot;\n&quot;+&quot;版本短号: &quot;+updateMessage.versionShort; dialogs.build(&#123; title: &quot;发现新版本&quot;, content: updateContent, positive: &quot;立即下载&quot;, negative: &quot;取消&quot;, neutral: &quot;去浏览器下载&quot; &#125;).on(&quot;positive&quot;,download) .on(&quot;neutral&quot;, () =&gt; &#123; app.openUrl(&quot;https://fir.im/ha23&quot;); &#125;) .show();&#125;//下载安装包的方法function download()&#123; threads.start(function()&#123; /*var url=&quot;http://api.fir.im/apps/5ca40357548b7a65912fc02b/download_token?api_token=b44bd08868ab6ad1b1c02ca260c389b6&quot;; //转成JSON对象 var downloadApi=JSON.parse(http.get(url).body.string()); //转成字符串 //var a=JSON.stringify(downloadApi.download_token).string();*/ //这里的download_token如果动态拼接的话会出现问题，然后正好前面返回的数据看到的，并且测试之后更新版本并不影响它的值，所以就直接使用了，本来不该这样用 app.openUrl(&quot;http://download.fir.im/apps/5ca40357548b7a65912fc02b/install?download_token=d1a11ae1ae9947fb66777f9540327497&quot;); &#125;);&#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(二)]]></title>
    <url>%2F2019%2F04%2F02%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 主页面 菜单 代码 总结 前言今天改了一下上次的UI还有添加了一下新功能。不得不说，这个UI是真的难调~ 正文主页面 菜单 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240//下面是UI层，主要就是图形&quot;ui&quot;;var color = &quot;#66ccff&quot;;//打开主页面UImainUI();//下面是各个不同的页面UI//主页面UIfunction mainUI()&#123; ui.layout( &lt;frame&gt; &lt;drawer id=&quot;drawer&quot;&gt; &lt;vertical&gt; &lt;appbar&gt; &lt;toolbar id=&quot;toolbar&quot; title=&quot;脚本列表&quot;/&gt; &lt;tabs id=&quot;tabs&quot;/&gt; &lt;/appbar&gt; &lt;viewpager id=&quot;viewpager&quot;&gt; &lt;frame&gt; &lt;vertical&gt; &lt;horizontal&gt; &lt;button id=&quot;autoGood&quot; text=&quot;QQ名片自动点赞&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;button id=&quot;autoGoodRelate&quot; text=&quot;相关&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;3&quot;/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;autoSignIn&quot; text=&quot;I西科自动签到&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;button id=&quot;autoSignInRelate&quot; text=&quot;相关&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;3&quot;/&gt; &lt;/horizontal&gt; &lt;/vertical&gt; &lt;/frame&gt; &lt;frame&gt; &lt;/frame&gt; &lt;/viewpager&gt; &lt;/vertical&gt; &lt;vertical layout_gravity=&quot;left&quot; bg=&quot;#ffffff&quot; w=&quot;280&quot;&gt; &lt;img w=&quot;280&quot; h=&quot;200&quot; scaleType=&quot;fitXY&quot; src=&quot;http://i1.bvimg.com/682525/a1c337b714162972.jpg&quot;/&gt; &lt;list id=&quot;menu&quot;&gt; &lt;horizontal bg=&quot;?selectableItemBackground&quot; w=&quot;*&quot;&gt; &lt;img w=&quot;50&quot; h=&quot;50&quot; padding=&quot;16&quot; src=&quot;&#123;&#123;this.icon&#125;&#125;&quot; tint=&quot;&#123;&#123;color&#125;&#125;&quot;/&gt; &lt;text textColor=&quot;black&quot; w=&quot;*&quot; h=&quot;*&quot; textSize=&quot;15sp&quot; text=&quot;&#123;&#123;this.title&#125;&#125;&quot; gravity=&quot;center&quot; singleLine=&quot;true&quot;/&gt; &lt;/horizontal&gt; &lt;/list&gt; &lt;/vertical&gt; &lt;/drawer&gt; &lt;/frame&gt; ); //自动点击的相关点击事件 ui.autoGoodRelate.click(()=&gt;&#123; autoGoodRelateUI(); &#125;); ui.autoSignInRelate.click(()=&gt;&#123; autoSignInUI(); &#125;); //toolbar activity.setSupportActionBar(ui.toolbar); //设置滑动页面的标题 ui.viewpager.setTitles([&quot;可使用脚本&quot;, &quot;开发中脚本&quot;]); //让滑动页面和标签栏联动 ui.tabs.setupWithViewPager(ui.viewpager); //让工具栏左上角可以打开侧拉菜单 ui.toolbar.setupWithDrawer(ui.drawer); ui.menu.setDataSource([ &#123; title: &quot;个人信息&quot;, icon: &quot;https://img.icons8.com/ios/100/000000/ninja-turtle.png&quot; &#125;, &#123; title: &quot;注意事项&quot;, icon: &quot;https://img.icons8.com/ios/100/000000/assignment-late.png&quot; &#125;, &#123; title: &quot;关于&quot;, icon: &quot;https://img.icons8.com/ios/100/000000/info.png&quot; &#125;, &#123; title: &quot;退出&quot;, icon: &quot;https://img.icons8.com/ios/100/000000/esc.png&quot; &#125; ]); ui.menu.on(&quot;item_click&quot;, item =&gt; &#123; switch(item.title)&#123; case &quot;个人信息&quot;: toast(&quot;尚在开发中哟，亲~&quot;); break; case &quot;注意事项&quot;: alert(&quot;本APP里面的脚本都是依托于无障碍服务，所以无障碍服务权限必须开启。&quot;); break; case &quot;关于&quot;: alert(&quot;Developed by THBELIEF!&quot;); break; case &quot;退出&quot;: ui.finish(); break; &#125; &#125;) //QQ自动点赞的点击事件 ui.autoGood.click(()=&gt;&#123; confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123; if(sure)&#123; //修改控件信息必须更改线程 threads.start(function()&#123; //自动点赞 StartClick(); &#125;); threads.start(function()&#123; //另外一个线程检测是否点击了音量下键 isKeyDown(); &#125;) &#125; &#125;); &#125;); //i西科自动签到点击事件 ui.autoSignIn.click(()=&gt;&#123; confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123; if(sure)&#123; //修改控件信息必须更改线程 threads.start(function()&#123; //自动签到 autoSignInFunction(); &#125;); &#125; &#125;); &#125;);&#125;//QQ名片自动点赞UIfunction autoGoodRelateUI()&#123; ui.layout( &lt;frame&gt; &lt;vertical&gt; &lt;button id=&quot;backMainUIByGoodRelateUI&quot; text=&quot;返回&quot; w=&quot;auto&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; /&gt; &lt;text text=&quot;本脚本适配V7.9.9.3965版QQ.注意：本脚本使用之前必须打开无障碍服务权限，否则不会运行。&quot; textSize=&quot;20sp&quot;/&gt; &lt;/vertical&gt; &lt;/frame&gt; ); //返回键返回主界面 ui.backMainUIByGoodRelateUI.click(()=&gt;&#123; mainUI(); &#125;);&#125;//i西科自动签到UIfunction autoSignInUI()&#123; ui.layout( &lt;frame&gt; &lt;vertical&gt; &lt;button id=&quot;backMainUIBySignInUI&quot; text=&quot;返回&quot; w=&quot;auto&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; /&gt; &lt;text text=&quot;本脚本适配3.9.0Android版i西科.注意：本脚本使用之前必须打开无障碍服务权限，否则不会运行。&quot; textSize=&quot;20sp&quot;/&gt; &lt;/vertical&gt; &lt;/frame&gt; ); ui.backMainUIBySignInUI.click(()=&gt;&#123; mainUI(); &#125;);&#125;//下面是各类方法的实现//从桌面一直打开到点赞页面的函数function open()&#123; //需要无障碍权限 auto(&quot;normal&quot;); //直接打开QQ（应该还要判断一下是否已经登录了） launchApp(&quot;QQ&quot;); //调用QQ提供的Android以及ios通用API打开QQ名片 var i = app.intent(&#123; action:&quot;android.intent.action.VIEW&quot;, data:&quot;mqqapi://card/show_pslcard?&amp;uin=&quot; &#125;); app.startActivity(i); //打开点赞列表 toast(&quot;请点击QQ点赞的图标进入点赞页面哦，亲~~~&quot;); sleep(250);&#125;//具体点赞的方法function good() &#123; //寻找点赞的小图标 var goodClick = desc(&quot;赞&quot;).untilFind(); var i = 0; while (i &lt; goodClick.size()) &#123; var j = 0; while (j &lt; 10) &#123;//十次点击 goodClick.get(i).click(); j = j + 1; &#125; i = i + 1; &#125; //点击完之后要往下翻 className(&quot;android.widget.AbsListView&quot;).scrollForward(); sleep(500); //如果出现显示更多就点击一下 if (text(&quot;显示更多&quot;).exists()) &#123; text(&quot;显示更多&quot;).findOne().parent().click(); &#125;&#125;//这个是QQ名片自动点赞的主方法function StartClick()&#123; //下面就是主函数部分 toast(&quot;请确保QQ已经登录哦亲~~~&quot;); open(); //进入点赞页面，页面跳转需要时间，必须延迟才行。 waitForActivity(&quot;com.tencent.mobileqq.activity.VisitorsActivity&quot;); toast(&quot;停止此脚本请按音量下键，亲~~~&quot;); while(true)&#123; good(); &#125;&#125;//检测是否点击了音量下键的方法function isKeyDown()&#123; //按键时不会弹出音量框 events.setKeyInterceptionEnabled(&quot;volume_down&quot;,true); //监听按键 events.observeKey(); events.on(&quot;key_down&quot;,function(volume_down,event)&#123; toast(&quot;正在关闭此脚本,亲~~~&quot;); //退出脚本 sleep(500); engines.stopAll(); //直接返回桌面 home(); &#125;);&#125;//2019.4.2 i西科自动签到方法function autoSignInFunction()&#123; auto(); //打开i西科 launchApp(&quot;i西科&quot;); //跳转到相应的界面 waitForPackage(&quot;org.weixvn.frame&quot;); //找到首页上签到的按钮，点击进去 id(&quot;it_sign_in&quot;).clickable().findOne().click(); waitForActivity(&quot;com.example.z.iswust.view.activity.impl.SignInActivity&quot;); //点击签到 sleep(1000); id(&quot;btn_signin&quot;).clickable().untilFind().click(); toast(&quot;签到成功了哟，亲~~~&quot;); sleep(500); //签到完成之后直接返回桌面 home();&#125; 总结1.布局和UI的设计还是需要好好斟酌。 2.尽量函数方法话。 3.下次升级蚂蚁森林自动化收取功能。 4.所有功能尽量都提供定时开启的功能。 未完待续~~~]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-活动]]></title>
    <url>%2F2019%2F04%2F01%2FAndroid-%E6%B4%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[目录： 生命周期 简单介绍 活动状态 运行状态 暂停状态 停止状态 销毁状态 活动的生存期 活动被回收之后如何恢复 启动模式 standard singleTop singleTask singleInstance 活动技巧 打印当前活动 随意退出程序 杀掉进程 启动活动最佳方式 生命周期简单介绍Android使用任务（Task）来管理活动，一个任务就是一组存放在栈里的活动的集合，这个栈也叫作返回栈（Back Stack）。要注意，栈是后进先出的数据结构。默认情况下，启动新活动的时候入栈处于栈顶位置。系统总是会将栈顶位置的活动给用户。 活动状态每个活动在其生命周期当中最多有4种状态。 运行状态处于栈顶的活动。 暂停状态活动不处于栈顶，但是仍然可见。 停止状态不在栈顶，同时完全不可见。 销毁状态活动从返回栈中移除了。 活动的生存期1.onCreate() 活动第一次被创建的时候调用，在这个方法中完成初始化操作，比如加载布局、绑定事件等。 2.onStart() 在活动由不可见变为可见的时候调用。 3.onResume() 在活动准备好和用户进行交互的时候调用，此时的活动一定位于返回栈的栈顶，并且处于运行状态。 4.onPause() 在系统准备去启动或者恢复另一个活动的时候调用，通常会在这个方法中将一些消耗cpu的资源释放掉，保存一些关键数据，该方法执行速度要快，不然会影响新的栈顶活动的使用。 5.onStop() 活动在活动完全不可见的时候调用，它和onPause方法的主要区别在于，如果启动的新活动是一个对话框式活动，那么onPause方法会得到执行，而onStop方法并不会执行。 6.onDestroy() 在活动被销毁之前调用，之后活动的状态将变为销毁状态。 7.onRestart() 在活动由停止状态变为运行状态之前调用，即活动被重新启动。 12345678完整生存期 onCreate()和 onDestroy()方法之间所经历的，就是完整生存期。一般，一个活动会在onCreate()方法中完成各种初始化操作，而在onDestroy()方法中完成释放内存的操作。可见生存期 onStart()和onStop()方法之间所经历的就是可见生存期。在该生存期内，活动对于用户总是可见的。我们可以通过这两个方法合理的管理对用户可见的资源。比如在onStart()方法中对资源进行加载，onStop()中进行释放。前台生存期 活动在onResume()方法和onPause()方法之间所经历的的就是前台生存期。此时活动处于运行状态。 活动被回收之后如何恢复很多时候，当内存不足的时候，系统会将一些返回栈中的一些活动给回收掉，如果又打开这个活动，那怎么找回数据呢？ Activity提供了一个onSaveInstanceState()回调方法。这个方法可以保证活动被回收之前一定会被调用，这个方法可以帮助保存该活动的临时数据。 onSaveInstanceState()回调方法会携带一个Bundle类型的参数，键值对形式存储数据，Bundle提供了一系列的方法用于保存数据，比如可以使用putString()方法保存字符串等等，这些方法需要传入两个参数，一个是键，这个键用于后面从Bundle中取值，第二个参数是真正要存储的数据。 其实这个Bundle和前面的Intent的使用方式很类似，这里就不贴代码了，实际上，还可以使用Bundle对象保存数据，然后将其放在Intent里面，再通过Intent传递。 启动模式 activity有四种启动模式，分别为standard，singleTop，singleTask，singleInstance。如果要使用这四种启动模式，必须在manifest文件中标签中的launchMode属性中配置。 12345&lt;activity android:name=&quot;.app.InterstitialMessageActivity&quot; android:label=&quot;@string/interstitial_label&quot; android:theme=&quot;@style/Theme.Dialog&quot; android:launchMode=&quot;singleTask&quot;&lt;/activity&gt; standard标准启动模式，也是activity的默认启动模式。在这种模式下启动的activity可以被多次实例化，即在同一个任务中可以存在多个activity的实例，每个实例都会处理一个Intent对象。如果Activity A的启动模式为standard，并且A已经启动，在A中再次启动Activity A，即调用startActivity（new Intent（this，A.class）），会在A的上面再次启动一个A的实例，即当前的桟中的状态为A–&gt;A。 singleTop如果一个以singleTop模式启动的activity的实例已经存在于栈顶，那么再启动这个Activity时，不会创建新的实例，而是重用位于栈顶的那个实例，并且会调用该实例的onNewIntent()方法将Intent对象传递到这个实例中。 如果以singleTop模式启动的activity的一个实例已经存在与任务桟中，但是不在桟顶，那么它的行为和standard模式相同，也会创建多个实例。 singleTask如果一个activity的启动模式为singleTask，那么系统总会在一个新任务的最底部（root）启动这个activity，并且被这个activity启动的其他activity会和该activity同时存在于这个新任务中。如果系统中已经存在这样的一个activity则会重用这个实例，并且调用他的onNewIntent()方法。即，这样的一个activity在系统中只会存在一个实例。 每次活动启动的时候系统会首先在返回栈中检查是否存在该活动的实例，如果存在就直接使用该实例，并且把这个活动之上的所有的活动都出栈。 singleInstance总是在新的任务中开启，并且这个新的任务中有且只有这一个实例，也就是说被该实例启动的其他activity会自动运行于另一个任务中。当再次启动该activity的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将Intent实例传递到该实例中。和singleTask相同，同一时刻在系统中只会存在一个这样的Activity实例。 活动技巧打印当前活动主要目的是明确当前所处的活动，用处是接手新的代码的时候可以更快的入手。 新建一个BaseActivity的Java文件，这个不用去AndroidManifest中去注册，就是一个普通的Java类。然后让它继承AppCompatActivity，重写onCreate方法： 1234567public class BaseActivity extends AppCompatActivity&#123; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); Log.d(&quot;BaseActivity&quot;,getClass().getSimpleName()); &#125;&#125; 然后让BaseActivity成为那些继承AppCompatActivity的活动的父类，不会影响他们的特性，同时还可以打印出当前活动。 随意退出程序有些时候我们会发现，如果在一个APP里面点击进去很多层之后必须要很多次BACK才可以退出程序。 解决方案：专门建立一个集合类用来管理所有的活动，提供相应的方法来添加活动与移除活动就可以了，然后有需要的地方直接调用方法就可以解决这个问题了。 杀掉进程有时候销毁某APP的所有活动之后还需要杀掉当前的进程，来保证程序完全的退出。 1android.os.Process.killProcess(android.os.Process.myPid()); killProcess方法用来杀掉一个进程，接收一个进程id参数，只能杀掉当前程序进程。 启动活动最佳方式普通的Intent显示启动与隐式启动都是没有任何的问题的。 但是有些时候如果另外一个活动不是你开发的，你也不知道该传哪些参数过去，这就很麻烦，可以换另外一种方案。 修改SecondActivity的代码如下： 123456public static void actionStart(Context context,String datal,String data2)&#123; Intent intent=new Intent(context,SecondActivity.class); intent.putExtra(&quot;param1&quot;,data1); intent.putExtra(&quot;param2&quot;,data2); context.startActivity(intent); &#125; 在SecondActivity当中添加一个actionStart方法，在这个方法中完成Intent的构建，另外所有的SecondActivity需要的数据都是通过actionStart的参数传递过来的，然后存到Intent中最后调用startActivity方法启动SecondActivity。这样的好处就是可以一目了然的知道需要哪些参数，同时调用的时候也更加的方便，只有一行代码。 MainActivity中代码： 123//或许是某个按钮的点击事件触发的活动跳转？SecondActivity.actionStart(MainActivity.this,&quot;data1&quot;,&quot;data2&quot;);//这其实就已经完成了跳转的功能了，因为Intent启动写到方法里面去了。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>活动</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Intent详解]]></title>
    <url>%2F2019%2F03%2F31%2FAndroid-Intent%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[目录： 简介 用途 启动Activity 启动Service 发送广播 主要属性 Acticon Data 次要属性 category Type component extras Flag 构造方法 常用方法 显示意图 隐示意图 番外 向下一个活动传递数据 返回数据给上一个活动 简介Intent在Android中是一个非常重要并且常用的类，可以用来在一个组件中启动App中的另一个组件或者是启动另一个App的组件，这里所说的组件指的是Activity、Service以及Broadcast。 用途启动Activity可以将Intent对象传递给startActivity()方法或startActivityForResult()方法以启动一个Activity，该Intent对象包含了要启动的Activity的信息及其他必要的数据。 启动Service可以将Intent对象传递给startService()方法或bindService()方法以启动一个Service，该Intent对象包含了要启动的Service的信息及其他必要的数据。 发送广播广播是一种所有App都可以接收的信息。Android系统会发布各种类型的广播，比如发布开机广播或手机充电广播等。我们也可以给其他的App发送广播，可以将Intent对象传递给sendBroadcast()方法或sendOrderedBroadcast()方法或sendStickyBroadcast()方法以发送自定义广播。 主要属性Acticon执行的动作类型。如果是自定义的Action的话，定义的时候需要包含app的包名： 1static final String ACTION_TIMEREVEL = &quot;com.exmple.action.TIMERAVEL&quot; Activity Actions： 12345678910111213ACTION_MAIN 表示程序入口ACTION_VIEW 自动以最合适的方式显示DataACTION_EDIT 提供可以编辑的ACTION_PICK 选择一个一条Data，并且返回它ACTION_DAIL 显示Data指向的号码在拨号界面Dailer上ACTION_CALL 拨打Data指向的号码ACTION_SEND 发送Data到指定的地方ACTION_SENDTO 发送多组Data到指定的地方ACTION_RUN 运行Data，不管Data是什么ACTION_SEARCH 执行搜索ACTION_WEB_SEARCH 执行网上搜索ACRION_SYNC 执同步一个DataACTION_INSERT 添加一个空的项到容器中 Broadcast Actions： 12ACTION_TIME_TICK 当前时间改变，并即时发送时间，只能通过系统发送。调用格式&quot;android.intent.action.TIME_TICK&quot;ACTION_TIME_CHENGED 设置时间。调用格式&quot;android.intent.action.TIME_SET&quot; Data操作数据，包括了URL数据类型和MIME Type类型数据，数据域需要与action相匹配。 次要属性category类别，是Action的附加信息，它主要的用途就是可以更明确一个Intent。 12345CATEGORY_DEFAULT 把一个组件Component设为可被implicit启动的。CATEGORY_LAUNCHER 把一个action设置为在顶级执行。并且包含这个属性的Activity所定义的icon将取代application中定义的icon。CATEGORY_BROWSABLE 当Intent指向网络相关时，必须要添加这个类别CATEGORY_HOME 使Intent指向Home界面CATEGORY_PREFERENCE 定义的Activity是一个偏好面板Preference Panel。 Type这个是数据类型，显示指定的Intent的数据类型，跳过了通过URL进行判断的步骤。 component这个是组件，指定Intent的目标组件名称，当指定了这个属性之后，系统将跳过匹配其他的属性，而直接匹配这个属性来启动对应的组件。 extras附加信息，可以附加一些信息在Intent中。 Flag通过setFlags（int）或者addFlags（int）可以把标签flags用在Intent中。 1234FLAG_ACTIVITY_CLEAR_TOP 相当于Single_TaskFLAGE_ACTIVITY_SINGLE_TOP 相当于Single_TopFLAG_ACTIVITY_NEW_TASK 类似于Single_InstanceFLAG_ACTIVITY_NO_HISTORY 当离开该Activity后，该Activity将被从任务栈中移除 构造方法1234Intent(Intent intent); //通过复制一个Intent来创建一个新的IntentIntent(String action); //构造一个指定action的Intent对象Intent(String action，Uri uri); //构造一个指定action，并且有指向数据的uri的Intent对象Intent(Context packageContext，Clsaa&lt;?&gt;class); //构造一个有指定Component属性的Intent 常用方法123456789101112131415addCategory(String Category); //添加一条Category属性addFlags(int Flags); //添加一条Flag标签clone（）; //复制一个Object类型的对象getExtras（）; //获得一个Bundle对象getSourceBounds（）; //获得发送Intent的组件的边界坐标makeMainActivity（ComponentName mainActivity）; //创建一个Category属性为luancher的Intent去启动mainActivityparseUri（String uri，int flags） //通过解析一个uri获得一个Intent对象setComponent（）; //添加component属性setClass（）; //相当于添加component属性setClassName（）; //相当于添加component属性resolveActivity（PackageManager）; //解析Intent启动的Activity，返回ComponentName对象createChooser（Intent target，CharSequence title）;// 创建一个有选择对话框的IntentgetData（）;setType（）;getData（）;getType（）;设置/获得Data/Type类型的数据 显示意图12Intent intent = new Intent(this, ActivityB.class);startActivity(intent); 隐示意图下面构建了一个Intent对象，并没有给其设置component name，所以该Intent是一个隐式的Intent对象。首先给intent设置了action的值为Intent.ACTION_SEND，action对隐式Intent来说是非常重要的。然后我们将intent的数据的MIME类型设置为纯文本类型(“text/plain”)，告知Android我们的Intent持有的是文本类型的数据。最后我们将实际的文本数据通过putExtra()方法作为额外数据设置进去。 另外，在构建好了Intent对象之后，没有立即执行startActivity(sendIntent)方法，而是将sendIntent作为参数传递给了PackageManager的resolveActivity()方法中，该方法会让Android根据该sendIntent找到潜在的适合启动的组件的信息，并以ResolveInfo类的对象的形式返回结果，如果返回null，表示当前系统中没有任何组件可以接收并处理该sendIntent。如果返回不是null，就表明系统中至少存在一个组件可以接收并处理该sendIntent，只有在这种情况下，我们才会执行代码startActivity(sendIntent)，在通过intent启动组件之前先判断要启动的组件存不存在是个良好的编程习惯，因为如果系统中不存在支持你的intent的组件，那么当你调用startActivity()、startService()、bindService()等方法的时候，Android就会抛出异常。 1234567891011121314Intent sendIntent = new Intent();// 设置action, action对隐式Intent来说是非常重要的sendIntent.setAction(Intent.ACTION_SEND);// 设置数据的MIME类型为纯文本类型sendIntent.setType(&quot;text/plain&quot;);// 设置额外的数据sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);// 获取包管理器PackageManager pm = getPackageManager();// 先判断系统中有没有潜在的App的Activity支持对该sendIntent的接收与处理if (pm.resolveActivity(sendIntent, 0) != null) &#123; startActivity(sendIntent);&#125; 参考链接 番外向下一个活动传递数据众所周知，Intent不只是可以拿来启动，还可以拿来传递数据。 大致思路是，通过Intent提供的putExtra（）方法将数据暂存在Intent中，启动另外一个活动之后再取出来就达到了目的了。 实例：(显示) 暂存： 1234String data=&quot;Hello World&quot;;Intent intent=new Intent(FirstActivity.this,SecondActivity.class);intent.putExtra(&quot;extra_data&quot;,data);//所谓的键值对，配合使用startActivity(intent); 取出： 12Intent intent=getIntent();String data=intent.getStringExtra(&quot;extra_data&quot;); 返回数据给上一个活动上一个活动先发出请求： 1startActivityForResult(intent, 1); //请求码 下一个活动返回数据： 1234Intent intent = new Intent();intent.putExtra(&quot;data_return&quot;, &quot;Hello MainActivity&quot;);setResult(RESULT_OK, intent);finish(); 上一个活动接收信息： 123456789101112/重写onActiviResult方法@Overrideprotected void onActivityResult(int requstCode, int resultCode, Intent data)&#123; switch (requstCode)&#123; //请求码 case 1: if(RESULT_OK == requstCode)&#123; //处理结果码 RESULT_CANCELED String returnResult = data.getStringExtra(&quot;data_return&quot;); &#125; break; default: &#125;&#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Intent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Menu菜单]]></title>
    <url>%2F2019%2F03%2F30%2FAndroid-Menu%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[目录： Menu菜单 选项菜单OptionsMenu 上下文菜单ContextMenu 浮动菜单PopupMenu 创建 1.代码 2.XML 在XML中定义Menu 选项菜单 使用 处理 上下文菜单 使用 处理 注意 浮动菜单 使用函数 使用方式 浮动窗口PopupWindow Menu菜单菜单是一种常见的与用户交互的一种用户界面组件。Android3.0以后推荐使用ActionBar来代替Menu。 Menu主要分为下面三种： 选项菜单OptionsMenu右上方三个点，点击之后出现的列表都是由选项菜单的对象进行控制的。 上下文菜单ContextMenu长按指定控件，在屏幕中心弹出列表对话框。 浮动菜单PopupMenu通过指定的控件指定监听，触发显示，可以让菜单列表显示在指定控件的下方。 创建1.代码2.XML以上两种方法下面详说。 在XML中定义Menu在res/menu目录下的xml文件中操作：（menu文件夹是用户自己新建的） 然后下面是具体参数： 12345678910111213141516171819202122232425&lt;menu&gt;：代表菜单资源&lt;item&gt;：菜单项 android:id // 菜单项的id android:icon // 菜单项的图标 android:title // 菜单项的标题 android:orderInCategory // 排序 android:showAsAction // 在ActionBar上的显示参数（API 11） never：不将MenuItem显示在ActionBar上（是默认值） always：总是将该MenuItem显示在ActionBar上 ifRoom：当AcitonBar上有空间时将该MenuItem显示在ActionBar上，没有空间就放入溢出菜单中 withText：将该MenuItem显示在ActionBar上，并显示该菜单项的文本 显示自定义ActionBar的View，需要和actionViewClass这组参数结合使用（API14）&lt;group&gt;：菜单组 二级菜单（子菜单的创建） 12345678910111213概念：在menu Item中嵌套menu元素，可以实现多级菜单，嵌套的菜单叫做子菜单，一般只会使用二级菜单，如果菜单层次太深，会严重影响用户体验。二级可选菜单 android:checkableBehavior 有三个属性值可选 all（多选） single（单选） none（不可选） 选项菜单使用 初始化选项菜单：onCreateOptionsMenu(Menu menu) 为菜单项设置监听器：onOptionsItemSelected(MenuItem item) 处理 1.在res文件夹内容准备一个menu文件夹，所有控制菜单显示的xml文件均被存于此处。 在menu文件夹中创建一个xml文件，让该文件以menu标签作为根标签。 在menu标签之间添加item标签，每一个item标签代表一个菜单选项。 处理item标签中的属性。 XML中代码 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- android:id 用于设置item的id，即唯一标识，用于稍后的点击判断 android:title 用于设置标题 android:orderInCategory 用于设置item选项在菜单列表中的排列顺序 属性值越小，排列顺序越靠前， 如果属性值相同，哪个item的代码在前面，哪个item就排名靠前 android:icon 用于设置图标。注意：如果item是显示在菜单列表中，那么 图标永远不显示 android:showAsAction android3.0 以后才出的属性 用于设置item在标题栏上的显示特点 可选属性值： never 该选项永远显示在菜单列表中 ifRoom 如果标题栏上有剩余空间，就显示在标题栏上，如果没有，就显示在菜单列表中 always 该选项永远直接显示在标题栏上 withText 让图标和文字同时显示 --&gt; &lt;item android:id=&quot;@+id/item1&quot; android:title=&quot;菜单项一&quot; android:orderInCategory=&quot;3000&quot; android:showAsAction=&quot;always|withText&quot; android:icon=&quot;@drawable/ic_launcher&quot;/&gt; &lt;item android:id=&quot;@+id/item2&quot; android:title=&quot;菜单项二&quot; android:orderInCategory=&quot;10&quot; android:showAsAction=&quot;ifRoom&quot; android:icon=&quot;@drawable/ic_launcher&quot;/&gt; &lt;item android:id=&quot;@+id/item3&quot; android:orderInCategory=&quot;20&quot; android:title=&quot;菜单项三&quot; android:icon=&quot;@drawable/ic_launcher&quot;/&gt;&lt;/menu&gt; MainActivity中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; /* * 重写onCreateOptionsMenu方法，在此方法中加载xml文件参数：代表要显示的菜单对象 * * 返回值：true 显示菜单， false 不显示菜单 */ @Override public boolean onCreateOptionsMenu(Menu menu)&#123; // TODOAuto-generated method stub /* * 将my.xml文件中的所有item菜单选项添加到参数二指定的menu对象中显示 */ getMenuInflater().inflate(R.menu.my_menu, menu); //通过代码添加菜单选项 /* * 1. 该菜单选项所在组的groupId * 2. 该菜单的唯一标识，id属性的值 * 3. 控制排列顺序，作用等同于orderInCategory属性 * 4：选项上要显示的文字标题 * */ menu.add(0, 1, 20, &quot;代码添加menu&quot;); return true; &#125; //重写此方法，获取菜单项的点击事件，参数代表被点击的菜单选项 @Override public boolean onOptionsItemSelected(MenuItemitem) &#123; // TODOAuto-generated method stub Toast.makeText(this,item.getTitle()+String.valueOf(item.getItemId()), Toast.LENGTH_SHORT).show(); //区分被点击的item switch (item.getItemId())&#123; caseR.id.item1: break; caseR.id.item2: break; caseR.id.item3: break; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 上下文菜单使用 初始化上下文菜单：onCreateContextMenu(ContextMenu menu, View v,ContextMenuInfo menuInfo) 为指定控件注册上下文菜单：registerForContextMenu(Viewview) 为菜单项设置监听器：onContextItemSelected(MenuItemitem) 处理 通过menu文件夹中的xml文件定义菜单列表中要显示的内容。 重写onCreateContextMenu方法，在该方法中通过。 重写onContextItemSelected方法获取菜单选项被点击的监听事件。 在页面的onCreate方法中通过registerForContextMenu方法的参数指定长按哪个控件对象显示菜单。 注意当registerForContextMenu方法中传递的是一个listview对象时，ContextMenu是针对列表中每个item进行设置。 在onContextItemSelected方法中可以通过以下方式获取别长按的item在listview中对应的position位置。 123AdapterContextMenuInfo aci = (AdapterContextMenuInfo) item.getMenuInfo();//通过菜单信息封装对象获取被点击的item的位置int position = aci.position; XML示例代码 123456789101112&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/list_item1&quot; android:title=&quot;复制&quot;/&gt; &lt;item android:id=&quot;@+id/list_item2&quot; android:title=&quot;删除&quot;/&gt; &lt;item android:id=&quot;@+id/list_item3&quot; android:title=&quot;重命名&quot;/&gt;&lt;/menu&gt; 浮动菜单使用函数创建浮动菜单对象：PopupMenu popupMenu = newPopupMenu(this, btn_show_popupmenu); 参数1：上下文环境。 参数2：需要绑定浮动菜单的控件id。 将菜单文件加载到内存中：getMenuInflater().inflate(R.menu.popup_menu,popupMenu.getMenu()); 为菜单项设置监听器：popupMenu.setOnMenuItemClickListener(OnMenuItemClickListener); 显示菜单：popupMenu.show(); 使用方式1.获取控件对象，设置任意监听，例如设置tv的点击事件： 1PopupMenu pm = newPopupMenu(PopupMenuActivity.this,tv); 2.向popupmenu对象中添加要显示的菜单选项： 1pm.inflate(R.menu.popup_menu); 3.通过show方法显示popupmenu对象： 1pm.show(); 浮动窗口PopupWindow这个其实就是Auto.js里面的悬浮窗。 构造方法： 12345678910111213141516 PopupWindow(View contentView, intwidth, int height) 参数1：contentView，浮动窗口中显示的内容 参数2：width，浮动窗口的宽度 参数3：height，浮动窗口的高度显示浮动窗口：showAsDropDown(Viewanchor, int xoff, int yoff) 参数1：anchor，浮动窗口出现在指定控件的下方 参数2：xoff，在X轴上的偏移量 参数3：yoff，在Y轴上的偏移量隐藏浮动窗口：dismiss() 显示带列表的浮动窗口： 123456789创建ListView对象 setAdapter(ListAdapter)：设置列表适配器，用于填充列表数据 setOnItemClickListener(OnItemClickListener)：设置列表项的监听事件setFocusable(true)：使浮动窗口可以获取焦点setBackgroundDrawable(newColorDrawable())：为解决焦点问题，这行代码必须执行 参考链接1]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Menu</tag>
        <tag>浮动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中的vector与set]]></title>
    <url>%2F2019%2F03%2F29%2Fc-%E4%B8%AD%E7%9A%84vector%E4%B8%8Eset%2F</url>
    <content type="text"><![CDATA[目录： C合法标识符 vector 简介 声明和初始化 输入访问 基本操作 二维 析构函数 c.~vector () 成员函数 c.assign(a，b) c.at(idx) c.back() c.begin() c.capacity() c.clear() c.empty() c.end() c.erase(pos) c.front() get_allocator c.insert(pos,elem) c.insert(pos,n,elem) c.insert(pos,beg,end) c.max_size() c.pop_back() c.push_back(elem) c.rbegin() c.rend() c.resize(num) c.reserve() c.size() c1.swap(c2)、swap(c1,c2) operator[] Set 特性 成员函数 C合法标识符C语言的标识符是字母或下划线(‘‘)开头的，字母、下划线(‘‘)和数字的字符串。 判断合法标识符的时候需要注意一下，很多时候需要用gets输入而不是scanf来输入，因为有可能输入的字符串含有空格。 vector简介向量 vector 是一种对象实体, 能够容纳许多其他类型相同的元素, 因此又被称为容器。 vector的优势就是在于可以随时调整自己的容量大小以便容纳数据。 使用的时候要加上头文件 1#include&lt;vector&gt; 声明和初始化12345678vector&lt;int&gt; a ; //声明一个int型向量a vector&lt;int&gt; a(10) ; //声明一个初始大小为10的向量 vector&lt;int&gt; a(10, 1) ; //声明一个初始大小为10且初始值都为1的向量 vector&lt;int&gt; b(a) ; //声明并用向量a初始化向量b vector&lt;int&gt; b(a.begin(), a.begin()+3) ; //将a向量中从第0个到第2个(共3个)作为向量b的初始值 int n[] = &#123;1, 2, 3, 4, 5&#125; ; vector&lt;int&gt; a(n, n+5) ; //将数组n的前5个元素作为向量a的初值 vector&lt;int&gt; a(&amp;n[1], &amp;n[4]) ; //将n[1] - n[4]范围内的元素作为向量a的初值 输入访问可以用普通的cin与cout进行输入与输出。 输出的时候还可以使用迭代器进行输出控制。 基本操作12345678a.size()获取元素个数a.empty()判断是否为空a.clear()清空元素a.insert(a.begin(), 1000)将1000插入到向量a的起始位置前 a.insert(a.begin(), 3, 1000)将1000分别插入到向量元素位置的0-2处(共3个元素)b.erase(b.begin())将起始位置的元素删除 b.erase(b.begin(), b.begin()+3)将(b.begin(), b.begin()+3)之间的元素删除a.swap(b)将向量a，b交换 二维其它操作与一维操作差不多。 1vector&lt; vector&lt;int&gt; &gt; b(10, vector&lt;int&gt;(5)); //创建一个10*5的int型二维向量 析构函数c.~vector ()销毁所有数据，释放内存。 成员函数c.assign(a，b)将a到b区间（前闭区间后开区间）中的数据赋值给c。 c.at(idx)传回idx所指向的数据，如果越界的话就抛出越界异常。 c.back()传回最后一个数据并且不检查是否存在这个数据。 c.begin()传回迭代器里面的第一个数据地址。 c.capacity()返回容器中的数据个数。 c.clear()清除容器中的所有数据。 c.empty()判断是否容器为空。 c.end()指向迭代器末端元素的下一个，也就是指向一个不存在的元素。 c.erase(pos)删除pos位置的数据，然后返回下一个数据的位置。 c.front()传回第一个数据。 get_allocator使用构造函数返回一个拷贝。 c.insert(pos,elem)在pos位置插入一个elem拷贝，传回新数据位置。 c.insert(pos,n,elem)在pos位置插入n个elem数据。无返回值。 c.insert(pos,beg,end)在pos位置插入在[beg,end)区间的数据。无返回值。 c.max_size()返回容器中最大数据的数量。 c.pop_back()删除最后一个数据。 c.push_back(elem)在尾部加入一个数据。 c.rbegin()传回一个逆向队列的第一个数据。 c.rend()传回一个逆向队列的最后一个数据的下一个位置。 c.resize(num)重新指定队列的长度。 c.reserve()保留适当的容量。 c.size()返回容器中实际数据的个数。 c1.swap(c2)、swap(c1,c2)将c1和c2元素互换。同上操作。 operator[]返回容器中指定位置的一个引用。 Setset（）是一种包含已排序对象的关联容器。 set集合容器实现了红黑树（Red-Black Tree）的平衡二叉检索树的数据结构，在插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，它不会插入相同键值的元素，而采取忽略处理。 平衡二叉树的检索使用中序遍历算法，检索效率高于vector、deque和list等容器。 对于set容器中的键值，不可直接去修改！应该先删除该键值，再插入新的键值。 特性1) 不能直接改变元素值，因为那样会打乱原本正确的顺序，要改变元素值必须先删除旧元素，则插入新元素。 2) 不提供直接存取元素的任何操作函数，只能通过迭代器进行间接存取，而且从迭代器角度来看，元素值是常数。 3) 元素比较动作只能用于型别相同的容器(即元素和排序准则必须相同)。 成员函数 begin()–返回指向第一个元素的迭代器。 clear()–清除所有元素。 count()–返回某个值元素的个数。 empty()–如果集合为空，返回true。 end()–返回指向最后一个元素的迭代器。 equal_range()–返回集合中与给定值相等的上下限的两个迭代器。 erase()–删除集合中的元素。 find()–返回一个指向被查找到元素的迭代器。 get_allocator()–返回集合的分配器。 insert()–在集合中插入元素。 lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器。 key_comp()–返回一个用于元素间值比较的函数。 max_size()–返回集合能容纳的元素的最大限值。 rbegin()–返回指向集合中最后一个元素的反向迭代器。 rend()–返回指向集合中第一个元素的反向迭代器。 size()–集合中元素的数目。 swap()–交换两个集合变量。 upper_bound()–返回大于某个值元素的迭代器。 value_comp()–返回一个用于比较元素间的值的函数。 set参考链接]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>合法标识符</tag>
        <tag>vector</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素性测试]]></title>
    <url>%2F2019%2F03%2F28%2F%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[目录： 素性测试 随机算法 Fermat primality test Miller–Rabin primality test Solovay–Strassen primality test 确定型启发式算法 AKS primality test Baillie–PSW primality test 试除法 Lucas primality test Lucas–Lehmer primality test 素性测试所谓的素性测试就是判定一个整数是否为素数的方法。 素性测试算法分为确定型启发式算法以及随机算法。 随机算法Fermat primality test费马素性检验是一种素数判定法则，利用随机化算法判断一个数是合数还是可能是素数。 Miller–Rabin primality test米勒-拉宾素性检验是一种素数判定法则，利用随机化算法判断一个数是合数还是可能是素数。 Solovay–Strassen primality test 确定型启发式算法AKS primality testAKS素性测试（又被称为 Agrawal–Kayal–Saxena素性测试 和 Cyclotomic AKS test）是一个决定型素性测试算法 ，这个算法可以在多项式时间之内，决定一个给定整数是素数或者合数。 Baillie–PSW primality test维基百科参考链接 试除法Lucas primality test Lucas–Lehmer primality test维基百科参考链接]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>素性测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-Widget框架（一）]]></title>
    <url>%2F2019%2F03%2F27%2FFlutter-Widget%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： Widget框架 简单实例 基础Widget 常用基础widget Text Row，Column Stack Container 手势 StatefulWidget 响应widget生命周期事件 Key 备注： Widget框架参考地址：Flutter中文网。 简单实例123456789101112import &apos;package:flutter/material.dart&apos;;void main() &#123; runApp( new Center( child: new Text( &apos;Hello, world!&apos;, textDirection: TextDirection.ltr, ), ), );&#125; 在编写应用程序时，通常会创建新的widget，这些widget是无状态的StatelessWidget或者是有状态的StatefulWidget， 具体的选择取决于您的widget是否需要管理一些状态。widget的主要工作是实现一个build函数，用以构建自身。 基础Widget常用基础widgetText创建一个带格式的文本。 Row，Column水平与垂直方向上面灵活的布局。 Stack与线性布局类似，允许Widget堆叠。同时可以使用Positioned来定位堆叠的Widget相对于Stack的上下左右四条边的位置。 Container创建矩形视觉元素。 手势手势的交互首先就是要检测输入的手势。 12345678910111213141516171819202122class MyButton extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new GestureDetector( onTap: () &#123; print(&apos;MyButton was tapped!&apos;); &#125;, child: new Container( height: 36.0, padding: const EdgeInsets.all(8.0), margin: const EdgeInsets.symmetric(horizontal: 8.0), decoration: new BoxDecoration( borderRadius: new BorderRadius.circular(5.0), color: Colors.lightGreen[500], ), child: new Center( child: new Text(&apos;Engage&apos;), ), ), ); &#125;&#125; GestureDetector widget并不具有显示效果，而是检测由用户做出的手势。 许多widget都会使用一个GestureDetector为其他widget提供可选的回调。 StatefulWidgetStatefulWidgets是特殊的widget，它知道如何生成State对象，然后用它来保持状态。 在Flutter中，Stateful与State是单独的对象，他们的对象具有不同的生命周期： Widget是临时对象，用于构建当前状态下的应用程序，而State对象在多次调用build()之间保持不变，允许它们记住信息(状态)。 在Flutter中，事件流是“向上”传递的，而状态流是“向下”传递的，重定向这一流程的共同父元素是State。 响应widget生命周期事件在StatefulWidget调用createState之后，框架将新的状态对象插入树中，然后调用状态对象的initState。 子类化State可以重写initState，以完成仅需要执行一次的工作。 当一个状态对象不再需要时，框架调用状态对象的dispose。 可以覆盖该dispose方法来执行清理工作。 Key可以使用key来控制框架将在widget重建时与哪些其他widget匹配。默认情况下，框架根据它们的runtimeType和它们的显示顺序来匹配。 使用key时，框架要求两个widget具有相同的key和runtimeType。 全局的key可以用来标识子Widget。同时在整个Widget结构中必须是全局唯一的，所以可以用全局Key来检索与WIdget关联的状态。 备注：Flutter中文网Widget目录]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>学习笔记</tag>
        <tag>Widget</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++常用函数]]></title>
    <url>%2F2019%2F03%2F26%2FC-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[目录： 前言 C++ cstdlib cctype algorithm cmath cstdlib C 前言目前在备战CCF，算法题刷了蛮多的了，这次就记录一下，常用的C++/C的函数。（只记录常用且实用的，不是大全，再次强调） C++cstdlib12345678910111213141516171819202122begin 得到指向字符串开头的Iterator（迭代器）end 得到指向字符串结尾的Iteratorrbegin 得到指向反向字符串开头的Iteratorrend 得到指向反向字符串结尾的Iteratorsize 得到字符串的大小length() 和size函数功能相同max_size 字符串可能的最大大小empty 判断是否为空operator[] 取第几个元素，相当于数组c_str 取得C风格的const char* 字符串swap 交换函数insert 插入字符append 追加字符push_back 追加字符erase 删除字符串clear 清空字符容器中所有内容replace 替代copy 字符串到空间find 查找,返回基于0的索引号substr(n1,len) 得到字符串从n1开始的长度为len的子串compare 比较字符串(支持所有的关系运算符)getline 从输入流中读入一行 cctype12345678910111213141516171819using ::isalpha; //是否字母using ::isdigit; //是否是数字using ::isgraph; //是否字母、数字或标点using ::islower; //是否小写using ::ispunct; //是否标点using ::isspace; //是否空格using ::isupper; //是否大写using ::isxdigit; //是否十六进制数字using ::tolower; //转为小写using ::toupper; //转为大写 algorithm 循环 对序列中的每个元素执行某项操作 for_each() 查找 在序列中找出某个值的第一次出现的位置 find(a,a+size,n) 返回b,当b=a+size即没找到，a为指针 在序列中找出符合某谓词的第一个元素 find_if() 在序列中找出一子序列的最后一次出现的位置 find_end() 在序列中找出第一次出现指定值集中之值位置 find_first_of() 在序列中找出相邻的一对值 adjacent_find() 计数 在序列中统计某个值出现的次数 count() 在序列中统计与某谓词匹配的次数 count_if() 比较 找出两个序列相异的第一个元素 mismatch() 两个序列中的对应元素都相同时为真 equal(a,a+n,b,cmp) 在序列中找到等于某值的连续n次出现的位置 equal_range(a,a+n,x) 搜索 在序列中找出一子序列的第一次出现的位置 search() 在序列中找出一值的连续n次出现的位置 search_n() 复制 从序列的第一个元素起进行复制 copy() 从序列的最后一个元素起进行复制 copy_backward() 交换 交换两个元素 swap() 交换指定范围的元素 swap_ranges() 交换由迭代器所指的两个元素 iter_swap() 变换 将某操作应用于指定范围的每个元素 transform() 替换 用一个给定值替换一些值 replace() 替换满足谓词的一些元素 replace_if() 复制序列时用一给定值替换元素 replace_copy() 复制序列时替换满足谓词的元素 replace_copy_if() 填充 用一给定值取代所有元素 fill() 用一给定值取代前n个元素 fill_n() 生成 用一操作的结果取代所有元素 generate() 用一操作的结果取代前n个元素 generate_n() 删除 删除具有给定值的元素 remove() 删除满足谓词的元素 remove_if() 复制序列时删除具有给定值的元素 remove_copy() 复制序列时删除满足谓词的元素 remove_copy_if() 唯一 删除相邻的重复元素 unique() 复制序列时删除相邻的重复元素 unique_copy() 反转 反转元素的次序 reverse(a,a+n) 复制序列时反转元素的次序 reverse_copy() 环移 循环移动元素 rotate(a,a+m,a+n)以m位置为界交换前后序列 复制序列时循环移动元素 rotate_copy() 随机 采用均匀分布来随机移动元素 random_shuffle() 划分 将满足某谓词的元素都放到前面 partition() 将满足某谓词的元素都放到前面并维持原顺序 stable_partition() 排序 以很好的平均效率排序 sort(a,a+20,cmp)bool cmp( int a, int b ){ return a&gt;b; }在容器中或string用begin（） 排序，并维持相同元素的原有顺序 stable_sort() 将序列的前一部分排好序 partial_sort() 复制的同时将序列的前一部分排好序 partial_sort_copy() 第n个元素 将第n各元素放到它的正确位置 nth_element() 二分检索 找到大于等于某值的第一次出现 lower_bound() 找到大于某值的第一次出现 upper_bound() 找到（在不破坏顺序的前提下）可插入给定值的最大范围 equal_range() 在有序序列中确定给定元素是否存在 binary_search() 归并 归并两个有序序列 merge() 归并两个接续的有序序列 inplace_merge() 有序结构上的集合操作 一序列为另一序列的子序列时为真 includes() 构造两个集合的有序并集 set_union() 构造两个集合的有序交集 set_intersection() 构造两个集合的有序差集 set_difference() 构造两个集合的有序对称差集（并-交） set_symmetric_difference() 堆操作 向堆中加入元素 push_heap() 从堆中弹出元素 pop_heap() 从序列构造堆 make_heap() 给堆排序 sort_heap() 最大和最小 两个值中较小的 min() 两个值中较大的 max() 序列中的最小元素 min_element(a,a+n) 序列中的最大元素 max_element() 词典比较 两个序列按字典序的第一个在前 lexicographical_compare() 排列生成器 按字典序的下一个排列 next_permutation() 按字典序的前一个排列 prev_permutation() cmath123456789using ::abs; //绝对值using ::exp; //指数值using ::fabs; //绝对值using ::fmod; //求余using ::sqrt; //开方 cstdlib1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253double atof(const char *str);把字符串str转换成double类型。等价于：strtod(str, (char**)NULL)。 int atoi(const char *str);把字符串str转换成int类型。等价于：(int)strtol(str, (char**)NULL, 10)。int rand(void);产生一个0到RAND_MAX之间的伪随机整数。RAND_MAX值至少为32767。void srand(unsigned int seed);设置新的伪随机数序列的种子为seed。种子的初值为1。void *malloc(size_t size);为大小为size的对象分配足够的内存，并返回指向所分配区域的第一个字节的指针；如果内存不足以满足要求，则返回NULL。不对分配的内存区域进行初始化。void free(void *ptr);释放ptr指向的内存空间，若ptr为NULL，则什么也不做。ptr必须指向先前用动态分配函数malloc、realloc或calloc分配的空间。void exit(int status);使程序正常终止。atexit函数以与注册相反的顺序被调用，所有打开的文件被刷新，所有打开的流被关闭。status的值如何被返回依具体的实现而定，但用0表示正常终止，也可用值EXIT_SUCCESS和EXIT_FAILURE。void qsort(void *base, size_t n, size_t size,int (*compare)(const void *, const void *));对由n个大小为size的对象构成的数组base进行升序排序。比较函数compare的形式如下：int func_name(const void *arg1, const voie *arg2);其返回值必须如下所示：arg1 &lt; arg2，返回值&lt;0；arg1 == arg2，返回值==0；arg1 &gt; arg2，返回值&gt;0。 C未完待续（貌似也差不多的说…）]]></content>
      <categories>
        <category>后端</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>常用函数</tag>
        <tag>用法</tag>
        <tag>备战CCF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10-64位Debug安装]]></title>
    <url>%2F2019%2F03%2F25%2FWin10-64%E4%BD%8DDebug%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 安装 配置 测试 Debug Debug常用功能 前言由于本学期开设了汇编实验这门课，相对应的，也有了汇编实验的实验课，由于需要用到debug，再加上win10需要配置，不像win7可以直接使用，这里就写一篇博客记录一下配置过程。 其实win10上使用debug一般有两种方法，一种是在电脑上面装上虚拟机，用win7直接使用debug，第二种就是今天介绍的用DOSBox来解决。 正文DOSBox是一种模拟器软件，主要是在IBM PC兼容机下，模拟旧时的操作系统：MS-DOS，支持许多IBM PC兼容的显卡和声卡，为本地的DOS程序提供执行环境，使这些程序可以正常运行于大多数现代计算机上的不同操作系统。DOSBox特别是为运行早期的计算机游戏所设计，主要以C++编写，是以GNU通用公共许可证许可发布的自由软件。 上面是对DOSBox的简单介绍，摘自维基百科，下面开始介绍具体流程。 首先，众所周知，win10上面是不支持直接使用debug的，如果一旦点击debug.exe的话，会报错。 安装关于debug与DOSBox的下载的话，都可以直接在搜索引擎搜索下载，这里要注意一下DOSBox的下载： DOSBox官网点击进去之后，会看到这样的画面。 然后就是点击这个，然后进去下载就可以。 下载完DOSBox之后会发现它是一个安装器，自己选择安装到哪里，但是一定要知道位置。至于debug.exe的安装位置的话，我的建议是，在C盘下面直接建一个MYDEBUG的文件夹，然后把相关文件放进去。（我这里的DEBUG是网盘里面找到的，实际上搜索下载的貌似只要一个debug.exe就可以） 配置安装完成之后，找到DOSBox安装目录下的DOSBox 0.74 Options.bat文件，然后双击: 然后在末尾添加如下代码： 123MOUNT C C:\MYDEBUGC:debug 这样配置的目的很单纯，只是让每次编译的时候不用准备前面这些条件，就可以直接使用，如果每次都要配置，太麻烦。 测试安装配置完之后自然要测试一下能不能用，先介绍一下debug，如下： DebugDebug是DOS、Windows都提供的实模式(8086方式)程序的调试工具。 使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级别跟踪程序的运行。 Debug常用功能1234567891011用Debug的R命令查看、改变CPU寄存器的内容; 用Debug的D命令查看内存中的内容; 用Debug的E命令改写内存中的内容; 用Debug的U命令将内存中的机器指令翻译成汇编指令; 用Debug的T命令执行一条机器指令; 用Debug的A命令以汇编指令的格式在内存中写入一条机器指令; 这里用命令测试一下是否可以使用： 绿色部分是之前配置的部分，红色箭头指向的就是命令，实测没问题可以使用，这样就可以开始愉快的汇编编程了。。。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Win10</tag>
        <tag>Debug</tag>
        <tag>DOSBox</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归递推与试除法]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%80%92%E5%BD%92%E9%80%92%E6%8E%A8%E4%B8%8E%E8%AF%95%E9%99%A4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录： 递推 递归 1.联系 2.区别 试除法（求解素数） 递推递推是一种经常被使用的简单算法，定义是一种用若干步可重复的简单运算来描述复杂问题的方法。 递推的特点在于，每一项都和他前面的若干项由一定的关联，这种关联一般可以通过递推关系式来表示，可以通过其前面若干项得出某项的数据。 对于递推问题的求解一般从初始的一个或若干个数据项出发，通过递推关系式逐步推进，从而得出想要的结果，这种求解问题的方法叫递推法。其中，初始的若干数据项称为边界。 简单实例如下： 喜欢西游记的同学肯定都知道悟空偷吃蟠桃的故事，你们一定都觉得这猴子太闹腾了，其实你们是有所不知：悟空是在研究一个数学问题！ 什么问题？他研究的问题是蟠桃一共有多少个！ 不过，到最后，他还是没能解决这个难题，呵呵^-^ 当时的情况是这样的： 第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？ Input 输入数据有多组，每组占一行，包含一个正整数n（1&lt;n&lt;30），表示只剩下一个桃子的时候是在第n天发生的。 Output 对于每组输入数据，输出第一天开始吃的时候桃子的总数，每个测试实例占一行。 Sample Input 2 4 Sample Output 4 22 分析： 这其实就是一个递推问题，需要注意的是，一般而言递推的计算效率要大于递归。由题意得f(n) = 2 * ( f(n-1) + 1 )，另外f(1)=1。这就可以求解出相应的答案了，由于题目太简单，这里只写思路。 代码： 12345678910111213141516171819202122#include &lt;stdio.h&gt; int peach(int n) &#123;//这里就是递推 if(n == 1) return 1; else &#123; long res = 1L; while(--n) res = 2 * (res + 1); return res; &#125;&#125; int main(void)&#123; int n; while(scanf(&quot;%d&quot;, &amp;n) != EOF) printf(&quot;%d\n&quot;, peach(n)); return 0;&#125; 递归上面说到，一般来说，递推的计算效率是高于递归的，那么递归与递推有什么区别和联系呢？ 1.联系递归和递推有一定的相似性。 这两个问题都可以描述为以下形式： f(n)=g(f(n-1)，…，f(0)) 这是二者的共同特点。 2.区别1）递归表现出来的是自己调用自己，递推则没有这样的形式。 2）递归是从问题的最终目标出发，将问题简单化，这就是逆向的求解。 递推则是从简单问题出发，正向的解决问题。 3）递归中，n是已知的。递推则可以是在计算中知道，不需要提前知道。 4）一般来说，递推的效率是大于递归的。 试除法（求解素数）一般来说，求解素数的话，要用到两种方式，一个是试除法一个是筛选法，这篇博客里面就写到了Eratosthenes筛选法，这里的话就介绍一下另外一种方法，试除法。试除法其实一般有很多种，这里只介绍一点。大致知道算法就行，现场写也可以。 123456789101112131415161718# include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdbool.h&gt;/*质数：一个自然数，如果只有1和它本身两个约数，这个数叫做质数（也称素数）．对于一个整数n，只需用小于等于√n所有素数去除，所以本算法的时间复杂度为O(√)的。*/bool IsPrime(int n,int prime[],int length)&#123; int i; for(i = 2; (long long)i*i &lt;= n&amp;&amp;prime[i]; i++) &#123; if(n %i == 0) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>递推</tag>
        <tag>试除法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-略知一二]]></title>
    <url>%2F2019%2F03%2F23%2Fjava%E5%9F%BA%E7%A1%80-%E7%95%A5%E7%9F%A5%E4%B8%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[目录： Collection Set HashSet LinkedHashSet SortedSet TreeSet List ArrayList 构造方法 LinkedList 构造方法 Map 特性 方法 HashMap 常用操作 Iterator Collection集合中只能放置对象的引用，不能放置原生数据类型。 常用方法： 1234567891011121314151617181920212223242526272829303132333435// 将所有元素从一个列表复制到另一个列表Collections.copy(new ArrayList(), new ArrayList());// 如果两个指定collection中没有相同的元素,则返回 trueCollections.disjoint(new ArrayList(), new ArrayList());// 使用指定元素替换指定列表中的所有元素Collections.fill(new ArrayList(), new Object());// 返回指定 collection 中等于指定对象的元素数Collections.frequency(new ArrayList(), new Object());// 返回指定源列表中第一次出现指定目标列表的起始位置,如果没有出现这样的列表,则返回 -1Collections.indexOfSubList(new ArrayList(), new ArrayList());// 根据元素的自然顺序，返回给定 collection 的最大元素Collections.max(new ArrayList());// //根据元素的自然顺序，返回给定 collection 的最大元素Collections.min(new ArrayList());// 使用另一个值替换列表中出现的所有某一指定值Collections.replaceAll(new ArrayList(), &quot;oldVal&quot;, &quot;newVal&quot;);// 反转指定列表中元素的顺序Collections.reverse(new ArrayList());// 返回一个比较器,它强行反转Collections.reverseOrder();// 返回一个比较器,它强行反转指定比较器的顺序Collections.reverseOrder(new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; return 0; &#125;&#125;);// 使用默认随机源随机更改指定列表的序列Collections.shuffle(new ArrayList());// 根据元素的自然顺序对指定列表按升序进行排序Collections.sort(new ArrayList());// 根据元素的自然顺序对指定列表按降序进行排序Collections.sort(new ArrayList(), Collections.reverseOrder());// 在指定列表的指定位置处交换元素Collections.swap(new ArrayList(), 1, 2); Set实现类：HashSet,LinkedHashSet. 子接口：SortSet，TreeSet. 不包含重复元素，最多包含一个null，元素没有顺序。 HashSetHashSet不是Ordered也不是Sorted,存储对象引用时是按照哈希策略来实现的, HashSet中是否存在一个对象是通过equals()和hashCode()协同判断，不保证顺序。 构造方法 123public HashSet() public HashSet(int initialCapacity) public HashSet(Collection c) 1public HashSet(Collection c) HashSet底层是使用HashMap实现的HashSet的add()方法详解: 判断已经存储在集合中的对象hashCode值是否与增加对象的hashCode值一致。 如果不一致,直接加进去。 如果一致,再进行equals()比较，如果equals()返回true,对象已经存在不增加进去，如果equals()返回false,把对象增加进去。 LinkedHashSetLinkedHashSet是Ordered,采用双链表实现的，有固定顺序,也就是插入顺序。LinkedHashSet底层是使用LinkedHashMap实现的。 构造方法 123public LinkedHashSet() public LinkedHashSet(int initialCapacity) public LinkedHashSet(Collection c) SortedSet保证迭代器按照元素递增顺序遍历的集合,可以按照元素的自然顺序进行排序。 常用方法： 123456789101112Object first() 返回此有序集合中当前第一个(最小的)元素 Object last() 返回此有序集合中最后一个(最大的)元素 SortedSet headSet(Object toElement) 返回此有序集合的部分视图,其元素严格小于toElement SortedSet tailSet(Object fromElement) 返回此有序集合的部分视图,其元素大于或等于fromElement SortedSet subSet(Object fromElement,Object toElement) 返回此有序集合的部分视图,元素范围从fromElement(包括)到toElement(不包括) Comparator comparator() 返回与此有序集合关联的比较器,如果使用元素的自然顺序,则返回 null TreeSetTreeSet是SortedSet接口的实现,元素不论以什么元素插入,在遍历的时候,都会以天然顺序遍历。因为它是自带排序的，所以如果想要增加自定义类型就必须指定排序的规则。TreeSet底层是使用TreeMap实现的。 构造方法 12345public TreeSet()public TreeSet(SortedSet s) public TreeSet(int initialCapacity)public TreeSet(Comparator&lt;? super E&gt;)public TreeSet(Collection c) List具有列表的功能,元素顺序均是按添加的先后进行排列的,允许重复的元素,允许多个null元素。 常用方法 1234567891011121314151617181920212223242526272829303132333435363738394041List list = new ArrayList();// 向列表的尾部追加指定的元素list.add(&quot;lwc&quot;);// 在列表的指定位置插入指定元素list.add(1, &quot;nxj&quot;);// 追加指定 collection 中的所有元素到此列表的结尾list.addAll(new ArrayList());// 从列表中移除所有元素list.clear();// 如果列表包含指定的元素,则返回truelist.contains(&quot;nxj&quot;);// 如果列表包含指定 collection 的所有元素,则返回 truelist.containsAll(new ArrayList());// 比较指定的对象与列表是否相等list.equals(new ArrayList());// 返回列表中指定位置的元素list.get(0);// 返回列表的哈希码值list.hashCode();// 返回列表中首次出现指定元素的索引,如果列表不包含此元素,则返回 -1list.indexOf(&quot;lwc&quot;);// 返回列表中最后出现指定元素的索引,如果列表不包含此元素,则返回 -1list.lastIndexOf(&quot;lwc&quot;);// 如果列表不包含元素,则返回 truelist.isEmpty();// 移除列表中指定位置的元素list.remove(0);// 移除列表中出现的首个指定元素list.remove(&quot;lwc&quot;);// 从列表中移除指定 collection 中包含的所有元素list.removeAll(new ArrayList());// 用指定元素替换列表中指定位置的元素list.set(0, &quot;lp&quot;);// 返回列表中的元素数list.size();// 返回列表中指定的fromIndex(包括)和toIndex(不包括)之间的部分视图list.subList(1, 2);// 返回以正确顺序包含列表中的所有元素的数组list.toArray();// 返回以正确顺序包含列表中所有元素的数组list.toArray(new String[] &#123; &quot;a&quot;, &quot;b&quot; &#125;); ArrayList构造方法123public ArrayList()public ArrayList(int initialCapacity)public ArrayList(Collection c) ArrayList依赖于数组实现的,初始长度为10的Object[],并且可随需要而增加的动态数组。 当元素超过10,那么ArrayList底层会新生成一个数组,长度为原来的1.5倍+1,然后将原数组内容复制到新数组中,并且后续增加的内容会放到新数组中,当新数组无法容纳增加的元素,重复该过程即可。 LinkedListLinkedList功能与ArrayList,Vector相同,内部是依赖双链表实现的,因此有很好的插入和删除性能,但随机访问元素的性能很差。 构造方法12public LinkedList()public LinkedList(Collection c) LinkedList类中有一个Entry内部类,Entry内部类包含3个部分向前的引用,向后的引用,数据 1header.next = header.previous = header; MapMap接口中键和值一一映射. 可以通过键来获取值. 特性 给定一个键和一个值，你可以将该值存储在一个Map对象. 之后，你可以通过键来访问对应的值。 当访问的值不存在的时候，方法就会抛出一个NoSuchElementException异常。 当对象的类型和Map里元素类型不兼容的时候，就会抛出一个 ClassCastException异常。 当在不允许使用Null对象的Map中使用Null对象，会抛出一个NullPointerException 异常。 当尝试修改一个只读的Map时，会抛出一个UnsupportedOperationException异常。 方法 1 void clear( ) 从此映射中移除所有映射关系（可选操作）。 2 boolean containsKey(Object k) 如果此映射包含指定键的映射关系，则返回 true。 3 boolean containsValue(Object v) 如果此映射将一个或多个键映射到指定值，则返回 true。 4 Set entrySet( ) 返回此映射中包含的映射关系的 Set 视图。 5 boolean equals(Object obj) 比较指定的对象与此映射是否相等。 6 Object get(Object k) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。 7 int hashCode( ) 返回此映射的哈希码值。 8 boolean isEmpty( ) 如果此映射未包含键-值映射关系，则返回 true。 9 Set keySet( ) 返回此映射中包含的键的 Set 视图。 10 Object put(Object k, Object v) 将指定的值与此映射中的指定键关联（可选操作）。 11 void putAll(Map m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。 12 Object remove(Object k) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。 13 int size( ) 返回此映射中的键-值映射关系数。 14 Collection values( ) 返回此映射中包含的值的 Collection 视图。 HashMap常用操作1.第一步就是给HashMap里面put一些键值对。 123456789101112HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(5, 2); hashMap.put(9, 2); hashMap.put(8, 1); hashMap.put(7, 3); hashMap.put(16, 1); hashMap.put(10, 2); hashMap.put(6, 2); //下面两个键值对是没有存的，因为key存过的不会重复存储，只会覆盖之前的vlue hashMap.put(5, 2); hashMap.put(5, 3); 2.containsKey(Object key)方法，返回值为boolean，用于判断当前HashMap中是否包含key对应的key-value。 3.containsValue(Object value)方法，返回值为boolean，用于判断当前HashMap中是否包含value对应的key-value。 4.遍历HashMap的两种方式： 1）利用haspmap.entrySet().iterator()：利用迭代器，从Entry中取出键、取出值，推荐使用这种方式进行遍历，效率较高： 12345678Iterator&lt;Entry&lt;Integer, Integer&gt;&gt; iterator = hashMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Entry&lt;Integer, Integer&gt; entry = iterator.next(); Integer key = entry.getKey(); Integer value = entry.getValue(); System.out.print(key + &quot;---&gt;&quot; + value); System.out.println(); &#125; 2）利用hashmap.keySet().iterator()：利用键的迭代器，每次取出一个键，再根据键，从HashMap中取出值，这种方式的效率不高，不推荐使用： 1234567Iterator&lt;Integer&gt; iterator2 = hashMap.keySet().iterator(); while (iterator2.hasNext()) &#123; Integer key = iterator2.next(); Integer value = hashMap.get(key); System.out.print(key + &quot;---&quot; + value); System.out.println(); &#125; 参考链接 Iterator 在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。迭代器与枚举有两点不同： 1231、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。2、方法名称得到了改进。 接口定义： 12345public interface Iterator &#123; boolean hasNext(); Object next(); void remove();&#125; Object next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型。 boolean hasNext()：判断容器内是否还有可供访问的元素。 void remove()：删除迭代器刚越过的元素。 未完待续~~~]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>略知一二</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-略有小成]]></title>
    <url>%2F2019%2F03%2F22%2Fjava%E5%9F%BA%E7%A1%80-%E7%95%A5%E6%9C%89%E5%B0%8F%E6%88%90%2F</url>
    <content type="text"><![CDATA[目录： 基本数据类型 种类 占用空间 类型转换 包装类 类型转换方法 引用问题 System类 简介 成员变量 成员方法 RunTime类 Date与DateFormat 构造函数 方法 日期比较 SimpleDateFormat格式化日期 格式化编码 printf格式化日期 解析字符串 sleep Calendar类与GregorianCalendar类 基本数据类型种类 讲到基本类型的话，不可避免的就是字面量值，其实它的意思就是表面上的值。 byte、short、int、long类型变量都可以赋予整型字面量值，譬如byte a = 10、short b = 0x45都是合法的赋值操作。Java编译器在编译是会检查字面量值所表示的数字大小是否处于变量类型的合法范围内，如果不在，则无法通过编译。如果多种数值类型的数据进行数学运算时，计算结果的类型是其中这些数值中最高等级或者其更高等级类型。 占用空间byte（字节）用无符号的8位表示，它的取值范围是[-2^7, 2^7-1]。它是最小的整型类型，默认值是0。 short（短整型）用有符号的16位表示，它的取值范围是[-2^15, 2^15-1]。默认值是0。 int（整型）用有符号的32位表示，它的取值范围是[-2^31, 2^31-1]，计算机中用存放的是整型数值的二进制补码。默认值是0。 long（长整型）用有符号的64位表示，它的取值范围是[-2^63, 2^63-1]。它的字面量表示以l或者L结束，如 long a = 45454L。默认值是0L。 float（单精度浮点型）用32位表示，float类型字面量值通常以f或者F结束。由于整型可以自动转换为float类型，所以，也可以将整型字面量值直接赋予float类型变量。默认值是0F。 double（双精度浮点型）用64位表示，遵循IEEE 754规范。它能表示比float更高精度的数值。double是Java基本类型中能达到的最高精度，如果还不能满足要求，可以使用Java中的BigDecimal类。默认值是0.0。 char（字符）用无符号的16位表示，它的取值范围是[0, 2^16-1]。Java中使用Unicode字符集来表示字符，Unicode将人类语言的所有已知字符映射成16位数字，所以Java中的char是16位的。默认值是\u00000。 boolean（ 布尔型）只要true和false两个字面量值，可用于逻辑判断。boolean只能表示1位的信息量，但是它的大小并没有精确地定义。 类型转换在JAVA里面除了boolean类型之外，其他7中类型相互之间可以进行转换。转换分为自动转换和强制转换。对于自动转换（隐式），无需任何操作，而强制类型转换需要显式转换，即使用转换操作符（type）。 占用空间大小进行排序：byte &lt;（short=char）&lt; int &lt; long &lt; float &lt; double 类型转换的总则是：小可直接转大、大转小会失去精度。小转大是Java帮我们自动进行转换的，与正常的赋值操作完全一样；大转小需要进行强制转换操作，其语法是target-type var =（target-type） value。 特别注意：大转小有可能在某些情况下产生不可预估的问题。 包装类Java里面的每一种基本类型都会对应一个唯一的包装类，基本类型与其包装类都可以通过包装类中的静态或者成员方法进行转换。所有的包装类都是final修饰的，也就是它们都是无法被继承和重写的。 基础类型和包装类型都可以通过赋值语法赋值给对立的变量类型。 类型转换方法 引用问题在Java中，“==”符号判断的内存地址所对应的值的相等性，具体来说，基本类型判断值是否相等，引用类型判断其指向的地址是否相等。 举个例子： 1234567Integer a1 = 1;Integer a2 = 1;System.out.println(a1 == a2); // trueInteger b1 = 222;Integer b2 = 222;System.out.println(b1 == b2); // false 这是为什么呢？ 如果打开Integer类中的valueOf()方法会发现： 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) // 判断实参是否在可缓存范围内，默认为[-128, 127] return IntegerCache.cache[i + (-IntegerCache.low)]; // 如果在，则取出初始化的Integer对象 return new Integer(i); // 如果不在，则创建一个新的Integer对象&#125; 由于1属于[-128, 127]集合范围内，所以valueOf()每次都会取出同一个Integer对象，故第一个“==”判断结果为true； 而222不属于[-128, 127]集合范围内，所以valueOf()每次都会创建一个新的Integer对象，由于两个新创建的对象的地址不一样，故第一个“==”判断结果为false。 参考链接 System类简介system类在java中的作用其实就是类似于系统的作用，它的内部包含了很多系统级别的属性以及控制方法。 成员变量主要就是包含了in（标准输入流，键盘输入），out（标准输出流，显示器）以及err（标准错误输出流）。 out与err的差别 System.out在JVM和操作系统都具有缓存功能，其实就是输出的数据不一定实时输出，有时候会积攒到一定数量才会输出；System.err会实时输出。 成员方法1.static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 该方法的作用是数组拷贝，src为被拷贝的数组，srcPos为src要拷贝的初始位置，dest为目的数组，目的数组dest放置拷贝数据的初始位置，length为从src拷贝到的数据长度。 2.static long currentTimeMillis() 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 3.static void exit(int status) 该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。 4.static void gc() 请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 5.static Properties getProperties() 获取系统的属性信息，并存储到Properties集合中。Properties集合中存储的都是String类型的键值对。 6.static String getProperty(String key) 获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示： 7.static String setProperty(String key, String value) 给系统设置一些属性信息，这些信息是全局的，其他程序都可以使用。 RunTime类Runtime类封装了运行时的环境。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。该类无法创建对象。 常用方法 static Runtime getRuntime() 返回一个Runtime实例。 Process exec(String command) 指定某个exe文件并返回该程序进程，参数command为本地exe文件路径。 long freeMemory() 返回Java虚拟机中的空闲内存量，以字节为单位 long maxMemory() 返回Java虚拟机试图使用的最大内存量 long totalMemory() 返回Java虚拟机中的内存总量 Date与DateFormatDate是Java中提供来封装当前的日期与时间的类。 构造函数12Date( );//使用当前日期和时间来初始化对象。Date(long millisec);//接收一个参数，该参数是从1970年1月1日起的毫秒数。 方法 日期比较 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。 使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。 SimpleDateFormat格式化日期SimpleDateFormat 允许用户选择任何自定义日期时间格式来运行。 123456789101112import java.util.*;import java.text.*; public class DateDemo &#123; public static void main(String args[]) &#123; Date dNow = new Date( ); /*这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。*/ SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;); System.out.println(&quot;当前时间为: &quot; + ft.format(dNow)); &#125;&#125; 格式化编码 字母 描述 示例 G 纪元标记 AD y 四位年份 2001 M 月份 July or 07 d 一个月的日期 10 h A.M./P.M. (1~12)格式小时 12 H 一天中的小时 (0~23) 22 m 分钟数 30 s 秒数 55 S 毫秒数 234 E 星期几 Tuesday D 一年中的日子 360 F 一个月中第几周的周几 2 (second Wed. in July) w 一年中第几周 40 W 一个月中第几周 1 a A.M./P.M. 标记 PM k 一天中的小时(1~24) 24 K A.M./P.M. (0~11)格式小时 10 z 时区 Eastern Standard Time ‘ 文字定界符 Delimiter “ 单引号 ` printf格式化日期printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。 转 换 符 说 明 示 例 c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007 F “年-月-日”格式 2007-10-27 D “月/日/年”格式 10/27/07 r “HH:MM:SS PM”格式（12时制） 02:25:51 下午 T “HH:MM:SS”格式（24时制） 14:28:16 R “HH:MM”格式（24时制） 14:28 解析字符串SimpleDateFormat 类的parse()方法来按照对应的格式化存储来解析字符串。 sleepsleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。 1Thread.sleep(1000); // 休眠1秒 Calendar类与GregorianCalendar类略…]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>略有小成</tag>
        <tag>基本数据类型</tag>
        <tag>包装类</tag>
        <tag>System类</tag>
        <tag>Runtime类</tag>
        <tag>Date类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分拆素数和]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%88%86%E6%8B%86%E7%B4%A0%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[目录： 题目内容 题目分析 Eratosthenes筛选法 试探法（回溯法） 代码详解 题目内容 原题链接 题目分析很明显，本题的要求是要求解分解的个数，主要思路就是利用Eratosthenes筛选法来求必要的素数，然后用试探法来求分解的个数。 原理：对于任何一个可以分解为两个素数之和的偶数，其中一个必然是小于或者等于1/2的。 Eratosthenes筛选法筛选法又称筛法，具体做法是：先把N个自然数按次序排列起来。1不是质数，也不是合数，要划去。第二个数2是质数留下来，而把2后面所有能被2整除的数都划去。2后面第一个没划去的数是3，把3留下，再把3后面所有能被3整除的数都划去。3后面第一个没划去的数是5，把5留下，再把5后面所有能被5整除的数都划去。这样一直做下去，就会把不超过N的全部合数都筛掉，留下的就是不超过N的全部质数。 （合数：一个正整数，除了1和它本身以外，还能被其他正整数整除，这个数就叫做合数。） （质数（prime number）又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。） 埃拉托斯特尼筛选法是最为知名的产生素数的筛选法，适用于产生最小的N个素数。 该方法的唯一缺点是使用的存储空间大，可以进一步改进。 另外，该算法也不适用于计算某个范围内的全部素数。 试探法（回溯法）先选择某一种可能的情况进行试探，在试探过程中，一旦发现此选择的假设是错误的，就退回一步重新选择，继续向前试探，如此反复进行，直到证明解或者无解。 代码详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cmath&gt;#define Max 10000using namespace std;//Eratosthenes筛选法void eratosthenesFunction(int num[],int n)&#123; //两个参数一个是筛选的数组，一个是筛选的最大值 //由于数组在函数中修改的值类似于取址赋值，这里直接里面修改外面也修改了 num[0]=num[1]=0; num[2]=1;//从2开始的质数才算进去 //首先先初始化，把所有质数序号的数组值赋值为1 for(int i=3;i&lt;=n;i++) &#123; num[i]=1; i++; num[i]=0; &#125; int max=sqrt(n); for(int i=3;i&lt;=max;i++) &#123; //下面就开始筛选了，把所有的之前出现过的质数的倍数给去掉 if(num[i])&#123; for(int j=i+i;j&lt;n;j+=i)&#123; num[j]=0; &#125; &#125; &#125;&#125;int main()&#123; int num[Max+1]=&#123;0&#125;;//因为我们算的都是正数，意思是没有用到下标为0的 int sum,count;//依次表示的是输入的正数和拆分个数 eratosthenesFunction(num,Max);//送进去筛选 while(1)&#123; cin&gt;&gt;sum; if(sum==0) break;//要先判断是否是终止条件 count=0;//这个是必须的，在循环中每一次循环都是不同的数字，必须重置 for(int i=2;i&lt;sum/2;i++)&#123; //对于任何一个可以分解为两个素数之和的偶数，其中一个必然是小于或者等于1/2的。 if(num[i]&amp;&amp;num[sum-i])&#123; //这里就是判断是否是两个质数 if(i!=sum-i)&#123; count++; &#125; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl; &#125; return 0;&#125; 最后结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分拆素数和</tag>
        <tag>试探法</tag>
        <tag>Eratosthenes筛选法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart学习笔记(一)]]></title>
    <url>%2F2019%2F03%2F21%2FDart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： 前言 简单实例 重要概念 关键字 变量 未初始化 Final与const关键字 前言由于最近写的一个东西需要到Flutter，所以Dart语言也必须学好，不多说，现在立马就开始吧。由于是个人向的学习笔记，所以，默认是已经学过其他编程语言了，然后很多和其他类似的语法就不过多赘述，只是表达目前新的东西。 简单实例12345678910// 定义一个函数printInteger(int aNumber) &#123; print(&apos;The number is $aNumber.&apos;); // Print to console.&#125;// 程序执行入口main() &#123; var number = 42; // Declare and initialize a variable. printInteger(number); // Call a function.&#125; dart内置的类型包括int，string，list，bool。 print()用于显示输出。 main()是一种特殊的，必须的顶级函数，应用程序就从这里开始执行。 重要概念在变量中可以放置的所有东西都是对象，而每个对象都是类的实例。无论数字、函数和null都是对象。所有对象都继承自[Object]类。 尽管Dart是强类型的，但类型声明是可选的，因为Dart可以推断类型。 在上面的代码中，数字被推断为int类型。 如果要明确说明不需要任何类型，请使用[特殊类型dynamic]。 Dart支持通用类型，如List(整数列表)或List(任何类型的对象列表)。 Dart支持顶级函数(如main())，以及绑定到类或对象(分别是静态方法（static）和实例（instance）方法)的函数。您还可以在函数(嵌套或局部函数)中创建函数。 Dart支持顶级变量，以及绑定到类或对象(静态和实例变量)的变量。实例变量有时被称为字段或属性。 与Java不同，Dart没有公开、保护和私有的关键字。如果标识符以下划线()开头，则该标识符对其库是私有的。 标识符可以以字母或下划线()开头，然后是这些字符加上数字的任何组合。 有时候，某事物是一个表达（expression ）还是一个语句（statement）是很重要的，所以这两个词要准确。 关键字这就是Dart里面所有的关键字： (1)带有上标1的单词是内置标识符。避免使用内置标识符作为标识符。如果尝试为类或类型名使用内置标识符，则会发生编译时错误。 (2)使用上标2的单词是在Dart的1.0版本之后添加的与异步支持相关的更新的、有限的保留字。在以async, async, 或者 sync 标记的任何函数体中，不能使用async, await, 或者 yield作为标识符。 关键字表中的所有其他词都是保留词。不能使用保留词作为标识符。 变量未初始化未初始化的变量的初始值为null。甚至具有数字类型的变量最初也是null，因为数字——就像dart中的其他东西一样——是对象。 12int lineCount;assert(lineCount == null); Final与const关键字最终变量只能设置一次，const变量是一个编译时常数。(Const变量是隐式最终变量。)最终的顶级或类变量在第一次使用时被初始化。 注意:实例变量可以是final，但不能是const。[实例变量定义在对象一级，它可以被类中的任何方法或者其他类中的方法访问，但是不能被静态方法访问。] 对于想要在编译时确定并且不再变的变量，使用const。如果const变量位于类级别，则将其标记为静态const。 const关键字不只是声明常量变量。还可以使用它来创建常量值，以及声明创建常量值的构造函数。任何变量都可以赋一个常量值。]]></content>
      <categories>
        <category>后端</category>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>Flutter</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-渐入佳境]]></title>
    <url>%2F2019%2F03%2F21%2Fjava%E5%9F%BA%E7%A1%80-%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83%2F</url>
    <content type="text"><![CDATA[目录： 前言 对象实例化过程 方法的覆盖 定义 特点 final关键字 数据 类 方法 空final 前言关于Java基础系列的学习路线，我已经在安卓学习路线总结plus里面写到了，我是按照那个上面的路线来学习的，如果有不明白的地方的话，可以移步前往作为 参考，也可以当成是目录。 对象实例化过程1.检查类是否已经加载，如果没有加载的话就加载这个类，需要加载所有的父类。 2.在内存堆中分配对象空间，递归分配所有父类和子类属性空间.先父类型再子类型,属性默认自动初始化.自动初始化为”0”值。 3.进行属性的赋值。 4.递归调用父类的构造器（默认的是调用父类的无参数构造器）。 5.调用本类的构造器。 注意： 1）静态初始化是指执行静态初始化块儿里面的内容。 2）实例初始化是指执行实例初始化块儿里面的内容。 3）构造方法：一个名称跟类的名称一样的方法，特殊在于不带返回值。 实例： 123456789101112131415161718192021222324252627public class TestInstanceInit &#123;public static int n = 0;// 静态变量static &#123;// 这是静态初始化块print();System.out.println(&quot;this is static block&quot;);&#125;&#123;// 实例初始化块System.out.println(n);&#125;public TestInstanceInit() &#123;// 构造方法System.out.println(&quot;this is TestInstanceInit&apos;s constructor~&quot;);&#125;public static void print() &#123;// 静态方法System.out.println(&quot;this is static method~&quot;);System.out.println(n);n += 1;&#125;public static void main(String[] args) &#123;new TestInstanceInit();&#125;&#125; 输出结果是: 12345this is static method~0this is static block1this is TestInstanceInit&apos;s constructor~ 执行顺序： (静态变量、静态初始化块)&gt;(变量、初始化快)&gt;构造器。 静态变量和静态初始化快/变量和初始化快的先后顺序取决于它们在类中出现的先后顺序。 参考链接 方法的覆盖定义如果在子类中定义一个方法，其名称、返回类型及参数签名正好与父类中某个方法的名称、返回类型及参数签名相匹配，那么可以说，子类的方法覆盖了父类的方法。 特点 子类的方法名称返回类型及参数签名 必须与父类的一致。 子类方法不能缩小父类方法的访问权限。 子类方法不能抛出比父类方法更多的异常。 方法覆盖只存在于子类和父类之间，同一个类中只能重载。 父类的静态方法不能被子类覆盖为非静态方法。 子类可以定义于父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法（满足覆盖约束）， 而且Java虚拟机把静态方法和所属的类绑定，而把实例方法和所属的实例绑定。 父类的非静态方法不能被子类覆盖为静态方法。 父类的私有方法不能被子类覆盖。 父类的抽象方法可以被子类通过两种途径覆盖（即实现和覆盖）。 父类的非抽象方法可以被覆盖为抽象方法。 final关键字在Java中final关键字可以用来修饰数据，方法，参数以及类。 数据final修饰的基本类型，在初始化之后就不能在赋值了，同理，修饰的对象一旦引用被初始化指向一个对象的话，就无法把它改指向另外一个对象。 但是要注意，被final修饰的对象引用，只是对象的应用不能修改，但是其自身却是可以修改的。 类当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。 final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。 方法使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。 注意:类的private方法会被隐式的指定为final方法。 空final谓的”空白final”是指被声明的为final但又为给定初值的对象引用或者基本数据。无论在什么情况下，编译器都会去确保final在使用前必须被初始化。若不进行初始化，会提示错误，这就意味着，必须在域的定义处或者每个构造器中使用表达式对final进行赋值，这正是final域在使用前被初始化的原因所在。]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>渐入佳境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(二)]]></title>
    <url>%2F2019%2F03%2F20%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[目录： 函数定义与调用 定义函数 调用函数 特殊arguments rest参数 变量相关 变量提升 全局作用域 名字空间 局部作用域 常量 解构赋值 方法 apply 装饰器 四个常用的高阶函数 map reduce filter sort 闭包 函数作为返回值 箭头函数 generator 优势 函数定义与调用定义函数第一种方法如下： 123function hanshu()&#123; ...&#125; 1.function指出这是一个函数定义； 2.hanshu是函数的名称； 3.(x)括号内列出函数的参数，多个参数以,分隔； 4.{ … }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。 第二种方法如下： 123var hanshu = function (x) &#123; ...&#125;; function (x) { … }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量hanshu，所以，通过变量hanshu就可以调用该函数。这两种其实是完全等价的，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 调用函数JS中有点儿特殊，主要就是特殊在JS中对于一个函数传进去的参数不做限制，传多了没有问题，只是在内部没有用而已，传少了的话计算结果会变成NaN。如果想保险一点儿的话，可以直接在函数里面对于传进来的参数做判断即可。 特殊arguments在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array。意思也就是，就算函数并没有定义任何的变量，也是可以拿到参数的值。 rest参数（ES6引入）rest参数只能写在最后，前面用…标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。 特别注意:JS里面有一个自动在行末添加分号的性质，所以特别需要注意。 变量相关注意，由于JS支持函数嵌套，在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。 变量提升JS函数的特性，它执行前会扫描整个函数体，把所有声明的变量都放到顶部。但是要注意，它只是提升变量的声明，并没有提升变量的赋值。 所以为了避免有些错误，建议是在函数体内，把所有的变量声明都放到函数的开头。 全局作用域不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性。 1234var bianliang=&apos;thbelief&apos;;function hanshu()&#123; ...&#125; 这里的话，访问bianliang与访问window.bianliang是完全一样的。 同时，第二种函数的定义方式其实也是一种全局的。 123var hanshu = function (x) &#123; ...&#125;; 所以，其实JS只有一个全局作用域。 名字空间全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。 例如: 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = &apos;myapp&apos;;MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return &apos;foo&apos;;&#125;; 这个其实是一个特别实用的方法，必须提倡。 局部作用域在循环中，一般使用let替代var声明次级作用域的变量。 12345678&apos;use strict&apos;;function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; i += 1;&#125; 常量ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域。但是需要注意，不是所有的地方都支持，因为ES6才引进。 解构赋值可以直接对多个变量同时赋值。 123&apos;use strict&apos;;// 如果浏览器支持解构赋值就不会报错:var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;]; 注意，对数组元素进行解构赋值时，多个变量要用[…]括起来。 有些时候数组本身还有嵌套，也可以解构赋值，但是需要保持嵌套层次和位置的一致性。 解构赋值还有很多用法，这里就不一一阐述了，需要的时候直接去查就好啦。 方法在一个对象中绑定函数，这就是这个对象的方法。 1234567891011var thbelief = &#123; name: &apos;thbelief&apos;, birth: 1999, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;thbelief.age; // function thbelief.age()thbelief.age(); 同时，this关键字在JS里面也有和C++同样的作用，可以直接调用本函数的方法。 但是一定要用对象的形式调用，这才是指向本函数里面的方法，不然的话就是对于整个全局作用域来说的。 解决的方法其实也有，就是var that = this;这条语句加上去在用的地方就可以了。 apply虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，还是可以控制this的指向！ 要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 用apply修复getAge()调用： 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var thbelief = &#123; name: &apos;thbelief&apos;, birth: 1999, age: getAge&#125;;thbelief.age(); getAge.apply(thbelief, []); 另一个与apply()类似的方法是call()，唯一区别是： apply()把参数打包成Array再传入； call()把参数按顺序传入。 比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下： 12Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5 装饰器利用apply()，我们还可以动态改变函数的行为。 JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。 四个常用的高阶函数mapmap可以传入任意的变量或者自己定义的相关函数，比如说做一个2的次方运算，相比较于我们傻乎乎的使用循环一层一层的套，map作为高阶函数无疑是更加具有实力的。 1234567&apos;use strict&apos;;function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] reduceArray的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算。 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x * 10 + y;&#125;); // 13579 filter其实有点儿类似于Android里面的过滤器。它的作用就是将Array里面的某些元素过滤掉，然后返回剩下的元素。 和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 12345var arr = [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, null, undefined, &apos;C&apos;, &apos; &apos;];var r = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;);r; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] sort需要注意的是，sort默认的排序不是简简单单的针对于数字进行排序。 它的默认把所有元素先转换为String再排序。 同时，作为一个函数，sort可以传入一个比较函数来作为依据。 比如说下面这个按照数字大小来进行排序： 1234567891011&apos;use strict&apos;;var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;); 闭包函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 12345678function lazy_sum(arr) &#123; var sum = function () &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;); &#125; return sum;&#125; 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数： 1var f = lazy_sum([1, 2, 3, 4, 5]); // function sum() 调用函数f时，才真正计算求和的结果： 1f(); // 15 函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种“闭包（Closure）”的程序结构拥有极大的威力。 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为它只会锁定最后一个结果。如果一定要引用循环变量的话，方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。 闭包还有很多应用，这里只是阐述基本概念，相关的使用要用的时候自己查即可。 箭头函数是在ES6之后推出的，只支持ES6之后的版本。 12345x =&gt; x * x;//两者完全等价function (x) &#123; return x * x;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。 箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。 还有一种可以包含多条语句，这时候就不能省略{ … }和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; 1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 如果要返回一个对象，并且是单表达式： 12// ok:x =&gt; (&#123; foo: x &#125;) this： 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。由于this在箭头函数中已经被绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略… generatorgenerator（生成器）是ES6新引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。 定义： 12345function* foo(x) &#123; yield x + 1; yield x + 2; return x + 3;&#125; generator和函数不同的是，generator由function定义（注意多出的号），并且，除了return语句，还可以用yield返回多次。 优势1.因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。 2.把异步回调代码变成“同步”代码。（深） 参考链接]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(一)]]></title>
    <url>%2F2019%2F03%2F19%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： 简介 正文 总结 下个版本 简介Auto.js使用JavaScript作为脚本语言，目前使用Rhino 1.7.7.2作为脚本引擎，支持ES5与部分ES6特性。 最开始接触Auto.js只是单纯的想写一个I西科自动签到的脚本，接触后才发现，写这样一个脚本其实简单的不行，然后了解了Auto.js的相关特性之后，我决定好好的学习一下这个工具，毕竟，它实在是太简约了，不像其他的脚本语言那么复杂，虽然…有点儿bug，毕竟开发者自己也只是一个大学生，不能指望有多完善，但是这种自动化脚本编辑实在是太有魅力了。 正文最近正在开发的Script，主要目的是借用Auto.js自带的UI模块儿集成一个个人向的脚本库。 这个版本的展示图： 目前代码展示如下，由于太简单，懒得上传到Github了，直接贴代码（后期如果有升级或者说是改良，会在下一个博客继续写） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&quot;ui&quot;;//下面就是主界面ui.layout( &lt;vertical&gt; &lt;horizontal&gt; &lt;text text=&quot;菜单&quot; w=&quot;*&quot; h=&quot;*&quot; layout_weight=&quot;1&quot; gravity=&quot;center&quot; textSize=&quot;30sp&quot; color=&quot;#000000&quot;/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;autoReply&quot; text=&quot;QQ自动回复&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;button id=&quot;autoReplyClose&quot; text=&quot;关闭&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;autoSignIn&quot; text=&quot;i西科自动签到&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;button id=&quot;autoSignInClose&quot; text=&quot;关闭&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;/horizontal&gt; &lt;/vertical&gt;);//封装的回复方法function WhatReply(notificationText)&#123; if(notificationText==&apos;A&apos;)&#123; return(&quot;您好，我是主人正在开发的人工智障robot001.\n ——robot001欢喜的答道。&quot;); &#125; else if(notificationText==&apos;B&apos;)&#123; return(&quot;好的，我马上联系主人...\n ——robot001郑重的答道。&quot;); &#125; else&#123; return &quot;主人在忙呢！\n有问题请回复下列单个字母：\n A.robot是谁？\n B.有要事迅速联系thbelief. \n ——robot001如此回答道。&quot;; &#125;&#125;//先封装一个自动回复的方法function autoReplyFunction()&#123; auto();//检查是否开启了无障碍服务权限 events.observeNotification();//监听消息 events.onNotification(function(notification)&#123; var string1=&quot;com.tencent.mobileqq&quot;;//如果是QQ消息的话 if(string1==notification.getPackageName())&#123; notification.click();//点击直接进入对应的聊天界面 //跳转必须要用startActivity waitForPackage(&quot;com.tencent.mobileqq&quot;); var t=className(&quot;android.widget.EditText&quot;).id(&quot;input&quot;).findOnce();//找到聊天输入控件 t.setText(WhatReply(notification.getText()));//这里加入回复的方法 className(&quot;android.widget.Button&quot;).id(&quot;fun_btn&quot;).findOnce().click();//发送即可 home();//直接返回桌面 &#125; &#125;);&#125;;//自动签到的方法function autoSignInFunction()&#123; auto(); //打开i西科 launchApp(&quot;i西科&quot;); //跳转到相应的界面 waitForPackage(&quot;org.weixvn.frame&quot;); //找到首页上签到的按钮，点击进去 id(&quot;it_sign_in&quot;).clickable().findOne().click(); waitForActivity(&quot;com.example.z.iswust.view.activity.impl.SignInActivity&quot;); //点击签到 if(id(&quot;btn_signin&quot;).clickable().findOne().click())&#123; //完成任务后返回桌面 home(); toast(&quot;签到成功了哟，亲~~~&quot;); &#125; &#125;//自动回复按钮的点击事件ui.autoReply.click(()=&gt;&#123; //UI模式的情况下必须用Promise形式或者回调模式 confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123; if(sure)&#123; //修改控件信息必须更改线程 threads.start(function()&#123; autoReplyFunction(); &#125;) &#125; &#125;);&#125;);//自动回复按钮的关闭点击事件ui.autoReplyClose.click(()=&gt;&#123; //这里由于只有一个脚本，我就直接把所有的脚本都关闭了，如果是很多脚本的话必须改 engines.stopAll(); toast(&quot;自动回复脚本已经关闭了哦，亲~&quot;);&#125;);//i西科自动签到的点击事件ui.autoSignIn.click(()=&gt;&#123; confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123; if(sure)&#123; //修改控件信息必须更改线程 threads.start(function()&#123; //自动签到的方法 autoSignInFunction(); &#125;) &#125; &#125;);&#125;); 总结1.一定要判断是否开启了无障碍服务权限以及通知使用权。 2.无论是不是用intent跳转页面或者应用，都应该用waitForActivity或者waitForPackage来跳转，不然容易出错。 3.基于控件的操作的时候，一定要注意寻找的依据，尽量使用不重复的依据，例如desc或者说id这种，提高兼容性。 4.方法的封装应该是根据功能来的，这一点本版本还没有做完善。 5.提示信息一定要做到位，该Toast的地方就一定要毫不犹豫的Toast. 6.如果想进入某个界面做某事，可以直接在外面套个if，这样出错的几率会小很多，比如说本版本的autoSignInFunction函数里面的点击签到。 7.UI模式情况下必须使用Promise形式或者说是回调模式。 8.还有就是，运行多个脚本的时候，都要使用多线程。 下个版本1.UI界面做的是真的丑，下个版本尽量修复。 2.添加检查更新的功能，直接app内检查更新并更新到最新版本。 3.添加更多的脚本选项。 4.定时运行，比如说，定时自启之类的，例如本版本的i西科自动签到功能，定时启动签到。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(一)]]></title>
    <url>%2F2019%2F03%2F18%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： 入门 基本语法 数据类型 Number 字符串 布尔值 比较运算符 null和undefined 数组 对象 变量 strict模式 字符串 数组 length indexOf slice push和pop unshift和shift sort reverse splice concat join 多维数组 对象 条件判断 循环 for…in while do while Map和Set iterable 入门基本语法每个语句以;结束，语句块用{...}。但是，JavaScript并不强制要求在每个语句的结尾加;，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上;。 数据类型NumberJS里面不区分整数和浮点数，都是用Number统一表示。 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 字符串字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分。 布尔值只表示true或者false。和C++与Java中完全类似，这里不过多赘述。 比较运算符注意，JavaScript允许对任意数据类型做比较。 12false == 0; // truefalse === 0; // false 特别要注意上述两种格式。 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 这是JS自身设计的缺陷，大佬们都是推荐的是不要使用==比较，始终坚持使用===比较。 还要注意一点是，NaN这个特殊的Number与所有值都不相等，包括它自己。 1NaN === NaN; // false 唯一能够判断NaN的方法就是isNaN()函数。 1isNaN(NaN); // true 最后，浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： 1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true null和undefinednull表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。 1[1, 2, 3.14, &apos;HelloWorld&apos;, null, true]; 创建数组的另一个方法是Array()函数来实现： 1new Array(1, 2, 3); // 创建了数组[1, 2, 3] 对象JavaScript的对象是一组由键-值组成的无序集合。 12345678var person = &#123; name: &apos;thbeleif&apos;, age: 20, tags: [&apos;js&apos;, &apos;web&apos;, &apos;mobile&apos;], city: &apos;mianyang&apos;, hasCar: false, zipcode: null&#125;; JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性。 要获取一个对象的属性，需要用对象变量.属性名的方式： 12person.name; // &apos;thbelief&apos;person.zipcode; // null 变量变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。 在Chrome浏览器里面使用JS的时候，可以直接使用console.log(x)来打印变量的值。 相比较于alert()的对话框，前者看起来无疑是更舒心的。 strict模式在JS设计之初，如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量。 后面有了改良，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。 启用strict模式的方法是在JavaScript代码的第一行写上即可： 1&apos;use strict&apos;; 字符串如果字符串内部既包含’又包含”可以用转义字符\来标识。 1&apos;I\&apos;m \&quot;OK\&quot;!&apos;; ASCII字符可以以\x##形式的十六进制表示。 1&apos;\x41&apos;; // 完全等同于 &apos;A&apos; 还可以用\u####表示一个Unicode字符。 1&apos;\u4e2d\u6587&apos;; // 完全等同于 &apos;中文&apos; 由于多行字符串用\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ` … ` 也可以表示。 123`这是一个多行字符串`; 要把多个字符串连接起来，可以用+号连接。 1234var name = &apos;小明&apos;;var age = 20;var message = &apos;你好, &apos; + name + &apos;, 你今年&apos; + age + &apos;岁了!&apos;;alert(message); 字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果。JS对于字符串提供了许多的方法，但是调用这些方法只会返回一个新的字符串，而不会改变原有的字符串内容。 123toUpperCase()把一个字符串全部变为大写。indexOf()会搜索指定字符串出现的位置。substring()返回指定索引区间的子串。 数组lengthJavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。 Array可以通过length属性来取得长度。 同时，直接给Array的length赋一个新的值会导致Array大小的变化。 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array。 如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化。 123var arr = [1, 2, 3];arr[5] = &apos;x&apos;;arr; // arr变为[1, 2, 3, undefined, undefined, &apos;x&apos;] indexOfArray也可以通过indexOf()来搜索一个指定的元素的位置。 12345var arr = [10, 20, &apos;30&apos;, &apos;xyz&apos;];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf(&apos;30&apos;); // 元素&apos;30&apos;的索引为2 sliceslice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array。 123var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]arr.slice(3); // 从索引3开始到结束: [&apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;] 注意到slice()的起止参数包括开始索引，不包括结束索引。 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。 1234var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];var aCopy = arr.slice();aCopy; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]aCopy === arr; // false push和poppush()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉。 unshift和shift如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉。 sort按照默认顺序进行排序，也可以自定义顺序。 reverse翻转整个Array，把元素顺序翻转过来。 splice从指定的索引开始删除若干元素，然后再从该位置添加若干元素。 12345678910var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]// 只删除,不添加:arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]// 只添加,不删除:arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;] concat把当前的Array和另一个Array连接起来，并返回一个新的Array。 值得注意的是，concat()方法并没有修改当前Array，而是返回了一个新的Array。 join把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。如果Array的元素不是字符串，将自动转换为字符串后再连接。 多维数组如果数组的某个元素又是一个Array，则可以形成多维数组。 1var arr = [[1, 2, 3], [400, 500, 600], &apos;-&apos;]; 对象JS的对象是一种无序的集合数据类型，它由若干键值对组成。 JS用一个{…}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,。 访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用’’括起来。 JavaScript规定，访问不存在的属性不报错，而是返回undefined。 由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性。 1234567891011var thbelief = &#123; name: &apos;thbelief&apos;&#125;;xiaoming.age; // undefinedxiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming[&apos;name&apos;]; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 果我们要检测thbelief是否拥有某一属性，可以用in操作符。 1&apos;name&apos; in thbelief; // true 另外，如果in判断一个属性存在，这个属性不一定是thbelief的，它可能是thbelief继承得到的。 要判断一个属性是否是thbelief自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法： 12345var thbelief = &#123; name: &apos;thbelief&apos;&#125;;thbelief.hasOwnProperty(&apos;name&apos;); // truethbelief.hasOwnProperty(&apos;toString&apos;); // false 条件判断JavaScript可以使用if () { … } else { … }来进行条件判断。 同时，也可以像C++中一样进行多重的嵌套。 循环熟悉的是单独的For循环，但是还包括了其他的不熟悉的循环方式。 for…in它可以把一个对象的所有属性依次循环出来。 12345678var o = &#123; name: &apos;thbelief&apos;, age: 20, city: &apos;mianyang&apos;&#125;;for (var key in o) &#123; console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;&#125; 要过滤掉对象继承的属性，用hasOwnProperty()来实现。（前文对象中曾经提到） 值得注意的是，for … in对Array的循环得到的是String而不是Number。 while与C++中类似。 do while与C++中类似。 Map和SetMap是一组键值对的结构，具有极快的查找速度。 12var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);m.get(&apos;Michael&apos;); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法： 1234567var m = new Map(); // 空Mapm.set(&apos;Adam&apos;, 67); // 添加新的key-valuem.set(&apos;Bob&apos;, 59);m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: truem.get(&apos;Adam&apos;); // 67m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;m.get(&apos;Adam&apos;); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： 1234var m = new Map();m.set(&apos;Adam&apos;, 67);m.set(&apos;Adam&apos;, 88);m.get(&apos;Adam&apos;); // 88 Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果。 同样的，通过delete(key)方法可以删除元素。 iterable具有iterable类型的集合可以通过新的for … of循环来遍历。 123456789101112var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + &apos;=&apos; + x[1]);&#125; for … in循环遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。如果手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果： 12345var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.name = &apos;Hello&apos;;for (var x in a) &#123; console.log(x); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;name&apos;&#125; for … in循环将把name包括在内，但Array的length属性却不包括在内。 for … of循环则完全修复了这些问题，它只循环集合本身的元素： 12345var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.name = &apos;Hello&apos;;for (var x of a) &#123; console.log(x); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;&#125; 参考链接]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java番外-多线程编程]]></title>
    <url>%2F2019%2F03%2F09%2Fjava%E7%95%AA%E5%A4%96-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[目录： 1.线程与进程的异同： 2.线程的生命周期： 新建状态： 就绪状态： 运行状态： 阻塞状态： 死亡状态： 3.线程的优先级： 4.创建线程的三种方式： 通过Runnable接口创建线程： 通过集成Thread类来创建线程： 通过Callable和Future创建线程： 三种方式的对比： 线程的几个重要的概念： 1.线程与进程的异同：线程：一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 进程：一个进程包括了由操作系统分配的内存空间，包含了一个或者多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。 2.线程的生命周期： 相关解释： 新建状态：使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态：当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态：如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态：如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态：一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 3.线程的优先级：每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 4.创建线程的三种方式： 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 通过Runnable接口创建线程：实现Runnable是一个类只需要执行一个方法来调用run（）即可。 1public void run（） 该方法可以重写，要理解的是run（）可以调用其他方法，使用其他的类，并且声明变量，就像主线程一样。 在创建一个实现Runnable接口的类之后，可以在类中实例化一个线程对象。 Thread中定义了几个构造方法，例如： 1Thread(Runnable threadOb,String threadName); 这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。 新线程创建之后，你调用它的 start() 方法它才会运行。 1void start（）； 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142class RunnableDemo implements Runnable &#123; private Thread t; private String threadName; RunnableDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;); R1.start(); RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;); R2.start(); &#125; &#125; 运行结果： 12345678910111213141516Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 4Running Thread-2Thread: Thread-2, 4Thread: Thread-1, 3Thread: Thread-2, 3Thread: Thread-1, 2Thread: Thread-2, 2Thread: Thread-1, 1Thread: Thread-2, 1Thread Thread-1 exiting.Thread Thread-2 exiting. 通过集成Thread类来创建线程：该方法是创建一个新的类然后让这个类继承自Thread类，然后创建一个该类的实例即可。 继承类的时候必须重写run（）方法，该方法是新线程的入口点，它也必须调用start方法才可以执行。本质上也是实现了Runnable接口的一个实例。 123456789101112131415161718192021222324252627282930313233343536373839404142class ThreadDemo extends Thread &#123; private Thread t; private String threadName; ThreadDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;); T1.start(); ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;); T2.start(); &#125; &#125; 运行结果： 12345678910111213141516Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 4Running Thread-2Thread: Thread-2, 4Thread: Thread-1, 3Thread: Thread-2, 3Thread: Thread-1, 2Thread: Thread-2, 2Thread: Thread-1, 1Thread: Thread-2, 1Thread Thread-1 exiting.Thread Thread-2 exiting. 下表列出了Thread类的一些重要方法： 序号 方法描述 1 public void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 2 public void run() 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 3 public final void setName(String name) 改变线程名称，使之与参数 name 相同。 4 public final void setPriority(int priority) 更改线程的优先级。 5 public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程。 6 public final void join(long millisec) 等待该线程终止的时间最长为 millis 毫秒。 7 public void interrupt() 中断线程。 8 public final boolean isAlive() 测试线程是否处于活动状态。 测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。 序号 方法描述 1 public static void yield() 暂停当前正在执行的线程对象，并执行其他线程。 2 public static void sleep(long millisec) 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 3 public static boolean holdsLock(Object x) 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。 4 public static Thread currentThread() 返回对当前正在执行的线程对象的引用。 5 public static void dumpStack() 将当前线程的堆栈跟踪打印至标准错误流。 实例： 如下的ThreadClassDemo 程序演示了Thread类的一些方法： 123456789101112131415// 文件名 : DisplayMessage.java// 通过实现 Runnable 接口创建线程public class DisplayMessage implements Runnable &#123; private String message; public DisplayMessage(String message) &#123; this.message = message; &#125; public void run() &#123; while(true) &#123; System.out.println(message); &#125; &#125;&#125; 1234567891011121314151617181920// 文件名 : GuessANumber.java// 通过继承 Thread 类创建线程 public class GuessANumber extends Thread &#123; private int number; public GuessANumber(int number) &#123; this.number = number; &#125; public void run() &#123; int counter = 0; int guess = 0; do &#123; guess = (int) (Math.random() * 100 + 1); System.out.println(this.getName() + &quot; guesses &quot; + guess); counter++; &#125; while(guess != number); System.out.println(&quot;** Correct!&quot; + this.getName() + &quot;in&quot; + counter + &quot;guesses.**&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233// 文件名 : ThreadClassDemo.javapublic class ThreadClassDemo &#123; public static void main(String [] args) &#123; Runnable hello = new DisplayMessage(&quot;Hello&quot;); Thread thread1 = new Thread(hello); thread1.setDaemon(true); thread1.setName(&quot;hello&quot;); System.out.println(&quot;Starting hello thread...&quot;); thread1.start(); Runnable bye = new DisplayMessage(&quot;Goodbye&quot;); Thread thread2 = new Thread(bye); thread2.setPriority(Thread.MIN_PRIORITY); thread2.setDaemon(true); System.out.println(&quot;Starting goodbye thread...&quot;); thread2.start(); System.out.println(&quot;Starting thread3...&quot;); Thread thread3 = new GuessANumber(27); thread3.start(); try &#123; thread3.join(); &#125;catch(InterruptedException e) &#123; System.out.println(&quot;Thread interrupted.&quot;); &#125; System.out.println(&quot;Starting thread4...&quot;); Thread thread4 = new GuessANumber(75); thread4.start(); System.out.println(&quot;main() is ending...&quot;); &#125;&#125; 运行结果： 1234567891011121314Starting hello thread...Starting goodbye thread...HelloHelloHelloHelloHelloHelloGoodbyeGoodbyeGoodbyeGoodbyeGoodbye....... 通过Callable和Future创建线程： 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。 实例： 123456789101112131415161718192021222324252627282930313233343536public class CallableThreadTest implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for(int i = 0;i &lt; 100;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i); if(i==20) &#123; new Thread(ft,&quot;有返回值的线程&quot;).start(); &#125; &#125; try &#123; System.out.println(&quot;子线程的返回值：&quot;+ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i = 0; for(;i&lt;100;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125; return i; &#125; &#125; 三种方式的对比： 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。 线程的几个重要的概念：1）线程同步。 2）线程间通信。 3）线程死锁。 4）线程控制，包括挂起停止与恢复。]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>番外</tag>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-融会贯通]]></title>
    <url>%2F2019%2F03%2F07%2Fjava%E5%9F%BA%E7%A1%80-%E8%9E%8D%E4%BC%9A%E8%B4%AF%E9%80%9A%2F</url>
    <content type="text"><![CDATA[目录： 1.继承： 1）概念： 2）格式： 3）类型： 4）特性： 5）关键字： extends关键字： implements关键字： super与this关键字： final关键字： 注意： 2.重写与重载： 1）重写： 概念： Super关键字的使用： 2）重载： 规则： 3）重载与重写的区别： 4）总结： 3.多态： 1）概念： 2）表现： 3）优点： 4）执行条件： 5）虚函数： 6）实现方式： 4.抽象类： 1）概念： 2）实例： 3）继承抽象类： 4）抽象方法： 5）总结： 5.封装： 1）概念： 2）优点： 3）实现步骤： 4）实例： 6.接口： 1）概念： 2）接口与类的相似点： 3）接口与类的区别： 4）接口特性： 5）抽象类与接口的区别： 6）接口的声明： 7）接口的实现： 8）接口的继承： 9）接口的多继承： 10）标记接口： 7.包： 1）作用： 2）创建包： 3）import关键字： 4）package目录结构： 5）设置CLASSPATH系统变量： 1.继承：1）概念：继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 2）格式：12345class 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; 3）类型：注意：java不支持多继承，但是支持多重继承。 4）特性：子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 5）关键字：注意：继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 extends关键字：在java中，类的继承是单一的继承，也就是说，一个类只能拥有一个父类，所以extends只能继承一个类。 123456789101112public class Animal &#123; private String name; private int id; public Animal(String myName, String myid) &#123; //初始化属性值 &#125; public void eat() &#123; //吃的方法的具体实现 &#125; public void sleep() &#123; //睡觉的方法的具体实现 &#125; &#125; public class Penguin extends Animal&#123; &#125; implements关键字：使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 1234567891011public interface A &#123; public void eat(); public void sleep();&#125; public interface B &#123; public void show();&#125; public class C implements A,B &#123;&#125; super与this关键字：super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用。 123456789101112131415161718192021222324class Animal &#123; void eat() &#123; System.out.println(&quot;animal : eat&quot;); &#125;&#125; class Dog extends Animal &#123; void eat() &#123; System.out.println(&quot;dog : eat&quot;); &#125; void eatTest() &#123; this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); &#125;&#125; final关键字：final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。 注:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final 123456声明类：final class 类名 &#123;//类体&#125;声明方法：修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;//方法体&#125; 注意：子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。 2.重写与重载：1）重写：概念：重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。其实就是外形不变，核心重写的意思。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 12345678910111213141516171819202122class Animal&#123; public void move()&#123; System.out.println(&quot;动物可以移动&quot;); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println(&quot;狗可以跑和走&quot;); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 &#125;&#125; 结果： 12动物可以移动狗可以跑和走 Super关键字的使用：当需要在子类中调用父类的被重写方法的时候，就必须使用super关键字。 123456789101112131415161718192021class Animal&#123; public void move()&#123; System.out.println(&quot;动物可以移动&quot;); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; super.move(); // 应用super类的方法 System.out.println(&quot;狗可以跑和走&quot;); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal b = new Dog(); // Dog 对象 b.move(); //执行 Dog类的方法 &#125;&#125; 结果： 12动物可以移动狗可以跑和走 2）重载：重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 规则：被重载的方法必须改变参数列表（参数的个数或者类型不一样）。 被重载的方法可以改变返回类型。 被重载的方法可以改变访问修饰符。 被重载的方法可以声明新的或者更广的检查异常。 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 1234567891011121314151617181920212223242526272829public class Overloading &#123; public int test()&#123; System.out.println(&quot;test1&quot;); return 1; &#125; public void test(int a)&#123; System.out.println(&quot;test2&quot;); &#125; //以下两个参数类型顺序不同 public String test(int a,String s)&#123; System.out.println(&quot;test3&quot;); return &quot;returntest3&quot;; &#125; public String test(String s,int a)&#123; System.out.println(&quot;test4&quot;); return &quot;returntest4&quot;; &#125; public static void main(String[] args)&#123; Overloading o = new Overloading(); System.out.println(o.test()); o.test(1); System.out.println(o.test(1,&quot;test3&quot;)); System.out.println(o.test(&quot;test4&quot;,1)); &#125;&#125; 3）重载与重写的区别： 4）总结：方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 (3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 3.多态：1）概念：多态就是同一个行为具有多个不同表现形式或者形态的能力。 （同一个接口，使用不同的实例而执行不同的操作） 2）表现：1234567现实中，比如我们按下 F1 键这个动作：如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 3）优点： 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 4）执行条件： 继承 重写 父类引用指向子类对象 例如： 1Parent p = new Child(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat Cat c = (Cat)a; // 向下转型 c.work(); // 调用的是 Cat 的 work &#125; public static void show(Animal a) &#123; a.eat(); // 类型判断 if (a instanceof Cat) &#123; // 猫做的事 Cat c = (Cat)a; c.work(); &#125; else if (a instanceof Dog) &#123; // 狗做的事 Dog c = (Dog)a; c.work(); &#125; &#125; &#125; abstract class Animal &#123; abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void work() &#123; System.out.println(&quot;抓老鼠&quot;); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; public void work() &#123; System.out.println(&quot;看家&quot;); &#125; &#125; 结果： 123456吃鱼抓老鼠吃骨头看家吃鱼抓老鼠 5）虚函数：虚函数的存在是为了多态。 Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。 6）实现方式：三种方式，包括：重写，接口，抽象类和抽象方法。 4.抽象类：1）概念：在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 2）实例：在java中使用abstract class来定义抽象类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 文件名 : Employee.java */public abstract class Employee&#123; private String name; private String address; private int number; public Employee(String name, String address, int number) &#123; System.out.println(&quot;Constructing an Employee&quot;); this.name = name; this.address = address; this.number = number; &#125; public double computePay() &#123; System.out.println(&quot;Inside Employee computePay&quot;); return 0.0; &#125; public void mailCheck() &#123; System.out.println(&quot;Mailing a check to &quot; + this.name + &quot; &quot; + this.address); &#125; public String toString() &#123; return name + &quot; &quot; + address + &quot; &quot; + number; &#125; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String newAddress) &#123; address = newAddress; &#125; public int getNumber() &#123; return number; &#125;&#125; 如果尝试以下例子： 123456789101112/* 文件名 : AbstractDemo.java */public class AbstractDemo&#123; public static void main(String [] args) &#123; /* 以下是不允许的，会引发错误 */ Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); &#125;&#125; 编译时会显示以下的错误： 1234Employee.java:46: Employee is abstract; cannot be instantiated Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); ^1 error 3）继承抽象类：可以通过一般的方法直接继承Employee类： 123456789101112131415161718192021222324252627282930313233/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; //Annual salary public Salary(String name, String address, int number, double salary) &#123; super(name, address, number); setSalary(salary); &#125; public void mailCheck() &#123; System.out.println(&quot;Within mailCheck of Salary class &quot;); System.out.println(&quot;Mailing check to &quot; + getName() + &quot; with salary &quot; + salary); &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double newSalary) &#123; if(newSalary &gt;= 0.0) &#123; salary = newSalary; &#125; &#125; public double computePay() &#123; System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; &#125;&#125; 尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。 123456789101112131415/* 文件名 : AbstractDemo.java */public class AbstractDemo&#123; public static void main(String [] args) &#123; Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00); Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00); System.out.println(&quot;Call mailCheck using Salary reference --&quot;); s.mailCheck(); System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); &#125;&#125; 运行结果如下： 123456789Constructing an EmployeeConstructing an EmployeeCall mailCheck using Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400. 4）抽象方法：如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。 Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。 抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。 12345678910public abstract class Employee&#123; private String name; private String address; private int number; public abstract double computePay(); //...&#125; 声明抽象方法会造成以下两个结果： 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 如果Salary类继承了Employee类，那么它必须实现computePay()方法： 12345678910111213/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; // Annual salary public double computePay() &#123; System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; &#125; //...&#125; 5）总结： 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 5.封装：1）概念：封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 2）优点： 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 3）实现步骤：修改属性的可见性来限制属性的访问（一般限制为private），例如： 1234public class Person &#123; private String name; private int age;&#125; 这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如： 1234567891011121314151617181920public class Person&#123; private String name; private int age;​ public int getAge()&#123; return age; &#125;​ public String getName()&#123; return name; &#125;​ public void setAge(int age)&#123; this.age = age; &#125;​ public void setName(String name)&#123; this.name = name; &#125;&#125; 之所以采用this关键字是为了解决实例变量和局部变量之间发生的同名冲突。 4）实例：12345678910111213141516171819202122232425262728293031/* 文件名: EncapTest.java */public class EncapTest&#123; private String name; private String idNum; private int age; public int getAge()&#123; return age; &#125; public String getName()&#123; return name; &#125; public String getIdNum()&#123; return idNum; &#125; public void setAge( int newAge)&#123; age = newAge; &#125; public void setName(String newName)&#123; name = newName; &#125; public void setIdNum( String newId)&#123; idNum = newId; &#125;&#125; 以上实例中public方法是外部类访问该类成员变量的入口。 通常情况下，这些方法被称为getter和setter方法。 因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。 通过如下的例子说明EncapTest类的变量怎样被访问： 123456789101112/* F文件名 : RunEncap.java */public class RunEncap&#123; public static void main(String args[])&#123; EncapTest encap = new EncapTest(); encap.setName(&quot;James&quot;); encap.setAge(20); encap.setIdNum(&quot;12343ms&quot;); System.out.print(&quot;Name : &quot; + encap.getName()+ &quot; Age : &quot;+ encap.getAge()); &#125;&#125; 运行结果： 1Name : James Age : 20 6.接口：1）概念：接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 2）接口与类的相似点： 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 3）接口与类的区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 4）接口特性： 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 5）抽象类与接口的区别： 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 6）接口的声明：1234[可见度] interface 接口名称 [extends 其他的接口名名] &#123; // 声明变量 // 抽象方法&#125; interface关键字用来声明一个接口。 123456789/* 文件名 : NameOfInterface.java */import java.lang.*;//引入包 public interface NameOfInterface&#123; //任何类型 final, static 字段 //抽象方法&#125; 接口有如下特性： 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。 接口中的方法都是公有的。 实例： 12345/* 文件名 : Animal.java */interface Animal &#123; public void eat(); public void travel();&#125; 7）接口的实现：当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。 类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 实现一个接口的语法，可以使用这个公式： 1...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ... 实例： 123456789101112131415161718192021/* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(&quot;Mammal eats&quot;); &#125; public void travel()&#123; System.out.println(&quot;Mammal travels&quot;); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 运行结果： 12Mammal eatsMammal travels 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 8）接口的继承：一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 下面的Sports接口被Hockey和Football接口继承： 1234567891011121314151617181920212223// 文件名: Sports.javapublic interface Sports&#123; public void setHomeTeam(String name); public void setVisitingTeam(String name);&#125; // 文件名: Football.javapublic interface Football extends Sports&#123; public void homeTeamScored(int points); public void visitingTeamScored(int points); public void endOfQuarter(int quarter);&#125; // 文件名: Hockey.javapublic interface Hockey extends Sports&#123; public void homeGoalScored(); public void visitingGoalScored(); public void endOfPeriod(int period); public void overtimePeriod(int ot);&#125; Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。 相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。 9）接口的多继承：在Java中，类的多继承是不合法，但接口允许多继承。 在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示： 1public interface Hockey extends Sports, Event 以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法。 10）标记接口：最常用的继承接口是没有包含任何方法的接口。 标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。 标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。 例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下： 123package java.util;public interface EventListener&#123;&#125; 没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的： 建立一个公共的父接口： 正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。 向一个类添加数据类型： 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。 7.包：为了更好的组织类，包就产生了，主要是用来区别类名的命名空间。 1）作用： 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 包语句的语法格式为： 1package pkg1[．pkg2[．pkg3…]]; 例如,一个Something.java 文件它的内容： 1234package net.java.util;public class Something&#123; ...&#125; 那么它的路径应该是 net/java/util/Something.java 这样保存的。 package(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。 一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。 以下是一些 Java 中的包： java.lang-打包基础的类 java.io-包含输入输出功能的函数 开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。 由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。 2）创建包：创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。 例子： 让我们来看一个例子，这个例子创建了一个叫做animals的包。通常使用小写的字母来命名避免与类、接口名字的冲突。 在 animals 包中加入一个接口（interface）： 1234567/* 文件名: Animal.java */package animals; interface Animal &#123; public void eat(); public void travel();&#125; 接下来，在同一个包中加入该接口的实现： 1234567891011121314151617181920212223package animals; /* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(&quot;Mammal eats&quot;); &#125; public void travel()&#123; System.out.println(&quot;Mammal travels&quot;); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 然后，编译这两个文件，并把他们放在一个叫做animals的子目录中。 用下面的命令来运行： 12345$ mkdir animals$ cp Animal.class MammalInt.class animals$ java animals/MammalIntMammal eatsMammal travel 3）import关键字：为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为： 1import package1[.package2…].(classname|*); 如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 例子： 下面的 payroll 包已经包含了 Employee 类，接下来向 payroll 包中添加一个 Boss 类。Boss 类引用 Employee 类的时候可以不用使用 payroll 前缀，Boss类的实例如下。 123456789package payroll; public class Boss&#123; public void payEmployee(Employee e) &#123; e.mailCheck(); &#125;&#125; 如果 Boss 类不在 payroll 包中又会怎样？Boss 类必须使用下面几种方法之一来引用其他包中的类。 使用类全名描述，例如： 1payroll.Employee 用 import 关键字引入，使用通配符 “*”： 1import payroll.*; 使用 import 关键字引入 Employee 类: 1import payroll.Employee; 注意： 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 4）package目录结构：类放在包中会有两种主要的结果： 包名成为类名的一部分，正如我们前面讨论的一样。 包名必须与相应的字节码所在的目录结构相吻合。 下面是管理你自己 java 中文件的一种简单方式： 将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如： 1234567// 文件名 : Car.java package vehicle; public class Car &#123; // 类实现 &#125; 接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。 1....\vehicle\Car.java 现在，正确的类名和路径将会是如下样子： 类名 -&gt; vehicle.Car 路径名 -&gt; vehicle\Car.java (在 windows 系统中) 通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。 例如：有一个 com.runoob.test 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录： 1....\com\runoob\test\Runoob.java 编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如： 123456789// 文件名: Runoob.java package com.runoob.test;public class Runoob &#123; &#125;class Google &#123; &#125; 现在，我们用-d选项来编译这个文件，如下： 1$javac -d . Runoob.java 这样会像下面这样放置编译了的文件： 12.\com\runoob\test\Runoob.class.\com\runoob\test\Google.class 你可以像下面这样来导入所有 \com\runoob\test\ 中定义的类、接口等： 1import com.runoob.test.*; 编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。 12&lt;path-one&gt;\sources\com\runoob\test\Runoob.java&lt;path-two&gt;\classes\com\runoob\test\Google.class 这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。 类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。 一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。 5）设置CLASSPATH系统变量：用下面的命令显示当前的CLASSPATH变量： Windows 平台（DOS 命令行下）：C:> set CLASSPATH UNIX 平台（Bourne shell 下）：# echo $CLASSPATH 删除当前CLASSPATH变量内容： Windows 平台（DOS 命令行下）：C:> set CLASSPATH= UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH 设置CLASSPATH变量: Windows 平台（DOS 命令行下）： C:> set CLASSPATH=C:\users\jack\java\classes UNIX 平台（Bourne shell 下）：# CLASSPATH=/home/jack/java/classes; export CLASSPATH]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>融会贯通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中STL用法]]></title>
    <url>%2F2019%2F03%2F04%2FC-%E4%B8%ADSTL%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录： 1.1STL的含义： 1.2STL六大组件： 1.3容器： 1.4STL迭代器： 1.5算法： &lt;一&gt;查找算法(13个)：判断容器中是否包含某个值 &lt;二&gt;排序和通用算法(14个)：提供元素排序策略 &lt;三&gt;删除和替换算法(15个) &lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合 &lt;五&gt;算术算法(4个) &lt;六&gt;生成和异变算法(6个) &lt;七&gt;关系算法(8个) &lt;八&gt;集合算法(4个) &lt;九&gt;堆算法(4个) 1.1STL的含义：STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。 STL的一个重要的特点就是数据结构和算法的分离。例如：由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组。 STL另外的一个特点就是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。 1.2STL六大组件：1）容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器； 2）迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象； 3）算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用； 4）仿函数（Function object） 5）迭代适配器（Adaptor） 6）空间配制器（allocator） 1.3容器：STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。 （1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；Vectors：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；Deques：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；Lists：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针； （2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap；Sets/Multisets：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；Maps/Multimaps：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找； 容器类自动申请和释放内存，无需new和delete操作。vector基于模板实现，需包含头文件vector。 12345678910111213141516171819202122232425262728293031//1.定义和初始化 vector&lt;int&gt; vec1; //默认初始化，vec1为空 vector&lt;int&gt; vec2(vec1); //使用vec1初始化vec2 vector&lt;int&gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2 vector&lt;int&gt; vec4(10); //10个值为的元素 vector&lt;int&gt; vec5(10,4); //10个值为的元素//2.常用操作方法 vec1.push_back(100); //添加元素 int size = vec1.size(); //元素个数 bool isEmpty = vec1.empty(); //判断是否为空 cout&lt;&lt;vec1[0]&lt;&lt;endl; //取得第一个元素 vec1.insert(vec1.end(),5,3); //从vec1.back位置插入个值为的元素 vec1.pop_back(); //删除末尾元素 vec1.erase(vec1.begin(),vec1.end());//删除之间的元素，其他元素前移 cout&lt;&lt;(vec1==vec2)?true:false; //判断是否相等==、！=、&gt;=、&lt;=... vector&lt;int&gt;::iterator iter = vec1.begin(); //获取迭代器首地址 vec1.clear(); //清空元素//3.遍历 //下标法 int length = vec1.size(); for(int i=0;i&lt;length;i++) &#123; cout&lt;&lt;vec1[i]; &#125; cout&lt;&lt;endl&lt;&lt;endl; //迭代器法 vector&lt;int&gt;::const_iterator iterator = vec1.begin(); for(;iterator != vec1.end();iterator++) &#123; cout&lt;&lt;*iterator; &#125; 1.4STL迭代器：Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator,实例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; v.push_back(3); //数组尾部插入3 v.push_back(2); v.push_back(1); v.push_back(0); cout &lt;&lt; &quot; 下标 &quot; &lt;&lt; v[3] &lt;&lt; endl; cout &lt;&lt; &quot; 迭代器 &quot; &lt;&lt; endl; for(vector&lt;int&gt;::iterator i = v.begin();i!= v.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //在第一个元素之前插入111 insert begin+n是在第n个元素之前插入 v.insert(v.begin(),111); //在最后一个元素之后插入222 insert end + n 是在n个元素之后插入 v.insert(v.end(),222); for(vector&lt;int&gt;::iterator i = v.begin();i!= v.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; vector&lt;int&gt; arr(10); for(int i = 0; i &lt; 10; i++) &#123; arr[i] = i; &#125; for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //删除 同insert arr.erase(arr.begin()); for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl ; arr.erase(arr.begin(),arr.begin()+5); for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl ; return 0 ; &#125; 数组转置： reverse(v.begin(),v.end()) 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; for(int i = 0; i &lt; 10; ++i) &#123; v.push_back(i); &#125; for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; reverse(v.begin(),v.end()); for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 1.5算法：算法部分主要由头文件algorithm，numeric和functional组成。 algorithm是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。 numeric体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。 functional中则定义了一些模板类，用以声明函数对象。STL中算法大致分为四类： 1）非可变序列算法：指不直接修改其所操作的容器内容的算法。 2）可变序列算法：指可以修改它们所操作的容器内容的算法。 3）排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。 4）数值算法：对容器内容进行数值计算。 &lt;一&gt;查找算法(13个)：判断容器中是否包含某个值adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。 binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。 count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。 count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。 equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示 upper_bound。 find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。 find_end: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代替等于操作。 find_first_of: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。 find_if: 使用输入的函数代替等于操作符执行find。 lower_bound: 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。 upper_bound: 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。 search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。 search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。 &lt;二&gt;排序和通用算法(14个)：提供元素排序策略inplace_merge: 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。 merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。 nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。 partial_sort: 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。 partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。 partition: 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。 random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。 reverse: 将指定范围内元素重新反序排序。 reverse_copy: 与reverse类似，不过将结果写入另一个容器。 rotate: 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。 rotate_copy: 与rotate类似，不过将结果写入另一个容器。 sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。 stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。 stable_partition: 与partition类似，不过不保证保留容器中的相对顺序。 &lt;三&gt;删除和替换算法(15个)copy: 复制序列 copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。 iter_swap: 交换两个ForwardIterator的值。 remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。 remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。 remove_if: 删除指定范围内输入操作结果为true的所有元素。 remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。 replace: 将指定范围内所有等于vold的元素都用vnew代替。 replace_copy: 与replace类似，不过将结果写入另一个容器。 replace_if: 将指定范围内所有操作结果为true的元素用新值代替。 replace_copy_if: 与replace_if，不过将结果写入另一个容器。 swap: 交换存储在两个对象中的值。 swap_range: 将指定范围内的元素与另一个序列元素值进行交换。 unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。 unique_copy: 与unique类似，不过把结果输出到另一个容器。 &lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。 prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。 &lt;五&gt;算术算法(4个)accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。 partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。 inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。 adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。 &lt;六&gt;生成和异变算法(6个)fill: 将输入值赋给标志范围内的所有元素。 fill_n: 将输入值赋给first到first+n范围内的所有元素。 for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。 generate: 连续调用输入的函数来填充指定的范围。 generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。 transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。 &lt;七&gt;关系算法(8个)equal: 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。 includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。 lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。 max: 返回两个元素中较大一个。重载版本使用自定义比较操作。 max_element: 返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。 min: 返回两个元素中较小一个。重载版本使用自定义比较操作。 min_element: 返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。 mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。 &lt;八&gt;集合算法(4个)set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。 set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。 set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。 set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。 &lt;九&gt;堆算法(4个)make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。 pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。 push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。 sort_heap: 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。 ……]]></content>
      <categories>
        <category>后端</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>用法</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础 初窥门径]]></title>
    <url>%2F2019%2F02%2F27%2FJava%E5%9F%BA%E7%A1%80-%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%2F</url>
    <content type="text"><![CDATA[目录： 1.Java的基本数据类型： 对应的包装类： 基本数据类型的默认值： 2.Java分支循环： 分支语句： if语句： switch语句： 三目运算符： 转义符： 循环语句： for循环： while语句： 3.String、StringBuffer、StringBuilder： 区别： String对象： String本质： 常量池： 实例： StringBuffer字符串变量（线程安全）是一个容器，最终会通过toString方法变成字符串： StringBuilder 字符串变量（非线程安全）： String与StringBuffer区别： 在修改的时候对象自身是否改变： 是否可变测试： 初始化区别： StringBuffer对象和String对象之间的互转: 偏重： 总结： StringBuffer与StringBuilder区别： 4.正则表达式： 1.1正则表达式的含义： 1.2具体实例： 1.3常见的匹配符号： 1.4元字符： 1.5限定符： 1.6分组和反向引用： 1.7仅分组却无反向引用： 1.8分组的反向引用副本： 1.9否定先行断言： 1.10指定正则表达式的模式： 1.11java中的反斜杠： 1.12易错： 1.13内置的字符串正则处理方法： 1.14：模式和匹配： 1.15：几个常用的例子： 1）中文的匹配： 2）数字范围的匹配： 3）img标签的匹配： 4）贪婪与非贪婪模式的匹配： 1.16：在线正则工具： 1.Java的基本数据类型：1234567整型 byte（字节型） short（短整型） int long（长整型）浮点型 float（单精度浮点型） double（双精度浮点型）逻辑型 boolean(它只有两个值可取 true false)字符型 char 对应的包装类：java.lang.Byte、java.lang.Short、java.lang.Integer、java.lang.Long、java.lang.Float、java.lang.Double、java.lang.Boolean、java.lang.Character. 基本数据类型的默认值： 2.Java分支循环：分支语句：123顺序语句分支语句循环语句 if语句：123456789if(boolean类型表达式)&#123; 语句1&#125;else&#123; 语句2&#125; switch语句：1234567891011121314151617181920switch(变量)&#123; case常量1:语句1;break; case常量2:语句2;break; case常量3: 语句3; break; default: 语句0; break;&#125;注：default可以忽略掉~ 三目运算符：123表达式1?表达式2:表达式3表达式1是布尔类型的，右边的问号表示判断它是true还是false，如果是true，整个表达式返回表达式2，如果是false整个表达式返回表达式3 转义符：12345678910111213回车(return) &apos;\r&apos; 13换行(nextLine) &apos;\n&apos; 10(在windows中执行换行动作用\r\n；在linux中执行换行动作用\n)制表(tab) &apos;\t&apos; (可以用来对齐打印的文字)双引号 &apos;\&quot;&apos; (反斜杠+双引号表示双引号字符)单引号 &apos;\&apos;&apos; (反斜杠+单引号表示单引号字符)反斜杠 &apos;\\&apos; (两个反斜杠表示一个反斜杠) 循环语句：for循环：1234567891011for(表达式1;表达式2;表达式3)&#123; 语句&#125;表达式1 在循环开始前执行一次，一般用于初始化表达式2 循环条件，一般为boolean类型，为true则循环继续，为false则循环终止(不写则表示一直为true)表达式3 每次循环在语句执行完后执行，一般用于对循环条件进行变更 while语句：12345678910111213141516171819while(条件)&#123; 语句&#125;当条件为true时，不停地执行语句do...while语句do&#123; 语句&#125;while(条件);和while逻辑一样，但是会先执行语句，再判断。do...while在任何情况下至少执行一次语句。 3.String、StringBuffer、StringBuilder：区别：123String对象是常量，它的值不能被创建后改变，StringBuffer和StringBuilder可以可变；StringBuilder非线程安全（单线程使用），String与StringBuffer线程安全（多线程使用）；如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。 String对象：String本质：String是值不可变的常量，是线程安全的。 String类使用了final修饰符，String类是不可继承的。 常量池：常量池是一个内存空间，不同于使用new关键字创建的对象所在的堆空间。 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复创建相等变量时节省了很多时间。 在编译期被确定，并被保存在已编译的.class文件中的一些数据，包括类、方法、接口等中的常量和字符串常量。常量池还具备动态性，运行期间可以将新的常量放入池中。java中基本类型的包装类的大部分都实现了常量池技术， 即Byte,Short,Integer,Long,Character,Boolean； 实例：12String s1 = new String(&quot;s1&quot;) ; String s2 = new String(&quot;s1&quot;) ; 1234// 3个，编译期在常量池中创建1个，即“s1”常量对象；运行期堆中创建2个，即s1和s2对象。String s1 = &quot;s1&quot;; String s2 = s1; s2 = &quot;s2&quot;; StringBuffer字符串变量（线程安全）是一个容器，最终会通过toString方法变成字符串：12345678910111213141516public final class StringBuffer extends AbstractStringBuilder implements Serializable, Appendable, CharSequence &#123; /** * Constructs a string buffer with no characters in it and an initial capacity of 16 characters. */ public StringBuffer() &#123; super(16); &#125; public synchronized StringBuffer append(int i) &#123; super.append(i); return this; &#125; public synchronized StringBuffer delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; StringBuilder 字符串变量（非线程安全）：12345678910111213public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, Appendable, CharSequence &#123; public StringBuilder() &#123; super(16); &#125; public StringBuilder append(String str) &#123; super.append(str); return this; &#125; public StringBuilder delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; String与StringBuffer区别：在修改的时候对象自身是否改变：（1） String在修改时不会改变对象自身 在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String 。 12String str = &quot;abc&quot;;//地址str1str = &quot;def&quot;;//地址str2 （2） StringBuffer在修改时会改变对象自身 每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。StringBuffer 上的主要操作是 append 和 insert 方法。 12StringBuffer strBuffer = new StringBuffer(&quot;abc&quot;);//地址strBuffer,值是abcstrBuffer.append(&quot;def&quot;);//地址strBuffer,值是abcdef 是否可变测试：String的地址已改变，对象已经改变为另一个；StringBuffer地址不变，还是同样的对象。 初始化区别：123String：StringBuffer s = null; StringBuffer s = “abc”; 1234StringBuffer：StringBuffer s = null; //结果警告：Null pointer access: The variable result can only be null at this locationStringBuffer s = new StringBuffer();//StringBuffer对象是一个空的对象StringBuffer s = new StringBuffer(“abc”);//创建带有内容的StringBuffer对象,对象的内容就是字符串”abc” StringBuffer对象和String对象之间的互转:他们属于不同的类型，不能直接进行强制类型转换。 1234String s = “abc”;StringBuffer sb1 = new StringBuffer(“123”);StringBuffer sb2 = new StringBuffer(s); //String转换为StringBufferString s1 = sb1.toString(); //StringBuffer转换为String 偏重：StringBuffer类中的方法主要偏重于对于字符串的变化，例如追加、插入和删除等，常用方法有：append方法、insert方法、deleteCharAt方法、reverse方法等。 总结：（1）如果要操作少量的数据用 String； （2）（多线程下）经常需要对一个字符串进行修改，例如追加、插入和删除等操作，使用StringBuffer要更加适合一些。 StringBuffer与StringBuilder区别：1.StringBuilder是一个可变的对象，是5.0新增的，提供一个与StringBuffer兼容的API，但不保证同步，主要是用在字符串缓冲区被单个线程使用的时候。 2.线程安全性： ​ StringBuffer：线程安全。 ​ StringBuilder：线程非安全。 3.大部分情况下：StringBuffer&gt;String 同时由于String对象不可变，重复新建对象：StringBuffer对象可变。 4.StringBuilder&gt;StringBuffer 当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的。 5.特殊情况下，String&gt;StringBuffer 123//String效率是远要比StringBuffer快的：String S1 = “This is only a” + “ simple” + “ test”;StringBuffer Sb = new StringBuilder(“This is only a”).append(“simple”).append(“ test”); 12345//String速度是非常慢的：String S2 = “This is only a”;String S3 = “ simple”;String S4 = “ test”;String S1 = S2 +S3 + S4; 6.总结： 123（1）如果要操作少量的数据用 String；（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。 参考链接 4.正则表达式：1.1正则表达式的含义：定义一个搜索模式的字符串。 正则表达式可以用于搜索、编辑和操作文本。 分析过程：首先正则表达式应用的是文本字符串（text/string），它会以定义的模式从左到右匹配文本，每个源字符只匹配一次。 1.2具体实例：123this is text 精确匹配字符串 &quot;this is text&quot;this\s+is\s+text 匹配单词 &quot;this&quot; 后跟一个或多个空格字符，后跟词 &quot;is&quot; 后跟一个或多个空格字符，后跟词 &quot;text&quot;^\d+(\.\d+)? ^ 定义模式必须匹配字符串的开始，d+ 匹配一个或多个数字，? 表明小括号内的语句是可选的，\. 匹配 &quot;.&quot;，小括号表示分组。例如匹配：&quot;5&quot;、&quot;1.5&quot; 和 &quot;2.21&quot; 1.3常见的匹配符号： 正则表达式 描述 . 匹配所有单个字符，除了换行符（Linux 中换行是 \n，Windows 中换行是 \r\n） ^regex 正则必须匹配字符串开头 regex$ 正则必须匹配字符串结尾 [abc] 复选集定义，匹配字母 a 或 b 或 c [abc][vz] 复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z [^abc] 当插入符 ^ 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c [a-d1-7] 范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间，但不匹配 d1 XZ 匹配 X 后直接跟着 Z X\ Z 匹配 X 或 Z 1.4元字符： 正则表达式 描述 \d 匹配一个数字，是 [0-9] 的简写 \D 匹配一个非数字，是 [^0-9] 的简写 \s 匹配一个空格，是 [ \t\n\x0b\r\f] 的简写 \S 匹配一个非空格 \w 匹配一个单词字符（大小写字母、数字、下划线），是 [a-zA-Z_0-9] 的简写 \W 匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 [^\w] 1.5限定符：限定符定义了一个元素可以发生的频率。 正则表达式 描述 举例 * 匹配 &gt;=0 个，是 {0,} 的简写 X* 表示匹配零个或多个字母 X，.*表示匹配任何字符串 + 匹配 &gt;=1 个，是 {1,} 的简写 X+ 表示匹配一个或多个字母 X ? 匹配 1 个或 0 个，是 {0,1} 的简写 X? 表示匹配 0 个或 1 个字母 X {X} 只匹配 X 个字符 \d{3} 表示匹配 3 个数字，.{10}表示匹配任何长度是 10 的字符串 {X,Y} 匹配 &gt;=X 且 &lt;=Y 个 \d{1,4} 表示匹配至少 1 个最多 4 个数字 *? 如果 ? 是限定符 * 或 + 或 ? 或 {} 后面的第一个字符，那么表示非贪婪模式（尽可能少的匹配字符），而不是默认的贪婪模式 1.6分组和反向引用：小括号 () 可以达到对正则表达式进行分组的效果。 模式分组后会在正则表达式中创建反向引用。反向引用会保存匹配模式分组的字符串片断，这使得我们可以获取并使用这个字符串片断。 在以正则表达式替换字符串的语法中，是通过 $ 来引用分组的反向引用，$0 是匹配完整模式的字符串（注意在 JavaScript 中是用 $&amp; 表示）；$1 是第一个分组的反向引用；$2 是第二个分组的反向引用，以此类推。 示例： 123456789101112131415package com.wuxianjiezh.demo.regex;public class RegexTest &#123; public static void main(String[] args) &#123; // 去除单词与 , 和 . 之间的空格 String Str = &quot;Hello , World .&quot;; String pattern = &quot;(\\w)(\\s+)([.,])&quot;; // $0 匹配 `(\w)(\s+)([.,])` 结果为 `o空格,` 和 `d空格.` // $1 匹配 `(\w)` 结果为 `o` 和 `d` // $2 匹配 `(\s+)` 结果为 `空格` 和 `空格` // $3 匹配 `([.,])` 结果为 `,` 和 `.` System.out.println(Str.replaceAll(pattern, &quot;$1$3&quot;)); // Hello, World. &#125;&#125; 上面的例子中，我们使用了 [.] 来匹配普通字符 . 而不需要使用 [\\.]。因为正则对于 [] 中的 .，会自动处理为 [\.]，即普通字符 . 进行匹配。 1.7仅分组却无反向引用：当我们在小括号 () 内的模式开头加入 ?:，那么表示这个模式仅分组，但不创建反向引用。 示例： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;img.jpg&quot;; // 分组且创建反向引用 Pattern pattern = Pattern.compile(&quot;(jpg|png)&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); System.out.println(matcher.group(1)); &#125; &#125;&#125; 运行结果： 12jpgjpg 若源码改为： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;img.jpg&quot;; // 分组但不创建反向引用 Pattern pattern = Pattern.compile(&quot;(?:jpg|png)&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); System.out.println(matcher.group(1)); &#125; &#125;&#125; 运行结果： 1234jpgException in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: No group 1 at java.util.regex.Matcher.group(Matcher.java:538) at com.wuxianjiezh.regex.RegexTest.main(RegexTest.java:15) 1.8分组的反向引用副本：Java 中可以在小括号中使用 ?&lt;name&gt; 将小括号中匹配的内容保存为一个名字为 name 的副本。 示例： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;@wxj 你好啊&quot;; Pattern pattern = Pattern.compile(&quot;@(?&lt;first&gt;\\w+\\s)&quot;); // 保存一个副本 Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); System.out.println(matcher.group(1)); System.out.println(matcher.group(&quot;first&quot;)); &#125; &#125;&#125; 运行结果： 123@wxj wxj wxj 1.9否定先行断言：我们可以创建否定先行断言模式的匹配，即某个字符串后面不包含另一个字符串的匹配模式。 否定先行断言模式通过 (?!pattern) 定义。比如，我们匹配后面不是跟着 “b” 的 “a”： 1a(?!b) 1.10指定正则表达式的模式：可以在正则的开头指定模式修饰符。 (?i) 使正则忽略大小写。 (?s) 表示单行模式（”single line mode”）使正则的 . 匹配所有字符，包括换行符。 (?m) 表示多行模式（”multi-line mode”），使正则的 ^ 和 $ 匹配字符串中每行的开始和结束。 1.11java中的反斜杠：反斜杠 \ 在 Java 中表示转义字符，这意味着 \ 在 Java 拥有预定义的含义。 这里例举两个特别重要的用法： 在匹配 . 或 { 或 [ 或 ( 或 ? 或 $ 或 ^ 或 * 这些特殊字符时，需要在前面加上 \\，比如匹配 . 时，Java 中要写为 \\.，但对于正则表达式来说就是 \.。 在匹配 \ 时，Java 中要写为 \\\\，但对于正则表达式来说就是 \\。 注意：Java 中的正则表达式字符串有两层含义，首先 Java 字符串转义出符合正则表达式语法的字符串，然后再由转义后的正则表达式进行模式匹配。 1.12易错： [jpg|png] 代表匹配 j 或 p 或 g 或 p 或 n 或 g 中的任意一个字符。 (jpg|png) 代表匹配 jpg 或 png。 1.13内置的字符串正则处理方法：在 Java 中有四个内置的运行正则表达式的方法，分别是 matches()、split())、replaceFirst()、replaceAll()。注意 replace() 方法不支持正则表达式。 方法 描述 s.matches(&quot;regex&quot;) 当仅且当正则匹配整个字符串时返回 true s.split(&quot;regex&quot;) 按匹配的正则表达式切片字符串 s.replaceFirst(&quot;regex&quot;, &quot;replacement&quot;) 替换首次匹配的字符串片段 s.replaceAll(&quot;regex&quot;, &quot;replacement&quot;) 替换所有匹配的字符 实例： 1234567891011121314151617181920package com.wuxianjiezh.regex;public class RegexTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;wxj&quot;.matches(&quot;wxj&quot;)); System.out.println(&quot;----------&quot;); String[] array = &quot;w x j&quot;.split(&quot;\\s&quot;); for (String item : array) &#123; System.out.println(item); &#125; System.out.println(&quot;----------&quot;); System.out.println(&quot;w x j&quot;.replaceFirst(&quot;\\s&quot;, &quot;-&quot;)); System.out.println(&quot;----------&quot;); System.out.println(&quot;w x j&quot;.replaceAll(&quot;\\s&quot;, &quot;-&quot;)); &#125;&#125; 运行结果： 123456789true----------wxj----------w-x j----------w-x-j 1.14：模式和匹配：Java 中使用正则表达式需要用到两个类，分别为 java.util.regex.Pattern 和 java.util.regex.Matcher。 第一步，通过正则表达式创建模式对象 Pattern。 第二步，通过模式对象 Pattern，根据指定字符串创建匹配对象 Matcher。 第三步，通过匹配对象 Matcher，根据正则表达式操作字符串。 来个例子，加深理解： 123456789101112131415161718192021222324252627package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String text = &quot;Hello Regex!&quot;; Pattern pattern = Pattern.compile(&quot;\\w+&quot;); // Java 中忽略大小写，有两种写法： // Pattern pattern = Pattern.compile(&quot;\\w+&quot;, Pattern.CASE_INSENSITIVE); // Pattern pattern = Pattern.compile(&quot;(?i)\\w+&quot;); // 推荐写法 Matcher matcher = pattern.matcher(text); // 遍例所有匹配的序列 while (matcher.find()) &#123; System.out.print(&quot;Start index: &quot; + matcher.start()); System.out.print(&quot; End index: &quot; + matcher.end() + &quot; &quot;); System.out.println(matcher.group()); &#125; // 创建第两个模式，将空格替换为 tab Pattern replace = Pattern.compile(&quot;\\s+&quot;); Matcher matcher2 = replace.matcher(text); System.out.println(matcher2.replaceAll(&quot;\t&quot;)); &#125;&#125; 运行结果： 123Start index: 0 End index: 5 HelloStart index: 6 End index: 11 RegexHello Regex! 1.15：几个常用的例子：1）中文的匹配：[\u4e00-\u9fa5]+ 代表匹配中文字。 12345678910111213141516package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;閑人到人间&quot;; Pattern pattern = Pattern.compile(&quot;[\\u4e00-\\u9fa5]+&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); &#125; &#125;&#125; 运行结果： 1閑人到人间 2）数字范围的匹配：比如，匹配 1990 到 2017。 注意：这里有个新手易范的错误，就是正则 [1990-2017]，实际这个正则只匹配 0 或 1 或 2 或 7 或 9 中的任一个字符。 正则表达式匹配数字范围时，首先要确定最大值与最小值，最后写中间值。 正确的匹配方式： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;1990\n2010\n2017&quot;; // 这里应用了 (?m) 的多行匹配模式，只为方便我们测试输出 // &quot;^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$&quot; 为判断 1990-2017 正确的正则表达式 Pattern pattern = Pattern.compile(&quot;(?m)^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); &#125; &#125;&#125; 运行结果： 123199020102017 3）img标签的匹配：比如，获取图片文件内容，这里我们考虑了一些不规范的 img 标签写法： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;&lt;img src=&apos;aaa.jpg&apos; /&gt;&lt;img src=bbb.png/&gt;&lt;img src=\&quot;ccc.png\&quot;/&gt;&quot; + &quot;&lt;img src=&apos;ddd.exe&apos;/&gt;&lt;img src=&apos;eee.jpn&apos;/&gt;&quot;; // 这里我们考虑了一些不规范的 img 标签写法，比如：空格、引号 Pattern pattern = Pattern.compile(&quot;&lt;img\\s+src=(?:[&apos;\&quot;])?(?&lt;src&gt;\\w+.(jpg|png))(?:[&apos;\&quot;])?\\s*/&gt;&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group(&quot;src&quot;)); &#125; &#125;&#125; 运行结果： 123aaa.jpgbbb.pngccc.png 4）贪婪与非贪婪模式的匹配：比如，获取 div 标签中的文本内容： 1234567891011121314151617181920212223242526package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;&lt;div&gt;文章标题&lt;/div&gt;&lt;div&gt;发布时间&lt;/div&gt;&quot;; // 贪婪模式 Pattern pattern = Pattern.compile(&quot;&lt;div&gt;(?&lt;title&gt;.+)&lt;/div&gt;&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group(&quot;title&quot;)); &#125; System.out.println(&quot;--------------&quot;); // 非贪婪模式 pattern = Pattern.compile(&quot;&lt;div&gt;(?&lt;title&gt;.+?)&lt;/div&gt;&quot;); matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group(&quot;title&quot;)); &#125; &#125;&#125; 运行结果： 1234文章标题&lt;/div&gt;&lt;div&gt;发布时间--------------文章标题发布时间 1.16：在线正则工具：JavaScript、Python在线表达工具]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>初窥门径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用指令（个人向）]]></title>
    <url>%2F2019%2F02%2F26%2Fhexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： Hexo的常用指令： 1.新建文章： 2.新建页面： 3.生成静态页面： 4.开启本地服务器的端口： 5.部署到网页上： 6.清除文件： 7.查看hexo版本： 8.复合指令： 9.卸载hexo： 10.如何安装旧版本hexo： 特殊操作：Hexo支持目录： Hexo的常用指令：1.新建文章：如果文章名包含空格必须加双引号，如果没有则可以不加。 1$ hexo new &quot;articleName&quot; 2.新建页面：新建一个题为“pageName”的页面，此时会在/source/目录下生成一个名为pageName的文件夹，其中包含一份 index 的md文件； 1$ hexo new page &quot;pageName&quot; 3.生成静态页面：主要是为了方便调试自己的博客，在未发布之前检查是否有问题。 12$ hexo generate$ hexo g 4.开启本地服务器的端口：开启预览访问的端口，默认端口为4000。关闭server使用 ctrl + c。 本地网址如下： 1http://localhost：4000 命令为： 12$ hexo server$ hexo s 在使用hexo server 可能会遇到端口被占用的情况，不妨使用以下指令来更改端口： 1$ hexo server -p 4001 5.部署到网页上：将目录下的 .deploy_git 文件夹部署到Github。部署前需要预先 hexo generate 生成静态文件。 关闭server使用 ctrl + c。 “INFO Deploy done: git”时即表示部署已经完成。 12$ hexo deploy$ hexo d 6.清除文件：清除目录下的缓存文件（db.json）和已经生成的静态文件（public）文件。网页正常情况下可以忽略此条命令。 1$ hexo clean 7.查看hexo版本：查看当前使用的hexo的版本号。 1$ hexo version 8.复合指令：hexo g -d # 等价于 hexo generate –deploy ：生成静态文件并部署。hexo s -d # 等价于 hexo deploy –generate ：开启预览并部署到Github。 简写形式hexo n #等价于 hexo newhexo g #等价于 hexo generatehexo s #等价于 hexo serverhexo d #等价于 hexo deployhexo v #等价于 hexo version 12$ hexo g -d$ hexo s -d 9.卸载hexo：3.0.0版本执行npm uninstall hexo-cli -g，之前版本执行npm uninstall hexo -g. 10.如何安装旧版本hexo：先卸载当前版本，以2.8.3为例，执行npm install hexo@2.8.3 -g，再初始化并安装依赖和插件。 特殊操作：Hexo支持目录：1.安装hexo-toc插件： 1npm install hexo-toc --save 2.配置站点配置文件_config.yml： 12toc: maxdepth: 5 3.使用： 在markdown文章中加入TOC占位符即可自动生成目录： 1&lt;!-- toc --&gt; 4.效果：]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>备忘</tag>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android学习路线总结plus]]></title>
    <url>%2F2019%2F02%2F26%2Fandroid%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%80%BB%E7%BB%93plus%2F</url>
    <content type="text"><![CDATA[目录： 1.java se基础： 2.android UI编程： 1）android初级控件的使用： 2）android高级控件的使用： 3）对话框与菜单的使用： 4）控件的布局方法： 5）多activity的管理： 6）自定义控件的实现方法： 3.android网络编程以及数据储存： 1）基于android平台的http通讯： 2）android数据储存技术： 4.进阶之路： 初级工程师： 中级工程师： 高级工程师： 1.java se基础：1).Java基本数据类型与表达式，分支循环。2).String和StringBuffer的使用、正则表达式。3).面向对象的抽象，封装，继承，多态，类与对象，对象初始化和回收；构造函数、this关键字、方法和方法的参数传递过程、static关键字、内部类。4).对象实例化过程、方法的覆盖、final关键字、抽象类、接口、继承的优点和缺点剖析；对象的多态性：子类和父类之间的转换、抽象类和接口在多态中的应用、多态带来的好处。5).Java异常处理，异常的机制原理。6).常用的设计模式：Singleton、Template、Strategy模式。7).JavaAPI介绍：种基本数据类型包装类，System和Runtime类，Date和DateFomat类等。8).Java集合介绍：Collection、Set、List、ArrayList、LinkedList、Hashset、Map、HashMap、Iterator等常用集合类API。9).JavaI/O输入输出流：File和FileRandomAccess类，字节流InputStream和OutputStream，字符流Reader和Writer，以及相应实现类，IO性能分析，字节和字符的转化流，包装流的概念，以及常用包装类，计算机编码。10).Java高级特性：反射和泛型。11).多线程原理：如何在程序中创建多线程(Thread、Runnable)，线程安全问题，线程的同步，线程之间的通讯、死锁。 2.android UI编程：1）android初级控件的使用：TextView控件的使用Button控件的使用方法EditText控件的使用方法ImageView的使用方法RadioButton的使用方法Checkbox的使用方法Menu的使用方法 2）android高级控件的使用：ListView的使用方法GridView的使用方法Adapter的使用方法Spinner的使用方法Gallary的使用方法ScrollView的使用方法RecyclerView 3）对话框与菜单的使用：Dialog的基本概念BlockquoteAlertDialog的使用方法DatePickerDialog的使用方法Menu的使用方法自定义Menu的实现方法 4）控件的布局方法：线性布局的使用方法相对布局的使用方法 5）多activity的管理：AndroidManifest.xml文件的作用Intent的使用方法使用Intent传递数据的方法启动Activity的方法IntentFilter的使用方法Activity Group的使用方法 6）自定义控件的实现方法：自定义ListView的实现方法可折叠ListView的使用方法自定义Adapter的实现方法自定义View的实现方法动态控件布局的上实现方法上拉刷新下拉加载更多 3.android网络编程以及数据储存：1）基于android平台的http通讯：Http协议回顾使用Get方法向服务器提交数据的方法使用POST方法向服务器提交数据的实现方法使用Http协议实现多线程下载使用Http协议实现断点续传 2）android数据储存技术：SQLite3数据库简介SQL语句回顾SQLite3编程接口介绍SQLite3事务管理SQLite3游标使用方法SQLite3性能分析访问SDCard的方法访问SharedPreferences的方法 4.进阶之路：初级工程师： 基本知识点比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术 书籍推荐《第一行代码 Android》、《疯狂Android》 中级工程师： AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别； Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用； 多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等； 事件分发：弹性滑动、滑动冲突等； 玩转View：View的绘制原理、各种自定义View； 动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理； 懂性能优化、熟悉mat等工具 懂点常见的设计模式 书籍推荐《Android开发艺术探索》、《Android群英传》 高级工程师： 继续加深理解”稍微深入的知识点“中所定义的内容 了解系统核心机制： 了解SystemServer的启动过程 了解主线程的消息循环模型 了解AMS和PMS的工作原理 能够回答问题”一个应用存在多少个Window？“ 了解四大组件的大概工作流程 … 基本知识点的细节 Activity的启动模式以及异常情况下不同Activity的表现 Service的onBind和onReBind的关联 onServiceDisconnected(ComponentName className)和binderDied()的区别 AsyncTask在不同版本上的表现细节 线程池的细节和参数配置 … 熟悉设计模式，有架构意识学习方法 书籍推荐《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》 参考链接]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>总结</tag>
        <tag>学习路线</tag>
        <tag>plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习路线总结（个人向）]]></title>
    <url>%2F2019%2F01%2F14%2FAndroid%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： Java基础： Java高阶： 数据结构及算法： 数据结构： 算法： Android基础： Android技术难点 Android框架层源码掌握 各种原理，经典第三方库源码系列 Android进程通信以及多进程开发 Android动画机制 Android绘图原理 Android页面恢复 混合开发及Android WebView应用 Gradle，自动化构建，持续集成相关 Android系统 Android Studio编译过程 Android架构： Android优化： 移动开发外围 服务器开发相关 前端开发相关 开发调试各种工具 Java基础：Java Object类方法 HashMap原理，Hash冲突，并发集合，线程安全集合及实现原理 HashMap 和 HashTable 区别 HashCode 作用，如何重载hashCode方法 ArrayList与LinkList区别与联系 GC机制 Java反射机制，Java代理模式 Java泛型 Synchronized原理 Volatile实现原理 方法锁、对象锁、类锁的意义和区别 线程同步的方法：Synchronized、lock、reentrantLock分析 Java锁的种类: 公平锁、乐观锁、互斥锁、分段锁、偏向锁、自旋锁等 ThreadLocal的原理和用法 ThreadPool的用法和示例 wait()和sleep()的区别 Java高阶：Java虚拟机，Java运行，Java GC机制（可达性分析法，引用计数法） Java对象的完整生命周期 JVM内存模型 进程间通信，线程间通信 JVM类加载机制 Java引用类型 设计模式：除常用设计模式之外，特别的，反射机制，代理模式 HTTP协议和HTTPS协议 Socket协议，Socket实现长连接 TCP和UDP协议 HTTP协议中GET和POST的具体实现 序列化和反序列化 线程池的实现原理 数据库基础知识：多表查询、索引、数据库事务 数据结构及算法：数据结构：栈和队列 数组和链表，自定义一个动态数组 Hash表，及Hash冲突的解决 二叉树 B+ B-树 基础排序算法：重点 快排、归并排序、堆排序（大根堆、小根堆） 快排的优化 二分查找与变种二分查找 哈夫曼树、红黑树 字符串操作，字符串查找，KMP算法 图的BFS、DFS、prim、Dijkstra算法（高阶技能） 经典问题：海量数据的处理 （10亿个数中找出最大的10000个数 TOP K问题） 算法：分治算法 动态规划 贪心算法 分支限界法 Android基础：Application生命周期 Android Activity生命周期 Android Service、IntentService，Service和组件间通信 Activity的onNewIntent Fragment的懒加载实现，参数传递与保存 ContentProvider实例详解 BroadcastReceiver使用总结 Android消息机制 Binder机制，共享内存实现原理 Android 事件分发机制 Android 多线程的实现：Thread、HandlerThread、AsyncTask、IntentService、RxJava ActivityThread工作原理 嵌套滑动实现原理 RecyclerView与ListView(缓存原理，区别联系，优缺点) View的绘制原理，自定义View，自定义ViewGroup View、SurfaceView 与 TextureView 主线程Looper.loop为什么不会造成死循环 ViewPager的缓存实现 requestLayout，invalidate，postInvalidate区别与联系 AndroidP新特性 Android两种虚拟机 ADB常用命令 Asset目录与res目录的区别 Android SQLite的使用入门 Android开发高级： 附：一般Android高级工程师招聘要求： 熟悉Android SDK，熟悉Android UI，熟悉Android各种调试工具； 有丰富的Android应用架构能力，能够独立主导并架构App；3. Mobile Web 开发经验；具备各种复合技能：熟悉iOS、H5、Python、.NET等多种开发语言的优先考虑； 对Android性能优化，安全，软件加固，自动化测试有深刻认识; 博客，开源项目 Android技术难点AIDL、Binder、多进程、View的绘制流程、事件分发、消息队列等。这类知识对于定位自己为高级Android工程师的人来说是必须掌握的，同时他也是能鉴别高级和初中级工程师的一块试金石，其中binder是Android系统进程间通信最重要的手段之一，现阶段app的发展离不开多进程的运用，经常会启动例如定位、推送等需要在后台开启动的进程来来保证主进程的内存运行；所以合理的使用多进程也是十分必要的；view的绘制是我们自定义控件的理论基础，只有掌握了view是如何绘制的才能个性化的自定义控件；事件分发一直是Android开发的难点之一，也是必须掌握的；关于handler机制也是android的一块难点，因为包括Asynctask、系统启动、Intentservice等底层都是通过handler来实现的，所以掌握后handler机制不仅能提高你的实战开发能力，更能让你系统的了解整个android系统运作的情况。 Android框架层源码掌握Android框架层有很多东西，以下几个是高级程序员必须要掌握的： Android包管理机制，核心PackageManagerService Window管理，核心WindowManagerService Android Activity启动和管理，核心ActivityManagerService 根Activity工作流程 Context关联类 各种原理，经典第三方库源码系列 自定义LayoutManager，RecyclerView中如何自定义LayoutManager VLayout实现原理，即如何自定义LayoutManager Glide加载原理，缓存方案，LRU算法 Retrofit的实现与原理 OKHttp3的使用，网络请求中的Intercept EventBus实现原理 ButterKnife实现原理 RxJava实现原理 Dagger依赖注入 热修复实现原理，解决方案 组件化原理和解决方案 Android进程通信以及多进程开发Android 多进程和Application关系 经典解决方案：多进程通信解决方案：Andromeda Android动画机制经典学习资料：HenCoder: 给高级Android工程师的进阶手册 Android绘图原理经典学习资料：HenCoder: 给高级Android工程师的进阶手册 Android页面恢复Android的页面恢复采用以下两个方法： onSaveInstanceState(Bundle outState) onRestoreInstanceState(Bundle savedInstanceState) onSaveInstanceState: 当Activity容易被系统销毁时，会触发该方法。具体的说 用户点击Home键 用户点击Home键，切换到其他应用程序 有电话来了等附加操作 混合开发及Android WebView应用混合开发涉及到的知识点主要包括： APP调用WebView加载url 掌握WebView的封装，了解所有的WebSettings配置，掌握WebViewClient、WebChromeClient 掌握WebView和Native双向通信机制，会自己封装双向通信中间件 对WebView的封装可参考：GitHub: AgentWeb 对通信中间件原理理解：GitHub：webprogress Gradle，自动化构建，持续集成相关Android系统Android Studio编译过程其中使用到的编译工具： aapt、aidl、Java Compiler、dex、 zipalign 主要步骤描述： 通过aapt打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样） 处理.aidl文件，生成对应的Java接口文件 通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex 通过apkbuilder工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk 通过Jarsigner工具，对上面的apk进行debug或release签名 通过zipalign工具，将签名后的apk进行对齐处理。 Android架构： MVC模式 MVP模式 MVVM模式 CLEAN模式 组件化开发 跨平台开发：Flutter、ReactNative（RN未来要黄，了解一下就好） Android优化： 移动开发外围服务器开发相关 SpringBoot技术 Restful API开发 网络协议理解：TCP/IP、HTTP/HTTPS、OSI七层协议 授权认证协议： OAuth2.0 等 基本的数据库技术 数据缓存技术：Memcached、Redis，Web缓存原理 消息队列技术 监控、日志分析技术 前端开发相关前端开发知识很多，框架层出不穷，本质的东西却只有以下这些。 核心必备：HTML、CSS、JavaScript 入门提高：浏览器兼容性、自定义UI和动效 中级技能：框架层出不穷，当前以vue.js、react.js 为核心 协作开发技能：包管理、模块化，工具采用 npm、webpack等 高级技能：框架原理源码研究 开发调试各种工具 性能分析工具：Memory Monitor 性能追踪及方法执行分析： TraceView 视图分析：Hierarchy Viewer ApkTool- 用于反向工程Android Apk文件的工具 Lint- Android lint工具是一个静态代码分析工具 Dex2Jar- 使用android .dex和java .class文件的工具 参考链接]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>总结</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用语法]]></title>
    <url>%2F2019%2F01%2F12%2FMarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录： 前言 一.标题 二.字体- [加粗](#加粗) - [斜体](#斜体) - [斜体加粗](#斜体加粗) - [删除线](#删除线) 三.引用 四.分割线 五.图片 六.超链接 七.列表 八.表格 九.代码 十.流程图 前言​ Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 一.标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 注意：这里的标准语法是必须#结束后再加上一个空格再加上想要写的文字。（但是有些地方貌似不加空格也可以，例如简书。但是最好还是按照标准的语法来写） 二.字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 三.引用在引用的文字前面加上&gt;即可。引用也可以嵌套，比如说两个&gt;&gt;三个&gt;&gt;&gt;之类的，貌似可以一直加下去，但是好像没什么用… 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;这是引用的内容 四.分割线三个或者三个以上的-或者*都可以。 1234-------******** 五.图片1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 六.超链接12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 例如： 12[简书](http://jianshu.com)[百度](http://baidu.com) 七.列表无序列表用-+*任何一种都可以。 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 有序列表数字加点即可。 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 列表嵌套：上一级和下一级之间敲上三个空格即可。 八.表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 九.代码单行代码直接代码之间分别用一个反引号包起来即可。 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行。 12345(```) 代码... 代码... 代码...(```) 十.流程图123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; ` 参考文章：Markdown基本语法]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Android6.0以上部分权限的动态获取]]></title>
    <url>%2F2019%2F01%2F12%2F%E5%85%B3%E4%BA%8EAndroid6-0%E4%BB%A5%E4%B8%8A%E9%83%A8%E5%88%86%E6%9D%83%E9%99%90%E7%9A%84%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[普通权限暂且不表，下面只列举Android6.0以后必须进行动态申请的权限。 下面以SD卡读取权限作为例子（如果实在不懂的话可以直接复制粘贴，只需要改一下权限的名称即可）： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 请求授权 */ private void requestPermission()&#123; if (Build.VERSION.SDK_INT &gt;= 23) &#123; int checkCallPhonePermission = ContextCompat.checkSelfPermission (this, Manifest.permission.READ_EXTERNAL_STORAGE); if (checkCallPhonePermission != PackageManager.PERMISSION_GRANTED) &#123; //在String[]中传入需要申请的权限 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 1); &#125; else&#123; //sendHomework(); //已经拥有了权限 Toast.makeText(this,"已经获取读SD卡权限",Toast.LENGTH_SHORT).show(); &#125; &#125; else &#123; //低版本 Toast.makeText(this,"已经获取读SD卡权限",Toast.LENGTH_SHORT).show(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //sendHomework(); //获取权限成功后的处理 Toast.makeText(this,"已经成功获取读SD卡权限",Toast.LENGTH_SHORT).show(); &#125; else &#123; //showToast("fail"); //获取权限失败的处理 Toast.makeText(this,"获取读SD卡权限失败",Toast.LENGTH_SHORT).show(); &#125; break; default: super.onRequestPermissionsResult(requestCode, permissions, grantResults); &#125; &#125; 对于新手来说，需要注意的是，如果你想要使用这个动态权限，除了上面这段代码之外，你还需要在项目的Manifest中注册你想要获取的权限（一般来说，只要不是危险权限，无论Android6.0前后，只要注册之后就可以直接使用了，但是危险权限，除了注册之外还需要手动的动态申请）。 另外，除了上面这段代码和注册之外，还需要在初始化之前在MainActivity中写上 1requestPermission() 来调用下面写的动态申请。 参考文章：Android6.0动态权限]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动态权限</tag>
        <tag>安卓6.0以上</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真机调试时如何用Androidstudio查询SQLite数据库]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E6%97%B6%E5%A6%82%E4%BD%95%E7%94%A8Androidstudio%E6%9F%A5%E8%AF%A2SQLite%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[目录： 前言： 1.首先在app对应下的build.gradle里面添加下面依赖： 2.自定义一个MyApplication继承Application，在onCreate中初始化stetho： 3.修改下列相关： 4.打开Chrome浏览器，输入网址： 5.点击弹出的网页Resource-&gt;Web SQL即可看到，下面是我的数据库显示情况： 前言：今天在调试一个有关于SQLite数据库的app的时候，突发奇想，想在手机上直接找到对应的db文件查看，结果是显而易见的，并没有找到相应的调试app的包名以及对应的文件夹。 然后在网上找了很多方法，试过之后，找到一个较方便且便捷的方法。如下： 1.首先在app对应下的build.gradle里面添加下面依赖：1234// Stetho coreimplementation &apos;com.facebook.stetho:stetho:1.3.1&apos;//If you want to add a network helperimplementation &apos;com.facebook.stetho:stetho-okhttp3:1.3.1&apos; 2.自定义一个MyApplication继承Application，在onCreate中初始化stetho：123456789101112131415public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); init(); &#125; private void init()&#123; Stetho.initializeWithDefaults(this); new OkHttpClient.Builder() .addNetworkInterceptor(new StethoInterceptor()) .build(); &#125;&#125; 3.修改下列相关：在AndroidManifest.xml中修改android:name=”.MyApplication” 然后运行app到手机上即可。 4.打开Chrome浏览器，输入网址：1chrome://inspect 操作好之后就是显示手机型号，下面有一个inspect直接点击即可。 5.点击弹出的网页Resource-&gt;Web SQL即可看到，下面是我的数据库显示情况： 这样就很简单啦，又方便又快捷！]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SQLite</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶（个人向）]]></title>
    <url>%2F2019%2F01%2F09%2FHexo%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言： 正文： 关于如何将自己的博客推送至百度与谷歌（默认情况下是不会被爬取的，这个时候就需要我们主动出击，让我们的博客可以直接被搜索到） 提交百度搜索引擎：（谷歌同理，过程一样） 站点地图： 安装百度谷歌的站点地图： 向谷歌提交链接： 百度收录： sitemap： 结语：百度的抓取速度是真的慢，另外，github.io的博客不允许百度蜘蛛爬取，直接再把博客推送到coding.me即可，百度收录的时候一定要用coding.me的网址。关于如何推送到coding，与github类似… 前言：首先，在我们刚刚搭建好这个博客的时候，我们会发现自己的博客显得很是简陋以及，单调，这个时候就是显示个性化的好时机了。hexo主题个性化是一个集合了许多方法的网址，可以参考。当然这只是沧海一粟，不值一提。还有更多的，诸如留言板，相册，网易云外链之类的优秀功能，具体详情可以直接百度，这里不过多赘述。 正文：关于如何将自己的博客推送至百度与谷歌（默认情况下是不会被爬取的，这个时候就需要我们主动出击，让我们的博客可以直接被搜索到）原因：Github和Coding都做了防爬虫处理，这样子我们博客可能就无法被搜索引擎收录，需要我们手动提交！ 验证是否被百度或者谷歌收录，即在相应的搜索栏中输入： 1site: thbelief.coding.me （注：site:后面是你的博客网址） 如果显示找不到相关网址，即没有被收录。如果找到了….那就恭喜不用操作了。 言归正传，回到正题。 提交百度搜索引擎：（谷歌同理，过程一样）登录百度搜索引擎 ps：可能需要个人信息认证，按照提示认证即可！ 然后是：添加站点-&gt;输入博客网址-&gt;设置站点领域（我设置的是信息技术）-&gt;选择验证方式。 这里只介绍第一种验证方式：文件验证 1.请点击 下载验证文件 获取验证文件 2.将验证文件放置于您所配置hexo博客的根目录下 3.点击这里确认验证文件可以正常访问 4.请点击“完成验证”按钮 注：为保持验证通过的状态,成功验证后请不要删除HTML文件 然后git bash输入框内输入hexo g -d部署到网站上面即可。 站点地图：站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 安装百度谷歌的站点地图：123npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 然后打开站点配置文件： 将url设置为你的站点名称。 然后执行hexo clean 以及 hexo g。 这样在你的网站根目录的public文件夹下生成sitemap.xml文件和baidusitemap.xml文件： 其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。 向谷歌提交链接：google站点平台：谷歌站点，然后就是注册账号、验证站点、提交sitemap， 提交site之后即可。 注意：无论是百度还是谷歌，都不是已通过就能直接搜索到，谷歌大致需要几小时，百度大致一个月左右，请耐心等待。 百度收录：百度收录较慢。故设置自动推送： 在主题配置文件下设置,将baidu_push设置为true： 12# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true sitemap：将生成的baidusitemap.xml提交到百度站点 点击链接提交： 然后刷新页面即可。 结语：百度的抓取速度是真的慢，另外，github.io的博客不允许百度蜘蛛爬取，直接再把博客推送到coding.me即可，百度收录的时候一定要用coding.me的网址。关于如何推送到coding，与github类似…]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用hexo+Github搭建个人博客（个人向）]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： hexo的介绍 准备 NodeJS Hexo安装 GitHub部分 Github Page 配置SSH 发布 更改主题 hexo的介绍官网上的描述是Hexo是一个快速，简单而强大的博客框架。我们可以使用Markdown（或其他语言）来编写文章，同时Hexo可以在几秒钟内生成具有美丽主题的静态文件以供我们使用。 简单来说它就是一个主打简单快速的博客框架，这个可以对比下知名度更高一些的WordPress，相对来说后者更强，不过更适合有服务器的人使用，只想做一个简单博客的首选hexo。 准备首先必须安装Git和NodeJS。（安装过程傻瓜式next操作即可） 注意一点就是NodeJS的路径。推荐D:\NodeJS (原因后面会阐述) 检测NodeJS是否安装成功的方式是： 输入Win+R输入cmd打开控制台输入下面代码： 12node -vnpm -v 如果两个都返回版本号即安装成功，否则需要再配环境变量。 NodeJS1.在NodeJS安装路径下面建立”node_global”及”node_cache”两个文件夹。 2.启动cmd输入： 12npm config set prefix &quot;D:\Program Files\nodejs\node_global&quot;npm config set cache &quot;D:\Program Files\nodejs\node_cache&quot; 3.配置环境变量： 环境变量-&gt;Path-&gt;编辑：添加上下面三行：（有的话就不用了） 123D:\NodeJS\D:\NodeJS\node_globalD:\NodeJs\node_cache 4.测试是否配置完成： 如果打开cmd输入下面代码然后在node_global目录下有express目录即完成了。 1npm install express -g Hexo安装打开git bash（为了避免出现错误后面的操作在git bash进行） 首先新建一个存放hexo文件的目录，例如在D盘根目录新建hexo文件夹，然后cd到该目录下，开始安装 1234567$ cd D:hexo/ #换成你的目录$ npm install -g hexo-cli #安装hexo脚手架$ hexo init #Hexo自动在当前文件夹下下载搭建网站所需的所有文件$ npm install #安装依赖包$ hexo g #完整命令为hexo generate，生成静态文件$ hexo s #完整命令为hexo server，启动服务器，用来本地预览 用浏览器访问http://localhost:4000，这时就可以看到了一个比较漂亮的博客了，这个是hexo的默认主题landscape，而我们会使用的是NexT主题，后面会说到怎么配置。 GitHub部分Github Page打开github主页，新建仓库（repository），这里要注意仓库的名称，比如我的帐号是thbelief，那么仓库名称应该是：thbelief.github.io。然后选择Public（公开）。 配置SSH以上过程完成后就是把hexo生成的静态页面上传了，到这里还没结束，还需要配置SSH，首先要本地生成公钥私钥 1$ ssh-keygen -t rsa -C &quot;你的邮件地址&quot; 引号里面的内容输入你的邮箱地址，然后回车，会提示你文件保存的路径，这时候按回车键确认，然后会提示你输入密码，输入即可（输入密码是看不到的），然后会确认输入一次，就可以在刚刚的路径看到生成了两个文件，一个是id_rsa，另一个是id_rsa.pub，用sublime打开id_rsa.pub然后选中里面的全部内容，复制下来。打开GitHub或Coding的SSH页面Github：setting–&gt;SSH and GPG keys–&gt;New SSH key在Key下面的框中粘贴刚刚复制的东西。 发布打开D:\hexo，用sublime打开_config.yml文件，文件最后可以看到 12deploy: type: 修改（注意要换上自己的链接） 12345deploy: type: git repository: git@github.com:yourname/yourname.github.io.git #发布到github #repository: git@git.coding.net:yourname/yourname.git #发布到Coding branch: master ctrl+s保存修改。打开git bash在当前目录输入以下命令： 1$ hexo d #完整命令为hexo deploy，将本地文件发布到page服务平台上 如遇遇到异常可以 12$ hexo clean &amp;&amp; hexo g$ hexo d 如果出现以下异常 1ERROR Deployer not found: git 尝试输入以下命令，然后重新执行刚刚的两条命令 1$ npm install hexo-deployer-git --save 这时候如果弹出一个对话框，输入在github/coding上面的用户名和密码即可这时候我们就可以在浏览器输入https://yourname.github.io 或者https://youname.coding.me 打开。（yourname记得替换） 更改主题D:\hexo目录下的theme文件夹下存放的就是博客的主题，hexo便是依据主题来生成静态文件的，挑选主题可以在官网https://hexo.io/themes/ 查找，根据自己的喜好来挑选。下载主题的一般方式如下： 12$ cd your-hexo-site #eg:D:\hexo$ git clone &#123;主题链接&#125; themes/&#123;主题名称&#125; 但是最好还是直接去官网下载压缩包解压到hexo目录下面的themes中，因为国内下这个很慢。（解压的时候名字一定要换成next，方便后序操作） 其实还有一种方法，也是对第一种方法的补充，直接更换npm的来源地，换成淘宝的即可，详情百度，这里不过多赘述。 启用主题的方式也很简单sublime打开上文提到的hexo目录下的_config.yml，ctrl+f输入theme查找这个关键字，修改其主题名称为下载的主题名称即可。 1theme: &#123;主题名称&#125; 以本人使用的next主题为例：下载最新版： 12$ cd D:hexo/$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改hexo目录下的_config.yml 1theme: next 具体可以到主题官网看看–NexT 参考文章：hexo搭建个人博客]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
</search>
