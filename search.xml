<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python学习笔记（九）]]></title>
    <url>%2F2019%2F06%2F20%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 面向对象编程 继承 多态 对象信息 type() isinstance() dir() 实例属性和类属性 面向对象编程继承关于继承与多态的详细的介绍这里就不说了，主要讲讲他们的优势。 继承的好处是——子类自动的获得父类的全部的功能。 简单实例: 1234567891011121314151617#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2019/6/18 15:21# @Author : thbelief# @Email : thbelief520@gmail.com# @File : Inheritance and polymorphism.py# @function: 继承多态的部分#codeclass printSomething(object): def printThis(self): print("bug")class test(printSomething): print("这是子类")test1=test()test1.printThis() 结果： 12345D:\python.code\venv\Scripts\python.exe &quot;D:/python.code/Inheritance and polymorphism.py&quot;这是子类bugProcess finished with exit code 0 通过这个简单的例子就可以简单的了解继承的特性。 多态由上面的部分可以自然的引出多态的使用，所谓的多态其实就是——子类中的与父类同名的方法其实子类的对象时直接调用子类的同名方法的。 简单实例： 12345678910111213141516#多态class printSomething(object): def printThis(self): print("bug")class test1(printSomething): def printThis(self): print("bug1")class test2(printSomething): def printThis(self): print("bug2")tmp1=printSomething()tmp2=test1()tmp3=test2()tmp1.printThis()tmp2.printThis()tmp3.printThis() 输出结果： 123456D:\python.code\venv\Scripts\python.exe &quot;D:/python.code/Inheritance and polymorphism.py&quot;bugbug1bug2Process finished with exit code 0 注意：在JAVA等语言中要求多态是必须传入对应的子类类型，但是Python中不一定。这也是静态语言与动态语言的差别。 对象信息拿到对象的首先肯定是要知道这个对象是什么类型以及拥有哪些方法。 type()判断对象的类型。 基本变量类型的判断可以直接判断，但是如果要判断对象是不是函数的话还是需要types模块中定义的变量。 types模块变量如下： 12345678910111213141516171819202122232425262728293031323334353637BooleanType BufferType BuiltinFunctionType BuiltinMethodType ClassType CodeType ComplexType DictProxyType DictType DictionaryType EllipsisType FileType FloatType FrameType FunctionType GeneratorType GetSetDescriptorType InstanceType IntType LambdaType ListType LongType MemberDescriptorType MethodType ModuleType NoneType NotImplementedType ObjectType SliceType StringType StringTypes TracebackType TupleType TypeType UnboundMethodType UnicodeType XRangeType 简单实例： 123456789101112131415161718#多态class printSomething(object): def printThis(self): print("bug")class test1(printSomething): def printThis(self): print("bug1")class test2(printSomething): def printThis(self): print("bug2")tmp1=printSomething()tmp2=test1()tmp3=test2()tmp1.printThis()tmp2.printThis()tmp3.printThis()#获取对象类型print(type(tmp1)) 结果： 1234567D:\python.code\venv\Scripts\python.exe &quot;D:/python.code/Inheritance and polymorphism.py&quot;bugbug1bug2&lt;class &apos;__main__.printSomething&apos;&gt;Process finished with exit code 0 isinstance()判断一个对象是否是某种类型。 12345678910111213141516171819#多态class printSomething(object): def printThis(self): print("bug")class test1(printSomething): def printThis(self): print("bug1")class test2(printSomething): def printThis(self): print("bug2")tmp1=printSomething()tmp2=test1()tmp3=test2()tmp1.printThis()tmp2.printThis()tmp3.printThis()#获取对象类型print(isinstance(tmp1,printSomething))print(isinstance(tmp2,printSomething)) 结果： 这里需要注意——子类继承下来之后判断的时候也会判断包含在父类。 12345678D:\python.code\venv\Scripts\python.exe &quot;D:/python.code/Inheritance and polymorphism.py&quot;bugbug1bug2TrueTrueProcess finished with exit code 0 dir()获取对象的所有的属性+方法。 通过getattr()、setattr()以及hasattr() 获取，设置，有无 来操作该对象。 简单实例： 123456789101112#dirclass printSomething(object): def printThis(self): print("bug")test=printSomething()#获取对象的所有属性方法print(dir(test))#操作对象状态getattr()、setattr()以及hasattr() 获取，设置，有无print(hasattr(test,"printThis"))print(hasattr(test,"printThis1"))setattr(test,'test','有这个属性了')print(getattr(test,"test")) 结果： 实例属性和类属性动态语言可以给类创建的实例绑定各种各样的属性。同样，类也可以给自己定义一个类属性。 在使用的时候千万不要定义实例属性名字和类属性一样，这样的话，相同名称的实例属性将自动屏蔽掉类属性。]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记（八）]]></title>
    <url>%2F2019%2F06%2F19%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 面向对象编程 简介 类与实例 访问限制 面向对象编程简介定义：把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 其实也就是类似于CLASS类的概念。同样的——面向对象的三大特点：封装继承多态。 简单实例： 1234567891011121314151617181920#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2019/6/14 15:56# @Author : thbelief# @Email : thbelief520@gmail.com# @File : OOP.py# @function: 面向对象编程#简单的类Classclass Student(object): def __init__(self,name,gender): self.name=name self.gender=gender def print_gender(self): print('%s: %s'%(self.name,self.gender))#简单实例test1=Student('thbelief','男')test2=Student('Dragon','女')print(test1.print_gender())print(test2.print_gender()) 结果： 类与实例定义： 通过class关键字+类名（通常大写开头的单词），object则是表示从哪个类继承下来的，一般如果没有的话默认就是object因为这是所有类最终都会继承的类。 12class Student(object): ... 创建实例： 通过类名+()实现。()中必须添加类中要求的参数（如果有要求的话）。 1Student('thbelief','男') 每个object的地址都不一样，而Student本身则是一个类。 绑定属性： 通过定义一个特殊的方法在创建实例的时候传入相关的参数。 123def __init__(self,name,gender): self.name=name self.gender=gender 注意： 这个init方法的第一个参数永远是self，表示创建的实例本身，因此，在init方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 数据封装： 这个就相当于C++那些类里面的内部变量，只能类内部才能访问，但是也可以专门设置一个函数用来传出参数。 12def print_score(self): print('%s: %s' % (self.name, self.gender)) 特别需要注意的是——由于Python允许对实例变量绑定任何数据，所以对于一个类的不同实例来说，拥有的变量以及名称都可能不一样。 访问限制Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。 12345678class Student(object): def __init__(self, name, gender): self.__name = name self.__gender = gender def print_score(self): print('%s: %s' % (self.__name, self.__gender)) 这样子外面就不能直接访问_变量了,但是仍然可以通过定义函数来获取甚至修改。 在Python中，变量名类似xxx的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以不能用这样的方法来定义变量。]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coin Changing]]></title>
    <url>%2F2019%2F06%2F18%2FCoin-Changing%2F</url>
    <content type="text"><![CDATA[目录： Coin Changing 题目描述 输入 输出 样例输入 样例输出 解法 代码 结果 Coin Changing题目描述设有n 种不同面值的硬币，各硬币的面值存于数组T［1:n］中。现要用这些面值的硬币来找钱。可以使用的各种面值的硬币个数存于数组Coins［1:n］中。 对于给定的1≤n≤10，硬币面值数组T和可以使用的各种面值的硬币个数数组Coins，以及钱数m，0≤m≤20001，编程计算找钱m的最少硬币数。 输入1第一行中只有1 个整数给出n的值,第2 行起每行2 个数，分别是T[j]和Coins[j]。最后1 行是要找的钱数m。 输出1最少硬币数,无解时输出-1 样例输入1234531 32 35 318 样例输出15 解法这是一道动态规划的题目。 运用动态规划的思想——将一个问题分裂成n个子问题，求出子问题的解并用子问题的解出问题的答案。 可知，可以将对m找零分解为对1、2、3、4、5…m找零。所以我们可以定义长度为m的数组dp[1~m]来存放对应子问题的求解，即dp[i]为要凑i块钱所需最少硬币数，那么dp[m]就是要求的答案。 假设当前要找零的钱是i（1&lt;i&lt;m）,当前所试探的硬币面值为k： （1）当i和k相等时，结果为1，即dp[i] = 1，说明可以直接通过一枚硬币就是最小硬币数了。 （2）当i大于k时，若dp[i]为0(未赋过值），且dp[i-k]不为0(从i元中减去k元后剩下的钱可以找开) 则dp[i] = dp[i-k]+1，即将子问题划分，然后加上本次的一枚硬币即可。 若dp[i]不为0(即已赋值)，则dp[i] = min( dp[i-k]+1, dp[i] ) 即dp[i]为dp[i-k]和dp[i]中的较小者。 （3）所以dp[i]的动态转移方程就是: 1dp[i] = min( dp[k], dp[k-t[i]]+1 ) //t[i]&lt;=k&lt;=m 代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define Max 999999int main()&#123; //硬币种类数n，找零钱数m int n,m,T[11],Coins[11]; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;T[i]&gt;&gt;Coins[i];//面值与对应的个数 &#125; cin&gt;&gt;m; int dp[20002]=&#123;0&#125;; for(int i=1;i&lt;20002;i++)&#123; //因为0时找零为0，后面的都初始化为最大值（寻找最少硬币数） dp[i]=Max; &#125; for(int i=1;i&lt;=n;i++)&#123; //一共n种硬币 for(int j=1;j&lt;=Coins[i];j++)&#123;//各面值硬币个数 for(int k=m;k&gt;=T[i];k--)&#123;//各面值 //动态规划思想求解 dp[k] = min(dp[k], dp[k-T[i]]+1); &#125; &#125; &#125; if(dp[m]&lt;=m)&#123; cout&lt;&lt;dp[m]&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;"-1"&lt;&lt;endl; &#125; return 0;&#125; 结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编实验（三）]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 指令系统（常用） 简介 MOV PUSH POP XCHG LEA ADD，ADC SUB，SBB INC，DEC NEG MUL，IMUL DIV，IDIV CBW，CWD AND,OR,XOR,NOT,TEST SHR,SHL,SAR,SAL CMP JMP JXX LOOP NOP 寻址方式 简介 立即寻址方式 寄存器寻址方式 直接寻址方式 寄存器间接寻址方式 寄存器相对寻址方式 基址变址寻址方式 相对基址变址寻址方式 MASM汇编代码简单框架 指令系统（常用）简介只是收集一些实验过程中经常用到的，并不全面。 MOV把源操作数送给目的操作数 。 PUSH把操作数压栈。 POP把操作数弹栈。 XCHG交换两个操作数的数据。 LEA有效地址送到寄存器。 ADD，ADC加法与进位加法。 SUB，SBB减法与带借位减法。 INC，DECINC OP即将OP的值加一，DEC OP相反。 NEG求补（取二进制补码）。 MUL，IMUL无符号和带符号乘法。 字节/字操作数结果保存在AX。 DIV，IDIV无符号和带符号除法。 CBW，CWD有符号数的扩展。 AND,OR,XOR,NOT,TEST前面四个都是普通的逻辑指令，Test则是相与结果不保存，根据特征置条件码。 SHR,SHL,SAR,SAL分别是逻辑右移，逻辑左移，算术右移，算术左移。 CMP比较值大小。 JMP跳到后面指定的地址。 JXX 当特定条件成立则跳往指定地址执行 。 参数： 1234567891011121314A: ABOVE,当C=0,Z=0时成立，大于转移B: BELOW,当C=1时成立，小于转移C: CARRY,当CF=1时成立 CXZ: CX寄存器的值为0(ZERO)时成立 E: EQUAL,当Z=1时成立 G: GREATER(大于),当Z=0且S=0时成立 L: LESS(小于),当S不为零时成立 N: NOT(相反条件),需和其它符号配合使用 O: OVERFLOW,O=1时成立 P: PARITY,P=1时成立 PE: PARITY EVEN,P=1时成立 PO: PARITY ODD,P=0时成立 S: SIGN,S=1时成立 Z: ZERO,Z=1时成立 LOOP循环控制。（CX） NOP不执行任何操作，但是花费CPU一个机器周期。 参考文章 寻址方式简介这里只是简单的举例，具体的详细情况可以参考——传送门。 立即寻址方式1MOV AX,1234H 寄存器寻址方式AX，AL等等。 直接寻址方式1MOV BX, [1234H] 寄存器间接寻址方式1MOV AX, [DI] 寄存器相对寻址方式1MOV AX,[DI+1223H] 基址变址寻址方式1MOV AX,[BX][DI] 相对基址变址寻址方式1MOV AX,[BX+DI-2] MASM汇编代码简单框架123456789101112131415161718DATA SEGMENT DATA ENDSSTACK SEGMENT PARA STACK ;DB 20H DUP (0)STACK ENDSCODE SEGMENTASSUME CS:CODE,DS:DATA,SS:STACKSTART: MOV AX,DATA MOV DS,AX MOV AX,STACK MOV SS,AX ;MOV SP,20H CODE ENDSEND START]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++运算符重载]]></title>
    <url>%2F2019%2F06%2F16%2FC-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[目录： C++ Operator运算符重载 前言 类成员函数的操作符重载 非类成员函数（全局函数）操作数重载 注意事项 使用范围 限制 C++ Operator运算符重载前言一般来说，对于C++本身提供的运算符比如+，-，==等等运算符来说，能比较的只能是基本数据类型或者标准库中的Class，对于我们自己定义的Class的基本运算操作来说，就显得很无力，是以引出了——运算符重载这种东西。 比如说，如果假定一个Class——Person（自定义）,ta存在==这种运算符的比较，当我们想判断两个人是否==的时候，是用原生的==？显然不可能，我们需要重载一下实现自己独立的运算符规则。 类成员函数的操作符重载重载的操作符在类体中被声明，声明方式如同普通成员函数一样，只不过ta的名字包含关键字operator，后面加上一个C++预定义的操作符。 比如： 类的声明： 12345678910class person&#123;private: int gender;public: person(int a) &#123; this-&gt;gender=a; &#125; inline bool operator == (const person &amp;ps) const;//==运算符重载&#125;; 类成员函数： 1234567inline bool person::operator==(const person &amp;ps) const&#123; if (this-&gt;gender==ps.gender) return true; return false;&#125; 调用： 1234person p1('boy');person p2('gril');if(p1==p2)//注意这里的==已经是上面重载过的类成员函数cout&lt;&lt;”the age is equal!”&lt;&lt;endl; 非类成员函数（全局函数）操作数重载全局函数必须注意——操作数的参数必须被显式指定。因为如果是类成员函数，明显知道类就是它的类型参数，但是全局函数ta不知道，所以必须显示指定。 如： 12345678bool operator==(person&amp; p1, person const &amp; p2) //指定参数类型&#123; if (p1.gender == p2.gender) &#123; return true; //满足要求 &#125; return false;&#125; 注意事项1.是否定义为全局函数还是类成员函数是根据具体情况判断的。 2.C++要求——赋值=，下标[]，调用()， 和成员指向-&gt; 操作符必须被定义为类成员操作符。否则会编译错误。 3.当返回值不是本函数内定义的局部变量时就可以返回一个引用。 4.在增量运算符中，放上一个整数形参，就是后增量运行符，它是值返回，对于前增量没有形参，而且是引用返回。 使用范围可以重载的操作符： 限制1、只有C++预定义的操作符才可以被重载。 2、重载操作符不能改变他们的操作符优先级。 3、除了对（）操作符外，对其他重载操作符提供缺省实参都是非法的。]]></content>
      <categories>
        <category>后端</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>结构体</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记（七）]]></title>
    <url>%2F2019%2F06%2F15%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 模块（Module） 简单介绍 使用 简单实例 作用域 安装第三方模块 如何安装 Python第三方模块网址 模块（Module）简单介绍Python中的模块——一个.py文件也就是一个模块。 使用模块可以避免函数名和变量名冲突。但是使用的时候还是要注意避免与内置函数名字出现冲突。 内置函数如下： Built-in Function abs() delattr() hash() memoryview() set() all() dict() help() min() setattr() any() dir() hex() next() slice() ascii() divmod() id() object() sorted() bin() enumerate() input() oct() staticmethod() bool() eval() int() open() str() breakpoint() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() 包的出现——是为了防止出现模块儿名冲突，引入的按目录来组织模块的方法。 每一个包目录下面都会有一个init.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。init.py可以是空文件，也可以有Python代码，因为init.py本身就是一个模块，而它的模块名就是包名。 使用简单实例以sys模块为工具写一个hello的模块。 123456789101112131415161718192021222324252627#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2019/6/14 8:23# @Author : thbelief# @Email : thbelief520@gmail.com# @File : Module.py# @function: 模块部分的代码——以sys模块为工具写一个hello的模块#任何模块代码的第一个字符串都被视为模块的文档注释&apos; a test module for Module&apos;#使用__author__变量把作者写进去__author__ = &apos;thbelief&apos;#使用其它模块儿的第一步就是导入模块import sysdef test(): #sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称. args = sys.argv if len(args)==1: print(&apos;Hello, world!&apos;) elif len(args)==2: print(&apos;Hello, %s!&apos; % args[1]) else: print(&apos;So many arguments!&apos;)if __name__==&apos;__main__&apos;: test() 运行结果： 注意下面这段代码： 12if __name__==&apos;__main__&apos;: test() 它的作用就是——当我们在命令行运行上面写的这个模块文件时，Python解释器把一个特殊变量name置为main，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。 作用域Python中变量是否给别人使用或者说只在模块内部使用是通过_前缀实现的。 正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等。 类似”_xxx”这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，_abc等。 一般来说——外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。 安装第三方模块如何安装首先是在Windows的命令提示符中输入pip，如果提示未安装或者报错的话，安装好再进行下面的操作。 正常情况如下： 安装命令就是： 1pip install 第三方模块名 Python第三方模块网址PyPI 在这个网址里面可以自由搜索想要的第三方模块，因为要安装一个第三方库，必须先知道该库的名称。]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记（六）]]></title>
    <url>%2F2019%2F06%2F14%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 返回函数 闭包 代码 输出 匿名函数 代码 输出 装饰器 代码 输出 偏函数 代码 输出 返回函数高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 如果返回的是函数的话，必须还要执行一下。 闭包所谓的闭包就是——当一个函数返回了一个函数后，其内部的局部变量还被新函数引用。 返回的函数并没有立刻执行，而是直到调用了才执行。 代码123456789101112131415161718192021222324252627#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2019/6/11 22:03# @Author : thbelief# @Email : thbelief520@gmail.com# @File : Returns the function.py# @function: 返回函数的实例#code#函数作为返回值#简单定义一个返回原值的函数def test(tmp): return tmpprint(test("hello！"))#做一个闭包def test1(tmp): def test(): return tmp return testt=test1("hello，world！")#请注意下面两个的输出print(t);print(t());#返回函数不要引用任何循环变量，或者后续会发生变化的变量。他都会以最后一个为准。#返回的既可以是计算结果也可以是函数，如果返回的是函数的话，是未执行的函数。 输出 匿名函数关键字lambda表示匿名函数，冒号前面的x表示函数参数。 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。 实例： 1list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])) 输出： 1[1, 4, 9, 16, 25, 36, 49, 64, 81] 代码123456789101112131415#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2019/6/12 20:12# @Author : thbelief# @Email : thbelief520@gmail.com# @File : Anonymous functions.py# @function: 匿名函数的实例#codedef build(x, y): return lambda: x * x + y * yprint(build(1,2));#这里需要注意返回出来的匿名函数是函数test=build(1,2);print(test()); 输出 装饰器在代码运行期间动态增加功能方式——装饰器。 代码1234567891011121314151617181920212223242526#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2019/6/12 20:27# @Author : thbelief# @Email : thbelief520@gmail.com# @File : decorator.py# @function: 装饰器#code#装饰器 在代码运行期间动态增加功能方式——装饰器#先定义一个简单的函数def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper#这里的@相当于now = log(now)@logdef printFunction(): print("2019.6.12");# printFunction();#现在在上述的功能上添加一个打印日志的功能printFunction(); 输出 偏函数当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 代码12345678910111213141516171819202122#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2019/6/12 20:41# @Author : thbelief# @Email : thbelief520@gmail.com# @File : Partial function.py# @function: 偏函数#codeprint(int('123456'));#默认参数是base，作为进制转换print(int('123456',base=8));print(int('123456',8));#进制转换函数，这里是2进制def int2(x,base=2): return int(x,base);print(int2('101111'));#functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数。import functoolsint2 = functools.partial(int, base=2);print(int2('1011111')); 输出]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QQ空间批量删除说说（JS）]]></title>
    <url>%2F2019%2F06%2F13%2FQQ%E7%A9%BA%E9%97%B4%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E8%AF%B4%E8%AF%B4%EF%BC%88JS%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 下载 截图 代码 前言为了使用写的一个小东西，QQ空间网页版说说栏目下可以进行全自动化批量删除说说。 下载传送门 截图 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// ==UserScript==// @name QQ空间批量删除说说// @namespace none// @version 1.0.0// @description 主要用于在QQ空间网页版的说说栏目下进行批量删除说说// @author thbelief// @include *://user.qzone.qq.com/*// ==/UserScript==(function() &#123; 'use strict'; //延迟时间定义1s let delayTime = 1000; let isStart=false; //这个用来存setTimeout对象 var timeoutTmp; function deleteShuoShuo() &#123; //执行删除的方法 document.querySelector('.app_canvas_frame').contentDocument.querySelector('.del_btn').click(); setTimeout(toSureDelete, delayTime); console.log("删除说说+1"); &#125; function toSureDelete() &#123; if(isStart)&#123; //确定删除的方法 document.querySelector('.qz_dialog_layer_btn').click(); timeoutTmp=setTimeout(deleteShuoShuo, delayTime); &#125;else&#123; console.log("停止确定！"); alert("已停止删除说说功能！"); &#125; &#125; //调用此函数即可 document.onkeydown = function (e) &#123; if (!e) e = window.event; //如果是空格的话就执行 if ((e.keyCode || e.which) == 32) &#123; console.log("检测到 按下了空格键"); if(isStart)&#123; isStart=false; // clearTimeout(timeoutTmp); console.log("停止删除说说！"); &#125;else&#123; var r = confirm("是否批量删除说说？"); if (r == true) &#123; isStart=true; console.log("开始删除说说！"); deleteShuoShuo(); &#125; else &#123; console.log("取消删除说说！"); &#125; &#125; &#125; &#125;&#125;)();]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>QQ空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Renting Boats]]></title>
    <url>%2F2019%2F06%2F12%2FRenting-Boats%2F</url>
    <content type="text"><![CDATA[目录： Renting Boats 题目 输入 输出 样例输入复制 样例输出 思路 代码 结果 Renting Boats题目长江游艇俱乐部在长江上设置了n 个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&lt; =i&lt; j &lt; =n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n 所需的最少租金。 输入1第1 行中有1 个正整数n（n&lt;=200），表示有n个游艇出租站。接下来的n-1 行是r(i,j),1&lt; =i&lt; j &lt; =n。 输出1从游艇出租站1 到游艇出租站n所需的最少租金 样例输入复制12335 157 样例输出112 思路这是一道动态规划的题目，但是也可以使用蛮力法来做。 我们可以使用数组去存具体的租金，然后算每一段距离的租金之和，如果便宜的话就保存下来下次去比较，知道最后比较完肯定是最少租金的一种方法。 代码注意这里是多组输入！ 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int main()&#123; //首先是定义一个数组用来存放出租站的坐标，初始化为0 int coordinates[201][201]=&#123;0&#125;; int n;//出租站的总数 while(cin&gt;&gt;n)&#123; for(int i=1;i&lt;n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; cin&gt;&gt;coordinates[i][j]; //每一次判断之后都将最短距离放到1的位置，然后到最后输出这个值即可。 if(coordinates[1][j]&gt;coordinates[1][i]+coordinates[i][j])&#123; coordinates[1][j]=coordinates[1][i]+coordinates[i][j]; &#125; &#125; &#125; cout&lt;&lt;coordinates[1][n]&lt;&lt;endl; &#125; return 0;&#125; 结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Renting Boats</tag>
        <tag>SWUST OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome插件-Vimium]]></title>
    <url>%2F2019%2F06%2F11%2FChrome%E6%8F%92%E4%BB%B6-Vimium%2F</url>
    <content type="text"><![CDATA[目录： 下载链接 快捷键 官网 下载链接传送门 快捷键 官网Vimium官网]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Chrome插件</tag>
        <tag>效率神器</tag>
        <tag>Vimium</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boyer–Moore–Horspool algorithm]]></title>
    <url>%2F2019%2F06%2F10%2FBoyer%E2%80%93Moore%E2%80%93Horspool-algorithm%2F</url>
    <content type="text"><![CDATA[目录： Boyer–Moore–Horspool algorithm 题目介绍 输入 输出 样例输入 样例输出 代码 结果 参考资料 Boyer–Moore–Horspool algorithm题目介绍The Boyer–Moore string search algorithm is a particularly efficient string searching algorithm. It was developed by Bob Boyer and J Strother Moore in 1977. The algorithm preprocesses the target string (key) that is being searched for, but not the string being searched (unlike some algorithms which preprocess the string to be searched, and can then amortize the expense of the preprocessing by searching repeatedly). The execution time of the Boyer-Moore algorithm can actually be sub-linear: it doesn’t need to actually check every character of the string to be searched but rather skips over some of them. Generally the algorithm gets faster as the key being searched for becomes longer. Its efficiency derives from the fact that, with each unsuccessful attempt to find a match between the search string and the text it’s searching in, it uses the information gained from that attempt to rule out as many positions of the text as possible where the string could not match. How the algorithm works What people frequently find surprising about the Boyer-Moore algorithm when they first encounter it is that its verifications – its attempts to check whether a match exists at a particular position – work backwards. If it starts a search at the beginning of a text for the word “ANPANMAN”, for instance, it checks the eighth position of the text to see if it contains an “N”. If it finds the “N”, it moves to the seventh position to see if that contains the last “A” of the word, and so on until it checks the first position of the text for a “A”. Why Boyer-Moore takes this backward approach is clearer when we consider what happens if the verification fails – for instance, if instead of an “N” in the eighth position, we find an “X”. The “X” doesn’t appear anywhere in “ANPANMAN”, and this means there is no match for the search string at the very start of the text – or at the next seven positions following it, since those would all fall across the “X” as well. After checking just one character, we’re able to skip ahead and start looking for a match starting at the ninth position of the text, just after the “X”. This explains why the best-case performance of the algorithm, for a text of length N and a fixed pattern of length M, is N/M: in the best case, only one in M characters needs to be checked. This also explains the somewhat counter-intuitive result that the longer the pattern we are looking for, the faster the algorithm will be usually able to find it. The algorithm precomputes two tables to process the information it obtains in each failed verification: one table calculates how many positions ahead to start the next search based on the identity of the character that caused the match attempt to fail; the other makes a similar calculation based on how many characters were matched successfully before the match attempt failed. (Because these two tables return results indicating how far ahead in the text to “jump”, they are sometimes called “jump tables”, which should not be confused with the more common meaning of jump tables in computer science.) the first table The first table is easy to calculate: Start at the last character of the sought string and move towards the first character. Each time you move left, if the character you are on is not in the table already, add it; its Shift value is its distance from the rightmost character. All other characters receive a count equal to the length of the search string. Example: For the string ANPANMAN, the first table would be as shown (for clarity, entries are shown in the order they would be added to the table): The amount of shift calculated by the first table is sometimes called the “bad character shift”[1]. the second table The second table is slightly more difficult to calculate: for each value of i less than the length of the search string, we must first calculate the pattern consisting of the last i characters of the search string, preceded by a mis-match for the character before it; then we initially line it up with the search pattern and determine the least number of characters the partial pattern must be shifted left before the two patterns match. For instance, for the search string ANPANMAN, the table would be as follows: (N signifies any character that is not N) The amount of shift calculated by the second table is sometimes called the “good suffix shift”[2] or “(strong) good suffix rule”. The original published Boyer-Moor algorithm [1] uses a simpler, weaker, version of the good suffix rule in which each entry in the above table did not require a mis-match for the left-most character. This is sometimes called the “weak good suffix rule” and is not sufficient for proving that Boyer-Moore runs in linear worst-case time. Performance of the Boyer-Moore string search algorithm The worst-case to find all occurrences in a text needs approximately 3N comparisons, hence the complexity is O(n), regardless whether the text contains a match or not. The proof is due to Richard Cole, see R. COLE, Tight bounds on the complexity of the Boyer-Moore algorithm, Proceedings of the 2nd Annual ACM-SIAM Symposium on Discrete Algorithms, (1991) for details. This proof took some years to determine. In the year the algorithm was devised, 1977, the maximum number of comparisons was shown to be no more than 6N; in 1980 it was shown to be no more than 4*N, until Cole’s result in 1991. References 1. ^ R. S. Boyer; J. S. Moore (1977). “A fast string searching algorithm”. Comm. ACM 20: 762-772. 输入123two lines and only characters “ACGT” in the string.the first line is string (&lt; = 102000)the second line is text(&lt; = 700000) 输出12position of the string in textelse -1 样例输入12GGCCTCATATCTCTCTCCCATTGGCCTCATATCTCTCTCCCTCCCTCCCCTGCCCAGGCTGCTTGGCATGG 样例输出16 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;//全局变量 int table[26];void shiftTable(char str[]) &#123; //将字符串的长度赋值给lens int lens = strlen(str); table[str[lens - 1] - &apos;A&apos;] = lens; for (int i = 0; i &lt; lens - 1; i++) &#123; table[str[i] - &apos;A&apos;] = lens - i - 1; &#125;&#125;int horspoolMatch(char str[], char text[]) &#123; int i, k; int strlens = strlen(str); int textlens = strlen(text); i = strlens - 1; shiftTable(str); while(i &lt;= textlens - 1) &#123; //用来寻找text是否匹配好了 k = 0; while(str[strlens - 1 - k] == text[i - k] &amp;&amp; k &lt;= strlens - 1 ) &#123; k++; &#125; if (k == strlens) &#123; //直接返回下标 return i - strlens + 1; &#125; else &#123; //通过i自增控制匹配的位置 i += table[text[i] - &apos;A&apos;]; &#125; &#125; return -1;&#125;int main() &#123; int pos; //这里是题目的限制 char str[102001], text[700001]; cin&gt;&gt;str&gt;&gt;text; // Boyer–Moore–Horspool algorithm pos = horspoolMatch(str, text); cout&lt;&lt;pos&lt;&lt;endl; return 0;&#125; 结果 参考资料【模式匹配】更快的Boyer-Moore算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Boyer–Moore–Horspool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记（五）]]></title>
    <url>%2F2019%2F06%2F09%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 高阶函数 特性 map/reduce filter sorted 高阶函数特性变量可以指向函数。 函数名其实也是变量名。 函数可以接受另一个函数作为参数。 map/reducemap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 简单用法如下： 代码： 12test=list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))print(test) 输出： 1234D:\python.code\venv\Scripts\python.exe &quot;D:/python.code/Higher-order function.py&quot;[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;]Process finished with exit code 0 reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。 reduce更多的是和其他的高阶函数配合使用，效果极佳。 简单实例： 12345678from functools import reducedef add(x, y): return x + ytest1=reduce(add, [1, 3, 5, 7, 9])print(test1) 输出： 125 filter作用是过滤。 filter()也是接受两个参数——一个函数一个序列，把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 值得注意的是——由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。 sortedsort是一个高阶函数，可以接收一个key函数来实现自定义的排序。 简单实例： 123#排序test=sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower)print(test)]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>高阶函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记（四）]]></title>
    <url>%2F2019%2F06%2F08%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 高级特性 切片 迭代 列表生成器 生成器 迭代器 高级特性之前已经提到过关于Python的一部分特性了，众所周知，Python不是说代码越多越复杂越好，需要的是更方便的解决问题以最少的代码最优的解法是最好的，这也是高级特性的来源。 切片在其它编译语言中如果要获得一个集合中的一部分元素我们通常的操作都是直接循环然后取，但是Python中有更方便的方式——切片——取指定索引范围的操作。 简单实例： 简单解释： Test[0:2]代表的是从索引0开始然后直到索引2为止（不包括索引2），在图中的实例中可以看到刚好两个元素。 特性： 既然正序可以，那么逆序（从后向前）也是可以的，但是注意，倒序（逆序）的时候——倒数第一个元素的索引是-1。 list与tuple都可以切片操作，但是tuple切片出来还是tuple。 对于字符串来说，切片也是可以使用的，某些地方可以使用切片来模拟Python本身提供的有些字符串函数，只是字符串切片出来之后也还是字符串。 迭代迭代这个词语其实也不陌生，平时熟悉的for循环遍历数组其实就是迭代。 但是在for循环中我们还有下标来执行迭代，在Python中有些可迭代对象却无法有下标，所以这就产生了Python特有的迭代。 判断是否可迭代： 通过collections模块的Iterable类型判断。 1234from collections.abc import Iterableprint(isinstance(&apos;thbelief&apos;,Iterable))print(isinstance([&apos;a&apos;,&apos;v&apos;],Iterable))print(isinstance(520,Iterable)) 输出： 123456D:\python.code\venv\Scripts\python.exe &quot;D:/python.code/Advanced features - iteration.py&quot;TrueTrueFalseProcess finished with exit code 0 当然，也不是不可以通过下标类似的方法来访问： Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： 12for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]): print(i, value) 结果： 列表生成器一个快捷生成list的生成式。 123456789#Code# 简单的生成式test=list(range(1,10))print(test)# 自定义生成式test=list(x*x for x in range(1,10))print(test)test=list(x*x for x in range(1,10) if x%3==0)print(test) 自定义生成式其实可以套多重循环来筛选等等，这里只是简单的介绍一下。 生成器Python中提供的一边循环一边计算的机制。 来源：通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。如果一边循环一边计算就很方便了。 生成器的元素是不可以直接打印每一个元素的。 123456#正常列表生成式test=[x * x for x in range(10)]print(test)#创建生成器test=(x * x for x in range(10))print(test) 结果： 12345D:\python.code\venv\Scripts\python.exe &quot;D:/python.code/Advanced features - generator.py&quot;[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&lt;generator object &lt;genexpr&gt; at 0x00000297D47BAA98&gt;Process finished with exit code 0 为什么会出现这种情况呢？前面说过生成器是边循环边计算。 使用： 123456789101112#创建生成器test=(x * x for x in range(10))print(test)#第一种就是单纯的next下去print(&quot;next:&quot;)print(next(test))print(next(test))print(next(test))#第二种是循环print(&quot;循环&quot;)for i in test: print(i) 结果： 迭代器可以直接作用于for循环的对象统称为可迭代对象：Iterable。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 判断是否是一个迭代器对象： 1234from collections.abc import Iteratorprint(isinstance((x for x in range(10)), Iterator))print(isinstance(&apos;abc&apos;, Iterator)) 12TrueFalse Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>高级特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长公共子串动态规划解法]]></title>
    <url>%2F2019%2F06%2F07%2F%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录： 定义 效果 代码 定义所谓的最大子序列即：只要前i项的和还没有小于0那么子序列就一直向后扩展，否则丢弃之前的子序列开始新的子序列，同时我们要记下各个子序列的和，最后找到和最大的子序列。 效果 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;int main() &#123; string str1,str2; //字符串AB的输入（其实也可以自己改进为从文本读入） cout&lt;&lt;&quot;字符串A：&quot;; cin&gt;&gt;str1; cout&lt;&lt;&quot;字符串B：&quot;; cin&gt;&gt;str2; int row = 0; int col = str2.size(); int end_index=0;//最后一个的下标 int max_len = 0;//最长子串长度 while(row &lt; str1.size()) &#123; int i = row; int j = col; int pre = 0; while(i&lt;str1.size()&amp;&amp; j &lt;str2.size()) &#123; if(str1[i]==str2[j]) &#123; pre+=1; if(pre&gt;max_len) &#123; max_len = pre; end_index = i; &#125; &#125; else &#123; pre =0; &#125; i++; j++; &#125; if(col &gt;0) &#123; col --; &#125; else &#123; row ++; &#125; &#125; cout&lt;&lt;&quot;字符串AB的最长公共子串：&quot;&lt;&lt;endl; for(int i =end_index -max_len+1; i&lt;=end_index; i++) cout&lt;&lt;str1[i]; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>最长公共子串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BiliBili全屏弹幕发送(回车)]]></title>
    <url>%2F2019%2F06%2F06%2FBiliBili%E5%85%A8%E5%B1%8F%E5%BC%B9%E5%B9%95%E5%8F%91%E9%80%81-%E5%9B%9E%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 简单介绍 功能介绍 使用方法 源码地址 源码 前言今天闲得无聊，为了娱乐一下，写了一个脚本。 正文简单介绍 脚本链接：传送门 功能介绍在B站看视频的时候全屏状态下默认是不能发送弹幕的，这个脚本的功能就是在全屏状态下回车键弹出发送弹幕的sendbar~ 使用方法在全屏状态下回车即可弹出弹幕发送框。直接输入想发送的句子，再回车即可发送出去并且默认关闭此弹幕发送框。 源码地址​ https://github.com/thbelief/BiliBili-Full-screen-barrage 欢迎去fork或者star~ 源码可能后面还会更新，看情况吧~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// ==UserScript==// @name BiliBili全屏弹幕发送(回车)// @namespace https://github.com/thbelief/BiliBili-Full-screen-barrage// @version 1.0.0// @description 在B站看视频的时候全屏状态下默认是不能发送弹幕的，这个脚本的功能就是在全屏状态下回车键弹出发送弹幕的sendbar~// @author thbelief// @match *://www.bilibili.com/bangumi/play/ep*// @match *://www.bilibili.com/bangumi/play/ss*// @match *://www.bilibili.com/video/av*// @match *://www.bilibili.com/watchlater/*// @grant GM_setValue// @grant GM_getValue// ==/UserScript==(function() &#123; 'use strict'; //选择 const q = function (selector) &#123; let nodes = []; if (typeof selector === 'string') &#123; Object.assign(nodes, document.querySelectorAll(selector)); nodes.selectorStr = selector; &#125; else if (selector instanceof NodeList) &#123; Object.assign(nodes, selector); &#125; else if (selector instanceof Node) &#123; nodes = [selector]; &#125; nodes.click = function (index = 0) &#123; nodes.length &gt; index &amp;&amp; nodes[index].click(); return this; &#125; nodes.addClass = function (classes, index = 0) &#123; nodes.length &gt; index &amp;&amp; nodes[index].classList.add(classes); return this; &#125; nodes.removeClass = function (classes, index = 0) &#123; nodes.length &gt; index &amp;&amp; nodes[index].classList.remove(classes); return this; &#125; nodes.css = function (name, value, index = 0) &#123; nodes.length &gt; index &amp;&amp; nodes[index].style.setProperty(name, value); return this; &#125; nodes.getCss = function (name, index = 0) &#123; return nodes.length &gt; index &amp;&amp; nodes[index].ownerDocument.defaultView.getComputedStyle(nodes[index], null).getPropertyValue(name); &#125; return nodes; &#125; let isSendBarExist=false; function doIt()&#123; //监控是否按下回车键 document.onkeydown = function (eTest) &#123; if (!eTest) eTest = window.event; if ((eTest.keyCode || eTest.which) == 13) &#123; // 判断是否是全屏 let isFullScreen = document.isFullScreen || document.mozIsFullScreen || document.webkitIsFullScreen; console.log("是否全屏状态："+isFullScreen); function fun()&#123; console.log("提示：在全屏状态下按了回车键！"); if(isSendBarExist)&#123; isSendBarExist=false; console.log("提示：已隐藏发送弹幕按钮！"); q('.bilibili-player-video-sendbar').css('opacity', 0).css('display', 'none')[0]; &#125;else&#123; isSendBarExist=true; console.log("提示：已显示发送弹幕按钮！"); //老版 q('.bilibili-player-video-sendbar').css('opacity', 1).css('display', 'flex'); //使输入框自动获得焦点 $('input').focus(); &#125; &#125;; if(isFullScreen)&#123; //如果是全屏状态的话，就进行回车键弹出发送弹幕的效果 fun(); &#125;else&#123; console.log("提示：未进入全屏状态！"); &#125; &#125; &#125; &#125; doIt(); &#125;)();]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(十八)]]></title>
    <url>%2F2019%2F06%2F05%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%85%AB%2F</url>
    <content type="text"><![CDATA[目录： underscore库 简单介绍 Collections map/filter every/some max/min groupBy shuffle / sample Arrays first/last flatten zip/unzip object range Functions Objects Chaining underscore库简单介绍JS是函数式的编程语言，支持高阶函数以及闭包，为了更方便的使用函数式的编程以及尽量减少浏览器之间的差异，这里就应运而生了这个库。 还有就是，这个库绑定之后是可以直接通过object使用的，而原生的array的方法不能直接给object使用，这也是它的优势所在。 underscore会把自身绑定到唯一的全局变量_上，这也是它名字的来源（下划线）。 Collectionscollections是集合类（Array+Object），underscore为集合类提供了对应的接口。 map/filter和原本的Array的map/filter是类似的，但是underscore的是支持object的，当作用给object的时候，传入的函数是： (第一个参数是value，第二个参数是key) 1function (value, key) 简单实例如下： 1234567891011&apos;use strict&apos;;var obj = &#123; name: &apos;thbelief&apos;, school: &apos;test school&apos;, address: &apos;XI road&apos;&#125;;var upper = _.map(obj, function (value, key) &#123; return ???;&#125;); every/some当集合的所有元素都满足条件时，.every()函数返回true，当集合的至少一个元素满足条件时，.some()函数返回true. max/min这两个函数就是返回当前集合中的最大/最小数。 groupBygroupBy()把集合的元素按照key归类。（key由传入的函数返回） shuffle / sampleshuffle()用洗牌算法随机打乱一个集合，sample()则是随机选择一个或多个元素。 Arraysunderscore为Array专门的提供了许多的工具类方法，很方便实用。 first/last取第一个和最后一个元素。 flatten这个函数会接收一个Array，无论这个Array里面嵌套多少的Array，最后都会被这个函数给变成一个一维数组。 zip/unzipzip()会把两个或多个数组的所有元素按索引对齐，然后按索引合并成新数组。 unzip()的作用和zip刚好相反。 object这个只是和JS中的对象object同名，但是是个函数。 将元素一一对应成object。 简单实例： 12345&apos;use strict&apos;;var names = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;];var scores = [85, 92, 59];_.object(names, scores); range快速生成一个序列。（神奇，取代for循环） Functions12345bind 修复当使用一个变量指向一个对象的方法时，出现的无法直接调用该方法的问题。(丢失this对象引用)partial 一个函数创建偏函数。memoize 自动缓存函数计算结果。once 保证某个函数执行且仅执行一次。delay 让一个函数延时执行。（和setTimeout差不多） Objects123456789keys 返回一个object自身所有的key，但不包含从原型链继承下来的.allKeys 返回除了object自身的key，还包含从原型链继承下来的，即所有的。values 返回object自身但不包含原型链继承的所有值。mapObject 针对object的map版本。invert 把object的每个key-value来个交换，key变成value，value变成key。extend 把多个object的key-value合并到第一个object并返回。extendOwn 把多个object的key-value合并到第一个object并返回。（忽略获取属性时忽略从原型链继承下来的属性）clone 把原有对象的所有属性都复制到新的对象。isEqual 对两个object进行深度比较，如果内容完全相同，则返回true。（Array其实也可以使用） Chainingunderscore其实也是支持链式调用的。使用的方法是——chain()。 简单实例： 1234var r = _.chain([1, 4, 9, 16, 25]) .map(Math.sqrt) .filter(x =&gt; x % 2 === 1) .value(); 值得注意的是——由于每一步返回的都是对象，所以最后一步的结果必须通过value方法来获得最终的结果。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>underscore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-USBPrompt开发]]></title>
    <url>%2F2019%2F06%2F04%2FAndroid-USBPrompt%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[目录： USBPrompt 下载网址 开源项目 简单介绍 关键代码 效果 USBPrompt今天花费几个小时写的一个小东西，主要就是娱乐用的，还是蛮开心的啊哈哈~ 下载网址传送门 开源项目传送门 欢迎fork或者star~ 简单介绍这个软件其实是个不怎么正经的软件，当然灵感来源就不说了，只是单纯的充电宝插拔的时候启发了我。 实现起来很简单——检测电源插拔，加载相应的mp3文件就可以了，别问我哪里来的资源文件，咳咳。 关键代码这个类用于检测电源情况，主要是为了扩展写这么多。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * @ProjectName: USBPrompt * @Package: com.example.usbprompt * @ClassName: BatteryListener * @Description: 电源监测 * @Author: thbelief * @CreateDate: 2019/6/3 12:30 */public class BatteryListener &#123; private Context mContext; private BatteryBroadcastReceiver receiver; private BatteryStateListener mBatteryStateListener; public BatteryListener(Context context) &#123; mContext = context; receiver = new BatteryBroadcastReceiver(); &#125; public void register(BatteryStateListener listener) &#123; mBatteryStateListener = listener; if (receiver != null) &#123; IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_BATTERY_CHANGED); filter.addAction(Intent.ACTION_BATTERY_LOW); filter.addAction(Intent.ACTION_BATTERY_OKAY); filter.addAction(Intent.ACTION_POWER_CONNECTED); filter.addAction(Intent.ACTION_POWER_DISCONNECTED); mContext.registerReceiver(receiver, filter); &#125; &#125; public void unregister() &#123; if (receiver != null) &#123; mContext.unregisterReceiver(receiver); &#125; &#125; private class BatteryBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent != null) &#123; String acyion = intent.getAction(); switch (acyion) &#123; case Intent.ACTION_BATTERY_CHANGED://电量发生改变 if (mBatteryStateListener != null) &#123; Log.e(&quot;thbelief&quot;, &quot;BatteryBroadcastReceiver --&gt; onReceive--&gt; ACTION_BATTERY_CHANGED&quot;); mBatteryStateListener.onStateChanged(); &#125; break; case Intent.ACTION_BATTERY_LOW://电量低 if (mBatteryStateListener != null) &#123; Log.e(&quot;thbelief&quot;, &quot;BatteryBroadcastReceiver --&gt; onReceive--&gt; ACTION_BATTERY_LOW&quot;); mBatteryStateListener.onStateLow(); &#125; break; case Intent.ACTION_BATTERY_OKAY://电量充满 if (mBatteryStateListener != null) &#123; Log.e(&quot;thbelief&quot;, &quot;BatteryBroadcastReceiver --&gt; onReceive--&gt; ACTION_BATTERY_OKAY&quot;); mBatteryStateListener.onStateOkay(); &#125; break; case Intent.ACTION_POWER_CONNECTED://接通电源 if (mBatteryStateListener != null) &#123; Log.e(&quot;thbelief&quot;, &quot;BatteryBroadcastReceiver --&gt; onReceive--&gt; ACTION_POWER_CONNECTED&quot;); mBatteryStateListener.onStatePowerConnected(); &#125; break; case Intent.ACTION_POWER_DISCONNECTED://拔出电源 if (mBatteryStateListener != null) &#123; Log.e(&quot;thbelief&quot;, &quot;BatteryBroadcastReceiver --&gt; onReceive--&gt; ACTION_POWER_DISCONNECTED&quot;); mBatteryStateListener.onStatePowerDisconnected(); &#125; break; &#125; &#125; &#125; &#125; public interface BatteryStateListener &#123; public void onStateChanged(); public void onStateLow(); public void onStateOkay(); public void onStatePowerConnected(); public void onStatePowerDisconnected(); &#125;&#125; 下面这个就是主活动： 由于是简单的一个APP，这里就没有用什么框架了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class MainActivity extends AppCompatActivity &#123; private MediaPlayer mediaPlayerInput,mediaPlayerOutput; private BatteryListener listener; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //隐藏标题栏Actionbar if (getSupportActionBar() != null)&#123; getSupportActionBar().hide(); &#125; //提示信息dialog final NiftyDialogBuilder dialogBuilder=NiftyDialogBuilder.getInstance(this); dialogBuilder .withTitle(&quot;警告!&quot;) .withMessage(&quot;本软件请勿在公共场合打开，如有差错导致悲惨的后果，本人概不负责！&quot;) .withDialogColor(&quot;#FFB6C1&quot;) .withMessageColor(&quot;#ffffff&quot;) .withButton1Text(&quot;知道了&quot;) .withEffect(Newspager) .setButton1Click(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dialogBuilder.cancel(); &#125; &#125;) .show(); //监听媒体音量方便判断是否手机静音 AudioManager audioManager = (AudioManager)getSystemService(Context.AUDIO_SERVICE); int currentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC); if(currentVolume==0) Toast.makeText(MainActivity.this, &quot;手机静音，不能正常提示，请调大音量！&quot;, Toast.LENGTH_LONG).show(); //电源插拔 listener = new BatteryListener(this); //播放MP3 mediaPlayerInput=MediaPlayer.create(this,R.raw.jiaochuan1); mediaPlayerOutput=MediaPlayer.create(this,R.raw.jiaochuan2); button=findViewById(R.id.btn); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this,button.getText(), Toast.LENGTH_SHORT).show(); if(button.getText().toString().equals(&quot;CLOSE&quot;))&#123; button.setText(&quot;OPEN&quot;); Toast.makeText(MainActivity.this, &quot;超级电源插拔提示已部署！&quot;, Toast.LENGTH_SHORT).show(); listener.register(new BatteryListener.BatteryStateListener() &#123; @Override public void onStateChanged() &#123; Log.e(&quot;thbelief&quot;, &quot;MainActivity --&gt; onStateChanged--&gt; &quot;); &#125; @Override public void onStateLow() &#123; Log.e(&quot;thbelief&quot;, &quot;MainActivity --&gt; onStateLow--&gt; &quot;); Toast.makeText(MainActivity.this, &quot;电源降低！&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onStateOkay() &#123; Log.e(&quot;thbelief&quot;, &quot;MainActivity --&gt; onStateOkay--&gt; &quot;); Toast.makeText(MainActivity.this, &quot;电源充满！&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onStatePowerConnected() &#123; Log.e(&quot;thbelief&quot;, &quot;MainActivity --&gt; onStatePowerConnected--&gt; &quot;); Toast.makeText(MainActivity.this, &quot;电源插入！&quot;, Toast.LENGTH_SHORT).show(); if(mediaPlayerOutput.isPlaying()) &#123; mediaPlayerOutput.stop(); mediaPlayerInput.start(); &#125;else&#123; mediaPlayerInput.start(); &#125; &#125; @Override public void onStatePowerDisconnected() &#123; Log.e(&quot;thbelief&quot;, &quot;MainActivity --&gt; onStatePowerDisconnected--&gt; &quot;); Toast.makeText(MainActivity.this, &quot;电源拔出！&quot;, Toast.LENGTH_SHORT).show(); if(mediaPlayerInput.isPlaying()) &#123; mediaPlayerInput.stop(); mediaPlayerOutput.start(); &#125;else&#123; mediaPlayerOutput.start(); &#125; &#125; &#125;); &#125;else if (button.getText().toString().equals(&quot;OPEN&quot;))&#123; button.setText(&quot;CLOSE&quot;); Toast.makeText(MainActivity.this, &quot;超级电源插拔提示已取消！&quot;, Toast.LENGTH_SHORT).show(); if (listener != null) &#123; listener.unregister(); &#125; &#125; &#125; &#125;); &#125; @Override protected void onDestroy() &#123; if (listener != null) &#123; listener.unregister(); &#125; super.onDestroy(); &#125;&#125; 效果]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>USBPrompt</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-安装Gradle报错解决]]></title>
    <url>%2F2019%2F06%2F03%2FAndroid-%E5%AE%89%E8%A3%85Gradle%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[目录： 前言 原因 解决方案 前言今天升级了AndroidStudio之后提示需要重新安装Gradle相关的东西，由于国内的不知名原因导致速度很慢很慢。设置了国内的HTTP代理之后报错： 1Could not GET &apos;https://dl.google.com/dl/android/maven2/com/android/support/appcompat-v7/28.0.0/appcompat-v7-28.0.0.pom&apos;. Received status code 400 from server: Bad Request Enable Gradle &apos;offline mode&apos; and sync project 原因设置代理的地方如下： 如下图可知，由于使用的是国内的镜像代理，这里涉及到一个https与http的差异，这里涉及到的就是这个问题。 解决方案直接在Android目录下找到gradle.properties这个文件打开，会发现图中两个https的，注释掉之后重新编译之后就可以发现项目不会出现问题了。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>报错</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-APK反编译]]></title>
    <url>%2F2019%2F06%2F02%2FAndroid-APK%E5%8F%8D%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[目录： 前言 准备 apktool dex2jar jd-gui/jadx-gui 使用 反编译apk获得资源文件 反编译apk获得java源码 前言反编译不是拿来做歪门邪道的，只是拿来学习。 准备首先是下载好下面三个工具： apktool这个是获取资源的，可以提取出图片文件以及布局文件进行查看。 apktool官网 需要注意一点——下载的时候不只是下载jar，还需要下载apktool.bat。具体的就看官网的安装说明即可。 下载完成之后将两个文件保存到自己找到的的位置，我是放在D盘下面的apktool文件夹。 之后就根据自己放的位置配置环境变量。 dex2jar下载网址 它的作用是将apk反编译为java源码（classes.dex转化成jar文件）。 下载之后同样配置好环境变量。 jd-gui/jadx-gui上面两个图形化界面随便选一个都可以。 jd-gui下载网址 它的作用是查看APK中classes.dex转化成出的jar文件，即源码文件。 下载之后放到自己知道的位置，方便之后使用。 使用测试是在WIn10的环境下面进行的。 反编译apk获得资源文件打开cmd，定位到apktool文件夹下面，把要反编译的apk放到这个文件夹下面，这里的命令格式如下： 1apktool d THBELIEFScript.apk_5.2.0.apk //这里的apk名字是我自己开发的apk名字 效果如下： 生成的同名文件夹即资源文件存放的位置。 反编译apk获得java源码首先是将apk后缀的安装包改后缀为.zip或者.rar然后解压。找到其中的classes.dex文件。（这个文件是后面要用的，必须找到），然后将该文件放到D:\dex2\dex2jar-2.0（这个是我自己解压之后dex2放的文件夹）下面。 通过命令行定位过去，输入以下命令： 1d2j-dex2jar.bat classed.dex //这里的d2j-dex2jar.bat是我这个版本的，其他版本的换一下就行了 输入之后回车会在该目录下面生成一个classes_dex2jar.jar文件。然后通过jd-gui打开就可以直接看到源码了。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>反编译</tag>
        <tag>APK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(十七)]]></title>
    <url>%2F2019%2F06%2F01%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%83%2F</url>
    <content type="text"><![CDATA[目录： 错误处理 类型 逻辑错误 异常错误 处理 try … catch … finally 错误类型 抛出错误 错误传播 异步错误处理 错误处理和其它的编译语言一样，JS写的过程中难免的也会出现一些错误，这个就涉及到错误的处理部分了，其实这个部分和JAVA有点儿类似，具体的就下面的部分详细说吧。 类型逻辑错误写程序的过程中出现了逻辑的错误导致的代码异常。 简单实例如下： 12var s = null;var len = s.length; // TypeError：null变量没有length属性 异常错误这个是执行过程中遇到的无法预测的异常出现的错误，比如——网络连接突然中断等等这些意料之外的错误。 处理一般来说，对于底层语言来说，错误是通过错误码来返回的。这就涉及到返回的值是否正确的判别了，可以预见，这种使用方法其实是十分的不方便的，所以在一些高级语言中使用的是另外的方法。 try … catch … finally简单实例： 123456789101112&apos;use strict&apos;;var r1, r2, s = null;try &#123; r1 = s.length; // 此处应产生错误 r2 = 100; // 该语句不会执行&#125; catch (e) &#123; console.log(&apos;出错了：&apos; + e);&#125; finally &#123; console.log(&apos;finally&apos;);&#125;console.log(&apos;r1 = &apos; + r1); // r1应为undefinedconsole.log(&apos;r2 = &apos; + r2); // r2应为undefined 执行流程如下： 当代码块被try { … }包裹的时候，就表示这部分代码执行过程中可能会发生错误，一旦发生错误，就不再继续执行后续代码，转而跳到catch块。catch (e) { … }包裹的代码就是错误处理代码，变量e表示捕获到的错误。最后，无论有没有错误，finally一定会被执行。 所以，有错误发生时，执行流程像这样： 先执行try { … }的代码；执行到出错的语句时，后续语句不再继续执行，转而执行catch (e) { … }代码；最后执行finally { … }代码。而没有错误发生时，执行流程像这样： 先执行try { … }的代码；因为没有出错，catch (e) { … }代码不会被执行；最后执行finally { … }代码。 错误类型JavaScript有一个标准的Error对象表示错误，还有从Error派生的TypeError、ReferenceError等错误对象。 抛出错误程序也可以主动抛出一个错误，让执行流程直接跳转到catch块。抛出错误使用throw语句。 错误传播如果代码出现了错误，但是又没有被try…catch捕获的话，程序会跳到哪里去呢？ 答案是会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。 所以正确的操作是——不在每一个函数内部捕获错误，只需要在合适的地方进行统一的捕获即可，一网打尽！ 具体的地方的话还是需要看具体的情况，不能一概而论。 异步错误处理JavaScript引擎是一个事件驱动的执行引擎，代码总是以单线程执行，而回调函数的执行需要等到下一个满足条件的事件出现后，才会被执行。 需要注意的就是——涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(十六)]]></title>
    <url>%2F2019%2F05%2F31%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%85%AD%2F</url>
    <content type="text"><![CDATA[目录： j-Query AJAX 简单介绍 get post getJSON 安全限制 j-QueryAJAX和前面博客提到的原因差不多，由于不同浏览器之间存在的差异，写出的代码其实也是千奇百怪。 j-Query其实也可以写AJAX，也很方便。 简单介绍j-Query在全局对象j-Query（$）绑定了ajax()函数，可以处理AJAX请求。 ajax(url, settings)函数需要接收一个URL和一个可选的settings对象。 常用选项： 1234567891011async：是否异步执行AJAX请求，默认为true，千万不要指定为false；method：发送的Method，缺省为&apos;GET&apos;，可指定为&apos;POST&apos;、&apos;PUT&apos;等；contentType：发送POST请求的格式，默认值为&apos;application/x-www-form-urlencoded; charset=UTF-8&apos;，也可以指定为text/plain、application/json；data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据contentType把data序列化成合适的格式；headers：发送的额外的HTTP头，必须是一个object；dataType：接收的数据格式，可以指定为&apos;html&apos;、&apos;xml&apos;、&apos;json&apos;、&apos;text&apos;等，缺省情况下根据响应的Content-Type猜测。 如何使用回调函数处理返回的数据和出错时候的响应呢？——j-Query的jqXHR对象类似于之前提到过的Promise对象，可以通过各种链式的写法来处理各种回调。 get常用的AJAX在j-Query中都提供了相应的辅助方法。 1234var jqxhr = $.get(&apos;/path/to/resource&apos;, &#123; name: &apos;Bob Lee&apos;, check: 1&#125;); post和get是类似的，但是需要注意的就是传入的第二个参数被序列化为application/x-www-form-urlencoded： 1234var jqxhr = $.post(&apos;/path/to/resource&apos;, &#123; name: &apos;Bob Lee&apos;, check: 1&#125;); getJSON123456var jqxhr = $.getJSON(&apos;/path/to/resource&apos;, &#123; name: &apos;Bob Lee&apos;, check: 1&#125;).done(function (data) &#123; // data已经被解析为JSON对象了&#125;); 安全限制由于j-Query中AJAX完全是封装的JS中的AJAX操作，所以安全限制和前面学习过的是一模一样的。 值得注意的是，如果需要使用JSONP的话，可以在ajax()中设置jsonp:’callback’,让j-Query实现JSONP的跨域加载数据。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>AJAX</tag>
        <tag>j-Query</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(十五)]]></title>
    <url>%2F2019%2F05%2F30%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%94%2F</url>
    <content type="text"><![CDATA[目录: j-Query 动画 show / hide slideUp / slideDown fadeIn / fadeOut 自定义 串行动画 j-Query动画用JS实现动画的代码其实写起来还是非常麻烦的。 使用j-Query实现动画效果的原理：以固定的时间间隔每次修改Dom元素的CSS样式，看起来也就是动画了。 show / hide前面的博客里面已经提到过，如果无参数调用这两个方法的话，其实就是显示和隐藏Dom元素，但是这里可以直接传入一个时间参数（可以是毫秒也可以是slow/fast这种字符串），这就变成了动画~~~ 12var div = $(&apos;#testShowHide&apos;);div.hide(3000); // 在3秒钟内这个Dom元素会逐渐消失 toggle()方法根据当前的状态选择是show还是hide~ 实例如下： hide(‘slow’) show(‘slow’) slideUp / slideDown上面的实例中可以清晰的看到show和hide是从左上角逐渐展开或者收缩的，而slideUp / slideDown是从垂直方向进行展开或者收缩的。 其实就相当于拉窗帘？ slideToggle()根据元素是否可见来决定下一步的操作。 12var div = $(&apos;#testSlide&apos;);div.slideUp(3000); // 在3秒钟内逐渐向上消失 slideUp(‘slow’) slideDown(‘slow’) fadeIn / fadeOutfadeIn / fadeOut的动画效果是淡入淡出，原理其实就是不断的设置Dom元素的opacity属性。 fadeToggle()则根据元素是否可见来决定下一步操作。 12var div = $(&apos;#testFade&apos;);div.fadeOut(&apos;slow&apos;); // 在0.6秒内淡出 简单实例： fadeOut(‘slow’) fadeIn(‘slow’) 自定义上面的效果其实都是很简单很基础的效果，其实真正好看的动画大部分都是自定义的。 animate()方法可以实现任意动画效果，需要传入的参数是DOM元素最终的CSS状态和时间，j-Query将在时间段内不断调整CSS直到达到预设的值。 123456var div = $(&apos;#testAnimate&apos;);div.animate(&#123; opacity: 0.25, width: &apos;256px&apos;, height: &apos;256px&apos;&#125;, 3000); // 在3秒钟内CSS过渡到设定值（注意这里是过渡~） 这个方法还可以传入一个函数，动画结束的时候将调用此函数。 其实可以看做是回调函数。 12345678910var div = $(&apos;#testAnimate&apos;);div.animate(&#123; opacity: 0.25, width: &apos;256px&apos;, height: &apos;256px&apos;&#125;, 3000, function () &#123; console.log(&apos;动画结束！&apos;); // 恢复至初始化状态: $(this).css(&apos;opacity&apos;, &apos;1.0&apos;).css(&apos;width&apos;, &apos;128px&apos;).css(&apos;height&apos;, &apos;128px&apos;);&#125;); 串行动画j-Query动画可以实现串行动画，其实就是有暂停（通过delay方法实现）。 注意，由于动画需要执行的时间，所以j-Query必须不断的返回Promise对象才能进行后续操作。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>j-Query</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(十四)]]></title>
    <url>%2F2019%2F05%2F29%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[目录: j-Query 事件 简单介绍 简单实例 事件种类 鼠标事件 键盘事件 其它事件 事件参数 取消绑定 事件触发条件 浏览器安全限制 j-Query事件简单介绍JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，就只能依赖触发事件来执行JavaScript代码。 浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的DOM节点上触发相应的事件。如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。 在j-Query没有出现之前，因为浏览器的差异导致的结果就是如果浏览器不同的话，想要实现一样的效果，需要实现不同的代码，但是现在只需要写统一的代码即可。 简单实例 点击这里！ 上面只是一个html中的定义，下面这个代码是上面这个绑定的事件。可以自行测试。 1234var a = $('#test-link');a.on('click', function () &#123; alert('Hello!');&#125;); 当然，上面的写法on是用来绑定事件的，需要传入事件的名称以及对应的处理函数。 还有一种写法是之前Auto.js之中提到过的click方法。 123a.click(function () &#123; alert(&apos;Hello!&apos;);&#125;); on方法和click方法是完全等价的。 事件种类鼠标事件123456click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。 键盘事件12345键盘事件仅作用在当前焦点的DOM上，通常是&lt;input&gt;和&lt;textarea&gt;。keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发。 其它事件12345focus：当DOM获得焦点时触发； blur：当DOM失去焦点时触发； change：当&lt;input&gt;、&lt;select&gt;或&lt;textarea&gt;的内容改变时触发； submit：当&lt;form&gt;提交时触发； ready：当页面被载入并且DOM树完成初始化后触发。 注意，ready仅作用于document对象。由于ready事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。 事件参数有些事件，如mousemove和keypress，必须获取鼠标位置和按键的值，所有事件都会传入Event对象作为参数。 取消绑定一个已被绑定的事件可以解除绑定，通过off(‘click’, function)实现。 无参数调用off()一次性移除已绑定的所有类型的事件处理函数。 事件触发条件事件的触发总是由用户操作引发的。 当用户在文本框中输入时，就会触发change事件。但是，如果用JavaScript代码去改动文本框的值，将不会触发change事件。这就很蛋疼了，有些时候我们希望使用JS代码去触发（脚本原理）。 用代码触发change事件，可以直接调用无参数的change()方法来触发该事件： 123var input = $(&apos;#test-input&apos;);input.val(&apos;change it!&apos;);input.change(); // 触发change事件 浏览器安全限制在浏览器中，有些JavaScript代码只有在用户触发下才能执行。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>j-Query</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(十三)]]></title>
    <url>%2F2019%2F05%2F28%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[j-Query上一篇博客其实关于j-Query的基本含义以及如何获得j-Query对象说的很清楚了，现在要说的就是关于拿到对象之后的使用方法了——操作Dom节点。 操作Dom修改Text和HTMLj-Query对象的text()和html()方法分别获取节点的文本和原始HTML文本。 原本的HTML结构如下： 12345&lt;!-- HTML结构 --&gt;&lt;ul id=&quot;test-ul&quot;&gt; &lt;li class=&quot;js&quot;&gt;JavaScript&lt;/li&gt; &lt;li name=&quot;book&quot;&gt;Java &amp;amp; JavaScript&lt;/li&gt;&lt;/ul&gt; 获取相应的文本和HTML： 12$(&apos;#test-ul li[name=book]&apos;).text(); // &apos;Java &amp; JavaScript&apos;$(&apos;#test-ul li[name=book]&apos;).html(); // &apos;Java &amp;amp; JavaScript&apos; 如何设置文本或者HTML呢？ 其实这个很简单，在j-Query中无参数调用text()是获取文本，传入参数就变成设置文本，HTML也是类似操作。 一个j-Query对象可以包含0个或任意个DOM对象，它的方法实际上会作用在对应的DOM节点上。意思其实就是，如果对一个j-Query对象进行了操作的话，它包含的所有的Dom对象都会被修改。 j-Query对象有一个好处是用户可以执行一个操作，作用在对应的一组DOM节点上。即使选择器没有返回任何DOM节点，调用j-Query对象的方法仍然不会报错： 12// 如果不存在id为thbelief的节点：$(&apos;#thbelief&apos;).text(&apos;Hello&apos;); // 代码不报错，没有节点被设置为&apos;Hello&apos; 这个操作其实是很有必要的，因为可以省去很多的if语句。 修改CSS从上面的修改Dom节点就可以看出，其实j-Query其实是有批量操作的特性的。 j-Query对象的所有方法都返回一个j-Query对象（可能是新的也可能是自身），这样可以进行链式调用。 1234var div = $(&apos;#test-div&apos;);div.css(&apos;color&apos;); // &apos;#000033&apos;, 获取CSS属性div.css(&apos;color&apos;, &apos;#336699&apos;); // 设置CSS属性div.css(&apos;color&apos;, &apos;&apos;); // 清除CSS属性 css()方法将作用于DOM节点的style属性，具有最高优先级。 如果要修改class属性，可以用j-Query提供的方法： 1234var div = $(&apos;#test-div&apos;);div.hasClass(&apos;highlight&apos;); // false， class是否包含highlightdiv.addClass(&apos;highlight&apos;); // 添加highlight这个classdiv.removeClass(&apos;highlight&apos;); // 删除highlight这个class 显示和隐藏DOM隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。 这里j-Query提供了hide()和show()两个方法。 123var a = $(&apos;a[target=_blank]&apos;);a.hide(); // 隐藏a.show(); // 显示 获取DOM信息利用j-Query提供的方法可以直接获取Dom的信息： 1234567891011121314// 浏览器可视窗口大小:$(window).width(); // 800$(window).height(); // 600// HTML文档大小:$(document).width(); // 800$(document).height(); // 3500// 某个div的大小:var div = $(&apos;#test-div&apos;);div.width(); // 600div.height(); // 300div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效div.height(&apos;200px&apos;); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效 另外还有attr()、removeAttr()、prop()等等方法。 操作表单对于表单元素，j-Query对象统一提供val()方法获取和设置对应的value属性。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>j-Query</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(十二)]]></title>
    <url>%2F2019%2F05%2F27%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[j-Query简单介绍j-Query 是一个 JavaScript 库。 j-Query 极大的简化了 JavaScript 编程。 作用（1）消除浏览器之间的差异。（绑定时间以及异步请求之类的） （2）操作DOM写法简单。 （3）实现动画简单方便、修改CSS等。 引入直接在head中引入即可使用。 1234&lt;head&gt; &lt;script src=&quot;//code.j-Query.com/j-Query-1.11.3.min.js&quot;&gt;&lt;/script&gt; ...&lt;/head&gt; 查询版本12&apos;use strict&apos;;console.log(&apos;当前j-Query版本：&apos; + $.fn.j-Query); $符号$是著名的j-Query符号。实际上，j-Query把所有功能全部封装在一个全局变量j-Query中，而这个符号其实也是一个合法的变量名，它是变量j-Query的别名。 1$ === j-Query; // true 一般情况下可以使用$来替代j-Query，因为这样写起来的话很方便，但是有个问题是，如果一旦这个符号已经被占用的话，就还是只能使用j-Query来了。 123filter() 过滤掉不符合选择器条件的节点。map() 把一个j-Query对象包含的若干DOM节点转化为其他对象。first()、last()和slice() 返回一个新的j-Query对象，把不需要的DOM节点去掉。 选择器选择器是j-Query的核心。 一个选择器写出来类似$(‘#dom-id’)。 Dom操作一般写法： 12// 按ID查找：var a = document.getElementById(&apos;dom-id&apos;); 这样可以看出，明显代码是略显繁琐的。 j-Query的选择器就是帮助我们快速定位到一个或多个DOM节点。 按照ID查找下面代码可以看出，明显的简单方便。 当然，返回的肯定是j-Query对象。 12// 查找&lt;div id=&quot;thbelief&quot;&gt;:var div = $(&apos;#thbelief&apos;); 所谓的j-Query对象的含义其实就是——类似数组，每个元素都是一个引用Dom节点的对象。 返回类型如下： 如果存在的话。 1[&lt;div id=&quot;thbelief&quot;&gt;...&lt;/div&gt;] 不存在返回如下： 1[] 这里需要注意的就是j-Query不会返回undefined和null，这样下一行就不用判断。 j-Query对象和Dom对象之间可以互相转换： 123var div = $(&apos;#thbelief&apos;); // j-Query对象var divDom = div.get(0); // 假设存在div，获取第1个DOM元素var another = $(divDom); // 重新把DOM包装为j-Query对象 按照tag查找12var ps = $(&apos;p&apos;); // 返回所有&lt;p&gt;节点ps.length; // 数一数页面有多少个&lt;p&gt;节点 按照class查找注意这个查找前面需要加一个”.”。 1var a = $(&apos;.red&apos;); // 所有节点包含`class=&quot;red&quot;`都将返回 或者： 同时查找多个。 1var a = $(&apos;.red.green&apos;); // 注意没有空格！ 按照属性查找12var email = $(&apos;[name=email]&apos;); // 找出&lt;??? name=&quot;email&quot;&gt;var passwordInput = $(&apos;[type=password]&apos;); // 找出&lt;??? type=&quot;password&quot;&gt; 当属性的值包含空格等特殊字符时，需要用双引号括起来。 组合查找其实就是把前面提到的查找方式自由组合。 例如下面这个查找tag+class组合。 1var tr = $(&apos;tr.red&apos;); // 找出&lt;tr class=&quot;red ...&quot;&gt;...&lt;/tr&gt; 多项选择器多项选择器就是把多个选择器用,组合起来一块选，返回的是所有选择出来的。 选出来的元素是按照它们在HTML中的出现顺序来排列的，并且不会存在重复元素。 1$(&apos;p,div&apos;); // 把&lt;p&gt;和&lt;div&gt;都选出来 层级选择器Dom的结构其实就是层级的，所以除了基本的选择器以外，层级选择器其实更具有查找的优越性。 如果两个DOM元素具有层级关系，就可以用$(‘ancestor descendant’)来选择，层级之间用空格隔开。 子选择器子选择器$(‘parent&gt;child’)类似层级选择器，但是限定了层级关系必须是父子关系，就是child节点必须是parent节点的直属子节点。 过滤器一般不独立使用，通常附加在选择器上面，以便更精确的定位元素。 表单相关123456789101112131415:input：可以选择&lt;input&gt;，&lt;textarea&gt;，&lt;select&gt;和&lt;button&gt;；:file：可以选择&lt;input type=&quot;file&quot;&gt;，和input[type=file]一样；:checkbox：可以选择复选框，和input[type=checkbox]一样；:radio：可以选择单选框，和input[type=radio]一样；:focus：可以选择当前输入焦点的元素，例如把光标放到一个&lt;input&gt;上，用$(&apos;input:focus&apos;)就可以选出；:checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如$(&apos;input[type=radio]:checked&apos;)；:enabled：可以选择可以正常输入的&lt;input&gt;、&lt;select&gt; 等，也就是没有灰掉的输入；:disabled：和:enabled正好相反，选择那些不能输入的。 查找通常情况下选择器可以直接定位到我们想要的元素，但是，当拿到一个j-Query对象后，还可以以这个对象为基准，进行查找和过滤。 这里使用的是find()方法查找所有的子节点。 12var ul = $(&apos;ul.lang&apos;); // 获得&lt;ul&gt;var dy = ul.find(&apos;.dy&apos;); // 获得JavaScript, Python, Scheme 使用parent()方法向上查找节点。 123var swf = $(&apos;#swift&apos;); // 获得Swiftvar parent = swf.parent(); // 获得Swift的上层节点&lt;ul&gt;var a = swf.parent(&apos;.red&apos;); // 获得Swift的上层节点&lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空j-Query对象 使用next()和prev()方法查找同一层级的节点。 过滤123filter() 过滤掉不符合选择器条件的节点。map() 把一个j-Query对象包含的若干DOM节点转化为其他对象。first()、last()和slice() 返回一个新的j-Query对象，把不需要的DOM节点去掉。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>j-Query</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习实验-线性回归预测]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%A2%84%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[目录： 实验目的对给定的数据集进行线性回归预测。 实验内容 先创建csv 文件。 利用WEKA 的TOOLS 讲csv 转换为arff 工具。 利用WEKA 学习线性回归模型。 实验过程(1)首先讲数据集在EXCEL 中进行处理，转变为CSV 文件格式，注意这里需要把原数据集中的属性名称改变为英文。 另存为data.csv 在桌面即可。等会儿还需要使用到。 (2)利用WEKA 的TOOLS 将CSV 格式转换为ARFF 格式。 也是另存为桌面为data.arff。 （3）将data.arff 导入进WEKA 进行线性回归预测即可。 （4）先使用Use training set 来测试。 （5）采用10 折交叉验证（ 10-fold cross validation） 来选择和评估模型。 (6)由于Weka 在处理丢失数据的时候已经做了均值处理。所以这里不对缺失值进行操作。 实验结果 实验总结问题 首先就是实验中遇到的问题— —缺失值的处理，最开始的想法是使用均值来替代，但是得出的结果和之前不处理是一样的，所以从这里我猜测WEKA 已经做了相关的处理，是以就不用进行另外的处理了。 最开始不知道如何将CSV 转换为ARFF 格式， 还好是找到了相关的方案。解决了这个问题。 总结值得注意的是， 数据缺失的话在WEKA 中需要使用? 来替代表示是一个缺失值， 不能使用-或者0 这种东西来替代。 在统计学中， 线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。 本次实验就是利用Weka 在生育率、老龄人口占比、老龄人口死亡占比、人口流动比率、女性育龄人口占比这6 个自变量和实际人口数之间进行建模分析。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>实验</tag>
        <tag>WEKA</tag>
        <tag>线性回归预测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(十一)]]></title>
    <url>%2F2019%2F05%2F25%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： Canvas 简单介绍 创建画布 浏览器支持 使用 绘制 注意事项 Canvas简单介绍Canvas是HTML5之后新增的组件，其实就是相当于画布，本身这个元素是没有绘制能力的，但是可以通过JS在这个画布上面进行图形与表格的绘制之类的。 创建画布一个Canvas其实就是定义了一个指定尺寸的矩形框，在这个范围里面可以随意的绘制自己想要绘制的图形。 1&lt;canvas id=&quot;testCanvas&quot; width=&quot;250&quot; height=&quot;250&quot;&gt;&lt;/canvas&gt; 浏览器支持由于不同的浏览器对于HTML5的支持标准不同，所以，使用这个画布之前必须加以判断，比如如果不支持的话返回提示。 实例如下： 123&lt;canvas id=&quot;testCanvas&quot; width=&quot;250&quot; height=&quot;250&quot;&gt; &lt;p&gt;Does not support！&lt;/p&gt;&lt;/canvas&gt; 如果浏览器支持Canvas的话会直接忽略内部的HTML，如果不支持的话就会显示画布里面的内容。 检测方法如下： 1234567&apos;use strict&apos;;var canvas = document.getElementById(&apos;testCanvas&apos;);if (canvas.getContext) &#123; console.log(&apos;浏览器支持Canvas!&apos;);&#125; else &#123; console.log(&apos;浏览器不支持Canvas!&apos;);&#125; 使用这里以2D作为示例。 要对一个画布对象进行绘制的话，首先需要获取到一个2D对象。方法是getContext(‘2d’)： 1var ctx = canvas.getContext(&apos;2d&apos;); 绘制3D的话需要使用WebGL规范： 1test = canvas.getContext(&quot;webgl&quot;); 绘制Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。 基本形状绘制： 123456789101112131415161718'use strict';var canvas = document.getElementById('test-shape-canvas'),ctx = canvas.getContext('2d');ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明ctx.fillStyle = '#dddddd'; // 设置颜色ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色// 利用Path绘制复杂路径:var path=new Path2D();path.arc(75, 75, 50, 0, Math.PI*2, true);path.moveTo(110,75);path.arc(75, 75, 35, 0, Math.PI, false);path.moveTo(65, 65);path.arc(60, 65, 5, 0, Math.PI*2, true);path.moveTo(95, 65);path.arc(90, 65, 5, 0, Math.PI*2, true);ctx.strokeStyle = '#0000ff';ctx.stroke(path); 效果如下： 基本文本绘制： 123456789101112'use strict';var canvas = document.getElementById('test-text-canvas'),ctx = canvas.getContext('2d');ctx.clearRect(0, 0, canvas.width, canvas.height);ctx.shadowOffsetX = 2;ctx.shadowOffsetY = 2;ctx.shadowBlur = 2;ctx.shadowColor = '#666666';ctx.font = '24px Arial';ctx.fillStyle = '#333333';ctx.fillText('带阴影的文字', 20, 40); 效果如下： 注意事项1.尽量使用整数坐标而不是浮点数。 2.如果要实现很复杂的效果的话，可以使用多个重叠的画布而不是在一个画布上面进行复杂的绘制。 3.背景图片如果不变可以直接用img标签并放到最底层。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习实验-K-Means模型聚类]]></title>
    <url>%2F2019%2F05%2F24%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C-K-Means%E6%A8%A1%E5%9E%8B%E8%81%9A%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[目录： 实验目的 实验内容 实验过程 实验结果 实验总结 问题 总结 实验目的利用K-Means模型对上个实验得到的数据集进行聚类。 实验内容 1） 选取数据空间中的K个对象作为初始中心，每个对象代表一个聚类中心。 2） 对于样本中的数据对象，根据它们与这些聚类中心的欧氏距离，按距离最近的准则将它们分到距离它们最近的聚类中心（最相似）所对应的类。 3） 更新聚类中心：将每个类别中所有对象所对应的均值作为该类别的聚类中心，计算目标函数的值。 4） 判断聚类中心和目标函数的值是否发生改变，若不变，则输出结果，若改变，则返回2）。 实验过程1.确定聚类中心。 2.计算欧式距离。 3.根据聚类中心的位置来分配样本中的数据对象. 4.更新当前的聚类中心。 5.输出结果到指定的KMeansOutPut.txt。 实验结果 实验总结问题 K的选择问题。 相似度定义问题。 初始化K个质心的选择。（这里还包含了一个局部最小的问题） 总结 本次实验中的kmeans算法首先选择K个初始质心，其中K是用户指定的参数，即所期望的簇的个数。 然后就是选择适当的初始质心，这也是kmeans算法的关键步骤。 由于随机的选取初始质心，这样生成簇的质量常常很差。有些会出现局部最小问题。 这里采取的是网上有人使用过的方法：选取具有最小SSE（误差的平方和）的簇集。即多次运行，每次使用一组不同的随机初始质心。 本次实验中使用的距离度量方法是欧式距离。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>实验</tag>
        <tag>KMeans</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(十)]]></title>
    <url>%2F2019%2F05%2F23%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%2F</url>
    <content type="text"><![CDATA[目录： Promise 简单介绍 是否支持Promise 简单实例 用法 Promise().then().then….catch() 多任务串行执行 Promise.all([p1,p2,…]) 多任务并行执行 Promise.race([p1,p2,…]) 多任务赛跑 Promise在JS中，所有的代码其实都是单线程执行的。 这也就导致了前面提到过的，所有的网络请求之类的操作都需要异步执行。（回调函数） 例如: 123456function callback() &#123; console.log('test');&#125;console.log('before');setTimeout(callback, 1000); // 1秒钟后调用callback函数console.log('after'); 1s之后出现了test： 一般AJAX的操作写法如下： 好处是统一执行逻辑，不关心是否结果正常，后面再加上判断即可。 123var ajax = ajaxGet('http://...');ajax.ifSuccess(success) .ifFail(fail); 简单介绍所谓的Promise，其实就是承诺的意思。 意思是——承诺将来会执行。 Promise在ES6中统一规范，是浏览器直接支持的，有些浏览器不支持。。。 是否支持Promise可以通过以下代码测试是否支持Promise： 1234'use strict';new Promise(function () &#123;&#125;);// 直接运行测试:console.log('Promise!'); 如果支持的话，会返回Promise这个字符串： 简单实例123456789101112131415161718192021222324252627282930313233'use strict';// 清除log:var logging = document.getElementById('test-promise-log');while (logging.children.length &gt; 1) &#123; logging.removeChild(logging.children[logging.children.length - 1]);&#125;// 输出log到页面:function log(s) &#123; var p = document.createElement('p'); p.innerHTML = s; logging.appendChild(p);&#125;new Promise(function (resolve, reject) &#123; log('start new Promise...'); var timeOut = Math.random() * 2; log('set timeout to: ' + timeOut + ' seconds.'); setTimeout(function () &#123; if (timeOut &lt; 1) &#123; log('call resolve()...'); resolve('200 OK'); &#125; else &#123; log('call reject()...'); reject('timeout in ' + timeOut + ' seconds.'); &#125; &#125;, timeOut * 1000);&#125;).then(function (r) &#123; log('Done: ' + r);&#125;).catch(function (reason) &#123; log('Failed: ' + reason);&#125;); 可以清晰的看到，执行的代码和处理结果的代码进行了分离。 用法Promise().then().then….catch() 多任务串行执行情景化记忆:在一个任务链中,比如我要向上级部门一层层的往上提交申请,if(某种条件)承诺帮你resolve解决问题,else承诺reject你的请求. 他给出的resolve问题的办法只是个空头Promise,then到总经理那实现具体承诺,如果总经理还是给一个空头承诺(返回Promise实例),还得then到董事长那里…. 任一一步做出的是reject的承诺,还有什么好说的,被拒绝了,后面的就不会再往上走了呀. 准备catch 拒绝通知吧blablabla. Promise.all([p1,p2,…]) 多任务并行执行都要成功才进入then,返回结果数组. Promise.race([p1,p2,…]) 多任务赛跑then()和catch(),谁先调用算谁的,其它任务中断.]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(九)]]></title>
    <url>%2F2019%2F05%2F22%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[目录： AJAX 含义 使用 安全限制问题 CORS 含义 AJAX含义全称是Asynchronous JavaScript and XML，即用JavaScript执行异步网络请求。 所谓的异步网络请求，其实就是需要回调函数。 另外，AJAX并不是JavaScript的规范。 Web的运作原理其实就是：一次HTTP请求对应一个界面。当用户在浏览器中提交一个表单的时候其实浏览器就会刷新一下，然后在新页面返回到底请求是成功了还是失败了。如果失败了一般都是会返回一个404的界面。 如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。 使用在如今的最新浏览器（低版本的貌似需要ActiveXObject对象）上使用AJAX需要用到XMLHttpRequest对象： 在创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。 在回调函数中，通过readyState === 4来判断请求是否完成，如果已完成，再根据status === 200来判断是否是成功的响应。 XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，不用写。 千万不能把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。 调用send()方法的时候其实才真正发送请求。 GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 1234567891011121314151617181920212223242526272829303132function success(text) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = text;&#125;function fail(code) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code;&#125;var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果: if (request.status === 200) &#123; // 成功，通过responseText拿到响应的文本: return success(request.responseText); &#125; else &#123; // 失败，根据响应码判断失败原因: return fail(request.status); &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125;// 发送请求:request.open('GET', '/categories/');request.send();alert('请求已发送，请等待响应...'); 安全限制问题默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。 但是也不是说不能请求其他网站的URL，还是有其他的办法的，常用方法如下： 使用JSONP，但是限制了只能使用GET请求，并且要求返回JS。（原理其实就是浏览器一般是运行跨域引用JS资源的。） 1234&lt;head&gt; &lt;script src=&quot;https://thbelief.coding.me//abc.js&quot;&gt;&lt;/script&gt; ...&lt;/head&gt; JSONP的返回格式一般是函数调用形式。例如： 在当前的页面先准备好foo函数，然后给页面动态的添加一个script节点，这就相当于动态的读取外域的JS资源了，然后等着回调函数的返回即可。 1foo(’data‘); CORS含义新的跨域方式。（浏览器需要支持HTML5） CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。 Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。 假设本域是one.com，外域是two.com，只要响应头Access-Control-Allow-Origin为对应的网址，或者是*，本次请求就可以成功。 值得注意的是，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>AJAX</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome主页被劫持解决方案]]></title>
    <url>%2F2019%2F05%2F21%2FChrome%E4%B8%BB%E9%A1%B5%E8%A2%AB%E5%8A%AB%E6%8C%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 检查劫持网页 确定被劫持位置 前言今天安装软件的时候不小心被强制劫持了主页，被恶心够了，好在最终解决了，用博客记录一下这次的解决过程。 正文这次我使用的是Chrome浏览器。直接使用这个浏览器做示范。 检查劫持网页在地址栏输入： 1chrome://version/ 找到命令行这一栏，观察里面是否出现劫持页面的网址。 确定被劫持位置有很多种劫持的方式，所以需要确定被劫持的是哪个位置。 快捷方式（任务栏或者非任务栏）、软件名.exe。大概就这三个地方，每个检查一下就可以了，一般都是快捷方式被属性被修改。 我这里示范一下检查任务栏固定的时候如何查看，如果在如图步骤之后在目标那一栏的后半部分看到了之前看到的网址。直接删除即可，这样打开浏览器就可以看到恢复啦！]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>主页劫持</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单背包问题]]></title>
    <url>%2F2019%2F05%2F20%2F%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[目录： 简单背包问题 题目介绍 输入 输出 样例输入 样例输出 题目分析 题目代码 题目结果 动态规划思想 含义 设计 自顶向下 自底向上 重点 总结 简单背包问题这道题是一道关于动态规划以及搜索的题目，这里就附上这道题的解法与代码。 题目介绍简单背包问题 1000(ms) 65535(kb) 1593 / 7745 Tags: 搜索 设有一个背包可以放入的物品重量为S，现有n件物品，重量分别是w1，w2，w3，…wn。 问能否从这n件物品中选择若干件放入背包中，使得放入的重量之和正好为S。 如果有满足条件的选择，则此背包有解，否则此背包问题无解。 输入12输入数据有多行，包括放入的物品重量为s，物品的件数n，以及每件物品的重量（输入数据均为正整数）多组测试数据。 输出1对于每个测试实例，若满足条件则输出“YES”，若不满足则输出“NO“ 样例输入12320 51 3 5 7 9 样例输出1YES 题目分析其实这只是一道很简单的动态规划题目。由于下面要仔仔细细的讲一下动态规划相关问题，这里不做详细描述，只贴代码。 题目代码123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int weightArray[100]=&#123;0&#125;;//这个全局数组用来存放物品的重量,目前只是申请了100的空间，如果不够的话可以继续增大int solve(int weight,int n) &#123; if (weight==0) &#123; //取空了的话就可以直接返回1了 return 1; &#125; if (n==0&amp;&amp;weight!=0) &#123; //所有东西都取出来了，但是还是不为0重量，说明出现了数据的问题返回0 return 0; &#125; if (solve(weight, n-1)==1) &#123; //假定第n个物品还没有被取出来，直接取第n－1号物品，成功了就返回1 return 1; &#125; return solve(weight-weightArray[n], n-1);//此时第n个物品已经取出来了，然后取第n－1号物品，以此类推即可&#125; int main() &#123; int weight,num; while (cin&gt;&gt;weight&gt;&gt;num) &#123;//多组输入 for (int i=1; i&lt;=num; i++) &#123; cin&gt;&gt;weightArray[i]; &#125; if(solve(weight,num)==1) //成功返回1 cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; return 0;&#125; 题目结果结果如下，已经达到了目的。 如果OJ上提交不过的话建议直接调大数组的大小，很多时候其实就是测试用例的范围问题。 动态规划思想含义所谓的动态规划（dynamic programming）思想其实就是通过组合子问题而解决整个问题的解。 设计自顶向下相当于递归函数，从大范围开始计算，然后不断保存中间结果，这是为了防止重复计算。 自底向上从小范围递推计算到大范围。 重点递归+边界。 总结其实这次只是简单的说一下这个动态规划的思想，这个也不是一句两句就可以解释清楚的，我以后准备专门抽时间通过实例来详细的写一篇关于动态规划的博客，敬请期待吧。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>简单背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习实验-VSM计算相似度]]></title>
    <url>%2F2019%2F05%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C-VSM%E8%AE%A1%E7%AE%97%E7%9B%B8%E4%BC%BC%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[目录： 实验目的 通过VSM模型来计算文档之间的相似度。 实验内容 熟练掌握term的选择。 计算每篇文章中每个term的权重。（TF-IDF） 计算文档的相似度。 实验过程1.首先要做的就是读取文档，然后就是去除停用词。关键代码如下:原理就是一行一行的读取，然后逐词匹配，如果是的话就去除该停用词。 2.计算TF-IDF TF计算因子代表了词频，即一个单词在文档中出现的次数，一般来说，在某个文档中反复出现的单词，往往能够表征文档的主题信息，即Tf值越大，越能代表文档所反映的内容，那么应该给于这个单词更大的权值。 Tf=1+log(Tf) IDF反映了一个特征词在整个文档集合中的分布情况，特征词出现在其中的文档数目越多，IDF值越低，这个词区分不同文档差异的能力越差，所以IDF衡量了单词对不同文档内容差异的区分能力。 IDF=log(N/nk) 3.计算权重： 权重=TF*IDF 4.相似度计算：这里使用的是Cosine算法。公式如下： 实验结果]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>实验</tag>
        <tag>VSM</tag>
        <tag>相似度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(八)]]></title>
    <url>%2F2019%2F05%2F18%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[目录： 操作文件 上传文件 File API 回调 操作文件上传文件在HTML表单中，可以上传文件的唯一控件就是： 1&lt;input type=&quot;file&quot;&gt; 当一个表单包含input type=”file”时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才可以正确编码并以multipart/form-data格式发送表单的数据。 另外，由于安全方面的考虑，不可能使用JS对input type=”file”的value进行赋值，上传文件之后也不能获取该文件的真实路径。 注意，一般上传文件都是由后台的服务器做处理，JS可以做的就是在上传的时候检测文件的扩展名，防止上传无效的格式。 123456var f = document.getElementById(&apos;test-file-upload&apos;);var filename = f.value; // &apos;C:\fakepath\test.png&apos;if (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) &#123; alert(&apos;Can only upload image file.&apos;); return false;&#125; File APIJS对用户上传文件的操作非常有限，例如无法读取文件内容，很多需要操作文件的网页不得不用Flash来实现。 HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。 具体操作这里不做演示，可以自行百度。 回调JS是单线程执行模式。 在JS中执行多任务其实都是用的异步调用。例如： 1reader.readAsDataURL(file); 上面的代码会发起一个异步的操作来读取文件的内容，由于是异步操作，JS中不知道什么时候会结束，所以之前需要设置一个回调函数。 123reader.onload = function(e) &#123; // 当文件读取完成后，自动调用此函数:&#125;; 文件读取完成之后JS会自动的调用自己设置的回调函数。执行回调函数的时候其实文件已经读取完毕了，所以可以安全地在回调函数内部获得文件的内容。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>操作文件</tag>
        <tag>File API</tag>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode搭建C++/C调试编译环境（使用DevC++）]]></title>
    <url>%2F2019%2F05%2F17%2FVSCode%E6%90%AD%E5%BB%BAC-C%E8%B0%83%E8%AF%95%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%EF%BC%88%E4%BD%BF%E7%94%A8DevC-%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 配置Dev下MinGW64的路径 安装VSCode插件 新建工作区 新建一个VSCode-C文件夹 配置 launch.json tasks.json c_cpp_properties.json 测试 前言关于VSCode使用Dev C++的MinGW64来调试C++/C网上的教程试了很多，大部分都已经过时了或者说是不适配了，最后就选择使用Dev原有的东西来实现，不建议自己下载MinGW64，里面安装的时候有些选项不知道选什么的话很容易出现问题。 配置Dev下MinGW64的路径假设Dev已经安装好了，然后现在要做的就是将Dev目录下的MinGW添加到环境变量的path里面去。 我的路径配置是： 注意这里必须是直接到bin目录 1D:\c.code\Dev\Dev-Cpp\MinGW64\bin 关于如何配置环境变量这部分就不说了，电脑-&gt;右键属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;Path-&gt;编辑-&gt;添加。添加完成之后一路确定退出保存即可。 安装VSCode插件直接搜索C++安装第一个就可以了，下面的那些可以看自己的情况安装。 还可以安装一个Code Runner插件，这个插件是用来运行代码的。（非调试，调试环境需要自己配置） 新建工作区由于VSCode本身不支持C++/C的调试环境，所以这些都需要自己配置。新建一个专门的C的工作区是最便利的方法。 新建一个VSCode-C文件夹新建一个文件夹，记住位置，然后在VSCode里面讲该文件夹添加为一个新的工作区。（以后写的C++/C代码都要放到这个文件夹下面才可以进行调试） 然后点击左下角的设置按钮，然后点击工作区，进入工作区的设置环境。（默认是用户设置，我们需要修改工作区的设置），然后在上面的搜索框输入Files.Encoding，将设置修改为gb2312。 配置在工作区下面的.vscode里面添加三个文件。 下面的配置文件必须修改为自己Dev目录下的MinGW路径。 launch.json1234567891011121314151617181920212223242526272829&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot; $&#123;file&#125;.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;preLaunchTask&quot;: &quot;build&quot;, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\c.code\\Dev\\Dev-Cpp\\MinGW64\\bin\\gdb.exe&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; ]&#125; tasks.json12345678910111213141516171819&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;file&#125;.exe&quot; ], &#125; ]&#125; c_cpp_properties.json1234567891011121314151617181920212223&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/**&quot;, &quot;D:\\c.code\\Dev\\Dev-Cpp\\MinGW64\\lib\\gcc\\x86_64-w64-mingw32\\4.9.2\\include\\c++&quot;, &quot;D:\\c.code\\Dev\\Dev-Cpp\\MinGW64\\lib\\gcc\\x86_64-w64-mingw32\\4.9.2\\include\\c++\tr1&quot;, &quot;D:/c.code/Dev/Dev-Cpp/MinGW64/lib/gcc/x86_64-w64-mingw32/4.9.2/include/c++/x86_64-w64-mingw32&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;compilerPath&quot;: &quot;D:\\c.code\\Dev\\Dev-Cpp\\MinGW64\\bin\\gcc.exe&quot;, &quot;cStandard&quot;: &quot;c99&quot;, &quot;cppStandard&quot;: &quot;c++98&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot; &#125; ], &quot;version&quot;: 4&#125; 测试在VSCode-C下面创建一个新文件Untitled-1.cpp，然后写上代码。（建议加上 system(“pause”);，这样控制台不会一闪而过）。 最后运行结果如下：]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>C++/C</tag>
        <tag>调试编译环境</tag>
        <tag>DevC++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析-实验一]]></title>
    <url>%2F2019%2F05%2F16%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： 前言 Euclid’s Game 题目简介 输入 输出 样例输入 样例输出 题目大意 题目分析 代码 Locker doors 题目简介 输入 输出 样例输入 样例输出 题目大意 题目分析 代码 俄式乘法 题目简介 输入 输出 样例输入 样例输出 题目分析 代码 约瑟夫问题的实现 题目简介 输入 输出 样例输入 样例输出 题目分析 代码 前言这周六就要算法分析半期考试了，正好要复习，就顺便写下博客加深一下理解。 Euclid’s Game题目简介Euclid’s Game 1000(ms) 65535(kb) 812 / 3173 Starts with two unequal positive numbers (M,N and M&gt;N) on the board. Two players move in turn. On each move, a player has to write on the board a positive number equal to the difference of two numbers already on the board; this number must be new, i.e., different from all the numbers already on the board. The player who cannot move loses the game. Should you choose to move first or second in this game? According to the above rules, there are two players play tihs game. Assumptions A write a number on the board at first, then B write it. Your task is write a program to judge the winner is A or B. 输入1Two unequal positive numbers M and N , M&gt;N (M&lt;1000000) 输出1A or B 样例输入13 1 样例输出1A 题目大意从两个不等的正数开始，将两个数写在板子上，M&gt;N，每个人只能在板子上写出板子上已有数的差值的绝对值，这个值必须是在板子上面没有出现过的，谁先不能写出谁就输了，所以该是先手还是后手才能赢下比赛？ 假设是A首先写，B后写，我们的任务就是写一个程序来判断谁会赢。 题目分析由数据规律可以得出。 每次写的数字，只能是最开始两个数的最大公约数的k倍，即k最大为M/（M与N的最大公约数）倍，判断M/（M与N的最大公约数）的奇偶性即可。 这里使用辗转相除法来实现求最大公约数。然后判断k的奇偶性即可。奇数则是A胜，否则就是B胜。 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;int main()&#123; //x，y分别赋值后x&gt;y，c作为余数（这里为后面的辗转相除法做准备） int m,n,x,y,c; cin&gt;&gt;m&gt;&gt;n; //由于题目表示m&gt;n,所以赋值之后x&gt;y x=m; y=n; //这里是辗转相除法 while(y)&#123; //余数c为零即y为零的时候自动退出循环 c=x%y; x=y; y=c; &#125; //这里的m就是输入的m，n中的较大值 m=m/x; if(m%2)&#123; //如果是奇数的话 cout&lt;&lt;&quot;A&quot;&lt;&lt;endl; &#125;else&#123; //如果是偶数的话 cout&lt;&lt;&quot;B&quot;&lt;&lt;endl; &#125; return 0;&#125; Locker doors题目简介Locker doors 1000(ms) 65535(kb) 812 / 3173 There are n lockers in a hallway numbered sequentially from 1 to n. Initially, all the locker doors are closed. You make n passes by the lockers, each time starting with locker #1. On the ith pass, i = 1, 2, …, n, you toggle the door of every ith locker: if the door is closed, you open it, if it is open, you close it. For example, after the first pass every door is open; on the second pass you only toggle the even-numbered lockers (#2, #4, …) so that after the second pass the even doors are closed and the odd ones are opened; the third time through you close the door of locker #3 (opened from the first pass), open the door of locker #6 (closed from the second pass), and so on. After the last pass, which locker doors are open and which are closed? How many of them are open? Your task is write a program to output How many doors are open after the last pass? Assumptions all doors are closed at first. 输入1a positive numbers n, total doors. n&lt;=100000 输出1a positive numbers ，the total of doors opened after the last pass. 样例输入110 样例输出13 题目大意走廊上有n个储物柜，从1到n依次编号。最初，所有的储物柜门都关闭了。每次从储物柜＃1开始，您都会通过储物柜进行n次通行。在第i次通过的时候，i = 1,2，…，n，切换每个第i个储物柜的门：如果门关闭，你打开它，如果它是打开的，你关闭它。例如，在第一次通过后，每扇门都打开; 在第二次通过时，您只需切换偶数编号的储物柜（＃2，＃4，……），以便在第二次通过后，偶数门关闭，奇数门打开; 第三次通过你关闭储物柜＃3的门（从第一次通过打开），打开储物柜＃6的门（从第二次通过关闭），依此类推。在最后一次行走过之后 哪些储物柜门是打开的，哪些是关闭的？有多少是开放的？我们的任务是写一个程序来输出最后一次通过后打开了多少扇门？假设所有门首先关闭。 题目分析首先，大家想到的最简单的应该是直接模拟，但是这里有个问题，像这么大的数据规模的话，是很容易超时的，这就不可取了。 测试多组数据之后会发现，其实这道题可以找到规律——最后开着的门其实编号都是平方数（也就是开根号得出整数的数）。比如18个门的话，最后1、4、9、16都是开着的。 代码12345678910#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; //从规律中发现其实强制转换之后也就是n开方的值 cout&lt;&lt;(int)sqrt(n)&lt;&lt;endl; return 0;&#125; 或者 123456789101112131415#include&lt;iostream&gt;#include&lt;cmath&gt; using namespace std;int main()&#123; int n; int num = 0; cin&gt;&gt;n; for (int i = 1; i &lt;= n; i++) &#123; //这里的floor是向下取整，返回的是不大于参数的最大整数，要用判断i开方之后是否是整数 if(sqrt(i)==floor(sqrt(i))) num++; &#125; cout&lt;&lt;num&lt;&lt;endl; return 0;&#125; 俄式乘法题目简介俄式乘法 1000(ms) 65535(kb) 2220 / 6369 俄式乘法，又被称为俄国农夫法，它是对两个正整数相乘的非主流算法。假设m和n是两个正整数，我们要计算它们的积。它的主要原理如下： if n is 偶数 n m=n/2 2m else n m=(n-1)/2 2m + m 该算法只包括折半，加倍，相加等几个简单操作，因此实现速度非常快。 输入1两个正整数 n,m。 输出12n和m的乘积。输出整个求和表达式，运算符与数字之间用一个空格隔开。 样例输入150 65 样例输出1130 + 1040 + 2080 = 3250 题目分析这个题太简单了，没啥好分析的，直接按照题目要求写即可。 推荐减常因子的减治法。 代码123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int n,m,c=0; int k=0,i; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(i=0;n!=0;i++) &#123; if(n%2==1&amp;&amp;n!=1) &#123; c+=m; printf(&quot;%d + &quot;,m); &#125; if(n==1) &#123; c+=m; printf(&quot;%d = %d\n&quot;,m,c); &#125; m*=2; if(n%2==1) &#123; n=(n-1)/2; &#125; else if(n%2==0) &#123; n=n/2; &#125; &#125; return 0;&#125; 或者 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std; int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; while(n!=0) &#123; int num=0; while(n!=0) &#123; if(n%2==0) &#123;//如果是偶数的话，将两个数一个乘2一个除2 n=n/2; m=m*2; &#125; if(n%2!=0) &#123;//如果是奇数的话 num+=m;//总和上先加上m n=(n-1)/2; if(n!=0) cout&lt;&lt;m&lt;&lt;&quot; + &quot;;//并没有结束 else cout&lt;&lt;m&lt;&lt;&quot; = &quot;&lt;&lt;num&lt;&lt;endl;//结束条件n=0 m=m*2; &#125; &#125; &#125; return 0;&#125; 约瑟夫问题的实现题目简介约瑟夫问题的实现 2000(ms) 65535(kb) 3524 / 11784 n个人围成一个圈，每个人分别标注为1、2、…、n，要求从1号从1开始报数，报到k的人出圈，接着下一个人又从1开始报数，如此循环，直到只剩最后一个人时，该人即为胜利者。例如当n=10,k=4时，依次出列的人分别为4、8、2、7、3、10，9、1、6、5，则5号位置的人为胜利者。给定n个人，请你编程计算出最后胜利者标号数。（要求用单循环链表完成。） 输入12第一行为人数n;第二行为报数k。 输出1输出最后胜利者的标号数。 样例输入1210 4 样例输出15 题目分析如题目，直接使用尾插法建立单循环链表，然后模拟就可以了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;typedef struct List&#123; int data; struct List *next;&#125;LinkList; int main()&#123; LinkList *L,*r,*s; L = (LinkList *)malloc(sizeof(LinkList)); r =L; int n,i; int k; cin&gt;&gt;n&gt;&gt;k; for(i = 1;i&lt;=n;i++) ///尾插法建立循环链表 &#123; s = (LinkList *)malloc(sizeof(LinkList)); s-&gt;data = i; r-&gt;next = s; r= s; &#125; r-&gt;next =L-&gt;next; //让最后一个链表的下一个节点指向开头 LinkList *p; p = L-&gt;next; while(p-&gt;next != p) //开始模拟（判断条件要注意：因为最后肯定剩下一个人， 所以最后一个数据的next还是他本身） &#123; for(i = 1;i&lt;k-1;i++) &#123; p = p-&gt;next; //每k个数死一个人 &#125; p-&gt;next = p-&gt;next-&gt;next; //将该节点从链表上删除。 p = p-&gt;next; &#125; //OJ上要求不带回车，所以直接输出即可 cout&lt;&lt;p-&gt;data; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Euclid&#39;s Game</tag>
        <tag>Locker doors</tag>
        <tag>俄式乘法</tag>
        <tag>约瑟夫问题的实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(七)]]></title>
    <url>%2F2019%2F05%2F15%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[目录： 前言 表单 简介 输入控件 获取值 填充值 HTML5控件 提交 前言前面一个博客中其实提到了一个网页脚本这种东西，不得不说，好不好用先不说，但是绝对对学习JS来说是一个很棒的想法。 GreasyFork这个网站就是一个脚本网站，大部分都是JS，可以参考学习。当然，如果要好好的使用的话建议还是下载一个Chrome的脚本插件。 表单简介表单其实也是一个DOM树。表单的操作对于脚本来说还是非常重要的，比如说输入框下拉框之类的，都可以通过JS来操作。 表单在网页中主要负责数据采集功能。一个表单有三个基本组成部分： 表单标签：这里面包含了处理表单数据所用CGI程序的URL以及数据提交到服务器的方法。 表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。 表单按钮：包括提交按钮、复位按钮和一般按钮；用于将数据传送到服务器上的CGI脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。 输入控件1234567891011文本框，对应的&lt;input type=&quot;text&quot;&gt;，用于输入文本；口令框，对应的&lt;input type=&quot;password&quot;&gt;，用于输入口令；单选框，对应的&lt;input type=&quot;radio&quot;&gt;，用于选择一项；复选框，对应的&lt;input type=&quot;checkbox&quot;&gt;，用于选择多项；下拉框，对应的&lt;select&gt;，用于选择一项；隐藏文本，对应的&lt;input type=&quot;hidden&quot;&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。 获取值例如获得一个input节点的引用的话，可以直接通过value来获得对应的输入值。 12var input = document.getElementById(&apos;test&apos;);input.value; // &apos;用户输入的值&apos; 这种方法可以类推到test、password等等属性，但是需要注意的是value属性对于单选框/复选框返回的永远是HTML预设的值，如果需要判断用户选择的是哪些的话，需要用到checked判断。 实例如下： 123456var mon = document.getElementById(&apos;monday&apos;);var tue = document.getElementById(&apos;tuesday&apos;);mon.value; // &apos;1&apos;tue.value; // &apos;2&apos;mon.checked; // true或者falsetue.checked; // true或者false 填充值对于单选框/复选框，设置checked的值即可。 对于另外的输入控件的话，直接设置value值即可。 12var input = document.getElementById(&apos;QQ&apos;);input.value = &apos;123456789&apos;; // 文本框的内容已更新 HTML5控件HTML5新增大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用input标签： 1&lt;input type=&quot;date&quot; value=&quot;2019-05-15&quot;&gt; 实例： 注意：这些属性只是对于支持HTML5的浏览器起作用，如果不支持的话就只是简单的文本格式test来显示。 提交JS支持两种方法来提交表单。（AJAX暂且不算） 方法一 通过form元素的submit()方法提交一个表单。 缺点：扰乱了浏览器对form的正常提交。浏览器默认点击button type=”submit”时提交表单，或者用户在最后一个输入框按回车键。 方法二 响应form本身的onsubmit事件，在提交form时作修改。 简单实例： 1234567891011121314&lt;!-- HTML --&gt;&lt;form id=&quot;test-form&quot; onsubmit=&quot;return checkForm()&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;test&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() &#123; var form = document.getElementById(&apos;test-form&apos;); // 可以在此修改form的input... // 继续下一步: return true;&#125;&lt;/script&gt; 注意return true来告诉浏览器继续提交，如果return false，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。 另外，在检查和修改input时，要充分利用input type=”hidden”来传递数据。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>表单</tag>
        <tag>Dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(十三)]]></title>
    <url>%2F2019%2F05%2F14%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 题外话 思路 完整代码 总结 前言之前开发的THBELIEFScript已经很久没有维护了，关键的原因还是没有可以需求的地方，最近刚好有了需求，所以就把这个项目重新提起来一下。这次开发的是chaoXing全自动的脚本，作用就是遇到题目做完然后跳过，看完这个视频自动寻找下一个视频。（不涉及任何作弊手动，仅仅是自动化），目前5.2.0的版本的chaoXIng有些手机不适配。 正文题外话传送门这个网址是一个JS脚本，也是和今天说的这个一样的作用只是大佬的比较完善，但是仅做参考，我只是拿来学习对于浏览器的操作的。 注意：4.30号开始chaoXing的更新导致浏览器脚本的查出概率很大。 思路首先肯定需要无障碍权限： 这里其实有点儿问题，相比传统的auto():来说，貌似有BUG。 12345678if(!floaty.checkPermission())&#123; toast(&quot;未打开无障碍权限！请打开无障碍权限。&quot;); floaty.requestPermission();&#125;else&#123; toast(&quot;无障碍权限已打开！&quot;); &#125; 然后我是想着需不需要直接跳转过去打开APP，如： 1234567if(currentPackage()!=&quot;com.chaoxing.mobile&quot;)&#123; toast(&quot;即将打开超星！&quot;); //直接打开学习通 app.launchApp(&quot;学习通&quot;);&#125;else&#123; toast(&quot;已经在学习通中，即将开始进行下一步操作！&quot;);&#125; 但是最后决定取消，由手动去前往打开。 定义了一个数组变量用来存储完成情况： 12//这个是存完成情况的var completionDeploy=[]; 设置一个音量下键停止脚本并弹出完成情况的东西： 12345678910111213//监听音量下键是否按下，退出脚本threads.start(function()&#123; events.setKeyInterceptionEnabled(&quot;volume_down&quot;,true); //监听按键 events.observeKey(); events.onKeyDown(&quot;volume_down&quot;, function(event)&#123; toast(&quot;即将关闭当前脚本！&quot;); alert(completionDeploy);//展示信息 sleep(5000); //engines.myEngine().forceStop(); engines.myEngine().forceStop(); &#125;);&#125;); 每隔一分钟检测是否有题是否已经看完当前视频： 1234567891011121314//开始定时器，每隔一分钟自动检索是否存在答题的可能性，如果需要答题的话就直接答题即可setInterval(function()&#123; //如果检测到有题目的话直接答题 answerProblem(); //如果已经看完了现在的之后 if(currentActivity()==&quot;com.chaoxing.fanya.aphone.ui.chapter.KnowledgePagerActivity&quot;)&#123; toast(&quot;当前的视频已经看完了，即将开始寻找下一个视频自动播放~&quot;); log(&quot;视频已看完，即将开始下一个视频~&quot;); //寻找下一个视频自动打开并且播放，以此类推 findNextVideo(); &#125;else&#123; toast(&quot;当前视频尚未看完！&quot;); &#125;&#125;, 1000*60);//一分钟检测一次 最后写好各个函数就可以了。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202//auto();//直接打开无障碍权限//检测是否打开了无障碍权限if(!floaty.checkPermission())&#123; toast(&quot;未打开无障碍权限！请打开无障碍权限。&quot;); floaty.requestPermission();&#125;else&#123; toast(&quot;无障碍权限已打开！&quot;); &#125;toast(&quot;请确保超星已经在后台打开并且已经打开即将开始播放的页面！&quot;);sleep(2000);//延迟两秒吧/*if(currentPackage()!=&quot;com.chaoxing.mobile&quot;)&#123; toast(&quot;即将打开超星！&quot;); //直接打开学习通 app.launchApp(&quot;学习通&quot;);&#125;else&#123; toast(&quot;已经在学习通中，即将开始进行下一步操作！&quot;);&#125;*//*//这个地方是检测是否在即将开始的页面if(currentActivity()==&quot;com.chaoxing.fanya.aphone.ui.chapter.KnowledgePagerActivity&quot;)&#123; //如果是在当前页面的话就直接play即可 //点击播放按钮 className(&quot;android.widget.Image&quot;).text(&quot;play&quot;).clickable().findOnce().click(); sleep(2000);&#125;*//*var countDownTime=60;//这是倒计时的秒数setInterval(function()&#123; toast(&quot;当前距离下一次检测还有&quot;+countDownTime+&quot;s！&quot;); countDownTime--; if(countDownTime==0)&#123; countDownTime=60; &#125;&#125;, 1000);*///这个是存完成情况的var completionDeploy=[];//监听音量下键是否按下，退出脚本threads.start(function()&#123; events.setKeyInterceptionEnabled(&quot;volume_down&quot;,true); //监听按键 events.observeKey(); events.onKeyDown(&quot;volume_down&quot;, function(event)&#123; toast(&quot;即将关闭当前脚本！&quot;); alert(completionDeploy);//展示信息 sleep(5000); //engines.myEngine().forceStop(); engines.myEngine().forceStop(); &#125;);&#125;);//开始定时器，每隔一分钟自动检索是否存在答题的可能性，如果需要答题的话就直接答题即可setInterval(function()&#123; //如果检测到有题目的话直接答题 answerProblem(); //如果已经看完了现在的之后 if(currentActivity()==&quot;com.chaoxing.fanya.aphone.ui.chapter.KnowledgePagerActivity&quot;)&#123; toast(&quot;当前的视频已经看完了，即将开始寻找下一个视频自动播放~&quot;); log(&quot;视频已看完，即将开始下一个视频~&quot;); //寻找下一个视频自动打开并且播放，以此类推 findNextVideo(); &#125;else&#123; toast(&quot;当前视频尚未看完！&quot;); &#125;&#125;, 1000*60);//一分钟检测一次/*//这个是测试用的setInterval(function()&#123; findNextVideo();&#125;,2000);*///具体的执行方法function answerProblem()&#123; //检测是否出现了弹窗的问题 sleep(1000); var isExistProblem=0; if(textContains(&quot;单选题&quot;).exists()||textContains(&quot;判断题&quot;).exists())&#123; isExistProblem=1; &#125;else if(textContains(&quot;多选题&quot;).exists()) isExistProblem=2; sleep(1000); log(&quot;是否存在:&quot;+isExistProblem); completionDeploy.push(&quot;是否存在：&quot;+isExistProblem+&quot;\n&quot;); if(isExistProblem==1)&#123; toast(&quot;当前存在单选题/判断题，即将开始答题！&quot;); log(&quot;当前存在单选题/判断题，即将开始答题！&quot;); completionDeploy.push(&quot;当前存在单选题/判断题，即将开始答题！&quot;+&quot;\n&quot;); //如果存在问题的话讲ABCD答案的空间全部找出来 var answerA=textContains(&quot;A&quot;).findOnce(); var answerB=textContains(&quot;B&quot;).findOnce(); var answerC=textContains(&quot;C&quot;).findOnce(); var answerD=textContains(&quot;D&quot;).findOnce(); var answerList=[answerA,answerB,answerC,answerD]; for(var i=0;i&lt;4;i++)&#123; answerList[i].parent().click(); if(isRight())&#123; //如果答题正确了，然后退出~ toast(&quot;答题完成！&quot;); log(&quot;答题完成！&quot;); completionDeploy.push(&quot;答题完成&quot;+&quot;\n&quot;); sleep(1000); break; &#125; &#125; &#125;else if(isExistProblem==2)&#123; //多选题 //toast(&quot;当前存在多选题题，即将开始答题！&quot;); log(&quot;当前存在多选题题，暂时不支持多选题，请手动答题！&quot;); completionDeploy.push(&quot;当前存在多选题题，暂时不支持多选题，请手动答题！&quot;+&quot;\n&quot;); &#125;else&#123; toast(&quot;当前的页面未检索到题目！&quot;); log(&quot;当前的页面未检索到题目！&quot;); sleep(1000); &#125; &#125;//寻找 下一个视频function findNextVideo()&#123; //下面是返回标题集页面的以便进行下一次开始答题 var titleNow=null; var titleNext=null; //currentActivity()==&quot;com.chaoxing.fanya.aphone.ui.chapter.KnowledgePagerActivity&quot; //这里是把当前已经看完的视频的标题记录下来，方便寻找下一个标题然后进行播放 titleNow=id(&quot;tv_chapter_name&quot;).findOnce().text(); toast(&quot;当前标题：&quot;+titleNow); //如果看完了返回外面的界面的话直接跳出去 id(&quot;btnBack&quot;).clickable().findOnce().click(); log(&quot;当前的界面名称：&quot;+titleNow); //完成情况添加 completionDeploy.push(titleNow+&quot;已完成！&quot;+&quot;\n&quot;); sleep(2000); //这是一个list，存放了所有 var titleList=id(&quot;tv_title&quot;).untilFind(); var titleListIndex=id(&quot;tv_sub_index&quot;).untilFind(); //log(titleList); //log(titleListIndex); for(var i=0;i&lt;titleList.length;i++)&#123; //log(titleList[i].text()); if((titleListIndex[i].text()+&quot; &quot;+titleList[i].text())==titleNow)&#123; //如果找到的话 //先滑动 swipe(device.width/2,device.width/2,device.width/2,device.height-titleList[i].bounds().centerY(),1000); titleNext=titleList[i+1].text(); toast(&quot;下一个标题的名字：&quot;+titleNext); log(&quot;下一个标题的名字：&quot;+titleNext); sleep(1000); break; &#125; &#125; if(!titleNext)&#123; toast(&quot;未找到&quot;+titleNext+&quot;标题！&quot;); sleep(1000); alert(completionDeploy);//展示信息 sleep(5000); engines.myEngine().forceStop(); &#125;else&#123; //找到控件位置然后点击进去 text(titleNext).findOnce().parent().click(); toast(&quot;已经进入 &quot;+titleNext+&quot; 标题&quot;); completionDeploy.push(&quot;已经进入 &quot;+titleNext+&quot; 标题&quot;+&quot;\n&quot;); sleep(4000); //点击播放按钮 className(&quot;android.widget.Image&quot;).text(&quot;play&quot;).clickable().findOnce().click(); sleep(2000); toast(&quot;开始播放...&quot;); &#125; //&#125; &#125;//判断当前的答题是否正确并且返回是否正确的值function isRight(answerX)&#123; //提交 if(text(&quot;提交&quot;).exists())&#123; text(&quot;提交&quot;).clickable().findOnce().click(); &#125; if(textContains(&quot;回答正确&quot;).exists())&#123; //再点击一次就重新进入看视频的状态 text(&quot;继续&quot;).clickable().findOnce().click(); toast(&quot;回答正确！&quot;); sleep(1000); return true; &#125;else if(textContains(&quot;回答错误&quot;).exists())&#123; toast(&quot;回答错误！&quot;); sleep(1000); return false; &#125;else&#123; toast(&quot;出现未知错误！&quot;); &#125;&#125; 总结其实是很简单的，但是自己的粗心大意导致开发周期无限期拉长，很难受！]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习实验-SVM模型分类]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C-SVM%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[目录： 前言 实验目的和内容 简介 步骤 使用工具 实验过程 实验结果 实验总结 前言这次的博客记录一下第一次机器学习的实验Classification with SVM model的内容，感觉还是蛮有趣的，有点儿意思。 libSVM简易使用手册这个博客就是很详细的libsvm的介绍，如果有疑问的话直接点击进去查看即可。 实验目的和内容简介这次的实验名称是Classification with SVM model，顾名思义，其实就是用SVM模型（支持向量机）进行分类。在本实验中其实就是先用train.data数据集对libsvm进行训练，再将已经训练好的模型对test.data数据集进行测试，得出本实验的结果。 步骤 首先第一步就是检查数据集是否是libsvm要求的标准输入格式，如果不是的话，还需要自行转换格式。 然后就是用train.data数据集对libsvm模型进行训练。 最后将训练好的模型对test.data进行测试得出结论然后记录即可。 使用工具这里使用的SVM软件包是台湾大学林智仁(Chih-Jen Lin)博士等开发设计的libsvm通用SVM软件包。 这里使用的编译语言是python。 通过gnuplot交互式绘图工具可视化编程。 实验过程1.由于原始数据集train.data和test.data不是libsvm的标准输入格式，这里就涉及到一个数据集预处理问题。解决方案如下： 这里我使用的是FormatDataLibsvm.xls通过Excel的宏定义来直接改变格式。 现在的数据集经过预处理之后已经变成了LIBSVM的标准输入格式了，然后将其存入两个TXT文档-TRAIN.TXT和TEST.TXT。（这里强调.TXT是为了后面的输入格式考虑） 直接通过TRAIN.TXT训练之后用模型去对TEST.TXT测试：通过命令行跳转到LIBSVM下的TOOLS目录中执行命令： 然后在gnuplot中就生成了相关的实验数据结果。 实验结果实验结果如下： 最优参数c=0.5，gamma=0.0078125 通过训练之后在test.txt数据集上的测试结果准确率accuracy=94.3754% 实验总结这次实验总的来说是很有意义的，通过libsvm这个通用SVM软件包进行了一次用SVM模型（支持向量机）进行分类的实际实验，对进一步了解SVM很有帮助。 实验中出现的问题不少，但是所幸都是解决了。具体问题如下： 首先就是对于老师专门点到的libsvm标准输入格式的问题，思考了很久，自己尝试写过C++程序来对原始数据集进行转化，想直接转化出libsvm的标准输入格式，但是失败了，所幸是通过博客了解到FormatDataLibsvm.xls这个Excel的宏，通过这个宏定义直接转换出了libsvm的标准输入格式。 然后就是关于数据集格式的问题，由于处理之后的数据集存在的是txt文本中，如果按照之前的省略后缀是不行的，必须加上具体的后缀格式才可以，之前并没有注意到这个问题，一直弄不出来。 通过实验结果的准确率可以明确的看出，其实SVM模型的作用是十分大的，也是我第一次实践中明确机器学习中这些模型的强大，获益颇多。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>实验</tag>
        <tag>libsvm</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-设备兼容]]></title>
    <url>%2F2019%2F05%2F12%2FAndroid-%E8%AE%BE%E5%A4%87%E5%85%BC%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[目录： 不同设备兼容问题 语言适配 使用字符资源 屏幕适配 创建不同的layout 创建不同的bitmap 系统版本适配 最小和目标API级别 运行时检测系统版本 平台风格和主题 不同设备兼容问题众所周知，这个世界上到目前为止出现的Android设备是各式各样的。语言，屏幕尺寸，Android的系统版本等重要的变量因素是制约一个APP的关键。如何适配不同的Android设备也是一个很重要的问题。 语言适配把UI中的字符串存储在外部文件，通过代码提取，这就是一种解决方法。 为支持多国语言，在res/中创建一个额外的values目录以连字符和ISO国家代码结尾命名，比如values-es/ 是为语言代码为”es”的区域设置的简单的资源文件的目录。Android会在运行时根据设备的区域设置，加载相应的资源。 如果已经确定支持某种语言，那么就需要创建资源的子目录以及字符串资源文件： 12345678MyProject/ res/ values/ strings.xml values-es/ strings.xml values-fr/ strings.xml 使用字符资源在源代码和其他XML文件中通过string元素的name属性来引用字符串资源。 123456// Get a string resource from your app&apos;s ResourcesString hello = getResources().getString(R.string.hello_world);// Or supply a string resource to a method that requires a stringTextView textView = new TextView(this);textView.setText(R.string.hello_world); 在XML文件中，每当XML属性要接受一个字符串值时，可以通过@string/&lt;string_name&gt;语法来引用字符串资源。 1234&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/hello_world&quot; /&gt; 屏幕适配app中应该包含一些可选资源，针对不同的屏幕尺寸和分辨率，来优化其外观。 4种普遍尺寸：小(small)，普通(normal)，大(large)，超大(xlarge) 4种普遍分辨率：低精度(ldpi), 中精度(mdpi), 高精度(hdpi), 超高精度(xhdpi) 同时不同的屏幕方向其实也是需要适配的一部分。 创建不同的layout和语言适配类似，为了针对不同的屏幕去优化用户体验，需要为每一种将要支持的屏幕尺寸创建唯一的XML文件。每一种layout需要保存在相应的资源目录中，目录以-&lt;screen_size&gt;为后缀命名。例如，对大尺寸屏幕(large screens)，一个唯一的layout文件应该保存在res/layout-large/中。 创建不同的bitmap应该为4种普遍分辨率:低，中，高，超高精度，都提供相适配的bitmap资源。这能使app在所有屏幕分辨率中都能有良好的画质和效果。能够有效的提升用户的体验。 这些图像，应该从原始的矢量图像资源着手，根据下列尺寸比例，生成各种密度下的图像。 1234xhdpi: 2.0hdpi: 1.5mdpi: 1.0 (基准)ldpi: 0.75 生成的图像和前面的类似，都是放入drawable资源目录中： 12345678910MyProject/ res/ drawable-xhdpi/ awesomeimage.png drawable-hdpi/ awesomeimage.png drawable-mdpi/ awesomeimage.png drawable-ldpi/ awesomeimage.png 这样做之后系统会在不同的设备上自动的调整选择适合的bitmap。 系统版本适配Android的系统版本是在一直更新的，如何保持老版本的支持就是一个问题。 最小和目标API级别AndroidManifest.xml文件中描述了我们的app的细节及app支持哪些Android版本。具体来说，uses-sdk元素中的minSdkVersion和targetSdkVersion 属性，标明在设计和测试app时，最低兼容API的级别和最高适用的API级别(这个最高的级别是需要通过测试的)。 应该将targetSdkVersion的值尽量的设置与最新可用的Android版本匹配。 1234&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; ... &gt; &lt;uses-sdk android:minSdkVersion=&quot;4&quot; android:targetSdkVersion=&quot;15&quot; /&gt; ...&lt;/manifest&gt; 运行时检测系统版本Android在Build常量类中提供了对每一个版本的唯一代号，在我们的app中使用这些代号可以建立条件，保证依赖于高级别的API的代码，只会在这些API在当前系统中可用时，才会执行。 1234567private void setUpActionBar() &#123; // Make sure we&apos;re running on Honeycomb or higher to use ActionBar APIs if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; ActionBar actionBar = getActionBar(); actionBar.setDisplayHomeAsUpEnabled(true); &#125;&#125; 平台风格和主题Android提供了用户体验主题，为app提供基础操作系统的外观和体验。这些主题可以在manifest文件中被应用于app中。使用内置的风格和主题，app会自然地随着Android新版本而自动适配最新的外观和体验。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(六)]]></title>
    <url>%2F2019%2F05%2F11%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[目录： 前言 Dom操作 获取Dom节点 常用方法 Dom更新 Dom插入 Dom删除 前言这一部分关于浏览器部分的知识其实是比较抽象的，建议直接在浏览器上面一边操作一边学习，这样作用更大。 Dom操作HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。 1234567更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；遍历：遍历该DOM节点下的子节点，以便进行进一步操作；添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。 获取Dom节点理所当然的，在操作一个Dom的时候应该先获取到Dom节点再进行相应的操作。 常用方法第一种 123document.getElementById() //直接定位唯一的一个DOM节点。document.getElementsByTagName() //返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。document.getElementsByClassName() // 返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。 第二种 这种方式低版本的IE8不支持。 使用querySelector()和querySelectorAll()，了解selector语法，然后使用条件来获取节点。 12345// 通过querySelector获取ID为thbelief的节点：var q1 = document.querySelector(&apos;#thbelief&apos;);// 通过querySelectorAll获取q1节点内的符合条件的所有节点：var ps = q1.querySelectorAll(&apos;div.highlighted &gt; p&apos;); 事实上，这里的DOM节点是指Element，但是DOM节点实际上是Node，在HTML中，Node包括Element、Comment、CDATA_SECTION等很多种，以及根节点Document类型，但是，绝大多数时候只关心Element，也就是实际控制页面结构的Node，其他类型的Node忽略即可。 根节点Document自动绑定为全局变量document。 Dom更新拿到Dom节点之后可以进行更新，可以直接修改节点的文本。 第一种方法 修改innerHTML属性，可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树。 注意：是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。 1234567// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;var p = document.getElementById(&apos;p-id&apos;);// 设置文本为abc:p.innerHTML = &apos;ABC&apos;; // &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;// 设置HTML:p.innerHTML = &apos;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&apos;;// &lt;p&gt;...&lt;/p&gt;的内部结构已修改 第二种方法 修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签。 123456// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;var p = document.getElementById(&apos;p-id&apos;);// 设置文本:p.innerText = &apos;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&apos;;// HTML被自动编码，无法设置一个&lt;script&gt;节点:// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p&gt; 区别： 读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本。另外注意IE&lt;9不支持textContent。 修改CSS也是经常需要的操作。 DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize。 Dom插入如果当前的Dom节点是空的，那么，直接使用innerHTML = ‘child‘就可以修改DOM节点的内容，这就相当于插入了。 如果当前的Dom节点不为空的话，不能通过那种方式，因为这样会替换掉原来的所有的子节点。 不为空有两种方法可以插入新的节点。 一个是使用appendChild，把一个子节点添加到父节点的最后一个子节点。 原始的结构： 1234567&lt;!-- HTML结构 --&gt;&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;&lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt; &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt; &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;&lt;/div&gt; 插入一项： 1234var js = document.getElementById(&apos;js&apos;), list = document.getElementById(&apos;list&apos;);list.appendChild(js); 之后的结构： 1234567&lt;!-- HTML结构 --&gt;&lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt; &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt; &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt; &lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;&lt;/div&gt; 再就是可以使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。 假设把Haskell插入到python前面： 原始结构： 123456&lt;!-- HTML结构 --&gt;&lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt; &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt; &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;&lt;/div&gt; 插入： 1234567var list = document.getElementById(&apos;list&apos;), ref = document.getElementById(&apos;python&apos;), haskell = document.createElement(&apos;p&apos;);haskell.id = &apos;haskell&apos;;haskell.innerText = &apos;Haskell&apos;;list.insertBefore(haskell, ref); 之后的结构： 1234567&lt;!-- HTML结构 --&gt;&lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;java&quot;&gt;Java&lt;/p&gt; &lt;p id=&quot;haskell&quot;&gt;Haskell&lt;/p&gt; &lt;p id=&quot;python&quot;&gt;Python&lt;/p&gt; &lt;p id=&quot;scheme&quot;&gt;Scheme&lt;/p&gt;&lt;/div&gt; Dom删除删除明显比插入操作简单很多，先获得当前节点以及其父节点，调用父节点的removeChild方法把自己删除掉即可。 1234567// 拿到待删除节点:var self = document.getElementById(&apos;thbelief&apos;);// 拿到父节点:var parent = self.parentElement;// 删除:var removed = parent.removeChild(self);removed === self; // true 注意：虽然该节点表面上是被删除了，但是实际上还在内存中。 还有一个问题，那就是，当你同时删除多个节点的时候，是否会出现问题呢？ 答案是肯定的，因为children的属性一直都是在实时的变化，原因如下： 另外，遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。所以，删除多个节点时，要注意children属性时刻都在变化。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>Dom</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(五)]]></title>
    <url>%2F2019%2F05%2F10%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[目录： 前言 浏览器对象 window navigator screen location document Cookie history 效果展示 前言众所周知，JS可以用来作为网页脚本的语言来使用。十分的方便。这里就开始记录JS对于浏览器的操作。由于目前国内很多浏览器的内核不同，编写的时候一定需要注意代码的可移植性与兼容性。 浏览器对象JS可以获取当前浏览器的对象然后进行操作。 windowwindow对象既是全局作用域也是浏览器窗口。 window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。 相对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。 在浏览器（我用的是chrome）页面F12然后在console窗口写入下面的代码回车即可。 1console.log(&apos;window inner size: &apos; + window.innerWidth + &apos; x &apos; + window.innerHeight); 结果： 1VM496:2 window inner size: 1516 x 1041 navigator这个表示的是浏览器的信息，常用属性如下： 12345navigator.appName：浏览器名称；navigator.appVersion：浏览器版本；navigator.language：浏览器设置的语言；navigator.platform：操作系统类型；navigator.userAgent：浏览器设定的User-Agent字符串。 同样的代码测试： 12345console.log(&apos;appName = &apos; + navigator.appName);console.log(&apos;appVersion = &apos; + navigator.appVersion);console.log(&apos;language = &apos; + navigator.language);console.log(&apos;platform = &apos; + navigator.platform);console.log(&apos;userAgent = &apos; + navigator.userAgent); 结果： 12345appName = NetscapeVM501:2 appVersion = 5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36VM501:3 language = zh-CNVM501:4 platform = Win32VM501:5 userAgent = Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36 注意： navigator的信息是可以被用户修改的，也就是说，其实不是百分百的正确，所以如果针对不同的浏览器编写不同的代码，不应该使用if来判断浏览器的版本。 正确的方式： 利用JS对不存在的对象会返回undefined的特质来直接使用||计算： 1var width = window.innerWidth || document.body.clientWidth; screen这个表示的是屏幕的信息，常用属性如下： 123screen.width：屏幕宽度，以像素为单位；screen.height：屏幕高度，以像素为单位；screen.colorDepth：返回颜色位数，如8、16、24。 代码测试： 1console.log(&apos;Screen size = &apos; + screen.width + &apos; x &apos; + screen.height); 结果： 1Screen size = 1920 x 1080 location表示的是当前页面的URL信息，如：（完整的URL） 1http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP 这个可以使用location.herf来获取各个值： 123456location.protocol; // &apos;http&apos;location.host; // &apos;www.example.com&apos;location.port; // &apos;8080&apos;location.pathname; // &apos;/path/index.html&apos;location.search; // &apos;?a=1&amp;b=2&apos;location.hash; // &apos;TOP&apos; 加载新的页面一般使用location.assign()。如果要重新加载当前页面，调用location.reload()方法。 12345if (confirm(&apos;重新加载当前页&apos; + location.href + &apos;?&apos;)) &#123; location.reload();&#125; else &#123; location.assign(&apos;/&apos;); // 设置一个新的URL地址&#125; document这个对象表示的是当前的页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。 document的title属性是从HTML文档中读取的，但是可以动态改变： 1document.title = &apos;努力学习JavaScript!&apos;; 执行操作之后浏览器窗口的标题就被改变了。 要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。 用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点。 document对象还有一个cookie属性，可以获取当前页面的Cookie。 CookieCookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)…，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。 Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。 JS可以通过document.cookie读取到当前页面的Cookie。 1document.cookie; 值得注意的是： 为了确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。原因是由于JS能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患。 那么httpOnly的作用是什么呢？ 设定了httpOnly的Cookie将不能被JavaScript读取，而这个行为是由浏览器实现。 history这个对象顾名思义是保存浏览器的历史记录的。 由于历史遗留的问题，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。但这不是一个好的选择，实在是太简单粗暴了，而且，由于现在的浏览器大量使用AJAX和页面交互，是以有些时候不是简单的后退就会达到效果，还容易造成不可预料的后果！所以，无论什么时候都不能使用这个对象！ 效果展示]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>浏览器对象</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客美化简述]]></title>
    <url>%2F2019%2F05%2F09%2Fhexo%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录： 前言 RSS 博客图标 侧边栏社交链接 背景动画 访问量 统计 搜索功能 顶部加载条 浏览进度 内链样式 前言之前搭建博客的时候实在是没有心思搞这些花里胡哨的，但是最近突然又有点儿兴趣了，就总结一下一些比较感兴趣的主题美化操作吧。（个人向）这里使用的是范例——next（貌似是最受欢迎的主题，网上的教程也很多），其他的主题的话还是需要自己配置的。 2019.5.9 目前的只是一部分，后面有更多的美化操作会直接在本博客下面续写，敬请期待。 RSS 所谓的RSS订阅是站点用来和其他站点之间共享内容的一种简易方式,即Really Simple Syndication(简易信息聚合)。其实作用就是用来将博客进行分享的功能。 首先就是安装插件（git bash的hexo目录下）： 1npm install --save hexo-generator-feed 然后在主题配置文件中修改rss即可： 1rss: /atom.xml 最后在侧边栏中会有显示，我嫌弃影响美观，给取消了。 博客图标所谓的博客图标其实就是当你将博客收藏为书签的时候看到的小图标。默认是next图标，这个可以直接修改。 直接在images目录（对应的主题比如说next目录下的images）下放置图片即可。然后修改主题配置文件的favicon即可，注意图片的格式，必须是ico。 12favicon: small: /images/favicon-16x16.ico 侧边栏社交链接这个很简单，直接在主题配置文件中找到social后面的内容找到，然后根据自己的需要选择就好。 123456789101112social: GitHub: https://github.com/thbelief || github E-Mail: mailto:2465749045@qq.com || envelope CSDN: https://blog.csdn.net/thbelief #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 这个可以自定义，只要自己写上去就可以了。（CSDN就是我自定义的，下面还可以设置对应的图标。） 1234567social_icons: enable: true icons_only: false transition: false E-Mail: envelope-square Github: github CSDN: crosshairs 背景动画在主题配置文件中找到canvas即可。我使用的是canvas_nest。 12345678910111213pace_theme: pace-theme-minimal# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false 访问量这个是可以在网站的底部加上访问量。 在\themes\next\layout_partials\footer.swig文件中添加下面的代码： 12345678910&lt;div class=&quot;powered-by&quot;&gt; &lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt; 统计这个可以给博客添加字数统计，阅读时长之类的功能。 首先是下载插件： 1npm install hexo-wordcount --save 然后是打开主题配置文件，然后找到post_wordcount，修改想要的功能即可： 下面是我的配置，可以根据自己的需求修改。 123456post_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 搜索功能顾名思义，就是给博客增加一个搜索功能。 先安装插件： 1npm install hexo-generator-searchdb --save 站点配置文件配置如下代码： 12345search: path: search.xml field: post format: html limit: 10000 主题配置文件修改： 先修改local_search，再修改pace_theme即可。 123# Local searchlocal_search: enable: true 顶部加载条修改主题配置文件，找到pace修改为true然后在选择一个pace_theme即可： 12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 浏览进度主题配置文件找到scrollpercent修改为true即可： 12# Scroll percent label in b2t button.scrollpercent: true 内链样式文章里的链接样式默认是只加一条下划线，颜色和普通文字一样，为了方便区分，在themes/next/source/css/_custom/custom.styl文件加以下代码，自行添加的样式都可以写在这个文件里： 12345678910.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125; &#125;]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>主题美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10家庭版远程连接腾讯云服务器（Linux）]]></title>
    <url>%2F2019%2F05%2F08%2FWin10%E5%AE%B6%E5%BA%AD%E7%89%88%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Linux%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 登录 可视化界面 步骤 win10远程连接 Win10家庭版远程连接问题（可忽略） 远程连接 输入服务器IP 远程桌面登录 前言最近写APP的时候想着弄个服务器，以便写后台，然后就去腾讯云弄了一个云服务器（Linux系统——Ubuntu64位）。然后配置云服务器之类的弄的有点儿麻烦，这里就直接写一篇博客记录一下这个过程。 登录购买云服务器之类的我就不说了，其实很简单的，就是简单的傻瓜式操作。这里直接进来找到实例。 点击登录。 这里我使用的是简单的密钥登录（密钥在登录旁边的更多里面去手动生成） 这里可以看到默认的端口和默认的用户名，关于后面会使用到的账号名与密码在哪里看呢？ 直接在腾讯云的消息里面就可以找到。（暂时用不到，但是后面远程连接之类的需要用到的） 登录之后的界面： 可视化界面没错，正式登录之后的云服务器网页端就是这样。是不是很难看？是不是很不方便？ 我也觉得，所以我使用了Linux上的可视化界面。 步骤​ 1、安装xrdp 1sudo apt-get install xrdp ​ 2、安装vnc4server 1sudo apt-get install vnc4server ​ 3、安装xubuntu-desktop 1 sudo apt-get install xubuntu-desktop ​ 4、向xsession中写入xfce4-session 1 echo “xfce4-session” &gt;~/.xsession ​ 5、开启xrdp服务 1 sudo service xrdp restart 这些步骤其实就是在云服务器中安装了可视化界面了。 win10远程连接Win10家庭版远程连接问题（可忽略）其实普通的win10远程连接也没什么，但是由于是家庭版遇到很多问题，所幸是解决了。 启用win10家庭版远程桌面服务端这个网址就是解决的地方。（这个步骤弄完之后需要重启才会生效） 远程连接输入服务器IP直接在win10搜索栏搜索远程桌面连接双击即可，打码的部分是输入云服务器的外网IP的位置。 远程桌面登录 输入前面说到的用户名和密码再点击OK即可。 这样就可以直接通过Win10远程连接Linux云服务器了！]]></content>
      <categories>
        <category>云服务器</category>
      </categories>
      <tags>
        <tag>腾讯云</tag>
        <tag>云服务器</tag>
        <tag>Linux</tag>
        <tag>WIn10家庭版</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nostalgia开发日记（一）]]></title>
    <url>%2F2019%2F05%2F07%2Fnostalgia%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 登陆界面 代码 效果演示 Activity关键代码（未完善） 效果演示 前言最近在学习基础的编程语言的时候有点儿无聊，想起很久没写Android程序了，决定开发一个新的APP。大概的定义就是一个类似于记忆日记之类的东西。目前还是没有多大的准备策划关于这个，就直接开始写了，准备后面抽个时间写好策划，目前就是写好一个登陆界面。还有最近准备开始仔仔细细的研究一下目前github上比较有趣的APP。 登陆界面代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;de.hdodenhof.circleimageview.CircleImageView xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/iv_login&quot; android:layout_width=&quot;96dp&quot; android:layout_height=&quot;96dp&quot; android:src=&quot;@drawable/login_logo&quot; app:civ_border_width=&quot;2dp&quot; app:civ_border_color=&quot;#FF000000&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;60dp&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Nostalgia&quot; android:textSize=&quot;23sp&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;160dp&quot; android:typeface=&quot;monospace&quot; android:id=&quot;@+id/tv_title&quot;/&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_userName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/tv_title&quot; android:layout_marginTop=&quot;40dp&quot; android:background=&quot;@drawable/rectangle_edittext&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_userIconName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:paddingBottom=&quot;15dp&quot; android:paddingLeft=&quot;30dp&quot; android:paddingTop=&quot;15dp&quot; android:src=&quot;@mipmap/ic_userimg&quot; /&gt; &lt;View android:id=&quot;@+id/viewName&quot; android:layout_width=&quot;1dip&quot; android:layout_height=&quot;20dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_toRightOf=&quot;@id/iv_userIconName&quot; android:background=&quot;@color/colorCursor&quot; /&gt; &lt;EditText android:id=&quot;@+id/et_userName&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;30dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_toRightOf=&quot;@id/viewName&quot; android:background=&quot;@null&quot; android:ems=&quot;19&quot; android:hint=&quot;用户名&quot; android:textColorHint=&quot;@color/colorCursor&quot; android:textCursorDrawable=&quot;@drawable/color_cursor&quot; android:textSize=&quot;15sp&quot; /&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_userPassword&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/rl_userName&quot; android:layout_marginTop=&quot;1dp&quot; android:background=&quot;@drawable/rectangle_edittext&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_userIconPwd&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:paddingBottom=&quot;15dp&quot; android:paddingLeft=&quot;30dp&quot; android:paddingTop=&quot;15dp&quot; android:src=&quot;@mipmap/ic_edittextupwd&quot; /&gt; &lt;View android:id=&quot;@+id/viewPwd&quot; android:layout_width=&quot;1dip&quot; android:layout_height=&quot;20dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_toRightOf=&quot;@id/iv_userIconPwd&quot; android:background=&quot;@color/colorCursor&quot; /&gt; &lt;EditText android:id=&quot;@+id/et_password&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;30dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_toRightOf=&quot;@id/viewPwd&quot; android:background=&quot;@null&quot; android:drawablePadding=&quot;5dp&quot; android:ems=&quot;19&quot; android:hint=&quot; 密码&quot; android:inputType=&quot;textPassword&quot; android:textColorHint=&quot;@color/colorCursor&quot; android:textCursorDrawable=&quot;@drawable/color_cursor&quot; android:textSize=&quot;15sp&quot; /&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@+id/rl_userPassword&quot; android:id=&quot;@+id/lr_relate&quot; android:layout_centerHorizontal=&quot;true&quot;&gt; &lt;CheckBox android:id=&quot;@+id/cb_checkbox&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/rl_userPassword&quot; android:layout_marginTop=&quot;20dp&quot; android:background=&quot;@null&quot; android:checked=&quot;false&quot; android:duplicateParentState=&quot;false&quot; android:text=&quot;记住密码&quot; android:textColor=&quot;#666666&quot; android:textSize=&quot;15sp&quot; android:buttonTint=&quot;@color/colorLoginButton&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;20dp&quot; android:id=&quot;@+id/tv_signIn&quot; android:text=&quot;注册账号&quot; android:background=&quot;@null&quot; android:textColor=&quot;#666666&quot; android:textSize=&quot;15sp&quot; android:layout_toRightOf=&quot;@id/cb_checkbox&quot; android:paddingLeft=&quot;20dp&quot;/&gt; &lt;/LinearLayout&gt; &lt;!--材料波纹效果--&gt; &lt;com.balysv.materialripple.MaterialRippleLayout android:id=&quot;@+id/ripple&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/lr_relate&quot; android:padding=&quot;10dp&quot; android:layout_marginTop=&quot;20dp&quot;&gt; &lt;Button android:id=&quot;@+id/btn_login&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerHorizontal=&quot;true&quot; android:background=&quot;@drawable/round_corner_bg&quot; android:gravity=&quot;center&quot; android:padding=&quot;10dp&quot; android:text=&quot;登录&quot; android:textColor=&quot;#fff&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;/com.balysv.materialripple.MaterialRippleLayout&gt;&lt;/RelativeLayout&gt; 效果演示 Activity关键代码（未完善）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.example.thbelief.nostalgia;import android.Manifest;import android.content.pm.PackageManager;import android.graphics.Color;import android.os.Build;import android.support.design.widget.Snackbar;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.CheckBox;import android.widget.EditText;import android.widget.TextView;import cn.bmob.v3.Bmob;import cn.bmob.v3.BmobObject;import cn.bmob.v3.BmobQuery;import cn.bmob.v3.BmobUser;import cn.bmob.v3.exception.BmobException;import cn.bmob.v3.listener.FindListener;import cn.bmob.v3.listener.SaveListener;import android.os.Handler;import android.widget.Toast;import com.roger.catloadinglibrary.CatLoadingView;import java.util.List;public class LoginActivity extends AppCompatActivity &#123; //CatLoadingView CatLoadingView mView; //各个数据 EditText editTextUserName; EditText editTextPassword; CheckBox checkBoxRememberPassword; TextView textViewSignIn; Button buttonLogin; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); //隐藏状态栏 if (getSupportActionBar() != null)&#123; getSupportActionBar().hide(); &#125; //初始化BombSDK Bmob.initialize(this, &quot;62151fd88930f462fb035cf7206a115d&quot;); //CatLoadingView mView=new CatLoadingView(); mView.setText(&quot;正在查询中...&quot;); //mView.setBackgroundColor(Color.parseColor(&quot;#000000&quot;)); //找id editTextUserName=findViewById(R.id.et_userName); editTextPassword=findViewById(R.id.et_password); checkBoxRememberPassword=findViewById(R.id.cb_checkbox); textViewSignIn=findViewById(R.id.tv_signIn); textViewSignIn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //注册的时候服务器会自己查询是否已经存在一样的账号，这里就不用先查询了 &#125; &#125;); buttonLogin=findViewById(R.id.btn_login); //登录的点击事件 buttonLogin.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mView.show(getSupportFragmentManager(),&quot;&quot;); Handler handler = new Handler(); handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; mView.onStop(); &#125; &#125;, 2000);//2秒后执行Runnable中的run方法 &#125; &#125;); &#125;&#125; 效果演示]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>nostalgia</tag>
        <tag>开发日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米五root教程]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%B0%8F%E7%B1%B3%E4%BA%94root%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 magisk包下载 具体步骤 前言为了使用某个东西，尝试将已经刷机的小米五备用机刷成了root之后写下这篇教程。方便自己记录以及使用~ 正文关于root的危害以及使用注意事项这里就不多嘴，懂的都懂~ 这里使用的是第三方recovery——TWRP来进行刷机。这个在小米五刷机简述中有提到过。具体下载安装可以参考这篇博客上面的东西！ magisk包下载这个包就是用来刷超级权限的。 直接前往下载地址然后下载最新的稳定版就可以了。 具体步骤1，准备一个u盘，把zip包复制到u盘，将u盘连接到手机。 2，进入TWRP中……进入“安装”，点击左下角的“选择存储”，选择“USB-OTG”，找到刚刚下载的magisk压缩包。 3，确认刷入，自动重启手机。（重启的时候注意选择不安装TWRP的应用，那个没什么用处）]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>小米五</tag>
        <tag>root</tag>
        <tag>卡刷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(四)]]></title>
    <url>%2F2019%2F05%2F05%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[目录： 面向对象 原型（prototype） 创建对象 构造函数 原型继承 class继承 面向对象原型（prototype）和Java之类的面向对象语言不同，JS中不区分类与实例的概念，而是通过原型（prototype）来实现面向对象的编程。 所谓的原型其实就是想要使用某个类型的时候如果没有这个类型直接在后面写出一个现成的对象。 简单实例： 1234567var person=&#123; name: &quot;thbelief&quot;, age: &quot;18&quot;, run: function()&#123; console.log(this.name,&quot;is running...&quot;); &#125;&#125;; 这里其实也看不出什么，后面再改变一下： 1234567891011121314var person=&#123; name: &quot;thbelief&quot;, age: &quot;18&quot;, run: function()&#123; console.log(this.name,&quot;is running...&quot;); &#125;&#125;;var xiaohua=&#123; name: &quot;小花&quot;&#125;;//这里就是把xiaohua的原型指向了对象person，其实也可以看成是继承下来的//这里只是演示使用这条语句，实际中不能这么使用xiaohua.__proto__=person; 这里的xiaohua就可以直接使用person对象的run方法了。 正确使用方法： 使用Object.create方法来传入一个原型对象，然后创建一个基于该原型的新对象（需要初始化，因为直接出来的对象是没有任何的属性的） 123456789101112131415161718192021222324var person=&#123; name: &quot;thbelief&quot;, age: &quot;18&quot;, run: function()&#123; console.log(this.name,&quot;is running...&quot;); &#125;&#125;;/*var xiaohua=&#123; name: &quot;小花&quot;&#125;;//这里就是把xiaohua的原型指向了对象person，其实也可以看成是继承下来的xiaohua.__proto__=person;*/function createPerson(name)&#123; //基于person对象原型创建一个新对象 var t=Object.create(person); //初始化 t.name=name; return t;&#125;var xiaohua=createPerson(&quot;小花&quot;);xiaohua.run(); 输出： 12[Running] node &quot;d:\脚本\tempCodeRunnerFile.javascript&quot;小花 is running... 创建对象这里其实涉及到了上面的一点儿知识——原型。 JS每个创建的对象都会设置一个原型，指向的就是它的原型对象。 例如： 先创建一个test函数。 123function test()&#123; return 0;&#125; 由于JS中万物都是对象，所以其实这也是一个对象。 它的原型链就是： 1test ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null 如果Function.prototype 中定义了某个方法，那么理所当然的，test函数当然也是可以使用的。（类似于继承） 具体的原型链指向方法： 1用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。 构造函数其实JS中的构造函数貌似和普通函数没多大的区别？ 构造函数实例： 123456function Student(name) &#123; this.name = name; this.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;); &#125;&#125; 使用： 这里使用关键字new来返回一个对象。 如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。 123var xiaoming = new Student(&apos;小明&apos;);xiaoming.name; // &apos;小明&apos;xiaoming.hello(); // Hello, 小明! 这里还涉及到一个在其它语言十分平常的问题——如果同一类对象都有相同的函数需求该怎么办呢？比如说都需要计算出工资之类的，这里就可以直接在这些对象共同的原型上增加一个类似的函数，这样这下面的这些对象都可以使用这些函数了。 有些时候可能会忘记使用new，那怎么办呢？ 在strict模式下，this.name = name将报错，因为this绑定为undefined，在非strict模式下，this.name = name不报错，因为this绑定为window，于是无意间创建了全局变量name，并且返回undefined，这个结果更糟糕。 所以，调用构造函数千万不要忘记写new。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如jslint将可以帮你检测到漏写的new。 最后，其实还可以编写一个createStudent()函数，在内部封装所有的new操作。如下： 123456789101112function Student(props) &#123; this.name = props.name || &apos;匿名&apos;; // 默认值为&apos;匿名&apos; this.grade = props.grade || 1; // 默认值为1&#125;Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);&#125;;function createStudent(props) &#123; return new Student(props || &#123;&#125;)&#125; 这个createStudent()函数有几个巨大的优点：一是不需要new来调用，二是参数非常灵活，可以不传，也可以这么传： 12345var xiaoming = createStudent(&#123; name: &apos;小明&apos;&#125;);xiaoming.grade; // 1 原型继承JS之前不支持CLASS区分类与实例，使用的是原型继承。 详情参考：JS原型继承教程 class继承关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。 如果浏览器之类的不支持ES6的话是不能使用的。 之前： 1234567function Student(name) &#123; this.name = name;&#125;Student.prototype.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);&#125; class继承： 123456789class Student &#123; constructor(name) &#123; this.name = name; &#125; hello() &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>函数</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记（三）]]></title>
    <url>%2F2019%2F05%2F04%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 函数 内置函数 函数对象引用 定义函数 导入自定义函数 空函数 参数检查 返回多值 默认参数 可变参数 关键字参数 命名关键字参数 参数组合 前言颓废了一天，想想每日任务还没有完成，实在是有点儿颓废不下去了，好吧，立马开始。 正文函数内置函数详情可以参考Python内置函数官方手册。这个手册里面全部都是Python内置的函数，可以直接通过函数名以及对应的参数直接调用。 具体包括下面这些： abs() delattr() hash() memoryview() set() all() dict() help() min() setattr() any() dir() hex() next() slice() ascii() divmod() id() object() sorted() bin() enumerate() input() oct() staticmethod() bool() eval() int() open() str() breakpoint() exec() isinstance() ord() sum() bytearray() filter() issubclass() pow() super() bytes() float() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() 当然，还可以主动的查询某个内置函数（需要提前了解函数名）： abs这里只是举例，泛指所有的内置函数名。 1help(abs) 结果：（使用VSCode编译） 123456Help on built-in function abs in module builtins:abs(x, /) Return the absolute value of the argument.None 函数对象引用函数名其实也是函数对象的一个引用，可以直接把函数名赋给一个变量，然后就相当于此函数多了一个别名，实例如下： 123test=max #将内置的最大值函数赋给testprint(test(1,2,3))print(max(1,2,3)) 结果： 1233 定义函数1.def语句+函数名+函数参数+”:”。 2.函数体，若有返回值则return返回。 注意：就算没有return返回值其实函数执行完成之后还是会返回值None。（简写：return None==return） 简单实例： 1234567def maxTwo(a,b): if a&gt;b: return a else: return bprint(maxTwo(1,2)) 输出： 12 导入自定义函数加入之前的maxTwo函数保存在了maxTwoPY.py文件中的话，可以直接在该文件的当前目录启动Python解释器，直接用下列代码导入： 1from maxTwoPY import maxTwo #前者是文件名，后者是函数名 空函数定义空函数的话有些时候还是需要的，可以直接使用pass语句。（不能为空函数体，如果为空的话其实会报错，这里其实pass只是起一个占位的作用以便调试） 12def test(): pass 参数检查Python中调用函数的话，如果参数的个数错误是会自动检测出来并且提示的，但是无法精确的反馈函数的参数类型是否正确（一般是我们自定义的函数才会出现这种情况，事实上内置函数都是另外有方法）。 一般的使用格式是： 12if not isinstance(参数名,(参数类型1,参数类型2)): raise TypeError(自定义报错信息) 简单实例： 123456789def maxTwo(a,b): if not isinstance(a,(int,float)): raise TypeError(&quot;bad type&quot;) if a&gt;b: return a else: return bprint(maxTwo(&quot;hello&quot;,2)) 输出结果： 返回多值其实Python中的返回多值就是一个tuple。 简单实例： 1234def test(a,b): test1=a+b test2=a-b return test1,test2 默认参数很多时候多参数的函数我们并不想同时输入多个参数进去，想少一点儿，这个时候默认参数的作用就体现出来了。 使用方法： 函数定义的时候就直接在形式参数位置给出默认值。（必选参数在前，默认参数在后） 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。 12345678def maxTwo(a,b=1): if not isinstance(a,(int,float)): raise TypeError(&quot;bad type&quot;) if a&gt;b: return a else: return bprint(maxTwo(1)) 输出： 11 另外，默认参数必须指向不变的对象。 可变参数很多时候由于实际问题的不确定性，其实很多时候都需要用到可变的参数。 定义一个函数： 12345def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 调用的时候需要先组装一个list或者tuple： 12calc([1, 2, 3])calc((1, 3, 5, 7)) 如果利用可变参数，会简化： 12calc(1, 2, 3)calc(1, 3, 5, 7) 替换为可变参数： 其实要做的就是在参数前面加上一个“*”，这样在函数内部默认接收到的就是一个tuple了，函数代码不用改变，调用的时候就可以变成可变参数了（0个参数也支持）： 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 那么问题来了，如果我们定义好的list或者tuple想传入可变参数函数怎么办呢？ “*”+list名即可。 12nums = [1, 2, 3]calc(*nums) 关键字参数可变参数允许传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。 而关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。 命名关键字参数对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。 但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua学习笔记(六)]]></title>
    <url>%2F2019%2F05%2F03%2FLua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 推荐网站 面向对象 四大特征 封装 继承 多态 抽象 如何使用 创建对象 访问属性 访问成员函数 完整实例 继承 重写 数据库 前言Lua的基础教程其实感觉都已经快接近尾声了，这次就直接把面向对象的这个部分以及一些其他的东西讲清楚，然后就结尾吧，其实大部分编程语言的内涵都是共通的，最主要的还是应用的问题。（只有实践才是检验真理的唯一标准！） 正文推荐网站Lua在线手册 Lua程序设计 这两个网站都是关于Lua语言的chm文档，可以参考学习，特别是第二个网站，十分的丰富。 面向对象这里的“对象”不是那个“对象”，学过C++或者Java这种面向对象语言的人肯定知道，Lua也是面向对象的，其实之前就说过Lua中其实都是对象。 四大特征封装指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。 继承继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。 多态同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。 抽象抽象(Abstraction)是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。 如何使用对象包括两个内容：属性+方法。前者使用Lua中的table表示，后者使用function表示。（继承可以通过metetable来模拟，事实上，模拟基本的对象大多时候都已经足够使用了） 另外，由于Lua中所有都是对象，是以，table其实也是对象，也有状态（成员变量以及成员函数）。 实例如下： 123456789101112--这里直接定义一个表table，其中包含了它的成员变量numtest=&#123;num=0&#125;--下面直接定义test对应的成员函数function test.addNum(count) test.num=test.num+countendprint(&quot;第一个：&quot;..test.num)test.addNum(10)print(&quot;第二个：&quot;..test.num) 结果: 创建对象这个过程其实就是为类的实例分配内存。 12--如果该类需要传入初始参数就通过小括号内传入test1=test:new(); 访问属性直接使用.来访问。 1test1.num; 访问成员函数1test1:addNum(1); 完整实例12345678910111213141516171819202122-- Meta classShape = &#123;area = 0&#125;-- 基础类方法 newfunction Shape:new (o,side) o = o or &#123;&#125; setmetatable(o, self) self.__index = self side = side or 0 self.area = side*side; return oend-- 基础类方法 printAreafunction Shape:printArea () print(&quot;面积为 &quot;,self.area)end-- 创建对象myshape = Shape:new(nil,10)myshape:printArea() 输出： 1面积为 100 继承继承的含义是——一个对象直接使用另外一个对象的属性方法之类。一般的作用就是扩展基类的属性与方法。使用场景举例：Person类下面或许就可以被继承一个Student类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556-- Meta classShape = &#123;area = 0&#125;-- 基础类方法 newfunction Shape:new (o,side) o = o or &#123;&#125; setmetatable(o, self) self.__index = self side = side or 0 self.area = side*side; return oend-- 基础类方法 printAreafunction Shape:printArea () print(&quot;面积为 &quot;,self.area)end-- 创建对象myshape = Shape:new(nil,10)myshape:printArea()Square = Shape:new()-- 派生类方法 newfunction Square:new (o,side) o = o or Shape:new(o,side) setmetatable(o, self) self.__index = self return oend-- 派生类方法 printAreafunction Square:printArea () print(&quot;正方形面积为 &quot;,self.area)end-- 创建对象mysquare = Square:new(nil,10)mysquare:printArea()Rectangle = Shape:new()-- 派生类方法 newfunction Rectangle:new (o,length,breadth) o = o or Shape:new(o) setmetatable(o, self) self.__index = self self.area = length * breadth return oend-- 派生类方法 printAreafunction Rectangle:printArea () print(&quot;矩形面积为 &quot;,self.area)end-- 创建对象myrectangle = Rectangle:new(nil,10,20)myrectangle:printArea() 输出结果： 123面积为 100正方形面积为 100矩形面积为 200 重写Lua中支持直接重写基础类的函数，在派生类中定义自己的实现方式。 实例其实就是上面一个例子中的。 数据库Lua支持的数据库：LuaSQL，支持的类型包括ODBC, ADO, Oracle, MySQL, SQLite 和 PostgreSQL。 LuaSQL可使用LuaRocks来安装需要的数据库驱动。 WIndows安装LuaRocks的方法教程 简单实例： 123456789101112131415161718192021222324252627282930313233require &quot;luasql.mysql&quot;--创建环境对象env = luasql.mysql()--连接数据库conn = env:connect(&quot;数据库名&quot;,&quot;用户名&quot;,&quot;密码&quot;,&quot;IP地址&quot;,端口)--设置数据库的编码格式conn:execute&quot;SET NAMES UTF8&quot;--执行数据库操作cur = conn:execute(&quot;select * from role&quot;)row = cur:fetch(&#123;&#125;,&quot;a&quot;)--文件对象的创建file = io.open(&quot;role.txt&quot;,&quot;w+&quot;);while row do var = string.format(&quot;%d %s\n&quot;, row.id, row.name) print(var) file:write(var) row = cur:fetch(row,&quot;a&quot;)endfile:close() --关闭文件对象conn:close() --关闭数据库连接env:close() --关闭数据库环境]]></content>
      <categories>
        <category>后端</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>脚本语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记（二）]]></title>
    <url>%2F2019%2F05%2F02%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 字符串 两个转换方法 字节bytes encode() len() 格式化 注意 List 特性 方法 tuple 相对不能修改性 单元素元组 条件判断 input()与int() 循环 for…in while break与continue dict 初始化 是否存在 in get() 删除 特性 set 初始化 方法 特性 前言貌似最近欠的博客蛮多的…但是做人还是要有始有终，努力填完自己挖的坑！ 正文字符串最新的Python3版本字符串是以Unicode编码的，意味着…Python的字符串支持多语言，例如可以包含中文在内。 两个转换方法ord()用于获取字符的整数表示。 chr()用于获取编码对应的字符。 123print(ord(&quot;A&quot;))print(ord(&quot;中&quot;))print(chr(25990)) 输出结果： 甚至可以使用十六进制作为字符串：（两者完全等同） 12&gt;&gt;&gt; &apos;\u4e2d\u6587&apos;&apos;中文&apos; 字节bytesPython中的字符串是Unicode编码，一个字符对应若干字节。如果需要上传到网络的话，需要转换为单个字节（bytes）。 在Python中在数据前面加上b前缀即表示单个字节。例如： 表示的是thbelief这8个字节。（单引号双引号都可以，其实就是正常的字符串使用方法，只是表示的意思不同而已） 1b&apos;thbelief&apos; encode()这个方法可以将Unicode表示的字符串编码为指定的bytes，反之亦然。（可以相互转换） len()计算字符串的字符数。 计算字节的字节数。 123print(len(&quot;A&quot;))print(len(&quot;你好&quot;)) 输出： 12312 格式化第一种： 和C语言一致，使用%来实现。参数如下： 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 简单实例： 1print(&apos;%2d-%02d&apos; % (3, 1)) 输出： 13-01 第二种format：（较麻烦，不推荐） 将传入的参数依次替换字符串内的占位符： 1print(&apos;Hello, &#123;0&#125;,&#123;1&#125;&apos;.format(&apos;thbelief&apos;, &quot;你好&quot;)) 输出： 1Hello, thbelief,你好 注意Python源代码其实就是一个文本文件，当源代码包含中文的时候，保存时必须指定保存为UTF-8编码，当Python解释器读取到源代码的时候，必须按UTF-8读取，所以一般在文件开头写上： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行是对于非windows系统的操作，告诉其这是一个Python可执行程序。 第二行就是说明本程序由UTF-8编码。（这里只是这么给他说，实际上究竟是什么编码还是自己编写的时候确定的，不是说你给他说你是UTF-8编码你就是了） Listlist即列表，是一种有序的集合，可以随时添加删除元素。 特性1.len()可以获取列表list里面的元素数量。 2.可以通过索引来访问列表中的元素。 1listTest[0] 3.如果列表越界的话，会报一个IndexError的错误。 1234listTest=[&apos;hello&apos;,&apos;thbelief&apos;]print(listTest[0])print(listTest[1])print(listTest[2]) 输出结果： 123hellothbeliefIndexError: list index out of range 4.访问最后一个元素的话，除了len-1索引之外，可以直接用-1下标来访问,以此类推，倒数第二个用-2…： 当然，如果反向访问越界的话，也会报错的。 1listTest[-1] 5.替换某个下标位置的元素： 直接访问赋值即可。 1listTest[i]=&apos;thbelief&apos; 6.列表中的元素的类型可以不一致。 方法1234append() 向列表的末尾增加元素insert(index，) index为下标，后一个为插入元素pop() 删除末尾元素pop(i) 删除指定下标的元素 tuple元组，和列表类似，但是初始化之后不能修改。使用()而不是list的[]. 相对不能修改性表面上来看，元组不能修改，但是，真的是这样麽？ 1234test=(&apos;a&apos;,&apos;b&apos;,[&apos;A&apos;,&apos;B&apos;])test[2][0]=&quot;hello&quot;test[2][1]=&quot;thbelief&quot;print(test) 猜猜结果是什么？ 不是说好不变的麽？为什么变了呢？ 答案是——元组并没有变，变的是元组内部的列表。指向的list并没有改变，只是其中的内容改变了！ 单元素元组单元素的元组只能这么定义： “,”是用来消除歧义的，因为如果是test=(1)，在解释器看来，就只是一个数学计算中的小括号，不会被当做元组。 1test=(1,) 条件判断由于大部分内容和C++重合，这里用一个实例来简单概括。 1234567nb=520if nb&gt;520: print(&quot;大于&quot;)elif nb&lt;520: print(&quot;小于&quot;)else: print(&quot;等于&quot;) 输出： 1等于 input()与int()输入，返回的数据类型是字符串。 1test=input(&quot;shuru:&quot;) 循环for…in依次迭代每个元素。 123test=[&quot;hello&quot;,&quot;world&quot;,&quot;thbelief&quot;]for i in test: print(i) 输出： 123helloworldthbelief 另外，Python提供一个range()函数可以生成一个整数序列，通过list就可以生成一个整数列表。（从0开始） while123456sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) break与continue用法和其他编译语言一模一样，这里就不过多赘述了。 dict全称是dictionary，也叫map，使用键值对存储，速度很快。 初始化1test=&#123;&apos;thbelief&apos;:18,&apos;nihao&apos;:20&#125; 或者： 1test[&apos;thbelief&apos;]=18 是否存在in查询该dict是否存在此key，如果存在的话返回true，否则false。 1&apos;thbelief&apos; in test 输出： 1true get()如果没获取到的话就返回第二个参数。 1test.get(&apos;thbelief&apos;, -1) 删除pop(key)即可。注意：dict内部存放的顺序和key放入的顺序是没有关系的。 特性1.key为不可变的对象，初始化之后不变。 2.可变对象不可以作为key。 set也是一组key的集合，不存在重复的key。 初始化创建的时候必须提供一个list作为输入集合：(重复元素自动过滤，同时内部非有序) 1test=set([1,2,3]) 方法add(key) 添加元素。 1test.add(1) remove(key)删除元素。 1test.remove(1) 特性1.无序和无重复元素的集合。 2.不可以放入可变对象。（如list之于元组的相对不可变性）]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10常用快捷键]]></title>
    <url>%2F2019%2F05%2F01%2FWin10%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 Alt+Tab Alt+F4 Win+L Win+D F2 F5 Alt + Enter Ctrl + Alt + Tab Ctrl+箭头键 Ctrl + Esc Ctrl + Shift + Esc Shift + Delete PrtScn Win+PrtScn Win+M Win+S Win+Shift+S Win+空格键 Win+‘+’ Win+Shift+左/右键 Alt + D Ctrl + E Ctrl+F Ctrl + N Ctrl + W F11 Win+W 前言今天是五一长假的第一天，一如往常，还是没有回家。 今天使用电脑的时候突然忘记了以前经常使用的一个win10的快捷键，于是灵感就来了，收集一些常用的win10的快捷键，方便自己使用。 正文首先，win10官方快捷键合集——这个网站是微软自己提供的快捷键的合集。（这些快捷键有些时候不一定会起作用，因为有些第三方软件会占用这个快捷键，请检查是否快捷键冲突） Alt+Tab在打开的应用之间来回的切换。 Alt+F4关闭当前的应用。 Win+L锁定电脑。 Win+D显示或者隐藏电脑桌面。 F2重命名所选项。 F5刷新活动窗口。（一般都是用于网页刷新） Alt + Enter直接打开所选项的属性窗口。 Ctrl + Alt + Tab使用鼠标在打开应用之间切换。 Ctrl+箭头键打开开始菜单使用这组快捷键可以调整开始菜单的大小。 Ctrl + Esc打开开始菜单。 Ctrl + Shift + Esc直接打开任务管理器。 Shift + Delete直接删除（不经过回收站）。 PrtScn捕获整个屏幕的屏幕截图并将其复制到剪贴板。 Win+PrtScn截取当前屏幕，放到图片文件夹下的屏幕截图文件夹中。 Win+M最小化所有的窗口。 Win+S打开搜索。 Win+Shift+S获取当前屏幕的部分截图。 Win+空格键切换输入语言以及键盘布局。 Win+‘+’打开放大镜。 Win+Shift+左/右键将桌面应用从一个显示器转移到另外一个显示器。 Alt + D选择地址栏。 Ctrl + E搜索框。（搜索其他网址之类的） Ctrl+F当前页面检索。（文字之类的） Ctrl + N打开新窗口。 Ctrl + W关闭当前的活动窗口。 F11最大化或者最小化当前的活动窗口。 Win+W打开自定义便签等等窗口。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Win10</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编实验（二）]]></title>
    <url>%2F2019%2F04%2F30%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 寄存器 指令 变量 前言关于汇编的部分其实已经耽搁很久了，今天实验课上抽时间记录一下，方便最后答辩。 正文寄存器这里只介绍实验用到的寄存器。同时将在实验中具体的描述如何使用这些寄存器。 1234567891011121314AX 累加器BX 基址寄存器 常用来存放存储器地址CX 计数器 DX 数据寄存器 一般用来存放数据SS 存放栈的段地址SP 堆栈寄存器 存放栈的偏移地址BP 基数指针寄存器 和SP联动，作为SP校准使用的，只有寻找堆栈中的数据和使用个别寻址方式的时候才可以使用到。DS 数据段寄存器 指出当前程序使用的 数据所存放段的最低地址，即存放数据段段地址。ES 附加段寄存器 存放当前执行程序中一个辅助数据段的段地址。CS 代码段寄存器 存放代码段的首地址。IP 指令指针寄存器 存放偏移地址。SI 源变址寄存器DI 目的变址寄存器PSW 标志寄存器 反映了CPU运算的状态特征并且存放某些控制标志。 指令12345678910111213ADD 加法SUB 减法MUL 无符号乘法DIV 无符号除法JA 无符号大于则转移到目标指令执行JB 无符号小于则转移到目标指令执行JG 有符号大于则跳转JL 有符号小于则跳转LOOP 主要实现循环功能INC 加1的指令DEC 减1的指令PUSH 压栈POP 弹栈 变量1234567DB 字节型变量，一个字节数据占1个字节单元，读完一个，偏移量加1。DW 字类型变量，一个字数据占2个字节单元，读完一个，偏移量加2。DD 双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加4。BUF 即BUFFER，缓冲区，意思是内存中的一段存放数据的区域。]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua学习笔记(五)]]></title>
    <url>%2F2019%2F04%2F29%2FLua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[目录： 错误处理 assert error pcall xpcall debug 调试 垃圾回收 垃圾回收函数 错误处理平时写代码的时候出现错误其实是一件十分平常的事情，自然，如何处理错误也是需要联系的方法。 一般在Lua中可以使用assert和error来处理错误。 assert简单实例： 123456local function add(a,b) assert(type(a)==&quot;number&quot;,&quot;a不是数字&quot;) assert(type(b)==&quot;number&quot;,&quot;b不是数字&quot;) return a+bendadd(10) 输出结果： 在这个过程中，assert先检查第一个参数，如果没问题什么也不做，如果有问题的话，就把第二个参数作为错误信息抛出来。 error语法： 1error (message [, level]) error的功能主要就是终止在执行的函数，同时返回message的内容作为错误信息（error永远不会返回），一般情况就是，error附加一些错误位置的信息到message的头部。 level参数： 123Level=1[默认]：为调用error位置(文件+行号)Level=2：指出哪个调用error的函数的函数Level=0:不添加错误位置信息 pcallLua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。 pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo。 语法如下： 12345if pcall(function_name, ….) then-- 没有错误else-- 一些错误end 值得注意的是，由于pcall是使用保护模式来调用第一个参数，所以可以捕获函数中执行时所有的错误。 xpcall通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。 Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。 debugdebug库提供的两个方法： 12debug.debug：提供一个Lua提示符，让用户来检查错误的原因debug.traceback：根据调用桟来构建一个扩展的错误消息 调试Lua中提供了debug库用于用户自定义调试器。 序号 方法 &amp; 用途 1. debug():进入一个用户交互模式，运行用户输入的每个字符串。 使用简单的命令以及其它调试设置，用户可以检阅全局变量和局部变量， 改变变量的值，计算一些表达式，等等。 输入一行仅包含 cont 的字符串将结束这个函数， 这样调用者就可以继续向下运行。 2. getfenv(object):返回对象的环境变量。 3. gethook(optional thread):返回三个表示线程钩子设置的值： 当前钩子函数，当前钩子掩码，当前钩子计数 4. getinfo ([thread,] f [, what]):返回关于一个函数信息的表。 你可以直接提供该函数， 也可以用一个数字 f 表示该函数。 数字 f 表示运行在指定线程的调用栈对应层次上的函数： 0 层表示当前函数（getinfo 自身）； 1 层表示调用 getinfo 的函数 （除非是尾调用，这种情况不计入栈）；等等。 如果 f 是一个比活动函数数量还大的数字， getinfo 返回 nil。 5. debug.getlocal ([thread,] f, local):此函数返回在栈的 f 层处函数的索引为 local 的局部变量 的名字和值。 这个函数不仅用于访问显式定义的局部变量，也包括形参、临时变量等。 6. getmetatable(value):把给定索引指向的值的元表压入堆栈。如果索引无效，或是这个值没有元表，函数将返回 0 并且不会向栈上压任何东西。 7. getregistry():返回注册表表，这是一个预定义出来的表， 可以用来保存任何 C 代码想保存的 Lua 值。 8. getupvalue (f, up)此函数返回函数 f 的第 up 个上值的名字和值。 如果该函数没有那个上值，返回 nil 。 以 ‘(‘ （开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块）。 10. sethook ([thread,] hook, mask [, count]):将一个函数作为钩子函数设入。 字符串 mask 以及数字 count 决定了钩子将在何时调用。 掩码是由下列字符组合成的字符串，每个字符有其含义：‘c’: 每当 Lua 调用一个函数时，调用钩子；‘r’: 每当 Lua 从一个函数内返回时，调用钩子；‘l’: 每当 Lua 进入新的一行时，调用钩子。 11. setlocal ([thread,] level, local, value):这个函数将 value 赋给 栈上第 level 层函数的第 local 个局部变量。 如果没有那个变量，函数返回 nil 。 如果 level 越界，抛出一个错误。 12. setmetatable (value, table):将 value 的元表设为 table （可以是 nil）。 返回 value。 13. setupvalue (f, up, value):这个函数将 value 设为函数 f 的第 up 个上值。 如果函数没有那个上值，返回 nil 否则，返回该上值的名字。 14. traceback ([thread,] [message [, level]]):如果 message 有，且不是字符串或 nil， 函数不做任何处理直接返回 message。 否则，它返回调用栈的栈回溯信息。 字符串可选项 message 被添加在栈回溯信息的开头。 数字可选项 level 指明从栈的哪一层开始回溯 （默认为 1 ，即调用 traceback 的那里）。 垃圾回收Lua中有自动内存管理功能，不需要主动释放内存，十分的方便。 Lua 运行了一个垃圾收集器来收集所有死对象 （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。 垃圾回收函数12345678910111213collectgarbage(&quot;collect&quot;): 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：collectgarbage(&quot;count&quot;): 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。collectgarbage(&quot;restart&quot;): 重启垃圾收集器的自动运行。collectgarbage(&quot;setpause&quot;): 将 arg 设为收集器的 间歇率 （参见 §2.5）。 返回 间歇率 的前一个值。collectgarbage(&quot;setstepmul&quot;): 返回 步进倍率 的前一个值。collectgarbage(&quot;step&quot;): 单步运行垃圾收集器。 步长&quot;大小&quot;由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。collectgarbage(&quot;stop&quot;): 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。 简单实例： 123456789101112--这是一个简单的垃圾回收实例array=&#123;&quot;hello&quot;,&quot;world&quot;,&quot;thbelief&quot;&#125;print(collectgarbage(&quot;count&quot;))array=nilprint(collectgarbage(&quot;count&quot;))print(collectgarbage(&quot;collect&quot;))print(collectgarbage(&quot;count&quot;)) 输出结果：]]></content>
      <categories>
        <category>后端</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>脚本语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto-js-Pro新特性总结]]></title>
    <url>%2F2019%2F04%2F28%2FAuto-js-Pro%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 调用JavaAPI 使用Android原生界面 前自定义UI布局 Android原生界面 如何使用 Canvas画布 SQLite数据库 协同(协程) WebSocket 前言学习使用auto.js来写脚本已经很久了，大部分都是直接贴上的THBELIEFScript软件的开发过程，并没有系统的介绍这个东西，其实我觉得不是很有必要，因为官方文档里面略微详细的描述了很大一部分的操作示例，其实大部分都是和其他的语言或者开发工具比较耦合的，众所周知，耦合性太大也不是多么美妙的事情，就算Android开发者会觉得入门很容易，但是不是自成体系终究还是落了下乘。 这篇博客的话，就简单的写一写最近Pro版本更新之后的一些新的操作以及之前开发中还没有使用到的操作，作为我的备忘录。（都以示例中的代码作为参考）。 正文调用JavaAPIScripting Java 使用Android原生界面众所周知，之前的Auto.js里面的界面UI都是用脱离出来的自定义写法直接写的，当时是不支持Android原生的界面的。但是Pro版本出来之后，就提供了这个功能。 前自定义UI布局 Android原生界面 如何使用目前的项目中如果使用Android原生的界面的话，目前直接需要的包括Android原生的Res文件夹下的内容（常规的drawable，layout，menu，values，甚至包括动画anim），以及AndroidManifest.xml，其内容如下： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- 当前版本暂时只支持这里的包名为org.autojs.autojspro，不能改成其他包名 --&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;org.autojs.autojspro&quot; &gt;&lt;/manifest&gt; 其他的文件就是自己写的js文件以及其他自己调用的东西了。 和Android中布局与点击事件分写的内容相同，Auto.js Pro里面也是如此，在Res文件夹下写好布局之后还不够，点击事件之类的具体逻辑需要放到js文件中处理，官方实例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&quot;ui&quot;;// 要使用Android Resources的特性，需要在project.json中加上androidResources属性// 之后将推出项目模块功能，可以轻松地使用项目模块创建// 使用此语句，启用本脚本的使用安卓资源的特性ui.useAndroidResources();// 设置自定义主题activity.theme.applyStyle(ui.R.style.MainTheme, true);// 设置状态栏颜色为从xml获取的颜色ui.statusBarColor(activity.resources.getColor(ui.R.color.mainColorPrimaryDark));// 对应文件 res/layout/main.xmlui.layoutFile(&quot;main&quot;);// 设置ViewPager的页面为他的子Viewui.viewPager.initAdapterFromChildren();// 底部三个按钮的idvar navigationIds = [ ui.R.id.navigation_home, ui.R.id.navigation_dashboard, ui.R.id.navigation_notifications];// 当底部按钮被选中时，切换ViewPager页面为相应位置的页面ui.navigation.setOnNavigationItemSelectedListener(function (item) &#123; ui.viewPager.currentItem = navigationIds.indexOf(item.itemId); return true;&#125;);// 当ViewPager页面切换时，切换底部按钮的状态ui.viewPager.addOnPageChangeListener(new Packages.androidx.viewpager.widget.ViewPager.OnPageChangeListener(&#123; onPageSelected: function (position) &#123; ui.navigation.setSelectedItemId(navigationIds[position]); &#125;&#125;));var anim = null;ui.fab.on(&quot;click&quot;, function () &#123; if (ui.viewPager.currentItem != 1) &#123; toast(&quot;这是一个使用Android资源构建的应用&quot;); return; &#125; if (anim != null) &#123; ui.ball.clearAnimation(); anim = null; &#125; else &#123; anim = android.view.animation.AnimationUtils.loadAnimation(activity, ui.R.anim.ball); ui.ball.startAnimation(anim); &#125;&#125;); 学过一点儿Android的其实大概都能看懂，这里就不细细的说了，总的来说，这次的这个功能写出来之后的界面绝对是更加的华丽的，十分的具有实用性，而不是之前的略微显得廉价的界面，给仁太点赞。 Canvas画布菜鸟教程-Canvas 由于之前一直在写软件，这种适合做游戏的功能并没有做，准备抽时间的话可以学一下，毕竟我很早之前就一直想做一款卡牌游戏，这个应该有用。 SQLite数据库这个也是Pro新增的特性，怎么说呢，其实开始脱离简单的键值对储存是一件蛮开心的事儿，同时也很开心，之前很多的想法可以实现了。 详细的SQLite数据库的操作可以参考菜鸟教程-SQLite。这里只是简单介绍一下Pro里面的使用方法。 协同(协程)这个和Lua中的协同差不多，这里就不细说了，详情请参考Lua学习笔记（4）。 WebSocket目前还不是很了解这个。之后了解之后再补上，这里先占位。（手动滑稽）]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>Auto.js Pro</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua学习笔记(四)]]></title>
    <url>%2F2019%2F04%2F27%2FLua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[目录： 协同 协同与线程的区别 语法 生产者-消费者问题解决（协同） I/O文件 两种模式 打开文件操作 简单模式 安全模式 协同协同，即coroutine与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，以及与其它的协同程序共享全局变量等等。 协同与线程的区别一个具有多线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。 在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。 协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。 语法 方法 描述 coroutine.create() 创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用 coroutine.resume() 重启 coroutine，和 create 配合使用 coroutine.yield() 挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果 coroutine.status() 查看 coroutine 的状态 注：coroutine 的状态有三种：dead，suspended，running，具体什么时候有这样的状态请参考下面的程序 coroutine.wrap（） 创建 coroutine，返回一个函数，一旦你调用这个函数，就进入 coroutine，和 create 功能重复 coroutine.running() 返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 corouting 的线程号 简单实例： 1234567891011121314151617181920212223242526272829303132333435363738394041--协同的实例--这个是创建协同xiecheng=coroutine.create( function(i) print(i); end)--重启协同，与创建配合使用可以唤醒函数调用coroutine.resume(xiecheng,1) --这个其实就是执行创建协同的内置函数print(coroutine.status(xiecheng)) --查看当前协同的状态print(&quot;----------&quot;)-- 打印一个分界线，方便看输出结果--下面这个是创建协同同时进入协同，和创建一样的xiecheng=coroutine.wrap( function (i) print(i); end)xiecheng(i)print(&quot;----------&quot;)xiecheng2=coroutine.create( function () for i=1,10 do print(i) if i==3 then print(coroutine.status(xiecheng2)) print(coroutine.running()) --返回正在跑的协同 end coroutine.yield() --将协同设置为挂起状态 end end)coroutine.resume(xiecheng2)coroutine.resume(xiecheng2)coroutine.resume(xiecheng2)print(coroutine.status(xiecheng2))print(coroutine.running())print(&quot;----------&quot;) 输出： 从running方法就可以看出，其实协同在底层的实现就是一个线程。 当create一个coroutine协同的时候就是在新线程中注册了一个事件。 当使用resume触发事件的时候，create的coroutine函数就被执行了，当遇到yield的时候就代表挂起当前线程，等候再次resume触发事件。 生产者-消费者问题解决（协同）1234567891011121314151617181920212223242526272829local newProductorfunction productor() local i = 0 while true do i = i + 1 send(i) -- 将生产的物品发送给消费者 endendfunction consumer() while true do local i = receive() -- 从生产者那里得到物品 print(i) endendfunction receive() local status, value = coroutine.resume(newProductor) return valueendfunction send(x) coroutine.yield(x) -- x表示需要发送的值，值返回以后，就挂起该协同程序end-- 启动程序newProductor = coroutine.create(productor)consumer() 结果： I/O文件两种模式文件流的操作无论是在C++或者C中其实已经遇到很多次了，但是Lua中略微不同，如何不同？下面开始详细介绍。 首先，Lua中的IO库分为两种模式： 12简单模式（simple model）拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。完全模式（complete model） 使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法。 所谓的简单模式，其实就是C中使用的IO方法，但是对于一些简单的文件操作还好，如果进行一些对文件的高级操作的时候，就显得十分的乏力，例如同时读取多个文件？ 打开文件操作1file = io.open(filename [, mode]) mode值如下： 模式 描述 r 以只读方式打开文件，该文件必须存在。 w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。 a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留） r+ 以可读写方式打开文件，该文件必须存在。 w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 a+ 与a类似，但此文件可读可写 b 二进制模式，如果文件是二进制文件，可以加上b + 号表示对文件既可以读也可以写 简单模式1234567891011121314151617181920212223--以只读方式打开文件file=io.open(&quot;IOTest.lua&quot;,&quot;r&quot;)-- 设置默认的输入文件为IOTest.luaio.input(file)--输出文件的第一行print(io.read())--关闭打开的文件io.close(file)--以附加的方式打开只写文件file=io.open(&quot;IOTest.lua&quot;,&quot;a&quot;)--设置默认的输出文件为IOTest.luaio.output(file)--在文件最后一行添加lua注释io.write(&quot;\n -- 文件末尾注释&quot;)--关闭打开文件io.close(file) 结果： 如上图所示，使用完全没问题，但是只能进行简单的操作，只能适应简单的文件操作。 上图实例中io.read中其实可以带参数的，如下： 模式 描述 “*n” 读取一个数字并返回它。例：file.read(“*n”) “*a” 从当前位置读取整个文件。例：file.read(“*a”) “*l”（默认） 读取下一行，在文件尾 (EOF) 处返回 nil。例：file.read(“*l”) number 返回一个指定字符个数的字符串，或在 EOF 时返回 nil。例：file.read(5) 其他的IO方法： 1234567io.tmpfile():返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除io.type(file): 检测obj是否一个可用的文件句柄io.flush(): 向文件写入缓冲中的所有数据io.lines(optional file name): 返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,但不关闭文件 安全模式很多时候我们需要同时处理多个文件或者同时处理一个文件（多操作）。 简单实例： 1234567891011121314151617-- 以只读方式打开文件file = io.open(&quot;IOTest.lua&quot;, &quot;r&quot;)-- 输出文件第一行print(file:read())-- 关闭打开的文件file:close()-- 以附加的方式打开只写文件file = io.open(&quot;test.lua&quot;, &quot;a&quot;)-- 在文件最后一行添加 Lua 注释file:write(&quot;--test&quot;)-- 关闭打开的文件file:close() 结果： 注：这里我就不重写弄文件了，直接使用上个简单模式创建的测试IOTest.lua文件。 其他方法： file:seek(optional whence, optional offset): 设置和获取当前文件位置,成功则返回最终的文件位置(按字节),失败则返回nil加错误信息。参数 whence 值可以是: “set”: 从文件头开始 “cur”: 从当前位置开始[默认] “end”: 从文件尾开始 offset:默认为0 不带参数file:seek()则返回当前位置,file:seek(“set”)则定位到文件头,file:seek(“end”)则定位到文件尾并返回文件大小 file:flush(): 向文件写入缓冲中的所有数据 io.lines(optional file name): 打开指定的文件filename为读模式并返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,并自动关闭文件。若不带参数时io.lines() &lt;=&gt; io.input():lines(); 读取默认输入设备的内容，但结束时不关闭文件,]]></content>
      <categories>
        <category>后端</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>脚本语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua学习笔记(三)]]></title>
    <url>%2F2019%2F04%2F26%2FLua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[目录： 模块与包 简介 创建 实例 require函数 加载机制 C包 Metatable元表 两个重要方法 _index元方法 总结 _newindex元方法 操作符 _call元方法 _tostring元方法 模块与包简介模块其实就是封装库。 Lua中的模块由变量、函数等已知元素组成的table构成。 创建创建一个table然后把需要导出的常量与函数放入其中，最后在返回这个table。 注：可以操作模块像操作table中的元素一样，事实上他们本质上并没有什么不同的地方。 实例注意：文件名和模块名需要一一对应… 123456789101112131415-- 文件名为test.lua-- 定义一个名字叫test的模块test=&#123;&#125;-- 定义一个常量test.changliang=&quot;常量&quot;--定义一个函数function test.functionOne() print(&quot;公有函数&quot;)end--下面这个私有函数只有通过公有函数才可以调用local function test.functionTwo() print(&quot;私有函数&quot;)endreturn test require函数这个函数是用来加载模块的。如果要加载模块，只需要简单的调用即可。 1234-- 第一种require(&quot;&lt;模块名&gt;&quot;)-- 第二种require &quot;&lt;模块名&gt;&quot; 执行之后会返回一个模块常量或函数组成的table。同时还会定义一个包含该table的全局变量。 用法如下： 12345-- test.lua 文件-- test 模块为上文提到到 test.luarequire(&quot;test&quot;)print(module.changliang)test.functionOne() 其实也可以另外定义一个名字，如： 1local name=require(&quot;test&quot;) 加载机制自定义模块不是放在所有位置都可以起作用，函数require有自己的加载策略。 require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。 这里有点儿小复杂，后面有时间专门写一篇博客详细解释。 C包这里有点儿小复杂，后面有时间专门写一篇博客详细解释。 Metatable元表在Lua中的table中可以根据对应的键key来获取value值，但是没办法对两个table同时进行操作。 元表则允许改变table的行为，每个行为都关联了对应的方法。 两个重要方法123setmetatable(table,metatable): 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。getmetatable(table): 返回对象的元表(metatable)。 对指定表设置元表： 123mytable = &#123;&#125; -- 普通表 mymetatable = &#123;&#125; -- 元表setmetatable(mytable,mymetatable) -- 把 mymetatable 设为 mytable 的元表 或者： 1mytable = setmetatable(&#123;&#125;,&#123;&#125;) 返回对象的元表： 1getmetatable(mytable) -- 返回mymetatable _index元方法通过键来访问table的时候，如果这个键没有对应的值，就会寻找该table的元表中的_index键，如果_index包含一个表格，系统就会在表格中查找对应的键。 如果__index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。 总结Lua查找一个表元素时候的规则如下： 1231.在表中查找，如果找到，返回该元素，找不到则继续。2.判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。3.判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回 nil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。 _newindex元方法这个元方法用来对表做更新。 _index方法则用来对表做访问。 当给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法，如果存在则调用这个函数而不进行赋值操作。 操作符在表可以做到某些的操作。具体操作符号参见下表： 模式 描述 __add 对应的运算符 ‘+’. __sub 对应的运算符 ‘-‘. __mul 对应的运算符 ‘*’. __div 对应的运算符 ‘/‘. __mod 对应的运算符 ‘%’. __unm 对应的运算符 ‘-‘. __concat 对应的运算符 ‘..’. __eq 对应的运算符 ‘==’. __lt 对应的运算符 ‘&lt;’. __le 对应的运算符 ‘&lt;=’. _call元方法这个方法在Lua调用一个值的时候调用。 _tostring元方法这个方法以前也遇到过类似的，顾名思义，其实就是更改表的输出行为。]]></content>
      <categories>
        <category>后端</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>脚本语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-书籍（进阶）]]></title>
    <url>%2F2019%2F04%2F25%2FAndroid-%E4%B9%A6%E7%B1%8D%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 《Java核心技术》 《Java解惑》 《Java并发编程实战》 《深入理解Java虚拟机》 《Thinking in java》 《Effective Java》 《数据结构与算法分析》 《图解HTTP》 《图解TCP/IP》 《TCP/IP详解》 Git使用手册 Android官方文档（中文版） 《第一行代码》 《APP研发录》 《Android群英传》 《深入理解Android》 《Android开发艺术探索》 《Android系统源代码情景分析》 《代码整洁之道》 《编写可读代码的艺术》 《HeadFirst设计模式》 《重构：改善既有代码的设计》 《敏捷软件开发-原则、模式与实践》 《Android源码设计模式》 《Android框架揭秘》 《Linux内核设计与实现》 《深入理解Linux内核》 《活着》 前言学Android也快一年多了，大大小小的博客教程也看了蛮多的了，实用性的编程也只是停留在很肤浅的地方，为了充实一下自己，加强自己对Android开发的了解以及打发不在电脑前面时的无聊时间。这里做一个Android学习书籍的总结，都是长久以来收集的，只看了几本书，实际上大部分时候是在看博客那些。准备接下来尽全力看完所有的书籍。 正文《Java核心技术》这个适用于Java的入门。（两本） 《Java解惑》这是一本介绍java烂代码的书… 《Java并发编程实战》全面介绍了Java的并发，以及如何设计并支持并发的数据结构。 《深入理解Java虚拟机》不难，但是很有必要。 《Thinking in java》这个适用于java进阶。 《Effective Java》实用至上！ 《数据结构与算法分析》算法与数据结构也很有学习的必要，如果没学过或者之前没学好的，可以多看看。 《图解HTTP》网络入门。 《图解TCP/IP》也是入门，通俗易懂。 《TCP/IP详解》网络的进阶。 Git使用手册Pro Git其实Android开发中Git也是必不可少的工具。好好的利用可以极大的提升效率。 Android官方文档（中文版）中文版官方文档虽然上面的很多东西都很基础，但是如果一开始就跟着官方的步骤来学的话，无疑后期接收会快很多。 《第一行代码》非常好的一本通俗易懂Android入门的书籍。基础入门的书籍只要一本就足以，这里推荐这一本，大致粗略的了解一番即可，给自己心中留下印象。当然大部分的代码手敲之后会更有效果。 《APP研发录》Android进阶。 《Android群英传》Android进阶。 《深入理解Android》Android进阶。 《Android开发艺术探索》Android进阶。 《Android系统源代码情景分析》Android进阶。 《代码整洁之道》久闻大名，代码写多了之后必看书籍之一！ 《编写可读代码的艺术》这个也是代码整洁之道一类的书籍。 《HeadFirst设计模式》只有对设计模式的深入理解才能对既有框架进行优化，才能设计更加优秀的城西！ 《重构：改善既有代码的设计》重构有些时候也是一种本事，这是毫无疑问的。 《敏捷软件开发-原则、模式与实践》没看过，别人推荐的。 《Android源码设计模式》底层书籍不必深入，但是了解也是必不可少的东西。 《Android框架揭秘》框架啊框架，必经之路。 《Linux内核设计与实现》这个的话如果不是Android全栈工程师不是非常有必要看，如果要看的话大抵能了解即可，不必深究。 《深入理解Linux内核》和上一本书的理由一样，这里给两本做参考，其实没必要看，但是看了会更加了解与深入这也是必然的。 《活着》没错，你没猜错，这本书就是字面意思，啊哈哈。从入门到入坟是不可取的，一定要好好活着！]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>书籍</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-登堂入室]]></title>
    <url>%2F2019%2F04%2F24%2Fjava%E5%9F%BA%E7%A1%80-%E7%99%BB%E5%A0%82%E5%85%A5%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 Java异常处理机制 Java I/O 泛型 简介 泛型方法 反射 简介 作用 前言前面拖了蛮久的Java学习的最后一篇博客就现在开始吧，不是说完全的学完了，只能说大致了解了，毕竟也不是什么专业的java工程师，对于Android来说，懂一点就行了，但是如果以后遇到猜到的坑或者值得记录的知识还是会写博客的。 这篇博客准备写简略一点，毕竟都开始涉及一些深入的东西了，很多大佬写的也很不错的。泛型反射需要也别注意，在安卓中很重要。 正文Java异常处理机制这里我就不嫌丑了，后面这个链接的大佬写的十分的精妙，直接移步即可。 深入理解java异常处理机制 Java I/OJava 流在处理上分为字符流和字节流。字符流处理的单元为 2 个字节的 Unicode 字符，分别操作字符、字符数组或字符串，而字节流处理单元为 1 个字节，操作字节和字节数组。 字符流一次处理一个缓冲区，字节流一次处理一个字节，明显字符流的效率要高。 参考链接 泛型简介泛型，即“参数化类型”。其实就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型方法1.所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前。 1&lt;A&gt; 2.每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 3.类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 4.泛型方法体的声明和其他方法一样。 注意:类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。 反射简介反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 作用1.运行时能判断任意一个对象所属的类。 2.在运行时构造任意一个类的对象。 3.运行时能判断任意一个类所具有的成员变量和方法。 4.运行时调用任意一个对象的方法。 5.动态代理。]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>登堂入室</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio优秀插件合集]]></title>
    <url>%2F2019%2F04%2F23%2FAndroidStudio%E4%BC%98%E7%A7%80%E6%8F%92%E4%BB%B6%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[目录： 前言 AS插件官方下载地址 插件详解 ADB WiFi Connect Android ButterKnife Zelezny CheckStyle-IDEA CodeGlance Dart fir.im upload Flutter Genymotion Gitee Github Grep Console GsonFormat LayoutFormatter Lifecycle Sorter MVPHelper Nyan Progress Bar Rainbow Brackets Translation WakaTime ECTranslation 前言从开始学习Android开始都是使用的AndroidStudio，也积累下很多的AndroidStudio上面的插件，这里就集合的注释一下，方便自己回忆。 AS插件官方下载地址插件下载官方地址 插件详解ADB WiFi Connect这个插件的作用是通过同一局域网下的WIFI连接Android设备，无线运行调试APP。（初始化连接还是需要USB线的） Android ButterKnife Zelezny官方注解：Simple plug-in for Android Studio/IDEA that allows one-click creation of Butterknife view injections. 其实简单的说，它的作用就是一键从布局文件中生成对应的View 声明和 ButterKnife 注解。这个插件十分的方便，方便什么呢？方便偷懒… CheckStyle-IDEACheckstyle是一种开发工具，可帮助程序员编写符合编码标准的Java代码。它使检查Java代码的过程自动化，从而使人类免于这项无聊（但重要）的任务。这使其成为希望实施编码标准的项目的理想选择。 Checkstyle可以检查源代码的许多方面。它可以找到类设计问题，方法设计问题。它还能够检查代码布局和格式问题。 CodeGlance这个插件的主要功能就是在代码编辑页面的右方提供一个代码小地图。 Dart这个是AS支持Dart语言的包，主要就是为了开发Flutter安装的插件。 fir.im upload这个插件是用于向fir.im平台推送应用新版本的插件。 Flutter这个就是一个新的Android框架的插件。 Genymotion这个是一个Android设备模拟器，比AS自带的好很多。 Gitee这个是向码云上传新代码的时候用到的。 Github向github推送的插件。 Grep ConsoleGrep，tail，filter，highlight …控制台所需的一切。也可以突出显示编辑器 - 非常适合分析日志… GsonFormat快速将JSON字符串转换为InnerClassEntity类.. LayoutFormatter作用于XML文件，主要的功能是规范化的调整XML里面的布局，使代码更加的规范，美化。 Lifecycle Sorter按照应用程序中调用它们的顺序对Activity或Fragment的生命周期方法进行排序。 MVPHelper一个快捷生成MVP框架即各个接口的插件。 Nyan Progress Bar这是一个不实用的插件，就是漂亮的进度条。 Rainbow Brackets彩虹括号，使代码显得更加的花里胡哨。 Translation在AS中翻译的插件。（Google） WakaTime自动检测AS的使用时间等等，主要就是做一个用户的使用情况可视化分析。 ECTranslation将选择的英文翻译成中文。 快捷键：Command+I快捷键。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>插件</tag>
        <tag>合集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM常见报错详解]]></title>
    <url>%2F2019%2F04%2F22%2FACM%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[目录： 前言 Waiting Compiling Accepted Wrong Answer Time Limit Exceeded Memory Limit Exceeded Output Limit Exceeded Floating Point Error Segmentation Fault buffer overflow – 缓冲区溢出 stack overflow – 堆栈溢出 Runtime Error Restricted Function Compilation Error Presentation Error 前言有些时候刷OJ会遇到一些OJ提交之后报错，这里就简单的汇总一下方便以后自己学习与回忆。 Waiting正在等待OJ评测程序。 CompilingOJ正在编译程序。 Accepted程序是正确的，已经成功的过了。 Wrong Answer运行的结果在样例下错误了。 Time Limit Exceeded程序运行时间太长了，超过了对应题目的时间限制。 Memory Limit Exceeded程序运行所用的内存太多了，超过了对应题目的限制。 Output Limit Exceeded程序输出了太多的内容了，超过了OJ的限制，可以试着检查程序中是否有可能存在无限循环输出。 Floating Point ErrorDivide by 0，除0错误。 Segmentation Fault下面的两种情况可能导致次错误： buffer overflow – 缓冲区溢出访问 了非法内存，或者在C/C++中访问了空指针等等。 stack overflow – 堆栈溢出有可能在c/c++程序的函数中申请了过大的空间，或者递归层次太多，导致堆栈溢出了。 Runtime Error程序在运行的时候出错了，异常终止了，导致这种状态的情况有许多，一般都是一些非法操作，比如文件操作，Java中的网络操作等等。Java中Runtime Error的更详细的叙述见下。另外C/C++中越界访问函数中定义的数组也会导致Runtime Error。 常见错误类型： 1234567891011121314151617ACCESS_VIOLATION 您的程序想从一些非法的地址空间读取或向其中写入内容。一般例如指针、数组下标越界都会造成这个错误的。ARRAY_BOUNDS_EXCEEDED 您的程序试图访问一个超出硬件支持范围的数组单元。FLOAT_DENORMAL_OPERAND 进行了一个非正常的浮点操作。一般是由于一个非正常的浮点数参与了浮点操作所引起的，比如这个数的浮点格式不正确。FLOAT_DIVIDE_BY_ZERO 浮点数除法出现除数为零的异常。FLOAT_OVERFLOW 浮点溢出。要表示的数太大，超出了浮点数的表示范围。FLOAT_UNDERFLOW 浮点下溢。要表示的数太小，超出了浮点数的表示范围。INTEGER_DIVIDE_BY_ZERO 在进行整数除法的时候出现了除数为零的异常。INTEGER_OVERFLOW 整数溢出。要表示的数值太大，超出了整数变量的范围。STACK_OVERFLOW 栈溢出。一般是由于无限递归或者在函数里使用了太大的数组变量的原因。顾名思义，stack overflow 就是是栈溢出了。在进行数值运算时，我们常常要和运算结果的溢出打交道。数值运算结果可能上溢（overflow），也可能是下溢（underflow）。不过栈的溢出显然只可能是上溢，即栈空间被用完了。 Restricted Function程序调用了不该调用的函数，比如fork(),execv(),socket等等危险的函数，在程序中只作与解决问题有关的事情，其他的操作都会被拦截下来。 Compilation Error编译错误，如果程序在本机能够正常编译，具体的要看OJ给出的提示。 Presentation Error程序运行的结果是正确的，但是格式和正确结果有点不一样。比如中间多了回车或者空格，建议仔细检查程序的输出部分。 出现这个错误有很多可能，比如说大小写？输出空格？换行符制表符？之类的东西很多，仔细研究一下题干就没问题了，离AC也就是一步之遥。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>报错</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记（一）]]></title>
    <url>%2F2019%2F04%2F21%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 输入输出 print() input() 基础 字符串 空值 变量 常量 除法 前言其实之前已经学过一部分了，但是很久没用了，就重新学习一下。本学习笔记只记录一些自己觉得蛮重要的东西，不是详细的入门博客。 学习过程中就不用Python Shell编译了，直接使用VSCode来编程。 正文输入输出print()在括号中加入字符串，可以直接打印出来。（单个或者多个字符串），多个字符串的话，遇到逗号就会输出一个空格。 123print(&quot;hello&quot;)print(&quot;hello&quot;,&quot;world&quot;)print(&quot;100+200=&quot;,100+200) 输出结果： 1234[Running] python -u &quot;c:\Users\40941\Desktop\tempCodeRunnerFile.python&quot;hellohello world100+200= 300 input()输入字符串，并存放到一个变量里面。 1name=input()//不会有任何的意思，直接就跳过去执行下一条命令了 基础字符串在Python里面””与’’的作用是一样的，单引号与双引号都是表示的是字符串。 注意：转义字符的使用！ 编码： 1&apos;I\&apos;m \&quot;OK\&quot;!&apos; 输出结果： 1I&apos;m &quot;OK&quot;! 用r’’可以表示’’内部的字符串默认不转义。 1print(r&apos;\\\t\\&apos;) 输出结果： 12[Running] python -u &quot;c:\Users\40941\Desktop\tempCodeRunnerFile.python&quot;\\\t\\ Python支持用’’’…’’’这种格式表示多行的内容，写法如下：（…是提示符，不是代码的一部分） 123print(&apos;&apos;&apos;line1... line2... line3&apos;&apos;&apos;) 空值None。和0不一样，0是有意义的，None则是一种特殊的空值。 变量变量名必须是大小写英文、数字和_下划线的组合，且不能用数字开头。 常量习惯上一般用全部大写的变量表示常量。（实际上PY中没有真正意义上的常量，都是可以改变的） 除法和C++里面的“整除”不同，Python提供了两种不同的除法。 第一种：精确除法’/‘: 结果显示为浮点数，即使整除也是浮点数，如3.0 110/3 结果： 13.3333333333333335 第二种： 地板除’//‘： 两个整数的地板除还是整数，结果只取结果的整数部分。]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua学习笔记(二)]]></title>
    <url>%2F2019%2F04%2F20%2FLua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[目录： 变量 赋值语句 多变量赋值 索引 循环 控制语句 流程控制 函数 可变参数 运算符 算术运算符 关系运算符 逻辑运算符 其它运算符 优先级 字符串 转义字符 字符串操作 字符串格式化 匹配模式 模式 捕获 数组 迭代器 泛型for迭代器 无状态迭代器 多状态迭代器 table 操作方法 变量使用前必须申明，即创建该变量。 包括：全局变量，局部变量，表中的域。 前文中提到过，Lua中所有的变量默认都是全局变量，有一种情况是例外的，那就是用local显示声明为局部变量的。 试尝试： 1234567891011a=1;local b = 2;function test() c=3; local d=4;endtest()print(&quot;a&quot;..a)print(&quot;b&quot;..b)print(&quot;c&quot;..c)print(d) 这里经过试验可以轻易的得知，local定义的变量的使用范围就是在当前的代码块儿之内的。一旦超出的话就直接归nil！ 这里使用到了Lua中的一些语法，例如function与end，这里就不一一的详细描述了，后面会讲到。 赋值语句多变量赋值在Lua中，多个变量可以一同赋值。（两边的数量相同时） 123a,b=&quot;hello&quot;,&quot;world&quot;print(a)print(b) 结果为： 12helloworld 当变量的个数不等于赋值个数的时候？ 12a. 变量个数 &gt; 值的个数 按变量个数补足nilb. 变量个数 &lt; 值的个数 多余的值会被忽略 注意，当函数返回多个值的时候，可以直接使用多变量赋值： 1a,b=fun() 这里的话返回的多个值会直接赋值给前面的变量。 索引对table表的使用索引主要就是包括了两种： 123456site=&#123;&#125;site[&quot;key&quot;]=&quot;thbelief&quot;--第一种方法print(&quot;第一种&quot;..site[&quot;key&quot;])--第二种方法print(&quot;第二种&quot;..site.key) 输出结果： 12第一种thbelief第二种thbelief 循环 循环类型 描述 while 循环 在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。 for 循环 重复执行指定语句，重复次数可在 for 语句中控制。 repeat…until 重复执行循环，直到 指定的条件为真时为止 循环嵌套 可以在循环内嵌套一个或多个循环语句（while do … end;for … do … end;repeat … until;） 控制语句Break：退出当前循环或语句。 流程控制需要特别注意，在Lua中0是true。 在Lua中，只有nil和false为假！ if语句、if…else语句、if的嵌套语句。 函数Lua中函数的定义： 1234optional_function_scope function function_name( argument1, argument2, argument3..., argumentn) function_body return result_params_comma_separatedend optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。 function_name: 指定函数名称。 argument1, argument2, argument3…, argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。 function_body: 函数体，函数中需要执行的代码语句块。 result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。 可变参数和c语言类似，Lua中用…表示函数有可变的参数。 select(‘#’, …) 返回可变参数的长度 select(n, …) 用于访问 n 到 select(‘#’,…) 的参数 123456789function add(...)--这里使用...表示可变参数local s=0for i,v in ipairs&#123;...&#125; do s=s+vendprint(&quot;可变参数数量：&quot;..select(&quot;#&quot;, ...))return sendprint(add(1,2,3,4)) 运算符算术运算符 操作符 描述 实例 + 加法 A + B 输出结果 30 - 减法 A - B 输出结果 -10 * 乘法 A * B 输出结果 200 / 除法 B / A w输出结果 2 % 取余 B % A 输出结果 0 ^ 乘幂 A^2 输出结果 100 - 负号 -A 输出结果v -10 由于太简单了，这里就不写例子了。 关系运算符 操作符 描述 实例 == 等于，检测两个值是否相等，相等返回 true，否则返回 false (A == B) 为 false。 ~= 不等于，检测两个值是否相等，相等返回 false，否则返回 true (A ~= B) 为 true。 &gt; 大于，如果左边的值大于右边的值，返回 true，否则返回 false (A &gt; B) 为 false。 &lt; 小于，如果左边的值大于右边的值，返回 false，否则返回 true (A &lt; B) 为 true。 &gt;= 大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false (A &gt;= B) 返回 false。 &lt;= 小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false (A &lt;= B) 返回 true。 这里需要注意的就是~=，和其它高级语言使用的！=不同，Lua中用~=表示不等于。 逻辑运算符 操作符 描述 实例 and 逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。 (A and B) 为 false。 or 逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。 (A or B) 为 true。 not 逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。 not(A and B) 为 true。 其它运算符 操作符 描述 实例 .. 连接两个字符串 a..b ，其中 a 为 “Hello “ ， b 为 “World”, 输出结果为 “Hello World”。 # 一元运算符，返回字符串或表的长度。 #”Hello” 返回 5 这两个其它运算符之前提过，这里就不详细描述了。 优先级12345678^not - (unary)* /+ -..&lt; &gt; &lt;= &gt;= ~= ==andor 字符串转义字符 转义字符 意义 ASCII码值（十进制） \a 响铃(BEL) 007 \b 退格(BS) ，将当前位置移到前一列 008 \f 换页(FF)，将当前位置移到下页开头 012 \n 换行(LF) ，将当前位置移到下一行开头 010 \r 回车(CR) ，将当前位置移到本行开头 013 \t 水平制表(HT) （跳到下一个TAB位置） 009 \v 垂直制表(VT) 011 \ 代表一个反斜线字符’’\’ 092 \’ 代表一个单引号（撇号）字符 039 \” 代表一个双引号字符 034 \0 空字符(NULL) 000 \ddd 1到3位八进制数所代表的任意字符 三位八进制 \xhh 1到2位十六进制所代表的任意字符 二位十六进制 字符串操作 序号 方法 &amp; 用途 1 string.upper(argument): 字符串全部转为大写字母。 2 string.lower(argument): 字符串全部转为小写字母。 3 string.gsub(mainString,findString,replaceString,num) 在字符串中替换,mainString为要替换的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换）` 4 string.find (str, substr, [init, [end]]) 在一个指定的目标字符串中搜索指定的内容(第三个参数为索引),返回其具体位置。不存在则返回 nil。 5 string.reverse(arg) 字符串反转 6 string.format(…) 返回一个类似printf的格式化字符串 7 string.char(arg) 和 string.byte(arg[,int]) char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符) 8 string.len(arg) 计算字符串长度。 9 string.rep(string, n) 返回字符串string的n个拷贝 10 .. 链接两个字符串 11 string.gmatch(str, pattern) 回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。 12 string.match(str, pattern, init) string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。 字符串格式化字符串格式化过程中可能用到的转义码： 123456789101112%c - 接受一个数字, 并将其转化为ASCII码表中对应的字符%d, %i - 接受一个数字并将其转化为有符号的整数格式%o - 接受一个数字并将其转化为八进制数格式%u - 接受一个数字并将其转化为无符号整数格式%x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母%X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母%e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e%E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E%f - 接受一个数字并将其转化为浮点数格式%g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式%q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式%s - 接受一个字符串并按照给定的参数格式化该字符串 将格式细化的时候，可以在%后面添加参数，参数的读入顺序如下： (1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号. (2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格. (3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐. (4) 宽度数值 (5) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位. 匹配模式字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类 %d 匹配任意数字。所以可以使用模式串 %d%d/%d%d/%d%d%d%d 搜索 dd/mm/yyyy 格式的日期： 123s = &quot;Deadline is 30/05/1999, firm&quot;date = &quot;%d%d/%d%d/%d%d%d%d&quot;print(string.sub(s, string.find(s, date))) 结果： 130/05/1999 所有的字符类： 1234567891011121314.(点): 与任何字符配对%a: 与任何字母配对%c: 与任何控制符配对(例如\n)%d: 与任何数字配对%l: 与任何小写字母配对%p: 与任何标点(punctuation)配对%s: 与空白字符配对%u: 与任何大写字母配对%w: 与任何字母/数字配对%x: 与任何十六进制数配对%z: 与任何代表0的字符配对%x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对[数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对[^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对 特别注意，当字符类使用大写字母的时候表示的是与非此字符类的所有其他字符配对，如%S表示与任何非空白字符配对。 特殊字符： 1( ) . % + - * ? [ ^ $ ‘%’ 用作特殊字符的转义字符，因此 ‘%.’ 匹配点；’%%’ 匹配字符 ‘%’。转义字符 ‘%’不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。 模式条目可以是： 单个字符类匹配该类别中任意单个字符； 单个字符类跟一个 ‘*‘， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串； 单个字符类跟一个 ‘+‘， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串； 单个字符类跟一个 ‘-‘， 将匹配零或更多个该类的字符。 和 ‘*‘ 不同， 这个条目总是匹配尽可能短的串； 单个字符类跟一个 ‘?‘， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个； %*n*， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。 %b*xy*， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。 %f[*set*]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 ‘\0‘ 一样。 模式模式 指一个模式条目的序列。 在模式最前面加上符号 ‘^‘ 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 ‘$‘ 将使匹配过程锚定到字符串的结尾。 如果 ‘^‘ 和 ‘$‘ 出现在其它位置，它们均没有特殊含义，只表示自身。 捕获模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 &quot;(a*(.)%w(%s*))&quot; ， 字符串中匹配到 &quot;a*(.)%w(%s*)&quot; 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 “.“ 匹配到的字符是 2 号捕获物， 匹配到 “%s*“ 的那部分是 3 号。 作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 “()aa()”作用到字符串“flaaap”上，将产生两个捕获物： 3 和 5 。 数组在Lua中，由于只有nil与false是假的，所以可以通过负数作为索引。 默认情况下，索引是通过1开始访问的。 一般来说，索引都是自己设置的，主要就是为了防止出现nil引起异常。 其它的数组特性和C++之类的很类似，这里就不详细描述了，直接跳过。 迭代器在 Lua 中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。 泛型for迭代器实际上泛型for在自身内部保存了三个值：迭代函数、状态常量、控制变量。 泛型for迭代器自身提供的集合的键值对语法格式： 123for k, v in pairs(t) do print(k, v)end k、v为变量列表，paies(t)为表达式列表。 实例如下： 12345array=&#123;&quot;hello&quot;,&quot;thbelief&quot;&#125;for key,value in pairs(array)do print(key,value)end 输出： 121 hello2 thbelief 泛型for的执行过程： 1.初始化，计算in后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。 2.将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。 3.将迭代函数的值赋值给参数列表。 4.判断是否为nil，是的话就结束循环，否则的话执行循环体。 5.回到第二步再次调用迭代函数。 其实可以把迭代器看做是一个函数，每次调用就返回集合的下一个元素。 无状态迭代器无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。 每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。 这种无状态迭代器的典型的简单的例子是 ipairs，它遍历数组的每一个元素。 多状态迭代器很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包。 还有一种方法就是将所有的状态信息封装到 table 内，将 table 作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在 table 内，所以迭代函数通常不需要第二个参数。 实例如下： 1234567891011121314151617181920array = &#123;&quot;hello&quot;, &quot;thbelief&quot;&#125;function elementIterator (collection) local index = 0 local count = #collection -- 闭包函数 return function () index = index + 1 if index &lt;= count then -- 返回迭代器的当前元素 return collection[index] end endendfor element in elementIterator(array)do print(element)end tableLua中的table使用的是关联型数组，可以使用任意的类型来做数组的索引，除了nil。 给一个变量a赋值为table表类型的时候，其实只是给的地址，指向的是内存，如果将a赋值给b，则两个变量指向的都是一个内存。 操作方法 序号 方法 &amp; 用途 1 table.concat (table [, sep [, start [, end]]]):concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。 2 table.insert (table, [pos,] value):在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾. 3 table.maxn (table)指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现) 4 table.remove (table [, pos])返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。 5 table.sort (table [, comp])对给定的table进行升序排序。 部分实例：]]></content>
      <categories>
        <category>后端</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>脚本语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua学习笔记(一)]]></title>
    <url>%2F2019%2F04%2F20%2FLua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： 基本语法 交互式编程 脚本式编程 注释 单行注释 多行注释 标识符 关键词 全局变量 数据类型 nil bool number string table function thread userdata 基本语法交互式编程所谓的交互式编程的意思，其实就是在命令行中输入程序就可以立即查看效果。 脚本式编程将Lua代码保持在.lua文件中执行。 两种编程方式下的简单的helloword程序： 注释单行注释两个减号。 1-- 多行注释这个东西有点儿小奇怪，习惯了就没问题了。 1234--[[ 多行注释 多行注释 --]] 总的： 12345print(&quot;helloword&quot;)--print(&quot;helloworld&quot;)--[[print(&quot;helloworld&quot;)--]] 标识符标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上0个或多个字母，下划线，数字（0到9）。 最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。 Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua 是一个区分大小写的编程语言。 正确标识符举例： 1mohd zara abc move_name a_123 关键词下面罗列出Lua的一些保留关键词，这些词不能作为常量或者变量或者用户的自定义标识符。 注意：下划线+大写字符串被默认为Lua内部的全局变量。 and break do else elseif end false for function if in local nil not or repeat return then true until while 全局变量和C++等语言不同的是，在Lua中，所有的变量都是所谓的“全局变量”。 并不需要声明，用的时候直接访问就可以了，如果访问一个未初始化的变量并不会报错，只是会返回一个nil而已，这里nil的意思其实就是false的意思？同理，删除一个全局变量直接赋值为nil即可。 12b = nilprint(b) 结果为： 1nil 数据类型Lua是动态的类型语言，它的变量不需要类型定义，只需要赋值即可。 数据类型 描述 nil 这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。 boolean 包含两个值：false和true。 number 表示双精度类型的实浮点数 string 字符串由一对双引号或单引号来表示 function 由 C 或 Lua 编写的函数 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路，用于执行协同程序 table Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。 可以使用type函数测试变量的类型： nil表示的是“空”，没有任何的有效值，它只能输出一个nil值。 这里需要特别的注意：使用nil做判断的时候必须用双引号： 这里第一个为false的原因是： 1type(type(X))==string booltrue和false两种值。 numberLua中默认的number类型只有一种——double（双精度）。 string和JS中差不多，双引号或者单引号都可以表示字符串。[[]] 可以表示”一块“字符串。 注意：Lua中字符串的拼接有点儿特殊，和其它的高级语言不一样： 只能使用”..”,不能使用”+”. 字符串长度计算——“#” 1print(#&quot;test&quot;) 输出： 14 tabletable即表，在Lua中table是通过“构造表达式”来实现的，最简单的就是“{}”，这个就是一个空表，也可以初始化表，即添加一些数据就可以了。 在Lua中，table其实就是一个关联数组。数组的索引可以是数字或者字符串。 和c++之类的不一样，Lua默认初始索引一般以1开始。 12345-- 创建一个空的 tablelocal tbl1 = &#123;&#125; -- 直接初始表local tbl2 = &#123;&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;&#125; 注意： table没有长度，一般是需要的时候直接加进去即可，没初始化的table的值都是nil。 functionLua中，函数可以存在变量里面。这个特性和JavaScript里面的特性有点儿像。 thread在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。 线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。 userdata所谓的自定义类型。 主要就是用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。]]></content>
      <categories>
        <category>后端</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>脚本语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(十二)]]></title>
    <url>%2F2019%2F04%2F19%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 截图取色 连续发送 个人信息界面 前言今天主要就是修复了一些BUG，优化了个人信息界面的升级系统（皮），加上新增了两个新的功能，包括截图取色以及连续发送的功能。 正文截图取色 这里借用的是一位大佬的框架。 主要的功能： 截图或者从相册中选择图像，然后可放缩显示的图像实现以方便的取色。 连续发送 主要实现的其实就是简单的聊天界面简简单单的连续发送。 可调整发送内容，发送频率以及可控停止。 关键代码如下： 123456789101112131415161718192021222324252627//4.19 连续发送function continuousTransmissionFunction()&#123; isKeyDown();//检测是否按下了音量下键 toast(&quot;请前往需要连续发送的聊天界面！&quot;); sleep(1000); var sendSpeed=rawInput(&quot;请输入发送的速度(每几秒发送一次):&quot;); var discourse=&quot;你好...&quot;; if(sendSpeed&gt;0)&#123; //只有输入的大于等于零才可以进入 floatingWindowDownGlide(&quot;发送内容&quot;,&quot;修改&quot;,modifyMessage); suspendButton(sendMessage); &#125;else&#123; toast(&quot;脚本启动失败，速度必须大于0！&quot;) &#125; function sendMessage()&#123; setInterval(()=&gt;&#123; className(&quot;android.widget.EditText&quot;).clickable().findOne().setText(discourse); sleep(1000); className(&quot;android.widget.Button&quot;).text(&quot;发送&quot;).findOnce().click();//发送即可 &#125;,sendSpeed*1000); &#125; function modifyMessage(input)&#123; discourse=input; &#125;&#125; 个人信息界面这个就纯粹是花里胡哨了。不实用，但是做的时候很开心。 关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function personalInformationUI()&#123; ui.layout( &lt;frame&gt; &lt;vertical&gt; &lt;horizontal&gt; &lt;button id=&quot;backMainUIBypersonalUI&quot; text=&quot;返回&quot; w=&quot;auto&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; /&gt; &lt;/horizontal&gt; &lt;vertical gravity=&quot;center&quot;&gt; &lt;img src=&quot;https://img.icons8.com/color/48/000000/joe-pineapples.png&quot; w=&quot;100&quot; h=&quot;100&quot; circle=&quot;true&quot; borderWidth=&quot;2dp&quot; borderColor=&quot;#202020&quot; gravity=&quot;center&quot; marginTop=&quot;100dp&quot;/&gt; &lt;text id=&quot;level&quot; text=&quot;等级: 普通会员(Min)&quot; gravity=&quot;center&quot; marginTop=&quot;20dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;horizontal gravity=&quot;center&quot;&gt; &lt;text id=&quot;progress_value&quot; text=&quot;经验值：0/100&quot; marginleft=&quot;10dp&quot; layout_weight=&quot;3&quot; gravity=&quot;center&quot; marginTop=&quot;10dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;progressbar id=&quot;progress&quot;layout_weight=&quot;6&quot; marginTop=&quot;10dp&quot; style=&quot;@style/Base.Widget.AppCompat.ProgressBar.Horizontal&quot;/&gt; &lt;button id=&quot;upgrade&quot; text=&quot;升级&quot; layout_weight=&quot;1&quot; marginTop=&quot;10dp&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; /&gt; &lt;/horizontal&gt; &lt;text id=&quot;username&quot; text=&quot;&quot; gravity=&quot;center&quot; marginTop=&quot;20dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text id=&quot;userpassword&quot; text=&quot;&quot; gravity=&quot;center&quot; marginTop=&quot;10dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;/vertical&gt; &lt;/vertical&gt; &lt;/frame&gt; ); if(storage.get(&quot;level&quot;)==&quot;至尊会员(Max)&quot;)&#123; ui.progress.setProgress(100); ui.level.setText(&quot;等级：&quot;+storage.get(&quot;level&quot;)); ui.progress_value.setText(&quot;经验值：100/100&quot;); &#125;else&#123; toast(&quot;请升级至至尊会员，升级不花一分钱，一键满级！&quot;); &#125; var isOverUpgrade = null; ui.upgrade.click(()=&gt;&#123; if(ui.progress.getProgress()==0)&#123; if(isOverUpgrade != null)&#123; stopDownload(); &#125;else&#123; startDownload(); &#125; &#125;else&#123; toast(&quot;升级失败，正在升级或者已经升至满级！&quot;); &#125; &#125;); function stopDownload()&#123; storage.remove(&quot;level&quot;); storage.put(&quot;level&quot;,&quot;至尊会员(Max)&quot;); toast(&quot;已经升级至最高等级！&quot;) clearInterval(isOverUpgrade); isOverUpgrade = null; &#125; function startDownload()&#123; if(ui.progress.getProgress() == 100)&#123; ui.progress.setProgress(0); &#125; isOverUpgrade = setInterval(()=&gt;&#123; var p = ui.progress.getProgress(); p++; if(p &gt; 100)&#123; ui.level.setText(&quot;等级: 至尊会员(Max)&quot;); alert(&quot;恭喜账号:&quot;+&quot;\n &quot;+storage.get(&quot;username&quot;)+&quot;您升至至尊会员！&quot;); stopDownload(); return; &#125; ui.progress.setProgress(p); ui.progress_value.setText(&quot;经验值：&quot;+p.toString()+&quot;/100&quot;); &#125;,50); &#125; ui.username.setText(&quot;用户名: &quot;+storage.get(&quot;username&quot;)); ui.userpassword.setText(&quot;密码: &quot;+storage.get(&quot;userpassword&quot;)); ui.backMainUIBypersonalUI.click(()=&gt;&#123; //退出之前必须先停掉 if(isOverUpgrade)&#123; clearInterval(isOverUpgrade); toast(&quot;升级尚未完成即退出，升级失败！&quot;); &#125; mainUI(); &#125;);&#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(三)]]></title>
    <url>%2F2019%2F04%2F18%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 JS三种输出方式 window.alert() console系列 document.write() JS标准对象 Date JSON 前言好久都没有更新JS的学习笔记了，现在有点儿空，就抽时间写篇博客记录一下。 正文JS三种输出方式这个其实是例外的，只是突然想在VSCode中调试JS程序，然后就专门的查了一下这个相关的。 window.alert()它会将括号内的内容以弹窗的方式展现出来。 console系列这个方式一般用于在编译器如VSCode之类的地方使用，很方便。 123console.log(&apos;控制台.日志()&apos;); console.warn(&apos;控制台.警告()&apos;); console.error(&apos;控制台.错误()&apos;); document.write()直接在页面上显示内容。 JS标准对象DateDate对象和Android中的一样都是用于获取日期与时间。 注意：这里只是获取本机的时间，不是网络时间，有些时候会出现问题。 常用方法： 1234567891011var now = new Date();now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)now.getFullYear(); // 2015, 年份now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月now.getDate(); // 24, 表示24号now.getDay(); // 3, 表示星期三now.getHours(); // 19, 24小时制now.getMinutes(); // 49, 分钟now.getSeconds(); // 22, 秒now.getMilliseconds(); // 875, 毫秒数now.getTime(); // 1435146562875, 以number形式表示的时间戳 示例： Date对象的创建 12var d = new Date(2015, 5, 19, 20, 15, 30, 123);//传入参数var d = Date.parse(&apos;2015-06-24T19:49:22.875+08:00&apos;);//ISO 8601格式分字符串 注意：传入参数创建的时候月份是0~11，意思是如果是六月的话需要传入的是5. JSON这个其实也是Android中遇到的朋友，很是熟悉了，这里就简单的说一下。 JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。 123456number：和JavaScript的number完全一致；boolean：就是JavaScript的true或false；string：就是JavaScript的string；null：就是JavaScript的null；array：就是JavaScript的Array表示方式——[]；object：就是JavaScript的&#123; ... &#125;表示方式。 注意：JSON还定死了字符集必须是UTF-8，为了统一解析，JSON的字符串规定必须用双引号””，Object的键也必须用双引号””。 另外，JSON.parse()可以把JSON字符串转变成一个JavaScript对象。]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>学习</tag>
        <tag>JS输出</tag>
        <tag>Date</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(十一)]]></title>
    <url>%2F2019%2F04%2F18%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 前言今天就是更新了4.9.0的版本，新增了一个二维码生成的功能，准备下一次重构底层代码了，现在写起来有点儿小难受。 正文二维码生成功能页面： 目前有的规划： 二维码生成的关键代码： 1234567891011121314151617//网络请求图片然后保存到本地 //这里用的是type1，返回的是base64encode编码的字符串,type2返回的就是图片png格式 threads.start(function()&#123; var url=&quot;http://apis.juhe.cn/qrcode/api?key=684e3d257f6034ebdfd80a2bbeddeb18&amp;type=2&amp;fgcolor=&quot;+ui.backgroundColor.text()+&quot;&amp;w=&quot;+ui.size.text()+&quot;&amp;m=&quot;+ui.marginSize.text()+&quot;&amp;text=&quot;+ui.textContent.text(); var img=images.load(url); if(img!=null)&#123; toast(&quot;网络请求成功&quot;); //提示一下是不是要生成？ //在根目录下创建一个文件夹“THBELIEFScript二维码” files.create(&quot;/sdcard/THBELIEFScript二维码/&quot;); images.save(img,&quot;/sdcard/THBELIEFScript二维码/&quot;+ui.textContent.text()+&quot;.png&quot;,&quot;png&quot;,100); toast(&quot;该二维码图片保存在&quot;+&quot;/sdcard/THBELIEFScript二维码/&quot;+ui.textContent.text()+&quot;.png&quot;); log(&quot;该二维码图片保存在&quot;+&quot;/sdcard/THBELIEFScript二维码/&quot;+ui.textContent.text()+&quot;.png&quot;); &#125;else&#123;//网络请求失败 toast(&quot;网络请求失败!&quot;); &#125;; &#125;);]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(十)]]></title>
    <url>%2F2019%2F04%2F17%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%8D%81%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 前言乘着今天没事就更新一下THBELIEFScript。 4.8.0的更新内容： 具体的更新状态： 个人信息： 设备信息: 正文个人信息主要代码： 123456789101112131415161718192021222324//个人信息的展示页面function personalInformationUI()&#123; ui.layout( &lt;frame&gt; &lt;vertical&gt; &lt;horizontal&gt; &lt;button id=&quot;backMainUIBypersonalUI&quot; text=&quot;返回&quot; w=&quot;auto&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; /&gt; &lt;/horizontal&gt; &lt;vertical gravity=&quot;center&quot;&gt; &lt;img src=&quot;https://img.icons8.com/color/48/000000/joe-pineapples.png&quot; w=&quot;100&quot; h=&quot;100&quot; circle=&quot;true&quot; borderWidth=&quot;2dp&quot; borderColor=&quot;#202020&quot; gravity=&quot;center&quot; marginTop=&quot;100dp&quot;/&gt; &lt;text id=&quot;level&quot; text=&quot;等级: 至尊会员(MAX)&quot; gravity=&quot;center&quot; marginTop=&quot;20dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text id=&quot;username&quot; text=&quot;&quot; gravity=&quot;center&quot; marginTop=&quot;20dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text id=&quot;userpassword&quot; text=&quot;&quot; gravity=&quot;center&quot; marginTop=&quot;10dp&quot; textSize=&quot;20sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;/vertical&gt; &lt;/vertical&gt; &lt;/frame&gt; ); ui.username.setText(&quot;用户名: &quot;+storage.get(&quot;username&quot;)); ui.userpassword.setText(&quot;密码: &quot;+storage.get(&quot;userpassword&quot;)); ui.backMainUIBypersonalUI.click(()=&gt;&#123; mainUI(); &#125;);&#125; 设备信息的主要代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function mainUI()&#123; ui.layout( &lt;frame&gt; &lt;vertical gravity=&quot;center&quot;&gt; &lt;text gravity=&quot;center&quot; text=&quot;设备信息&quot; textSize=&quot;30sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Width&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Height&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;BuildId&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Broad&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Brand&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Device&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Model&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Product&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Bootloader&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Hardware&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Fingerprint&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Serial&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;SdkInt&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Incremental&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Release&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;BaseOS&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;SecurityPatch&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;Codename&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;GetAndroidId&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;GetMacAddress&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;GetTotalMem&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;text gravity=&quot;center&quot; id=&quot;GetAvailMem&quot; text=&quot;&quot; textSize=&quot;15sp&quot; textColor=&quot;#000000&quot;/&gt; &lt;/vertical&gt; &lt;/frame&gt; ); ui.Width.setText(&quot;设备宽度： &quot;+device.width); ui.Height.setText(&quot;设备高度： &quot;+device.height); ui.BuildId.setText(&quot;修订版本号： &quot;+device.buildId); ui.Broad.setText(&quot;主板型号： &quot;+device.broad); ui.Brand.setText(&quot;厂商品牌： &quot;+device.brand); ui.Device.setText(&quot;工业设计名称： &quot;+device.device); ui.Model.setText(&quot;设备型号： &quot;+device.model); ui.Product.setText(&quot;整个产品名称： &quot;+device.product); ui.Bootloader.setText(&quot;Bootloader版本： &quot;+device.bootloader); ui.Hardware.setText(&quot;硬件名称： &quot;+device.hardware); ui.Fingerprint.setText(&quot;唯一标识码： &quot;+device.fingerprint); ui.Serial.setText(&quot;硬件序列号： &quot;+device.serial); ui.SdkInt.setText(&quot;AndroidAPI版本： &quot;+device.sdkInt); ui.Incremental.setText(&quot;Incremental： &quot;+device.incremental); ui.Release.setText(&quot;Android系统版本号： &quot;+device.release); ui.BaseOS.setText(&quot;BaseOS： &quot;+device.baseOS); ui.SecurityPatch.setText(&quot;安全补丁程序级别： &quot;+device.securityPatch); ui.Codename.setText(&quot;开发代号： &quot;+device.codename); ui.GetAndroidId.setText(&quot;AndroidId： &quot;+device.getAndroidId()); ui.GetMacAddress.setText(&quot;Mac地址： &quot;+device.getMacAddress()); ui.GetTotalMem.setText(&quot;内存总量： &quot;+device.getTotalMem()); ui.GetAvailMem.setText(&quot;当前可用内存： &quot;+device.getAvailMem());&#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(九)]]></title>
    <url>%2F2019%2F04%2F16%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 前言今天早上没课，然后就随手修复了THBELIEFScript的一些BUG，然后增添了一个登陆的界面。 正文用的是免费的API。免费API集合。 用到的包括开发者注册拿到apikey，然后就是运用了用户的注册与登陆。 具体的情况如下： 然后就是写了一个登陆的界面，然后加上了逻辑。 关键代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213//界面function jiemian()&#123; ui.run(()=&gt;&#123; mainUI(); &#125;); checkHaveUpdate();&#125;//登录界面function LoginPageFunction()&#123; ui.statusBarColor(&quot;#000000&quot;) var kg, kg2, u = 1,op = 0; var stg = storages.create(&quot;user&quot;); var zh = stg.get(&quot;list&quot;, &#123;see: &quot;&quot;,name: &quot;&quot;,pass: &quot;&quot;&#125;); main(); function main()&#123; if (zh.see == &quot;1&quot;) &#123; denru(true,zh.name,zh.pass); &#125;else if (zh.see == &quot;2&quot;) &#123; jiemian(); &#125;else&#123; denru(); &#125; &#125; function denru(t,n,p)&#123; ui.layout( &lt;vertical bg=&quot;#708090&quot;&gt; &lt;vertical h=&quot;auto&quot; align=&quot;center&quot; marginTop=&quot;100&quot;&gt; &lt;img layout_gravity=&quot;center&quot; src=&quot;https://img.icons8.com/color/48/000000/joe-pineapples.png&quot; w=&quot;70&quot; h=&quot;70&quot; circle=&quot;true&quot;/&gt; &lt;/vertical&gt; &lt;card w=&quot;*&quot; h=&quot;250&quot; margin=&quot;20&quot; cardCornerRadius=&quot;15dp&quot; cardBackgroundColor=&quot;#b0c4de&quot; cardElevation=&quot;15dp&quot; gravity=&quot;bottom&quot; foreground=&quot;?selectableItemBackground&quot;&gt; &lt;vertical&gt; &lt;linear margin=&quot;0 40 0 0&quot;&gt; &lt;img w=&quot;30&quot; h=&quot;30&quot; src=&quot;@drawable/ic_person_black_48dp&quot;/&gt; &lt;input id=&quot;name&quot; w=&quot;*&quot; h=&quot;40&quot; hint=&quot;用户名&quot;/&gt; &lt;/linear&gt; &lt;linear&gt; &lt;img w=&quot;30&quot; h=&quot;30&quot; src=&quot;@drawable/ic_https_black_48dp&quot;/&gt; &lt;input id=&quot;password&quot; hint=&quot;密码&quot; w=&quot;*&quot; h=&quot;40&quot; inputType=&quot;textPassword&quot;/&gt; &lt;/linear&gt; &lt;linear gravity=&quot;center&quot;&gt; &lt;checkbox id=&quot;cb1&quot; text=&quot;记住密码&quot;/&gt; &lt;checkbox id=&quot;cb2&quot; text=&quot;自动登入&quot;/&gt; &lt;/linear&gt; &lt;linear gravity=&quot;center&quot;&gt; &lt;horizontal&gt; &lt;button id=&quot;login&quot; w=&quot;250&quot; h=&quot;*&quot; text=&quot;登录&quot; size=&quot;16&quot; style=&quot;Widget.AppCompat.Button.Colored&quot;/&gt; &lt;/horizontal&gt; &lt;/linear&gt; &lt;linear gravity=&quot;center&quot;&gt; &lt;text w=&quot;106&quot; gravity=&quot;center&quot; color=&quot;#111111&quot; size=&quot;16&quot;&gt;还没有账号？&lt;/text&gt; &lt;text id=&quot;register&quot; w=&quot;auto&quot; h=&quot;auto&quot; size=&quot;16&quot; text=&quot;注册&quot; paddingRight=&quot;15&quot;/&gt; &lt;text id=&quot;reg&quot; w=&quot;auto&quot; h=&quot;auto&quot; size=&quot;16&quot; paddingLeft=&quot;10&quot; text=&quot;忘记密码&quot;/&gt; &lt;/linear&gt; &lt;/vertical&gt; &lt;/card&gt; &lt;/vertical&gt; ); if (t) &#123;ui.name.setText(n);ui.password.setText(p);ui.cb1.setChecked(t);&#125; ui.login.on(&quot;click&quot;, () =&gt; &#123; threads.start(function() &#123; if (!ui.name.text()) &#123; toast(&quot;您还没有输入用户名!&quot;); return; &#125; if (!ui.password.text()) &#123; toast(&quot;还没有输入密码呢&quot;); return; &#125; var str = JSON.parse(http.get(&quot;https://api.apiopen.top/loginUser?apikey=d1cef6f3e25ab08f623bbb147f32bb5d&amp;name=&quot; + ui.name.text() + &quot;&amp;passwd=&quot; + ui.password.text()).body.string()); if (str.code !== 200) &#123; toast(str.message); return; &#125; else &#123; if (op == 1) &#123; stg.put(&quot;list&quot;, &#123;see: &quot;1&quot;,name: ui.name.text(),pass: ui.password.text()&#125;); toast(&quot;登入&quot; + str.message); jiemian(); &#125; else if (op == 2) &#123; stg.put(&quot;list&quot;, &#123;see: &quot;2&quot;,name: ui.name.text(),pass: ui.password.text()&#125;); toast(&quot;登入&quot; + str.message); jiemian(); &#125; else &#123; storages.remove(&quot;user&quot;); toast(&quot;登入&quot; + str.message); jiemian(); &#125; &#125; &#125;) &#125;); ui.emitter.on(&quot;back_pressed&quot;, e =&gt; &#123; if (!kg) &#123; kg = true; toast(&quot;再按一次退出&quot;); setTimeout(() =&gt; &#123; kg = false; &#125;, 250); e.consumed = true; &#125; else &#123; e.consumed = false; &#125;; &#125;); ui.register.on(&quot;click&quot;, () =&gt; &#123; zhuce(); &#125;); ui.reg.on(&quot;click&quot;, () =&gt; &#123; dialogs.confirm(null, &quot;抱歉，暂时没有找回密码功能，是否重新注册一个新账号?&quot;, (a) =&gt; &#123; if (a) &#123; zhuce(); &#125; &#125;) &#125;); ui.cb1.on(&quot;check&quot;, (checked) =&gt; &#123; if (checked) &#123; op = 1; &#125; else &#123; op = 0; u = 0; ui.cb2.setChecked(false); &#125; &#125;); ui.cb2.on(&quot;check&quot;, (checked) =&gt; &#123; if (checked) &#123; ui.cb1.setChecked(true); op = 2; u = 1; &#125; else &#123; if (u) &#123; op = 1; &#125; &#125; &#125;); &#125; function zhuce()&#123; ui.layout( &lt;vertical bg=&quot;#708090&quot;&gt; &lt;card w=&quot;*&quot; h=&quot;250&quot; margin=&quot;20 180 20 20&quot; cardCornerRadius=&quot;15dp&quot; cardBackgroundColor=&quot;#b0c4de&quot; cardElevation=&quot;15dp&quot; gravity=&quot;bottom&quot; foreground=&quot;?selectableItemBackground&quot;&gt; &lt;vertical&gt; &lt;vertical h=&quot;auto&quot; align=&quot;center&quot; margin=&quot;5 30 5 5&quot;&gt; &lt;linear&gt; &lt;img w=&quot;30&quot; h=&quot;30&quot; src=&quot;@drawable/ic_person_black_48dp&quot;/&gt; &lt;input id=&quot;name&quot; w=&quot;*&quot; h=&quot;40&quot; hint=&quot;输入用户名&quot; /&gt; &lt;/linear&gt; &lt;linear&gt; &lt;img w=&quot;30&quot; h=&quot;30&quot; src=&quot;@drawable/ic_https_black_48dp&quot;/&gt; &lt;input id=&quot;password&quot; hint=&quot;输入密码&quot; w=&quot;*&quot; h=&quot;40&quot; inputType=&quot;textPassword&quot;/&gt; &lt;/linear&gt; &lt;linear&gt; &lt;img w=&quot;30&quot; h=&quot;30&quot; src=&quot;@drawable/ic_https_black_48dp&quot;/&gt; &lt;input id=&quot;password2&quot; hint=&quot;再次输入密码&quot; w=&quot;*&quot; h=&quot;40&quot; inputType=&quot;textPassword&quot;/&gt; &lt;/linear&gt; &lt;linear gravity=&quot;center&quot;&gt; &lt;horizontal&gt; &lt;button id=&quot;login&quot; w=&quot;250&quot; h=&quot;*&quot; text=&quot;立即注册&quot; size=&quot;16&quot; style=&quot;Widget.AppCompat.Button.Colored&quot;/&gt; &lt;/horizontal&gt; &lt;/linear&gt; &lt;/vertical&gt; &lt;/vertical&gt; &lt;/card&gt; &lt;/vertical&gt; ); ui.emitter.on(&quot;back_pressed&quot;, e =&gt; &#123; if (!kg2) &#123; kg2 = true; denru(); setTimeout(() =&gt; &#123; kg2 = false; &#125;, 1000); e.consumed = true; &#125; else &#123; e.consumed = false; &#125;; &#125;); ui.login.on(&quot;click&quot;, () =&gt; &#123; threads.start(function() &#123; if (!ui.name.text()) &#123; toast(&quot;您还没有输入用户名!&quot;); return; &#125; if (!ui.password.text() &amp;&amp; !ui.password2.text()) &#123; toast(&quot;还没有输入密码呢&quot;); return; &#125; if (ui.password.text() !== ui.password2.text()) &#123; toast(&quot;您输入的两次密码不一样&quot;); &#125; else &#123; var str = JSON.parse(http.get(&quot;https://api.apiopen.top/registerUser?apikey=d1cef6f3e25ab08f623bbb147f32bb5d&amp;name=&quot; + ui.name.text() + &quot;&amp;passwd=&quot; + ui.password.text()).body.string()); if (str.code !== 200) &#123; toast(str.message); &#125; else &#123; dialogs.confirm(&quot;注册&quot; + str.message, &quot;您已经注册成为至尊会员！\n您的户名为：&quot; + ui.name.text() + &quot;\n密码为：&quot; + ui.password.text() + &quot;\n是否马上去登入?&quot;, (a) =&gt; &#123; if (a) &#123; denru(); &#125; else &#123; ui.finish(); &#125; &#125;) &#125; &#125; &#125;); &#125;); &#125;&#125; 备注： 准备抽个时间重构一下底层的代码，主js文件实在是写的太臃肿了。很不喜欢现在，都写了一千多行了main.js…]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米五刷机简述]]></title>
    <url>%2F2019%2F04%2F15%2F%E5%B0%8F%E7%B1%B3%E4%BA%94%E5%88%B7%E6%9C%BA%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 ADB工具 主要功能 ADB下载 OS下载 第三方rec的下载 小米手机解锁（小米手机必要） 安装REC 清理 安装OS 注意 收尾 ADB安装APK到手机 前言不久之前刚刚把我退役的小米五刷机刷成了Android原生的LineageOS系统，这里就记录一下过程吧。 正文ADB工具adb（Android Debug Bridge），安卓平台调试桥，是连接Android手机与PC端的桥梁，通过adb可以管理、操作模拟器和设备，如安装软件、查看设备软硬件参数、系统升级、运行shell命令等。 主要功能 1.运行设备的shell(命令行) 。 2.管理模拟器或设备的端口映射 。 3.计算机和设备之间上传/下载文件 。 4.将本地apk软件安装至模拟器或android设备。 ADB下载这里就不详细的写如何下载安装配置ADB工具了，百度即可，安装配置很简单，下面直接贴上官网的链接。 官网链接 OS下载进入LineageOS官网找到相对应的小米五的刷机包，直接下载最新的包就可以了。（一定要记住下载后放置的位置，并且不用解压）。 注意：要求在MIUI版本在8.8.30及以上，这个必须有，因为LineageOS要求固件支持。 第三方rec的下载REC即Recovery模式，也俗称卡刷。 这里用的是TWRP官网这个工具。 小米手机解锁（小米手机必要）注意：只有小米手机才需要！ 如果已经解锁的可以直接跳过。 如果没有解锁的话直接移步到小米官方解锁网站。上面有很详细的步骤，一步一步的跟着做就可以了。 安装REC1.关机状态按住音量下键+关机键。 用数据线连接电脑与手机，在电脑的cmd中输入下面的代码： 1adb reboot bootloader 2.输入命令把rec刷进去： 1fastboot flash recovery &quot;*****.img&quot; //*****是前面下载rec后放置的位置的路径+包的名字 3.运行rec： 1fastboot boot &quot;***.img&quot; //*****是前面下载rec后放置的位置的路径+包的名字 成功的状态： 12bootingFinished. Total time: 1.138s 清理进入界面之后先恢复出厂设置，然后格式化Data，然后选择高级选项，把cache和data清除掉，System不能更改。 安装OS把之前下载的OS包移动到sdcard路径下： 1adb push &quot;****.zip&quot; /sdcard/ 打开twrp里面的安装选项，找到sdcard目录，点击进去会发现一个zip包，这个就是移动进去的OS，然后点击安装即可。 注意有些时候如果提示没有权限或其他错误，先重启重启不是直接重启手机，是重新进入rec。可以在rec的首页面重启，也可以输入adb命令。 收尾需要值得注意的是，刷进去之后的浏览器由于某些众所周知的原因不能使用也就是说下载不了软件这些的，必须通过ADB工具将电脑上下载好的apk安装到手机上去。（还需要打开手机的开发者权限，打开ADB调试）。 ADB安装APK到手机1.电脑的命令行窗口输入下面的代码：（打开开发者权限的ADB调试之后才找得到设备） 1adb devices 2.安装apk： 123adb install (apk完整路径）//(安装)例如：adb install D:/THBELIEFScript.apk 参考链接]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>小米五</tag>
        <tag>卡刷</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编实验（一）]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 Debug命令 E命令 U命令 T命令 A命令 D命令 前言前不久刚开始上汇编实验，这里就用博客记录一下学习的过程，顺便也做备份，方便自己以后复习。 正文Debug命令1234567891011R命令：查看、修改CPU中寄存器的内容D命令：查看内存中的内容E命令：修改内存中的内容（可以写入数据、指令）U命令：将内存中的内容解释为机器指令和对应的汇编指令T命令：执行CS:IP指向的内存单元处的指令A命令：以汇编指令的形式向内存中写入指令 2019.4.29新增： 12345678910P命令：执行汇编程序，单步跟踪。和T命令的不同点是P命令不会跟踪进入子程序或软中断。使用方法和T命令一模一样。G命令：执行汇编指令。如果不设置断点的话，程序运行到中止指令才停止。G[起始地址][断点地址]F命令：使用指定的值填充指定内存区域中的地址。F[范围][填充列表]L命令：从磁盘中将文件或者扇区读入内存。将文件调入内存必须先使用DEBUG的N命令设定文件名。 E命令用E命令将数据写入内存。 这里是先用E命令写入内存，再用D命令查看了内存的内容，可以看到确实是修改了的，然后再用E命令发现又可以修改了。 U命令查看内存中机器码的含义。 T命令单步执行内存中的机器码。 A命令将汇编指令写入内存中。 D命令查看内存中的内容。]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(八)]]></title>
    <url>%2F2019%2F04%2F14%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 关键代码 前言今天的话主要就是修复了一下易班签到的BUG吧，然后就是下面贴一下代码，太累了，就不仔细的解释了，好了，下面开始~~~ 正文关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899function SignIn(signInAccount,signInPassword)&#123; var t=threads.start(function()&#123; //输入账号密码 id(&quot;login_account_et&quot;).findOne().setText(signInAccount); id(&quot;login_password_et&quot;).findOne().setText(signInPassword); sleep(1000); //登录按钮 id(&quot;login_btn&quot;).findOne().click(); //等待前往主页面活动 waitForActivity(&quot;com.yiban.app.activity.HomeActivity&quot;); sleep(1000); //去签到的页面 id(&quot;page_home_discover_tab_btn&quot;).findOne().click() id(&quot;page_explore_chenckin_layout&quot;).findOne().click(); sleep(1000); //判断是否有签到，签到了直接退出，没有签到就签到 if(text(&quot;奖励已经拿过咯~&quot;).exists())&#123; //已经签过到的页面 toast(signInAccount+&quot;已经签到过了!&quot;); accountSignInMessage.push(signInAccount+&quot;已经签到过了!&quot;); sleep(1000); id(&quot;widget_custom_titlebar_back_btn&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.HomeActivity&quot;); &#125;else if(text(&quot;下一步&quot;).exists())&#123; //检测是否打开自动同步开关 if(isShareButton)&#123; //如果打开了就直接勾选 id(&quot;sync_to_feed_check&quot;).clickable().find().click(); accountSignInMessage.push(signInAccount+&quot;签到已经同步至动态!&quot;); toast(&quot;已经勾选同步动态按钮，正在同步中...&quot;); &#125; //没有签过到的页面 sleep(1000); var t=className(&quot;android.widget.LinearLayout&quot;).clickable().find(); //默认选择第二个答案 t[2].click(); toast(signInAccount+&quot;签到完成了哦！&quot;); accountSignInMessage.push(signInAccount+&quot;签到完成了哦!&quot;); sleep(1000); text(&quot;下一步&quot;).findOne().click(); sleep(1000); id(&quot;positiveButton&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.HomeActivity&quot;); &#125;else&#123; toast(&quot;签到失败，未检索到&quot;); accountSignInMessage.push(signInAccount+&quot;签到失败，未检索到&quot;); sleep(1000); id(&quot;widget_custom_titlebar_back_btn&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.HomeActivity&quot;); &#125; if(isSendMessage)&#123; //如果打开了群聊冒泡的开关 toast(&quot;正在准备群聊冒泡...&quot;); id(&quot;page_home_contacts_tab_btn&quot;).clickable().find().click(); sleep(1000); id(&quot;l_groupchat&quot;).clickable().find().click(); waitForActivity(&quot;com.yiban.app.activity.GroupMergeActivity&quot;); sleep(1000) if(text(sendName).exists())&#123; toast(&quot;发现群聊:&quot;+sendName+&quot;!&quot;); sleep(1000); //本身返回的不是集合，还要找子控件集合 var t=className(&quot;android.widget.TextView&quot;).text(sendName).findOne().bounds(); click(t.centerX(),t.centerY()); waitForActivity(&quot;com.yiban.app.activity.ChatActivity&quot;); toast(&quot;已经打开群聊，准备冒泡...&quot;); sleep(1000); id(&quot;page_chat_message_et&quot;).findOne().setText(sendContent); sleep(1000); id(&quot;page_chat_message_send_btn&quot;).findOne().click(); toast(&quot;账号&quot;+signInAccount+&quot;发送&quot;+sendContent+&quot;在&quot;+sendName); accountSignInMessage.push(&quot;账号&quot;+signInAccount+&quot;发送&quot;+sendContent+&quot;在&quot;+sendName); id(&quot;widget_custom_titlebar_back_btn&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.GroupMergeActivity&quot;); &#125;else&#123; toast(&quot;未检索到群聊！&quot;); accountSignInMessage.push(&quot;账号&quot;+signInAccount+&quot;未检索到&quot;+sendName); &#125; sleep(1000); id(&quot;widget_custom_titlebar_back_btn&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.HomeActivity&quot;); &#125; //退出当前账号 id(&quot;widget_custom_head&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.UserInfoPageActivity&quot;); sleep(1000); id(&quot;r_setting&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.SettingMainActivity&quot;); sleep(1000); text(&quot;退出账号&quot;).findOne().click(); sleep(1000); id(&quot;positiveButton&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.LoginNew2Activity&quot;); toast(signInAccount+&quot;正常退出并正在销毁线程...&quot;); accountSignInMessage.push(&quot;账号&quot;+signInAccount+&quot;正常销毁线程！&quot;); t.interrupt(); &#125;);&#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Lottie动画库]]></title>
    <url>%2F2019%2F04%2F13%2FAndroid-Lottie%E5%8A%A8%E7%94%BB%E5%BA%93%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 Lottie效果展示 Lottie简单介绍 Lottie优势 Lottie劣势 Lottie简单示例 依赖 通过AE的插件导出的json文件 布局 代码 Lottie相关网址 Lottie在线json文件动画预览 LottieFiles 前言这两天在写一个自己的小东西，然后碰巧在github上看到一个动画库，感觉挺有意思的，就通过今天的博客记录下来。 正文Lottie效果展示 Lottie简单介绍Lottie是一个用于 Android和 iOS 的代码库，可以解析用Adobe After Effects 制作动画后通过Bodymovin 插件导出的 JSON 数据文件并在移动端原生渲染! Lottie优势 开发无需编写动画,只需加载。 Android, iOS, 和React Native多平台支持。 Path,flat等风格动画实现完美。 可手动设置进度,绑定手势,事件等。 可网络加载,动态控制播放速度等。 性能好,显示效果完。 不需要进行屏幕的适配，完全原生。 … Lottie劣势 能在AE中实现的效果非常有限。 对AE使用要求高一点, 动画更加依赖设计师。 使用位图后,资源消耗大。 …… Lottie简单示例依赖 通过AE的插件导出的json文件 布局 代码 Lottie相关网址Lottie在线json文件动画预览这个网址 LottieFiles这个网址]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Lottie</tag>
        <tag>动画库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(七)]]></title>
    <url>%2F2019%2F04%2F12%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 前言易班批量签到的脚本这两天基本已经完全的完善了。 今天还抽空把3.8.0做了一个开屏检测更新的动画效果，借助的是另外一个大佬的框架。 正文UI新增： 易班批量签到新增关键代码： 1234567//检测是否打开自动同步开关 if(isShareButton)&#123; //如果打开了就直接勾选 id(&quot;sync_to_feed_check&quot;).clickable().find().click(); accountSignInMessage.push(signInAccount+&quot;签到已经同步至动态!&quot;); toast(&quot;已经勾选同步动态按钮，正在同步中...&quot;); &#125; 123456789101112131415161718192021222324252627282930if(isSendMessage)&#123; //如果打开了群聊冒泡的开关 toast(&quot;正在准备群聊冒泡...&quot;); id(&quot;page_home_contacts_tab_btn&quot;).clickable().find().click(); sleep(1000); id(&quot;l_groupchat&quot;).clickable().find().click(); waitForActivity(&quot;com.yiban.app.activity.GroupMergeActivity&quot;); sleep(1000) if(text(sendName).exists())&#123; toast(&quot;发现群聊:&quot;+sendName+&quot;!&quot;); var t=className(&quot;android.widget.LinearLayout&quot;).findOne(); for(var i=0;i&lt;t.childCount();i++)&#123; if(t.child(i).text()==sendName)&#123; t.click(); waitForActivity(&quot;com.yiban.app.activity.ChatActivity&quot;); &#125; &#125; toast(&quot;已经打开群聊，准备冒泡...&quot;); id(&quot;page_chat_message_et&quot;).findOne().setText(sendContent); sleep(1000); id(&quot;page_chat_message_send_btn&quot;).findOne().click(); sleep(1000); toast(&quot;账号&quot;+signInAccount+&quot;发送&quot;+sendContent+&quot;在&quot;+sendName); accountSignInMessage.push(&quot;账号&quot;+signInAccount+&quot;发送&quot;+sendContent+&quot;在&quot;+sendName); id(&quot;widget_custom_titlebar_back_btn&quot;).findOne().click(); waitForActivity(&quot;com.yiban.app.activity.GroupMergeActivity&quot;); &#125;else&#123; toast(&quot;未检索到群聊！&quot;); accountSignInMessage.push(&quot;账号&quot;+signInAccount+&quot;未检索到&quot;+sendName); &#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(六)]]></title>
    <url>%2F2019%2F04%2F11%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[目录： 前言 展示 帮助文档 常见问题 易班批量签到 前言这两天的话，对于这个软件的更新就包括了帮助文档，界面重构，常见问题，易班批量签到等等。 展示 帮助文档在主页面的viewpager中添加另外一个页面作为帮助文档的展示。 帮助文档其实也是直接拉的博客里面的。 123456789&lt;frame&gt; &lt;vertical&gt; &lt;ScrollView&gt; &lt;vertical&gt; &lt;webview id=&quot;webview&quot; h=&quot;*&quot; margin=&quot;0 16&quot;/&gt; &lt;/vertical&gt; &lt;/ScrollView&gt; &lt;/vertical&gt; &lt;/frame&gt; 具体实现： 12//获取帮助文档的网页 ui.webview.loadUrl(&quot;https://thbelief.github.io/2019/04/10/THBELIEFScript%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/&quot;); 常见问题和帮助文档差不多的布局。 123456789&lt;frame&gt; &lt;vertical&gt; &lt;list id=&quot;answerProblem&quot;&gt; &lt;horizontal&gt; &lt;text textColor=&quot;&#123;&#123;this.color&#125;&#125;&quot; w=&quot;*&quot; h=&quot;*&quot; textSize=&quot;20sp&quot; text=&quot;&#123;&#123;this.line&#125;&#125;&quot; /&gt; &lt;/horizontal&gt; &lt;/list&gt; &lt;/vertical&gt; &lt;/frame&gt; 代码： 123456789//先设置标题ui.viewpager.setTitles([&quot;可使用脚本&quot;, &quot;开发中脚本&quot;,&quot;常见问题&quot;,&quot;帮助文档&quot;]);//再填充数据 ui.answerProblem.setDataSource([ &#123; line: &quot;&quot;， color： “” &#125; ]); 易班批量签到关键代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&quot;ui&quot;;auto();//是否按下音量下键isKeyDown();//创建两个txt文件，一个是账号一个是密码，一一对应files.create(&quot;/sdcard/account.txt&quot;);files.create(&quot;/sdcard/password.txt&quot;);//本地键值对存储var storage=storages.create(&quot;易班批量签到速率&quot;);//先清除所有的本地数据，因为每次的默认值都是15s每次登陆storage.clear();storage.put(&quot;speed&quot;,15);//这个是界面的UIinterfaceUI(); function interfaceUI()&#123; ui.layout( &lt;frame&gt; &lt;vertical gravity=&quot;center&quot;&gt; &lt;horizontal&gt; &lt;img src=&quot;http://sowcar.com/t6/698/1554895620x1822614218.jpg&quot; w=&quot;*&quot; h=&quot;200&quot; scaleType=&quot;fitXY&quot; /&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;text text=&quot;基本设置&quot; h=&quot;*&quot; w=&quot;*&quot; gravity=&quot;center&quot; textSize=&quot;20dp&quot; textColor=&quot;red&quot;/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;list id=&quot;accountList&quot; layout_weight=&quot;1&quot; gravity=&quot;center&quot;&gt; &lt;vertical&gt; &lt;text textColor=&quot;black&quot; w=&quot;*&quot; h=&quot;*&quot; textSize=&quot;15dp&quot; text=&quot;&#123;&#123;this.title&#125;&#125;&quot; gravity=&quot;center&quot; singleLine=&quot;true&quot;/&gt; &lt;/vertical&gt; &lt;/list&gt; &lt;list id=&quot;passwordList&quot; layout_weight=&quot;1&quot; gravity=&quot;center&quot;&gt; &lt;vertical&gt; &lt;text textColor=&quot;black&quot; w=&quot;*&quot; h=&quot;*&quot; textSize=&quot;15dp&quot; text=&quot;&#123;&#123;this.title&#125;&#125;&quot; gravity=&quot;center&quot; singleLine=&quot;true&quot;/&gt; &lt;/vertical&gt; &lt;/list&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;addDeleteAccount&quot; text=&quot;账户编辑&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; gravity=&quot;center&quot; /&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;addDeletePassword&quot; text=&quot;密码编辑&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; gravity=&quot;center&quot; /&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;input id=&quot;SignInSpeed&quot; text=&quot;15&quot; hint=&quot;签到速率（默认15s）&quot; inputType=&quot;number&quot; layout_weight=&quot;1&quot;/&gt; &lt;text text=&quot;秒/登陆&quot; /&gt; &lt;button id=&quot;sureSpeed&quot; text=&quot;更改速率&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; gravity=&quot;center&quot; layout_weight=&quot;3&quot;/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;start&quot; text=&quot;开始运行&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; gravity=&quot;center&quot; /&gt; &lt;/horizontal&gt; &lt;/vertical&gt; &lt;/frame&gt; ); //增添的点击事件 ui.addDeleteAccount.click(()=&gt;&#123; toast(&quot;可以增添账号啦!~~~&quot;); app.viewFile(&quot;/sdcard/account.txt&quot;); &#125;); ui.addDeletePassword.click(()=&gt;&#123; toast(&quot;可以增添密码啦!~~~&quot;); app.viewFile(&quot;/sdcard/password.txt&quot;); &#125;); ui.sureSpeed.click(()=&gt;&#123; alert(&quot;登陆速率是根据自身手机流畅度调节的，默认是15s/每次登陆签到，如果出现一次登陆签到还没结束就提示了下一次登录的话，建议调大数值，放缓频率，反之亦然！&quot;); if(ui.SignInSpeed.text()&lt;5)&#123; toast(&quot;修改失败，不建议修改至5s以下。&quot;); &#125;else&#123; storage.remove(&quot;speed&quot;); storage.put(&quot;speed&quot;,ui.SignInSpeed.text()); toast(&quot;成功修改至:&quot;+storage.get(&quot;speed&quot;)); ui.SignInSpeed.setText(storage.get(&quot;speed&quot;)); &#125; &#125;); ui.start.click(()=&gt;&#123; var accountFile=open(&quot;/sdcard/account.txt&quot;,&quot;r&quot;); var passwordFile=open(&quot;/sdcard/password.txt&quot;,&quot;r&quot;); var count=1; //文件里面第一排必须排除 //accountFile.readline(); //passwordFile.readline(); //var accountFileArray=[]; //var passwordFileArray=[]; app.launchApp(&quot;易班&quot;); setInterval(function()&#123; var accountFileArray=accountFile.readline(); var passwordFileArray=passwordFile.readline(); log(&quot;第&quot;+count+&quot;个文件读取&quot;+accountFileArray+passwordFileArray); count++;//计数 if(accountFileArray==null)&#123; dialogs.build(&#123; title: &quot;友情提示&quot;, content: &quot;已经完成所有的签到了哦，亲~&quot;, positive: &quot;知道了&quot; &#125;).on(&quot;positive&quot;,()=&gt;&#123; toast(&quot;正在自动退出脚本...&quot;); exit();//跳出条件不登录 &#125;).show(); &#125;else&#123; toast(&quot;正在准备登录中，每一次登录签到约&quot;+storage.get(&quot;speed&quot;)+&quot;s~~~&quot;); &#125; log(&quot;登录&quot;+accountFileArray); toast(&quot;登录&quot;+accountFileArray); SignIn(accountFileArray,passwordFileArray); &#125;, 1000*storage.get(&quot;speed&quot;)); //SignIn(&quot;18227410387&quot;,&quot;13547296248tyty&quot;) &#125;); &#125;function SignIn(signInAccount,signInPassword)&#123; threads.start(function()&#123; //输入账号密码 id(&quot;login_account_et&quot;).findOne().setText(signInAccount); id(&quot;login_password_et&quot;).findOne().setText(signInPassword); sleep(1000); //登录按钮 id(&quot;login_btn&quot;).findOne().click(); sleep(1000); //去签到的页面 id(&quot;page_home_discover_tab_btn&quot;).findOne().click() id(&quot;page_explore_chenckin_layout&quot;).findOne().click(); sleep(1000); //判断是否有签到，签到了直接退出，没有签到就签到 if(text(&quot;奖励已经拿过咯~&quot;).exists())&#123; toast(&quot;已经签到过了&quot;); sleep(1000); back(); &#125;else&#123; //bounds(0,550,1080,642).findOne().click(); className(&quot;android.widget.LinearLayout&quot;).clickable().find().click(); sleep(500); text(&quot;下一步&quot;).findOne().click(); sleep(500); id(&quot;positiveButton&quot;).findOne().click(); &#125; //退出当前账号 id(&quot;widget_custom_head&quot;).findOne().click(); sleep(500); id(&quot;r_setting&quot;).findOne().click(); sleep(500); text(&quot;退出账号&quot;).findOne().click(); id(&quot;positiveButton&quot;).findOne().click(); &#125;);&#125;function isKeyDown()&#123; //监听音量下键是否按下，退出脚本 threads.start(function()&#123; events.setKeyInterceptionEnabled(&quot;volume_down&quot;,true); //监听按键 events.observeKey(); events.onKeyDown(&quot;volume_down&quot;, function(event)&#123; toast(&quot;已关闭易班批量签到脚本！&quot;); engines.myEngine().forceStop(); &#125;); &#125;);&#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
        <tag>THBELIEFScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[THBELIEFScript帮助文档]]></title>
    <url>%2F2019%2F04%2F10%2FTHBELIEFScript%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[目录： QQ名片自动点赞 I西科自动签到 蚂蚁森林一键收取能量 蚂蚁庄园星星球 重力传感器验证 连续点击 易班批量导入 准备工作 导入账号与密码 开始使用 注意 匀速上滑 设备信息 二维码生成 QQ名片自动点赞打开无障碍权限之后点击按钮就可以直接使用了，最新版本优化之后可以直接跳转至点赞的页面，不用手动的点击了。 I西科自动签到目前还只是一个鸡肋的脚本，因为之前一直在想着给它加上一个定时签到，但是一直没时间，就搁置了。 蚂蚁森林一键收取能量这个也是一个鸡肋目前，原因和I西科签到一样，没时间修改定时。 蚂蚁庄园星星球使用很简单，直接点击就可以了，有些时候会出现一些BUG，比如说到后期有可能会误触到炸弹导致失败。目前我测试的最高分达到了2500+。 重力传感器验证这个就只是简单的测试。 连续点击这个是以指定的时间连续点击相同的位置。 易班批量导入准备工作首先保持易班更新到最新版。 然后在批量导入之前打开易班登录，先进入签到页面，点击签到，再退回到登录页面。保持易班在后台运行，打开THBELIEFScript的脚本页面。 （这是为了提升效率，类似于机器学习） 完成上述活动之后准备就完成了。 导入账号与密码分别打开账号编辑与密码编辑的页面，输入一一对应的一行行数据。（推荐用WPS之类的文本编辑器打开，然后就是记住，不能用WPS的副本，不然存进去，存不到编辑页面去） 账号编辑页面如下： 开始使用使用之前还可以修改速率，这个和自身手机的流畅度有关。 然后就可以开始了。 注意1.账号和密码一一对应。 2.两个编辑页面的txt文档在内部存储器的根目录下，必须修改这个才有效，如WPS的副本之类的修改之后也无效。 3.两个文档里面的行数应该是一样的。 4.如果出现问题，重新来几次就可以了，道理和准备工作相同。 5.音量下键退出脚本。 6.脚本依托于无障碍服务权限，类似于模拟点击之类的，所以当前页面在脚本执行期间不能乱动，只建议在空闲时间使用。因为当脚本运行的时候，不能碰手机。否则，相当于两个人玩手机？ 匀速上滑这个就只是为了上课刷空间之类的设计的，有时间设置以及悬浮按钮，只是可能滑动的动作不够丝滑。 设备信息这个就是显示当前的设备的信息，有些可能出现null之类的提示，那是因为获取不到相应的信息，不影响。 二维码生成这个就是写来玩的，生成二维码。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Auto.js</tag>
        <tag>脚本</tag>
        <tag>THBELIEFScript</tag>
        <tag>帮助文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bomb使用（一）]]></title>
    <url>%2F2019%2F04%2F10%2FBomb%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 创建应用 SDK自动导入（AndroidStudio） 配置AndroidManifest.xml 基本使用 初始化 添加一行数据 添加数据 获取一行数据 修改一行数据 删除一行数据 创建应用 SDK自动导入（AndroidStudio）1.在project的build.gradle文件下添加Bomb的maven仓库地址： 1234567allprojects &#123; repositories &#123; jcenter() //Bmob的maven仓库地址--必填 maven &#123; url &quot;https://raw.github.com/bmob/bmob-android-sdk/master&quot; &#125; &#125; &#125; 2.在app的build.gradle中添加下列依赖项： 12345678dependencies &#123; implementation &apos;cn.bmob.android:bmob-sdk:3.7.2&apos; implementation &quot;io.reactivex.rxjava2:rxjava:2.2.2&quot; implementation &apos;io.reactivex.rxjava2:rxandroid:2.1.0&apos; implementation &apos;com.squareup.okio:okio:2.1.0&apos; implementation &apos;com.google.code.gson:gson:2.8.5&apos; implementation &apos;com.squareup.okhttp3:okhttp:3.12.0&apos; &#125; 配置AndroidManifest.xml权限： 123456789101112&lt;!--允许联网 --&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;!--获取GSM（2g）、WCDMA（联通3g）等网络状态的信息 --&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;!--获取wifi网络状态的信息 --&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt; &lt;!--保持CPU 运转，屏幕和键盘灯有可能是关闭的,用于文件上传和下载 --&gt;&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; &lt;!--获取sd卡写的权限，用于文件上传和下载--&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;!--允许读取手机状态 用于创建BmobInstallation--&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; 配置contentprovider： 1234&lt;provider android:name=&quot;cn.bmob.v3.util.BmobContentProvider&quot; android:authorities=&quot;应用包名.BmobContentProvider&quot;&gt;&lt;/provider&gt; 如下： 基本使用初始化在MainActivity的oncreate方法中添加如下代码： 12//第一：默认初始化Bmob.initialize(this, &quot;Your Application ID&quot;); 添加一行数据首先创建的JavaBean（对应为Bmob后台的数据表，详细更解释的请查看的Android开发文档） 1234567891011121314151617public class Person extends BmobObject &#123; private String name; private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 添加数据12345678910111213Person p2 = new Person();p2.setName(&quot;lucky&quot;);p2.setAddress(&quot;北京海淀&quot;);p2.save(new SaveListener&lt;String&gt;() &#123; @Override public void done(String objectId,BmobException e) &#123; if(e==null)&#123; toast(&quot;添加数据成功，返回objectId为：&quot;+objectId); &#125;else&#123; toast(&quot;创建数据失败：&quot; + e.getMessage()); &#125; &#125;&#125;); 效果： 获取一行数据123456789101112//查找Person表里面id为6b6c11c537的数据BmobQuery&lt;Person&gt; bmobQuery = new BmobQuery&lt;Person&gt;();bmobQuery.getObject(&quot;6b6c11c537&quot;, new &gt;QueryListener&lt;Person&gt;() &#123; @Override public void done(Person object,BmobException e) &#123; if(e==null)&#123; toast(&quot;查询成功&quot;); &#125;else&#123; toast(&quot;查询失败：&quot; + e.getMessage()); &#125; &#125;&#125;); 修改一行数据123456789101112131415//更新Person表里面id为6b6c11c537的数据，address内容更新为“北京朝阳”Person p2 = new Person();p2.setAddress(&quot;北京朝阳&quot;);p2.update(&quot;6b6c11c537&quot;, new UpdateListener() &#123; @Override public void done(BmobException e) &#123; if(e==null)&#123; toast(&quot;更新成功:&quot;+p2.getUpdatedAt()); &#125;else&#123; toast(&quot;更新失败：&quot; + e.getMessage()); &#125; &#125;&#125;); 删除一行数据1234567891011121314Person p2 = new Person();p2.setObjectId(&quot;6b6c11c537&quot;);p2.delete(new UpdateListener() &#123; @Override public void done(BmobException e) &#123; if(e==null)&#123; toast(&quot;删除成功:&quot;+p2.getUpdatedAt()); &#125;else&#123; toast(&quot;删除失败：&quot; + e.getMessage()); &#125; &#125;&#125;);]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Bomb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-ListView与RecyclerView简述]]></title>
    <url>%2F2019%2F04%2F09%2FAndroid-ListView%E4%B8%8ERecyclerView%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录： ListView 简单使用 xml布局 mainActivity代码 定制界面 实体类Fruit 子项的布局 自定义适配器 MainActivity代码 RecyclerView 特性 添加依赖 xml布局 自定义适配器 子项布局 MainActivity 分割线 - ItemDecoration 布局 - LayoutManager 动画 - ItemAnimator 点击事件 下拉刷新 上拉加载更多 ListView简单使用xml布局在布局中加入ListView控件。 123456&lt;ListView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/list_view&quot; &gt; &lt;/ListView&gt; mainActivity代码12345678910111213public class MainActivity extends Activity &#123; private String[] data = &#123; &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Watermelon&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Pineapple&quot;, &quot;Strawberry&quot;, &quot;Cherry&quot;, &quot;Mango&quot; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;( MainActivity.this, android.R.layout.simple_list_item_1, data); //android.R.layout.simple_list_item_1是Android内置的布局文件，很简单，为了方便使用ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); &#125; &#125; ArrayAdapter adapter = new ArrayAdapter( MainActivity.this, android.R.layout.simple_list_item_1, data); 的意思是：创建一个数组适配器的代码，里面有三个参数，第一个参数是上下文，就是当前的Activity, 第二个参数是android sdk中自己内置的一个布局，它里面只有一个TextView，这个参数是表明我们数组中每一条数据的布局是这个view，就是将每一条数据都显示在这个 view上面；第三个参数就是我们要显示的数据。listView会根据这三个参数，遍历data里面的每一条数据，读出一条，显示到第二 个参数对应的布局中，这样就形成了我们看到的listView. 定制界面步骤如下： 1.ListView使用。 2.自定义Adapter适配器使用。 3.定义实体类作为泛型传给适配器。 4.为ListView的子项指定一个自定义的布局。（比如一段文字或者说再加上一张图片） 5.创建一个自定义的适配器，用来传数据，一般都是继承自ArrayAdapter，因为这个适配器能够传入泛型，比较方便，然后重写构造方法与GetView方法。 6.在MainActivity中修改相应的代码。 实体类Fruit1234567891011121314151617public class Fruit &#123; private String name; private int imageId; public Fruit(String name, int imageId) &#123; this.name = name; this.imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125;&#125; 子项的布局12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/fruit_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;TextView android:id=&quot;@+id/fruit_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_marginLeft=&quot;10dip&quot; /&gt;&lt;/LinearLayout&gt; 自定义适配器123456789101112131415161718public class FruitAdapter extends ArrayAdapter&#123; private final int resourceId; public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) &#123; super(context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Fruit fruit = (Fruit) getItem(position); // 获取当前项的Fruit实例 View view = LayoutInflater.from(getContext()).inflate(resourceId, null);//实例化一个对象 ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);//获取该布局内的图片视图 TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);//获取该布局内的文本视图 fruitImage.setImageResource(fruit.getImageId());//为图片视图设置图片资源 fruitName.setText(fruit.getName());//为文本视图设置文本内容 return view; &#125;&#125; MainActivity代码123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends Activity &#123; private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); // 初始化水果数据 FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); &#125; private void initFruits() &#123; Fruit apple = new Fruit(&quot;Apple&quot;, R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit(&quot;Banana&quot;, R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit(&quot;Orange&quot;, R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit(&quot;Watermelon&quot;, R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit(&quot;Pear&quot;, R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit(&quot;Grape&quot;, R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit(&quot;Pineapple&quot;, R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit(&quot;Strawberry&quot;, R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit(&quot;Cherry&quot;, R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit(&quot;Mango&quot;, R.drawable.mango_pic); fruitList.add(mango); &#125;&#125; RecyclerView在开发中，ListView是用的最多的控件之一，但是还是有很多不足的地方，比如说运行效率有些时候会显得非常的差劲，而且只能实现数据的纵向滚动的效果。这里就应运而生RecyclerView了。 特性插拔式体验，高度解耦合。 1234布局（显示方式）：可通过LayoutManager（LinearLayoutManager，GridLayoutManager，StaggeredGridLayoutManager ）设置；分割线：通过 ItemDecoration 实现Item 增删动画：通过 ItemAnimatorViewHolder 的创建和绑定：通过实现 Adapter 补充： 12345LayoutManager：RecyclerView 会根据 Layout Manager 提供的视图来填充自身，常用的布局管理器有LinearLayoutManager（线性布局管理器）、GridLayoutManager（网格布局管理器）、StaggeredGridLayoutManager （瀑布流布局管理器）等。ViewHolder：列表中的视图由 ViewHolder 实例展示。 ViewHolder 用于对控件的实例进行缓存，负责显示子项。例如，如果列表显示了音乐集合，那么每个 ViewHolder 可能代表一个专辑。Adapter：ViewHolder 对象由 Adapter 管理。Adapter 按需创建 ViewHolder，并为其绑定数据。绑定意味着根据 Adapter 中的位置为子视图填充对应的数据。 添加依赖由于和百分比布局一样都是新增的控件，所以需要添加support库的依赖。 项目的build.gradle中： 123dependencies &#123; implementation &apos;com.android.support:recyclerview-v7:27.1.1&apos;&#125; xml布局123456&lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:divider=&quot;#FFFF0000&quot; android:dividerHeight=&quot;10dp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 自定义适配器由于FruitAdapter是继承自RecyclerView.Adapter 的，那么就必须重写onCreateViewHolde r ()、onBindViewHolder()和getitemCount()这3个方法。 onCreateViewHolder()方法是用于创建ViewHolder实例的，在这个方法中将fruit_item 布局加载进来， 然后创建一个ViewHolder 实例， 并把加载出来的布局传入到构造函数当中， 最后将ViewHolder的实例返回。 onBindViewHolder()方法是用于对RecyclerView子项的数据进行赋值的，会在每个子项被滚动到屏幕内的时候执行，这里我们通过position参数得到当前项的类实例，然后再将数据设置到ViewHolder的ImageView和TextView当中即可。 getitemCount()方法就非常简单了，它用于告诉RecyclerView 一共有多少子项，直接返回数据源的长度就可以了。 12345678910111213141516171819202122232425262728293031323334353637public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; &#123; //数据源 private List&lt;String&gt; mList; public MyAdapter(List&lt;String&gt; list) &#123; mList = list; &#125; //返回item个数 @Override public int getItemCount() &#123; return mList.size() ; &#125; //创建ViewHolder实例 @NonNull @Override public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; return new NormalHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item, parent, false)); &#125; //填充视图 @Override public void onBindViewHolder(@NonNull final MyAdapter.ViewHolder holder, final int position) &#123; holder.mView.setText(mList.get(position)); &#125; public class ViewHolder extends RecyclerView.ViewHolder &#123; public TextView mView; public ViewHolder(View itemView) &#123; super(itemView); mView = itemView.findViewById(R.id.text_view); &#125; &#125;&#125; 子项布局123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/text_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;120dp&quot; android:gravity=&quot;center&quot; android:background=&quot;#c0c7c759&quot; android:textSize=&quot;20sp&quot; android:text=&quot;1&quot; /&gt;&lt;/FrameLayout&gt; MainActivityLayoutManager用于指定RecyclerView的布局方式，这里使用的LinearLayoutManager是线性布局的意思， 可以实现 和ListView类似的效果。 123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity &#123; private RecyclerView mRecyclerView; private MyAdapter mMyAdapter; private LinearLayoutManager mLayoutManager; private List&lt;String&gt; list; @Override protected void onCreate(final Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initData(); mRecyclerView = findViewById(R.id.recycler_view); mMyAdapter = new MyAdapter(list); mLayoutManager = new LinearLayoutManager(this); mRecyclerView.setLayoutManager(mLayoutManager); mRecyclerView.setAdapter(mMyAdapter); &#125; private void initData() &#123; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= 20; i++) &#123; list.add(&quot;Item &quot; + i); &#125; &#125;&#125; 效果： 分割线 - ItemDecoration可以通过RecyclerView.addItemDecoration()来实现。 略… 布局 - LayoutManagerLayoutManager 负责在 RecyclerView 中度量和定位 Item 视图，并确定何时回收用户不再可见的 Item 的策略。通过更改 LayoutManager，可以使用 RecyclerView 实现标准的垂直滚动列表、统一的网格、交错网格、水平滚动集合等。 几个实现类： 123LinearLayoutManager：LayoutManager 的子类，线性布局管理器，支持横向、纵向GridLayoutManager：LinearLayoutManager 的子类，网格布局管理器StaggeredGridLayoutManager：LayoutManager 的子类，瀑布流布局管理器 动画 - ItemAnimator动画也是 RecyclerView 很强大的一点，用户可以通过实现 ItemAnimator 这个抽象类来定制我们想要的动画。 官方为我们提供了一种默认的实现 DefaultItemAnimator ，借助这个类，我们就可以加入 Item 的添加和删除动画，实现起来很简单，只需要加入下面这一行代码即可： 1mRecyclerView.setItemAnimator(new DefaultItemAnimator()); 然后再具体更改自己的代码就行了，这里只是简单的介绍了一下关于动画的一点儿东西，还有很多好看的动画，可以参考一下这个链接。 点击事件12ListView 中点击事件只能针对子项，无法监听内部控件RecyclerView 按需对任意 View 设置点击监听，不存在点击不到的控件。 通过接口回调实现。 具体使用方法请面向百度编程。 下拉刷新SwipeRefreshLayout。 具体使用方法请面向百度编程。 上拉加载更多footerview。 具体使用方法请面向百度编程。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM打表与C/C++字符串输入]]></title>
    <url>%2F2019%2F04%2F08%2FACM%E6%89%93%E8%A1%A8%E4%B8%8EC-C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[目录： ACM打表方法 C/C++字符串输入方法 scanf gets getchar cin getline(cin,s) ACM打表方法众所周知，在ACM比赛中，对于代码的运行时间运行内存之类的东西是有要求的，很多时候为了提高速度，会采用打表的方法。 比如说ACM里面一道题让你求第n个质数，n&lt;=10000，如果第一个测试用例让你求第1000个，那么你可以将前1000个已经算好了的存起来，如果题目再问到小于1000的情况，前面已经计算过了，那么我们就可以直接输出，算出的结果继续存起来，以备下一次的实用，如此类推，这个存起来的过程就叫做打表。 C/C++字符串输入方法注意，不同的编译器头文件可能不一样，需要注意一下这个问题。 scanf遇到空格会终止。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define N 101010using namespace std;int main()&#123; char s[N],b[N]; cout&lt;&lt;&quot;请输入字符串：\n&quot;; while(~scanf(&quot;%s&quot;,s))&#123; int i = 0; while((b[i] = s[i])!=&apos;\0&apos;) i++; cout&lt;&lt;&quot;字符串复制如下：\n&quot;; puts(b); cout&lt;&lt;&quot;请输入字符串：\n&quot;; &#125; return 0;&#125; 结果如下： 12345678请输入字符串：DJHHJ DHJKSDH字符串复制如下：DJHHJ请输入字符串：字符串复制如下：DHJKSDH请输入字符串： 它自己会将其分为两个字符串。 gets包括空格，但是遇到’\n’会终止。 getchar终止的条件是自己定的，在终止之前可以读入所有的操作。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define N 101010using namespace std;int main()&#123; char s[N],b[N]; int i = 0; cout&lt;&lt;&quot;请输入字符串：\n&quot;;//这里就是遇到回车就结束了。 while((s[i] = getchar())!=&apos;\n&apos;)///模仿getline &#123; b[i] = s[i]; i++; &#125; cout&lt;&lt;&quot;字符串复制如下：\n&quot;; puts(b); return 0;&#125; cin这是C++的输入，和scanf类似。 getline(cin,s)这是string的特定输入法。可以读入空格，以”\n”结束。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define N 101010using namespace std;int main()&#123; //char s[N],b[N]; string s,b; cout&lt;&lt;&quot;请输入字符串：\n&quot;; while(getline(cin,s))&#123; b = s; cout&lt;&lt;&quot;字符串复制如下：\n&quot;; // puts(b); cout&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;&quot;请输入字符串：\n&quot;; &#125; return 0;&#125; 参考链接]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>打表</tag>
        <tag>ACM</tag>
        <tag>字符串输入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-自定义控件简述]]></title>
    <url>%2F2019%2F04%2F07%2FAndroid-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录： 自定义控件要求 制作步骤 自定义控件两个方式 基本原理 1.）测量-Measure过程是计算视图大小，View measure过程相关方法主要有三个： 2.）布局-Layout过程用于设置视图在屏幕中显示的位置，View layout过程相关方法主要要三个： 3.)绘制-draw过程主要用于利用前两步得到的参数，将视图显示在屏幕上，到这里也就完成了整个的视图绘制工作。 自定义控件要求1.遵循Android标准的命名，可配置，事件处理。 2.在XML布局中可配置控件属性。 3.点击事件之类的交互行为。 4.兼容性，Android不同版本之间应该具有广泛的适用性。 制作步骤1.view工作原理。 2.编写view类。 3.为view类增添属性。 4.绘制UI。 5.与用户进行交互（响应）。 6.自定义回调函数。 自定义控件两个方式 继承ViewGroup ​ 例如：ViewGroup、LinearLayout、FrameLayout、RelativeLayout等。 继承View ​ 例如：View、TextView、ImageView、Button等。 基本原理View的绘制基本上由measure()、layout()、draw()这个三个函数完成。 1.）测量-Measure过程是计算视图大小，View measure过程相关方法主要有三个：123public final void measure(int widthMeasureSpec, int heightMeasureSpec) protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) measure调用onMeasure，onMeasure测量宽度、高度然后调用setMeasureDimension保存测量结果，measure，setMeasureDimension是final类型，view的子类不需要重写，onMeasure在view的子类中重写。 关于MeasureSpec： (1) UPSPECIFIED :父容器对于子容器没有任何限制,子容器想要多大就多大. (2) EXACTLY父容器已经为子容器设置了尺寸,子容器应当服从这些边界,不论子容器想要多大的空间. (3) AT_MOST子容器可以是声明大小内的任意大小. 2.）布局-Layout过程用于设置视图在屏幕中显示的位置，View layout过程相关方法主要要三个：123public void layout(int l, int t, int r, int b)protected boolean setFrame(int left, int top, int right, int bottom)protected void onLayout(boolean changed, int left, int top, int right, int bottom) layout通过调用setFrame（l,t,r,b），l,t,r,b即子视图在父视图中的具体位置，onLayout一般只会在自定义ViewGroup中才会使用。 3.)绘制-draw过程主要用于利用前两步得到的参数，将视图显示在屏幕上，到这里也就完成了整个的视图绘制工作。12public void draw(Canvas canvas)protected void onDraw(Canvas canvas) 通过调用draw函数进行视图绘制，在View类中onDraw函数是个空函数，最终的绘制需求需要在自定义的onDraw函数中进行实现，比如ImageView完成图片的绘制，如果自定义ViewGroup这个函数则不需要重载。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(五)]]></title>
    <url>%2F2019%2F04%2F06%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 fir下载 版本 展示 主要代码 增添一个脚本 更新一个版本 总结 前言经过多代版本的更迭，现在这个版本已经稳定下来了。能够自己开发一个这种APP，还是很有成就感的。 下面就是最近一个版本的更新信息： 12342.6.0修复后台BUG。增添蚂蚁森林一键收取能量，星星球以及重力传感器验证功能，同时增加内测IPV6聊天室功能。更改应用图标。 正文fir下载fir下载链接 版本 展示 主要代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//2019.4.5 悬浮按钮方法function suspendButton(qqSpaceLikeFunction)&#123; var window =floaty.window( &lt;frame&gt; &lt;button id=&quot;action&quot; text=&quot;载入脚本...&quot; textColor=&quot;#000000&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; w=&quot;100&quot; h=&quot;40&quot; bg=&quot;#77ffffff&quot;/&gt; &lt;/frame&gt; ); //计时器1s window.setPosition(device.width/2,device.height/2); setInterval(()=&gt;&#123;&#125;, 1000); for(i=3;i&gt;0;i--)&#123; sleep(1000); window.action.setText(i+&apos;s&apos;); &#125; sleep(1000); window.action.setText(&apos;停止运行&apos;); var execution = null; //记录按键被按下时的触摸坐标 var x = 0, y = 0; //记录按键被按下时的悬浮窗位置 var windowX, windowY; //记录按键被按下的时间以便判断长按等动作 var isWork=false; //当前点赞线程 var thread; window.action.setOnTouchListener(function(view, event)&#123; switch(event.getAction())&#123; case event.ACTION_DOWN: x = event.getRawX(); y = event.getRawY(); windowX = window.getX(); windowY = window.getY(); downTime = new Date().getTime(); return true; case event.ACTION_MOVE: //移动手指时调整悬浮窗位置 window.setPosition(windowX + (event.getRawX() - x), windowY + (event.getRawY() - y)); //如果按下的时间超过1.5秒判断为长按，退出脚本 if(new Date().getTime() - downTime &gt; 1500)&#123; exit(); &#125; return true; case event.ACTION_UP: //手指弹起时如果偏移很小则判断为点击 if(Math.abs(event.getRawY() - y) &lt; 5 &amp;&amp; Math.abs(event.getRawX() - x) &lt; 5)&#123; if(window.action.getText() == &apos;开始运行&apos;)&#123; window.action.setText(&apos;停止运行&apos;); toast(&quot;脚本停止运行&quot;); threads.shutDownAll(); &#125;else&#123; window.action.setText(&apos;开始运行&apos;); toast(&quot;脚本开始运行&quot;); thread=threads.start(function()&#123; qqSpaceLikeFunction(); &#125;); &#125; &#125; return true; &#125; return true; &#125;);&#125;//护眼模式点击事件的方法2019.4.6function antForestFunction()&#123; //内置音量下键关闭，故不做监测 //下面是其他js文件的载入路径 var path = &quot;./蚂蚁森林.js&quot;; toast(&quot;开始运行，音量下键结束运行...&quot;); sleep(1000); if(!files.exists(path))&#123; toast(&quot;蚂蚁森林相关文件缺失...&quot;); exit(); &#125; var execution=null; execution=engines.execScriptFile(path);&#125;//星星球点击事件的方法2019.4.6function starStarBallFunction()&#123; //内置音量下键关闭，故不做监测 //下面是其他js文件的载入路径 var path = &quot;./星星球.js&quot;; toast(&quot;开始运行，音量下键结束运行...&quot;); sleep(1000); if(!files.exists(path))&#123; toast(&quot;星星球相关文件缺失...&quot;); exit(); &#125; var execution=null; execution=engines.execScriptFile(path);&#125;//重力传感器方法function cubeAnimationFunction()&#123; //内置音量下键关闭，故不做监测 //下面是其他js文件的载入路径 var path = &quot;./立方体动画.js&quot;; toast(&quot;开始运行，音量下键结束运行...&quot;); sleep(1000); if(!files.exists(path))&#123; toast(&quot;重力传感器验证相关文件缺失...&quot;); exit(); &#125; var execution=null; execution=engines.execScriptFile(path);&#125;//IPV6聊天室方法function chatRoomFunction()&#123; //内置音量下键关闭，故不做监测 //下面是其他js文件的载入路径 var path = &quot;./ipv6聊天室.js&quot;; toast(&quot;开始运行，音量下键结束运行...&quot;); sleep(1000); if(!files.exists(path))&#123; toast(&quot;IPV6聊天室相关文件缺失...&quot;); exit(); &#125; var execution=null; execution=engines.execScriptFile(path);&#125; 增添一个脚本为了防止自己忘记，这里写一下增添一个脚本的常规步骤。 1.添加控件 主要就是在两个页面（开发中与可使用）添加对应的控件就可以了。 一般是两个，第一个是按钮，第二个是相关界面的跳转。 2.添加相关的点击事件。 点击事件指向的是“相关”的UI。 3.添加脚本的点击事件。 buttonClickEvent是自己创建的方法，主要是传进去一个控件的ID，然后传入需要执行的具体方法。 buttonClickEvent： 4.直接写具体实现方法。 一般是把具体实现方法写到另外一个js文件里面，再引入之后使用，免得main.js里面太多东西。 更新一个版本1.将VSCode里面的代码save到device上面去，记得放到同一个项目里面去（只能导入，不能直接从文件管理器剪切移动过去） 2.打包测试。没问题的话发给电脑。 3.电脑登录fir.im，更新版本。 4.写完版本更新内容的话复制粘贴到基本信息里面的应用描述。（开屏检查更新推送） 5.改写内置的版本号（每次更新必备） 、 总结1）下一次修复一下更新问题。 2）增添一个模块叫相关问题，把需要注意的地方都写上去。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-线程停止的三种方式]]></title>
    <url>%2F2019%2F04%2F05%2Fjava%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[目录： 前提 方式一 方式二 方式三 前提停止线程在多线程开发中很有必要，掌握线程的停止可以对线程的停止进行有效的处理。 方式一使用退出标志，使得线程正常的退出，也就是run方法之后进程终止。用flag来作为进程是否继续进行的条件。 12345public void run() &#123; while(flag)&#123; //do something &#125;&#125; 方式二使用stop强行中断线程，不推荐使用，暴力终止，可能使一些清理性的工作得不到完成。还可能对锁定的内容进行解锁，容易造成数据不同步的问题。 方式三使用interrupt方法中断线程。 java中有以下两个方法： this.interrupted():测试当前线程是否已经中断（静态方法）。如果连续调用该方法，则第二次调用将返回false。在api文档中说明interrupted()方法具有清除状态的功能。执行后具有将状态标识清除为false的功能。 this.isInterrupted():测试线程是否已经中断，但是不能清除状态标识。 抛异常法： 1234567891011121314151617181920public class MyThread4 extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; for (int i = 0; i &lt; 50000; i++) &#123; if (this.isInterrupted()) &#123; System.out.println( &quot;线程已经结束，我要退出&quot; );// return; throw new InterruptedException(); &#125; System.out.println( &quot;i=&quot; + (i + 1) ); &#125; System.out.println( &quot;我是for下面的语句，我被执行说明线程没有真正结束&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;进入MyThread.java类中run方法的catch异常了&quot; ); e.printStackTrace(); &#125; &#125;&#125; 沉睡停止法： 1234567891011121314151617181920212223 @Override public void run() &#123; super.run(); try &#123; System.out.println( &quot;begin run&quot; ); Thread.sleep( 500 ); System.out.println( &quot;begin end&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;在沉睡中终止&quot;); e.printStackTrace(); &#125; &#125;public static void main(String[] args) &#123; try &#123; MyThread5 thread5 = new MyThread5(); thread5.start(); Thread.sleep( 20 ); thread5.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;main catch&quot; ); e.printStackTrace(); &#125; &#125; 或者： 12345678910111213141516 try &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.println( &quot;i=&quot; +(i + 1) ); &#125; System.out.println( &quot;run begin&quot; ); Thread.sleep( 200 ); System.out.println( &quot;run end&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;先停止，后sleep&quot; ); e.printStackTrace(); &#125;public static void main(String[] args) &#123; MyThread5 thread5 = new MyThread5(); thread5.start(); thread5.interrupt(); &#125; 参考链接]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(四)]]></title>
    <url>%2F2019%2F04%2F04%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 总结 前言今天早上八点就起来改代码，现在终于把更新这个功能修改完了。等会儿还有事儿，唉，想睡午觉都不行了。 正文今天一天就更新了这么多版本，也是没谁了，主要是为了测试APP更新的功能。 下面是代码： 12345678910111213141516171819202122232425262728293031323334353637//2019.4.4 开屏进入检查是否有更新，有就提示，没有就不提示function checkHaveUpdate()&#123; threads.start(function()&#123; //网络请求必须更改线程，不能在主线程 //通过fir.im的API来进行版本查询 var url=&quot;http://api.fir.im/apps/latest/5ca40357548b7a65912fc02b?api_token=b44bd08868ab6ad1b1c02ca260c389b6&amp;type=android&quot;; var res =http.get(url); //下面必须用app.versionCode获取本地APP版本号，3.00是测试用的 if(res.statusCode == 200)&#123; //toast(&quot;请求成功&quot;); //先检测是否有版本号存储本地 var versionShortFromWeb=JSON.parse(res.body.string()).versionShort; if(storage.get(&quot;versionShort&quot;)==versionShortFromWeb)&#123; //如果版本短号一样则不更新 toast(&quot;欢迎回来，亲~~~&quot;); &#125; else&#123; //有更新 //或许这里可以给一个alert框显示一些更新内容 var allUpdateMessageUrl=&quot;http://api.fir.im/apps/5ca40357548b7a65912fc02b?api_token=b44bd08868ab6ad1b1c02ca260c389b6 &quot;; var allUpdateMessage =JSON.parse(http.get(allUpdateMessageUrl).body.string()); var showallUpdateMessage=&quot;更新内容： &quot;+&quot;\n&quot;+allUpdateMessage.desc; dialogs.build(&#123; title: &quot;发现新版本&quot;, content:showallUpdateMessage, positive: &quot;知道了&quot; &#125;).on(&quot;positive&quot;,()=&gt;&#123; toast(&quot;有更新，请前往菜单页面更新哦，~亲~&quot;); &#125;).show(); log(versionShortFromWeb+app.versionName); &#125; &#125;else&#123;//网络请求失败 toast(&quot;找不到网络呢，亲！&quot;); &#125;; &#125;);&#125; 主要是增添了开屏检查更新的功能： 总结遇到了很多的问题，总归还是很有收获，个人开发APP遇到这么多问题是我始料不及的，但是也很庆幸，因为学到了很多。 现在还有些问题没有解决，包括本地存储的versionShort版本号还是没有完善，只是默认点击了浏览器下载或者直接下载就会更改本地的versionShort为最新版本号，还有就是下载的问题，貌似302？测试不够多现在还不是很明确。 还有就是需要考虑一下在线数据存储器问题。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(三)]]></title>
    <url>%2F2019%2F04%2F03%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 代码 前言今天又是元气满满的一天，改了一天的代码，累死…主要就是在fir.im上面上传了代码，然后给应用添加了一个可以检查更新的功能，有关于网络请求方面有很多问题，不得不说！ 正文代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//2019.4.3检查是否有更新，有更新的话就下载function checkIsUpdata()&#123; threads.start(function()&#123; //网络请求必须更改线程，不能在主线程 //通过fir.im的API来进行版本查询 var url=&quot;http://api.fir.im/apps/latest/5ca40357548b7a65912fc02b?api_token=b44bd08868ab6ad1b1c02ca260c389b6&amp;type=android&quot;; var res =http.get(url); //下面必须用app.versionCode获取本地APP版本号，2.00是测试用的 var now_version=app.versionCode; if(res.statusCode == 200)&#123; //toast(&quot;请求成功&quot;); if(res.body.string().indexOf(now_version)&gt;0) &#123;//已经是最新版 toast(&quot;已经是最新版了哦，亲~~~&quot;); &#125; else &#123;//有新版 //弹出选择框 updataApp(url); &#125; log(res.body.string().indexOf(now_version)); &#125;else&#123;//网络请求失败 toast(&quot;请求失败:&quot; + res.statusMessage); &#125;; &#125;);&#125;;//更新的具体方法function updataApp(url)&#123; //Json.stringify是将Json对象美化,parse是把它变成JSON对象 updateMessage=JSON.parse(http.get(url).body.string()); var updateContent=&quot;名称: &quot;+updateMessage.name+&quot;\n&quot;+&quot;版本号: &quot;+updateMessage.version+&quot;\n&quot;+&quot;版本短号: &quot;+updateMessage.versionShort; dialogs.build(&#123; title: &quot;发现新版本&quot;, content: updateContent, positive: &quot;立即下载&quot;, negative: &quot;取消&quot;, neutral: &quot;去浏览器下载&quot; &#125;).on(&quot;positive&quot;,download) .on(&quot;neutral&quot;, () =&gt; &#123; app.openUrl(&quot;https://fir.im/ha23&quot;); &#125;) .show();&#125;//下载安装包的方法function download()&#123; threads.start(function()&#123; /*var url=&quot;http://api.fir.im/apps/5ca40357548b7a65912fc02b/download_token?api_token=b44bd08868ab6ad1b1c02ca260c389b6&quot;; //转成JSON对象 var downloadApi=JSON.parse(http.get(url).body.string()); //转成字符串 //var a=JSON.stringify(downloadApi.download_token).string();*/ //这里的download_token如果动态拼接的话会出现问题，然后正好前面返回的数据看到的，并且测试之后更新版本并不影响它的值，所以就直接使用了，本来不该这样用 app.openUrl(&quot;http://download.fir.im/apps/5ca40357548b7a65912fc02b/install?download_token=d1a11ae1ae9947fb66777f9540327497&quot;); &#125;);&#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(二)]]></title>
    <url>%2F2019%2F04%2F02%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 主页面 菜单 代码 总结 前言今天改了一下上次的UI还有添加了一下新功能。不得不说，这个UI是真的难调~ 正文主页面 菜单 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240//下面是UI层，主要就是图形&quot;ui&quot;;var color = &quot;#66ccff&quot;;//打开主页面UImainUI();//下面是各个不同的页面UI//主页面UIfunction mainUI()&#123; ui.layout( &lt;frame&gt; &lt;drawer id=&quot;drawer&quot;&gt; &lt;vertical&gt; &lt;appbar&gt; &lt;toolbar id=&quot;toolbar&quot; title=&quot;脚本列表&quot;/&gt; &lt;tabs id=&quot;tabs&quot;/&gt; &lt;/appbar&gt; &lt;viewpager id=&quot;viewpager&quot;&gt; &lt;frame&gt; &lt;vertical&gt; &lt;horizontal&gt; &lt;button id=&quot;autoGood&quot; text=&quot;QQ名片自动点赞&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;button id=&quot;autoGoodRelate&quot; text=&quot;相关&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;3&quot;/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;autoSignIn&quot; text=&quot;I西科自动签到&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;button id=&quot;autoSignInRelate&quot; text=&quot;相关&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;3&quot;/&gt; &lt;/horizontal&gt; &lt;/vertical&gt; &lt;/frame&gt; &lt;frame&gt; &lt;/frame&gt; &lt;/viewpager&gt; &lt;/vertical&gt; &lt;vertical layout_gravity=&quot;left&quot; bg=&quot;#ffffff&quot; w=&quot;280&quot;&gt; &lt;img w=&quot;280&quot; h=&quot;200&quot; scaleType=&quot;fitXY&quot; src=&quot;http://i1.bvimg.com/682525/a1c337b714162972.jpg&quot;/&gt; &lt;list id=&quot;menu&quot;&gt; &lt;horizontal bg=&quot;?selectableItemBackground&quot; w=&quot;*&quot;&gt; &lt;img w=&quot;50&quot; h=&quot;50&quot; padding=&quot;16&quot; src=&quot;&#123;&#123;this.icon&#125;&#125;&quot; tint=&quot;&#123;&#123;color&#125;&#125;&quot;/&gt; &lt;text textColor=&quot;black&quot; w=&quot;*&quot; h=&quot;*&quot; textSize=&quot;15sp&quot; text=&quot;&#123;&#123;this.title&#125;&#125;&quot; gravity=&quot;center&quot; singleLine=&quot;true&quot;/&gt; &lt;/horizontal&gt; &lt;/list&gt; &lt;/vertical&gt; &lt;/drawer&gt; &lt;/frame&gt; ); //自动点击的相关点击事件 ui.autoGoodRelate.click(()=&gt;&#123; autoGoodRelateUI(); &#125;); ui.autoSignInRelate.click(()=&gt;&#123; autoSignInUI(); &#125;); //toolbar activity.setSupportActionBar(ui.toolbar); //设置滑动页面的标题 ui.viewpager.setTitles([&quot;可使用脚本&quot;, &quot;开发中脚本&quot;]); //让滑动页面和标签栏联动 ui.tabs.setupWithViewPager(ui.viewpager); //让工具栏左上角可以打开侧拉菜单 ui.toolbar.setupWithDrawer(ui.drawer); ui.menu.setDataSource([ &#123; title: &quot;个人信息&quot;, icon: &quot;https://img.icons8.com/ios/100/000000/ninja-turtle.png&quot; &#125;, &#123; title: &quot;注意事项&quot;, icon: &quot;https://img.icons8.com/ios/100/000000/assignment-late.png&quot; &#125;, &#123; title: &quot;关于&quot;, icon: &quot;https://img.icons8.com/ios/100/000000/info.png&quot; &#125;, &#123; title: &quot;退出&quot;, icon: &quot;https://img.icons8.com/ios/100/000000/esc.png&quot; &#125; ]); ui.menu.on(&quot;item_click&quot;, item =&gt; &#123; switch(item.title)&#123; case &quot;个人信息&quot;: toast(&quot;尚在开发中哟，亲~&quot;); break; case &quot;注意事项&quot;: alert(&quot;本APP里面的脚本都是依托于无障碍服务，所以无障碍服务权限必须开启。&quot;); break; case &quot;关于&quot;: alert(&quot;Developed by THBELIEF!&quot;); break; case &quot;退出&quot;: ui.finish(); break; &#125; &#125;) //QQ自动点赞的点击事件 ui.autoGood.click(()=&gt;&#123; confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123; if(sure)&#123; //修改控件信息必须更改线程 threads.start(function()&#123; //自动点赞 StartClick(); &#125;); threads.start(function()&#123; //另外一个线程检测是否点击了音量下键 isKeyDown(); &#125;) &#125; &#125;); &#125;); //i西科自动签到点击事件 ui.autoSignIn.click(()=&gt;&#123; confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123; if(sure)&#123; //修改控件信息必须更改线程 threads.start(function()&#123; //自动签到 autoSignInFunction(); &#125;); &#125; &#125;); &#125;);&#125;//QQ名片自动点赞UIfunction autoGoodRelateUI()&#123; ui.layout( &lt;frame&gt; &lt;vertical&gt; &lt;button id=&quot;backMainUIByGoodRelateUI&quot; text=&quot;返回&quot; w=&quot;auto&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; /&gt; &lt;text text=&quot;本脚本适配V7.9.9.3965版QQ.注意：本脚本使用之前必须打开无障碍服务权限，否则不会运行。&quot; textSize=&quot;20sp&quot;/&gt; &lt;/vertical&gt; &lt;/frame&gt; ); //返回键返回主界面 ui.backMainUIByGoodRelateUI.click(()=&gt;&#123; mainUI(); &#125;);&#125;//i西科自动签到UIfunction autoSignInUI()&#123; ui.layout( &lt;frame&gt; &lt;vertical&gt; &lt;button id=&quot;backMainUIBySignInUI&quot; text=&quot;返回&quot; w=&quot;auto&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; /&gt; &lt;text text=&quot;本脚本适配3.9.0Android版i西科.注意：本脚本使用之前必须打开无障碍服务权限，否则不会运行。&quot; textSize=&quot;20sp&quot;/&gt; &lt;/vertical&gt; &lt;/frame&gt; ); ui.backMainUIBySignInUI.click(()=&gt;&#123; mainUI(); &#125;);&#125;//下面是各类方法的实现//从桌面一直打开到点赞页面的函数function open()&#123; //需要无障碍权限 auto(&quot;normal&quot;); //直接打开QQ（应该还要判断一下是否已经登录了） launchApp(&quot;QQ&quot;); //调用QQ提供的Android以及ios通用API打开QQ名片 var i = app.intent(&#123; action:&quot;android.intent.action.VIEW&quot;, data:&quot;mqqapi://card/show_pslcard?&amp;uin=&quot; &#125;); app.startActivity(i); //打开点赞列表 toast(&quot;请点击QQ点赞的图标进入点赞页面哦，亲~~~&quot;); sleep(250);&#125;//具体点赞的方法function good() &#123; //寻找点赞的小图标 var goodClick = desc(&quot;赞&quot;).untilFind(); var i = 0; while (i &lt; goodClick.size()) &#123; var j = 0; while (j &lt; 10) &#123;//十次点击 goodClick.get(i).click(); j = j + 1; &#125; i = i + 1; &#125; //点击完之后要往下翻 className(&quot;android.widget.AbsListView&quot;).scrollForward(); sleep(500); //如果出现显示更多就点击一下 if (text(&quot;显示更多&quot;).exists()) &#123; text(&quot;显示更多&quot;).findOne().parent().click(); &#125;&#125;//这个是QQ名片自动点赞的主方法function StartClick()&#123; //下面就是主函数部分 toast(&quot;请确保QQ已经登录哦亲~~~&quot;); open(); //进入点赞页面，页面跳转需要时间，必须延迟才行。 waitForActivity(&quot;com.tencent.mobileqq.activity.VisitorsActivity&quot;); toast(&quot;停止此脚本请按音量下键，亲~~~&quot;); while(true)&#123; good(); &#125;&#125;//检测是否点击了音量下键的方法function isKeyDown()&#123; //按键时不会弹出音量框 events.setKeyInterceptionEnabled(&quot;volume_down&quot;,true); //监听按键 events.observeKey(); events.on(&quot;key_down&quot;,function(volume_down,event)&#123; toast(&quot;正在关闭此脚本,亲~~~&quot;); //退出脚本 sleep(500); engines.stopAll(); //直接返回桌面 home(); &#125;);&#125;//2019.4.2 i西科自动签到方法function autoSignInFunction()&#123; auto(); //打开i西科 launchApp(&quot;i西科&quot;); //跳转到相应的界面 waitForPackage(&quot;org.weixvn.frame&quot;); //找到首页上签到的按钮，点击进去 id(&quot;it_sign_in&quot;).clickable().findOne().click(); waitForActivity(&quot;com.example.z.iswust.view.activity.impl.SignInActivity&quot;); //点击签到 sleep(1000); id(&quot;btn_signin&quot;).clickable().untilFind().click(); toast(&quot;签到成功了哟，亲~~~&quot;); sleep(500); //签到完成之后直接返回桌面 home();&#125; 总结1.布局和UI的设计还是需要好好斟酌。 2.尽量函数方法话。 3.下次升级蚂蚁森林自动化收取功能。 4.所有功能尽量都提供定时开启的功能。 未完待续~~~]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-活动]]></title>
    <url>%2F2019%2F04%2F01%2FAndroid-%E6%B4%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[目录： 生命周期 简单介绍 活动状态 运行状态 暂停状态 停止状态 销毁状态 活动的生存期 活动被回收之后如何恢复 启动模式 standard singleTop singleTask singleInstance 活动技巧 打印当前活动 随意退出程序 杀掉进程 启动活动最佳方式 生命周期简单介绍Android使用任务（Task）来管理活动，一个任务就是一组存放在栈里的活动的集合，这个栈也叫作返回栈（Back Stack）。要注意，栈是后进先出的数据结构。默认情况下，启动新活动的时候入栈处于栈顶位置。系统总是会将栈顶位置的活动给用户。 活动状态每个活动在其生命周期当中最多有4种状态。 运行状态处于栈顶的活动。 暂停状态活动不处于栈顶，但是仍然可见。 停止状态不在栈顶，同时完全不可见。 销毁状态活动从返回栈中移除了。 活动的生存期1.onCreate() 活动第一次被创建的时候调用，在这个方法中完成初始化操作，比如加载布局、绑定事件等。 2.onStart() 在活动由不可见变为可见的时候调用。 3.onResume() 在活动准备好和用户进行交互的时候调用，此时的活动一定位于返回栈的栈顶，并且处于运行状态。 4.onPause() 在系统准备去启动或者恢复另一个活动的时候调用，通常会在这个方法中将一些消耗cpu的资源释放掉，保存一些关键数据，该方法执行速度要快，不然会影响新的栈顶活动的使用。 5.onStop() 活动在活动完全不可见的时候调用，它和onPause方法的主要区别在于，如果启动的新活动是一个对话框式活动，那么onPause方法会得到执行，而onStop方法并不会执行。 6.onDestroy() 在活动被销毁之前调用，之后活动的状态将变为销毁状态。 7.onRestart() 在活动由停止状态变为运行状态之前调用，即活动被重新启动。 12345678完整生存期 onCreate()和 onDestroy()方法之间所经历的，就是完整生存期。一般，一个活动会在onCreate()方法中完成各种初始化操作，而在onDestroy()方法中完成释放内存的操作。可见生存期 onStart()和onStop()方法之间所经历的就是可见生存期。在该生存期内，活动对于用户总是可见的。我们可以通过这两个方法合理的管理对用户可见的资源。比如在onStart()方法中对资源进行加载，onStop()中进行释放。前台生存期 活动在onResume()方法和onPause()方法之间所经历的的就是前台生存期。此时活动处于运行状态。 活动被回收之后如何恢复很多时候，当内存不足的时候，系统会将一些返回栈中的一些活动给回收掉，如果又打开这个活动，那怎么找回数据呢？ Activity提供了一个onSaveInstanceState()回调方法。这个方法可以保证活动被回收之前一定会被调用，这个方法可以帮助保存该活动的临时数据。 onSaveInstanceState()回调方法会携带一个Bundle类型的参数，键值对形式存储数据，Bundle提供了一系列的方法用于保存数据，比如可以使用putString()方法保存字符串等等，这些方法需要传入两个参数，一个是键，这个键用于后面从Bundle中取值，第二个参数是真正要存储的数据。 其实这个Bundle和前面的Intent的使用方式很类似，这里就不贴代码了，实际上，还可以使用Bundle对象保存数据，然后将其放在Intent里面，再通过Intent传递。 启动模式 activity有四种启动模式，分别为standard，singleTop，singleTask，singleInstance。如果要使用这四种启动模式，必须在manifest文件中标签中的launchMode属性中配置。 12345&lt;activity android:name=&quot;.app.InterstitialMessageActivity&quot; android:label=&quot;@string/interstitial_label&quot; android:theme=&quot;@style/Theme.Dialog&quot; android:launchMode=&quot;singleTask&quot;&lt;/activity&gt; standard标准启动模式，也是activity的默认启动模式。在这种模式下启动的activity可以被多次实例化，即在同一个任务中可以存在多个activity的实例，每个实例都会处理一个Intent对象。如果Activity A的启动模式为standard，并且A已经启动，在A中再次启动Activity A，即调用startActivity（new Intent（this，A.class）），会在A的上面再次启动一个A的实例，即当前的桟中的状态为A–&gt;A。 singleTop如果一个以singleTop模式启动的activity的实例已经存在于栈顶，那么再启动这个Activity时，不会创建新的实例，而是重用位于栈顶的那个实例，并且会调用该实例的onNewIntent()方法将Intent对象传递到这个实例中。 如果以singleTop模式启动的activity的一个实例已经存在与任务桟中，但是不在桟顶，那么它的行为和standard模式相同，也会创建多个实例。 singleTask如果一个activity的启动模式为singleTask，那么系统总会在一个新任务的最底部（root）启动这个activity，并且被这个activity启动的其他activity会和该activity同时存在于这个新任务中。如果系统中已经存在这样的一个activity则会重用这个实例，并且调用他的onNewIntent()方法。即，这样的一个activity在系统中只会存在一个实例。 每次活动启动的时候系统会首先在返回栈中检查是否存在该活动的实例，如果存在就直接使用该实例，并且把这个活动之上的所有的活动都出栈。 singleInstance总是在新的任务中开启，并且这个新的任务中有且只有这一个实例，也就是说被该实例启动的其他activity会自动运行于另一个任务中。当再次启动该activity的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将Intent实例传递到该实例中。和singleTask相同，同一时刻在系统中只会存在一个这样的Activity实例。 活动技巧打印当前活动主要目的是明确当前所处的活动，用处是接手新的代码的时候可以更快的入手。 新建一个BaseActivity的Java文件，这个不用去AndroidManifest中去注册，就是一个普通的Java类。然后让它继承AppCompatActivity，重写onCreate方法： 1234567public class BaseActivity extends AppCompatActivity&#123; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); Log.d(&quot;BaseActivity&quot;,getClass().getSimpleName()); &#125;&#125; 然后让BaseActivity成为那些继承AppCompatActivity的活动的父类，不会影响他们的特性，同时还可以打印出当前活动。 随意退出程序有些时候我们会发现，如果在一个APP里面点击进去很多层之后必须要很多次BACK才可以退出程序。 解决方案：专门建立一个集合类用来管理所有的活动，提供相应的方法来添加活动与移除活动就可以了，然后有需要的地方直接调用方法就可以解决这个问题了。 杀掉进程有时候销毁某APP的所有活动之后还需要杀掉当前的进程，来保证程序完全的退出。 1android.os.Process.killProcess(android.os.Process.myPid()); killProcess方法用来杀掉一个进程，接收一个进程id参数，只能杀掉当前程序进程。 启动活动最佳方式普通的Intent显示启动与隐式启动都是没有任何的问题的。 但是有些时候如果另外一个活动不是你开发的，你也不知道该传哪些参数过去，这就很麻烦，可以换另外一种方案。 修改SecondActivity的代码如下： 123456public static void actionStart(Context context,String datal,String data2)&#123; Intent intent=new Intent(context,SecondActivity.class); intent.putExtra(&quot;param1&quot;,data1); intent.putExtra(&quot;param2&quot;,data2); context.startActivity(intent); &#125; 在SecondActivity当中添加一个actionStart方法，在这个方法中完成Intent的构建，另外所有的SecondActivity需要的数据都是通过actionStart的参数传递过来的，然后存到Intent中最后调用startActivity方法启动SecondActivity。这样的好处就是可以一目了然的知道需要哪些参数，同时调用的时候也更加的方便，只有一行代码。 MainActivity中代码： 123//或许是某个按钮的点击事件触发的活动跳转？SecondActivity.actionStart(MainActivity.this,&quot;data1&quot;,&quot;data2&quot;);//这其实就已经完成了跳转的功能了，因为Intent启动写到方法里面去了。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>活动</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Intent详解]]></title>
    <url>%2F2019%2F03%2F31%2FAndroid-Intent%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[目录： 简介 用途 启动Activity 启动Service 发送广播 主要属性 Acticon Data 次要属性 category Type component extras Flag 构造方法 常用方法 显示意图 隐示意图 番外 向下一个活动传递数据 返回数据给上一个活动 简介Intent在Android中是一个非常重要并且常用的类，可以用来在一个组件中启动App中的另一个组件或者是启动另一个App的组件，这里所说的组件指的是Activity、Service以及Broadcast。 用途启动Activity可以将Intent对象传递给startActivity()方法或startActivityForResult()方法以启动一个Activity，该Intent对象包含了要启动的Activity的信息及其他必要的数据。 启动Service可以将Intent对象传递给startService()方法或bindService()方法以启动一个Service，该Intent对象包含了要启动的Service的信息及其他必要的数据。 发送广播广播是一种所有App都可以接收的信息。Android系统会发布各种类型的广播，比如发布开机广播或手机充电广播等。我们也可以给其他的App发送广播，可以将Intent对象传递给sendBroadcast()方法或sendOrderedBroadcast()方法或sendStickyBroadcast()方法以发送自定义广播。 主要属性Acticon执行的动作类型。如果是自定义的Action的话，定义的时候需要包含app的包名： 1static final String ACTION_TIMEREVEL = &quot;com.exmple.action.TIMERAVEL&quot; Activity Actions： 12345678910111213ACTION_MAIN 表示程序入口ACTION_VIEW 自动以最合适的方式显示DataACTION_EDIT 提供可以编辑的ACTION_PICK 选择一个一条Data，并且返回它ACTION_DAIL 显示Data指向的号码在拨号界面Dailer上ACTION_CALL 拨打Data指向的号码ACTION_SEND 发送Data到指定的地方ACTION_SENDTO 发送多组Data到指定的地方ACTION_RUN 运行Data，不管Data是什么ACTION_SEARCH 执行搜索ACTION_WEB_SEARCH 执行网上搜索ACRION_SYNC 执同步一个DataACTION_INSERT 添加一个空的项到容器中 Broadcast Actions： 12ACTION_TIME_TICK 当前时间改变，并即时发送时间，只能通过系统发送。调用格式&quot;android.intent.action.TIME_TICK&quot;ACTION_TIME_CHENGED 设置时间。调用格式&quot;android.intent.action.TIME_SET&quot; Data操作数据，包括了URL数据类型和MIME Type类型数据，数据域需要与action相匹配。 次要属性category类别，是Action的附加信息，它主要的用途就是可以更明确一个Intent。 12345CATEGORY_DEFAULT 把一个组件Component设为可被implicit启动的。CATEGORY_LAUNCHER 把一个action设置为在顶级执行。并且包含这个属性的Activity所定义的icon将取代application中定义的icon。CATEGORY_BROWSABLE 当Intent指向网络相关时，必须要添加这个类别CATEGORY_HOME 使Intent指向Home界面CATEGORY_PREFERENCE 定义的Activity是一个偏好面板Preference Panel。 Type这个是数据类型，显示指定的Intent的数据类型，跳过了通过URL进行判断的步骤。 component这个是组件，指定Intent的目标组件名称，当指定了这个属性之后，系统将跳过匹配其他的属性，而直接匹配这个属性来启动对应的组件。 extras附加信息，可以附加一些信息在Intent中。 Flag通过setFlags（int）或者addFlags（int）可以把标签flags用在Intent中。 1234FLAG_ACTIVITY_CLEAR_TOP 相当于Single_TaskFLAGE_ACTIVITY_SINGLE_TOP 相当于Single_TopFLAG_ACTIVITY_NEW_TASK 类似于Single_InstanceFLAG_ACTIVITY_NO_HISTORY 当离开该Activity后，该Activity将被从任务栈中移除 构造方法1234Intent(Intent intent); //通过复制一个Intent来创建一个新的IntentIntent(String action); //构造一个指定action的Intent对象Intent(String action，Uri uri); //构造一个指定action，并且有指向数据的uri的Intent对象Intent(Context packageContext，Clsaa&lt;?&gt;class); //构造一个有指定Component属性的Intent 常用方法123456789101112131415addCategory(String Category); //添加一条Category属性addFlags(int Flags); //添加一条Flag标签clone（）; //复制一个Object类型的对象getExtras（）; //获得一个Bundle对象getSourceBounds（）; //获得发送Intent的组件的边界坐标makeMainActivity（ComponentName mainActivity）; //创建一个Category属性为luancher的Intent去启动mainActivityparseUri（String uri，int flags） //通过解析一个uri获得一个Intent对象setComponent（）; //添加component属性setClass（）; //相当于添加component属性setClassName（）; //相当于添加component属性resolveActivity（PackageManager）; //解析Intent启动的Activity，返回ComponentName对象createChooser（Intent target，CharSequence title）;// 创建一个有选择对话框的IntentgetData（）;setType（）;getData（）;getType（）;设置/获得Data/Type类型的数据 显示意图12Intent intent = new Intent(this, ActivityB.class);startActivity(intent); 隐示意图下面构建了一个Intent对象，并没有给其设置component name，所以该Intent是一个隐式的Intent对象。首先给intent设置了action的值为Intent.ACTION_SEND，action对隐式Intent来说是非常重要的。然后我们将intent的数据的MIME类型设置为纯文本类型(“text/plain”)，告知Android我们的Intent持有的是文本类型的数据。最后我们将实际的文本数据通过putExtra()方法作为额外数据设置进去。 另外，在构建好了Intent对象之后，没有立即执行startActivity(sendIntent)方法，而是将sendIntent作为参数传递给了PackageManager的resolveActivity()方法中，该方法会让Android根据该sendIntent找到潜在的适合启动的组件的信息，并以ResolveInfo类的对象的形式返回结果，如果返回null，表示当前系统中没有任何组件可以接收并处理该sendIntent。如果返回不是null，就表明系统中至少存在一个组件可以接收并处理该sendIntent，只有在这种情况下，我们才会执行代码startActivity(sendIntent)，在通过intent启动组件之前先判断要启动的组件存不存在是个良好的编程习惯，因为如果系统中不存在支持你的intent的组件，那么当你调用startActivity()、startService()、bindService()等方法的时候，Android就会抛出异常。 1234567891011121314Intent sendIntent = new Intent();// 设置action, action对隐式Intent来说是非常重要的sendIntent.setAction(Intent.ACTION_SEND);// 设置数据的MIME类型为纯文本类型sendIntent.setType(&quot;text/plain&quot;);// 设置额外的数据sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);// 获取包管理器PackageManager pm = getPackageManager();// 先判断系统中有没有潜在的App的Activity支持对该sendIntent的接收与处理if (pm.resolveActivity(sendIntent, 0) != null) &#123; startActivity(sendIntent);&#125; 参考链接 番外向下一个活动传递数据众所周知，Intent不只是可以拿来启动，还可以拿来传递数据。 大致思路是，通过Intent提供的putExtra（）方法将数据暂存在Intent中，启动另外一个活动之后再取出来就达到了目的了。 实例：(显示) 暂存： 1234String data=&quot;Hello World&quot;;Intent intent=new Intent(FirstActivity.this,SecondActivity.class);intent.putExtra(&quot;extra_data&quot;,data);//所谓的键值对，配合使用startActivity(intent); 取出： 12Intent intent=getIntent();String data=intent.getStringExtra(&quot;extra_data&quot;); 返回数据给上一个活动上一个活动先发出请求： 1startActivityForResult(intent, 1); //请求码 下一个活动返回数据： 1234Intent intent = new Intent();intent.putExtra(&quot;data_return&quot;, &quot;Hello MainActivity&quot;);setResult(RESULT_OK, intent);finish(); 上一个活动接收信息： 123456789101112/重写onActiviResult方法@Overrideprotected void onActivityResult(int requstCode, int resultCode, Intent data)&#123; switch (requstCode)&#123; //请求码 case 1: if(RESULT_OK == requstCode)&#123; //处理结果码 RESULT_CANCELED String returnResult = data.getStringExtra(&quot;data_return&quot;); &#125; break; default: &#125;&#125;]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Intent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Menu菜单]]></title>
    <url>%2F2019%2F03%2F30%2FAndroid-Menu%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[目录： Menu菜单 选项菜单OptionsMenu 上下文菜单ContextMenu 浮动菜单PopupMenu 创建 1.代码 2.XML 在XML中定义Menu 选项菜单 使用 处理 上下文菜单 使用 处理 注意 浮动菜单 使用函数 使用方式 浮动窗口PopupWindow Menu菜单菜单是一种常见的与用户交互的一种用户界面组件。Android3.0以后推荐使用ActionBar来代替Menu。 Menu主要分为下面三种： 选项菜单OptionsMenu右上方三个点，点击之后出现的列表都是由选项菜单的对象进行控制的。 上下文菜单ContextMenu长按指定控件，在屏幕中心弹出列表对话框。 浮动菜单PopupMenu通过指定的控件指定监听，触发显示，可以让菜单列表显示在指定控件的下方。 创建1.代码2.XML以上两种方法下面详说。 在XML中定义Menu在res/menu目录下的xml文件中操作：（menu文件夹是用户自己新建的） 然后下面是具体参数： 12345678910111213141516171819202122232425&lt;menu&gt;：代表菜单资源&lt;item&gt;：菜单项 android:id // 菜单项的id android:icon // 菜单项的图标 android:title // 菜单项的标题 android:orderInCategory // 排序 android:showAsAction // 在ActionBar上的显示参数（API 11） never：不将MenuItem显示在ActionBar上（是默认值） always：总是将该MenuItem显示在ActionBar上 ifRoom：当AcitonBar上有空间时将该MenuItem显示在ActionBar上，没有空间就放入溢出菜单中 withText：将该MenuItem显示在ActionBar上，并显示该菜单项的文本 显示自定义ActionBar的View，需要和actionViewClass这组参数结合使用（API14）&lt;group&gt;：菜单组 二级菜单（子菜单的创建） 12345678910111213概念：在menu Item中嵌套menu元素，可以实现多级菜单，嵌套的菜单叫做子菜单，一般只会使用二级菜单，如果菜单层次太深，会严重影响用户体验。二级可选菜单 android:checkableBehavior 有三个属性值可选 all（多选） single（单选） none（不可选） 选项菜单使用 初始化选项菜单：onCreateOptionsMenu(Menu menu) 为菜单项设置监听器：onOptionsItemSelected(MenuItem item) 处理 1.在res文件夹内容准备一个menu文件夹，所有控制菜单显示的xml文件均被存于此处。 在menu文件夹中创建一个xml文件，让该文件以menu标签作为根标签。 在menu标签之间添加item标签，每一个item标签代表一个菜单选项。 处理item标签中的属性。 XML中代码 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- android:id 用于设置item的id，即唯一标识，用于稍后的点击判断 android:title 用于设置标题 android:orderInCategory 用于设置item选项在菜单列表中的排列顺序 属性值越小，排列顺序越靠前， 如果属性值相同，哪个item的代码在前面，哪个item就排名靠前 android:icon 用于设置图标。注意：如果item是显示在菜单列表中，那么 图标永远不显示 android:showAsAction android3.0 以后才出的属性 用于设置item在标题栏上的显示特点 可选属性值： never 该选项永远显示在菜单列表中 ifRoom 如果标题栏上有剩余空间，就显示在标题栏上，如果没有，就显示在菜单列表中 always 该选项永远直接显示在标题栏上 withText 让图标和文字同时显示 --&gt; &lt;item android:id=&quot;@+id/item1&quot; android:title=&quot;菜单项一&quot; android:orderInCategory=&quot;3000&quot; android:showAsAction=&quot;always|withText&quot; android:icon=&quot;@drawable/ic_launcher&quot;/&gt; &lt;item android:id=&quot;@+id/item2&quot; android:title=&quot;菜单项二&quot; android:orderInCategory=&quot;10&quot; android:showAsAction=&quot;ifRoom&quot; android:icon=&quot;@drawable/ic_launcher&quot;/&gt; &lt;item android:id=&quot;@+id/item3&quot; android:orderInCategory=&quot;20&quot; android:title=&quot;菜单项三&quot; android:icon=&quot;@drawable/ic_launcher&quot;/&gt;&lt;/menu&gt; MainActivity中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; /* * 重写onCreateOptionsMenu方法，在此方法中加载xml文件参数：代表要显示的菜单对象 * * 返回值：true 显示菜单， false 不显示菜单 */ @Override public boolean onCreateOptionsMenu(Menu menu)&#123; // TODOAuto-generated method stub /* * 将my.xml文件中的所有item菜单选项添加到参数二指定的menu对象中显示 */ getMenuInflater().inflate(R.menu.my_menu, menu); //通过代码添加菜单选项 /* * 1. 该菜单选项所在组的groupId * 2. 该菜单的唯一标识，id属性的值 * 3. 控制排列顺序，作用等同于orderInCategory属性 * 4：选项上要显示的文字标题 * */ menu.add(0, 1, 20, &quot;代码添加menu&quot;); return true; &#125; //重写此方法，获取菜单项的点击事件，参数代表被点击的菜单选项 @Override public boolean onOptionsItemSelected(MenuItemitem) &#123; // TODOAuto-generated method stub Toast.makeText(this,item.getTitle()+String.valueOf(item.getItemId()), Toast.LENGTH_SHORT).show(); //区分被点击的item switch (item.getItemId())&#123; caseR.id.item1: break; caseR.id.item2: break; caseR.id.item3: break; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 上下文菜单使用 初始化上下文菜单：onCreateContextMenu(ContextMenu menu, View v,ContextMenuInfo menuInfo) 为指定控件注册上下文菜单：registerForContextMenu(Viewview) 为菜单项设置监听器：onContextItemSelected(MenuItemitem) 处理 通过menu文件夹中的xml文件定义菜单列表中要显示的内容。 重写onCreateContextMenu方法，在该方法中通过。 重写onContextItemSelected方法获取菜单选项被点击的监听事件。 在页面的onCreate方法中通过registerForContextMenu方法的参数指定长按哪个控件对象显示菜单。 注意当registerForContextMenu方法中传递的是一个listview对象时，ContextMenu是针对列表中每个item进行设置。 在onContextItemSelected方法中可以通过以下方式获取别长按的item在listview中对应的position位置。 123AdapterContextMenuInfo aci = (AdapterContextMenuInfo) item.getMenuInfo();//通过菜单信息封装对象获取被点击的item的位置int position = aci.position; XML示例代码 123456789101112&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/list_item1&quot; android:title=&quot;复制&quot;/&gt; &lt;item android:id=&quot;@+id/list_item2&quot; android:title=&quot;删除&quot;/&gt; &lt;item android:id=&quot;@+id/list_item3&quot; android:title=&quot;重命名&quot;/&gt;&lt;/menu&gt; 浮动菜单使用函数创建浮动菜单对象：PopupMenu popupMenu = newPopupMenu(this, btn_show_popupmenu); 参数1：上下文环境。 参数2：需要绑定浮动菜单的控件id。 将菜单文件加载到内存中：getMenuInflater().inflate(R.menu.popup_menu,popupMenu.getMenu()); 为菜单项设置监听器：popupMenu.setOnMenuItemClickListener(OnMenuItemClickListener); 显示菜单：popupMenu.show(); 使用方式1.获取控件对象，设置任意监听，例如设置tv的点击事件： 1PopupMenu pm = newPopupMenu(PopupMenuActivity.this,tv); 2.向popupmenu对象中添加要显示的菜单选项： 1pm.inflate(R.menu.popup_menu); 3.通过show方法显示popupmenu对象： 1pm.show(); 浮动窗口PopupWindow这个其实就是Auto.js里面的悬浮窗。 构造方法： 12345678910111213141516 PopupWindow(View contentView, intwidth, int height) 参数1：contentView，浮动窗口中显示的内容 参数2：width，浮动窗口的宽度 参数3：height，浮动窗口的高度显示浮动窗口：showAsDropDown(Viewanchor, int xoff, int yoff) 参数1：anchor，浮动窗口出现在指定控件的下方 参数2：xoff，在X轴上的偏移量 参数3：yoff，在Y轴上的偏移量隐藏浮动窗口：dismiss() 显示带列表的浮动窗口： 123456789创建ListView对象 setAdapter(ListAdapter)：设置列表适配器，用于填充列表数据 setOnItemClickListener(OnItemClickListener)：设置列表项的监听事件setFocusable(true)：使浮动窗口可以获取焦点setBackgroundDrawable(newColorDrawable())：为解决焦点问题，这行代码必须执行 参考链接1]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Menu</tag>
        <tag>浮动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中的vector与set]]></title>
    <url>%2F2019%2F03%2F29%2Fc-%E4%B8%AD%E7%9A%84vector%E4%B8%8Eset%2F</url>
    <content type="text"><![CDATA[目录： C合法标识符 vector 简介 声明和初始化 输入访问 基本操作 二维 析构函数 c.~vector () 成员函数 c.assign(a，b) c.at(idx) c.back() c.begin() c.capacity() c.clear() c.empty() c.end() c.erase(pos) c.front() get_allocator c.insert(pos,elem) c.insert(pos,n,elem) c.insert(pos,beg,end) c.max_size() c.pop_back() c.push_back(elem) c.rbegin() c.rend() c.resize(num) c.reserve() c.size() c1.swap(c2)、swap(c1,c2) operator[] Set 特性 成员函数 C合法标识符C语言的标识符是字母或下划线(‘‘)开头的，字母、下划线(‘‘)和数字的字符串。 判断合法标识符的时候需要注意一下，很多时候需要用gets输入而不是scanf来输入，因为有可能输入的字符串含有空格。 vector简介向量 vector 是一种对象实体, 能够容纳许多其他类型相同的元素, 因此又被称为容器。 vector的优势就是在于可以随时调整自己的容量大小以便容纳数据。 使用的时候要加上头文件 1#include&lt;vector&gt; 声明和初始化12345678vector&lt;int&gt; a ; //声明一个int型向量a vector&lt;int&gt; a(10) ; //声明一个初始大小为10的向量 vector&lt;int&gt; a(10, 1) ; //声明一个初始大小为10且初始值都为1的向量 vector&lt;int&gt; b(a) ; //声明并用向量a初始化向量b vector&lt;int&gt; b(a.begin(), a.begin()+3) ; //将a向量中从第0个到第2个(共3个)作为向量b的初始值 int n[] = &#123;1, 2, 3, 4, 5&#125; ; vector&lt;int&gt; a(n, n+5) ; //将数组n的前5个元素作为向量a的初值 vector&lt;int&gt; a(&amp;n[1], &amp;n[4]) ; //将n[1] - n[4]范围内的元素作为向量a的初值 输入访问可以用普通的cin与cout进行输入与输出。 输出的时候还可以使用迭代器进行输出控制。 基本操作12345678a.size()获取元素个数a.empty()判断是否为空a.clear()清空元素a.insert(a.begin(), 1000)将1000插入到向量a的起始位置前 a.insert(a.begin(), 3, 1000)将1000分别插入到向量元素位置的0-2处(共3个元素)b.erase(b.begin())将起始位置的元素删除 b.erase(b.begin(), b.begin()+3)将(b.begin(), b.begin()+3)之间的元素删除a.swap(b)将向量a，b交换 二维其它操作与一维操作差不多。 1vector&lt; vector&lt;int&gt; &gt; b(10, vector&lt;int&gt;(5)); //创建一个10*5的int型二维向量 析构函数c.~vector ()销毁所有数据，释放内存。 成员函数c.assign(a，b)将a到b区间（前闭区间后开区间）中的数据赋值给c。 c.at(idx)传回idx所指向的数据，如果越界的话就抛出越界异常。 c.back()传回最后一个数据并且不检查是否存在这个数据。 c.begin()传回迭代器里面的第一个数据地址。 c.capacity()返回容器中的数据个数。 c.clear()清除容器中的所有数据。 c.empty()判断是否容器为空。 c.end()指向迭代器末端元素的下一个，也就是指向一个不存在的元素。 c.erase(pos)删除pos位置的数据，然后返回下一个数据的位置。 c.front()传回第一个数据。 get_allocator使用构造函数返回一个拷贝。 c.insert(pos,elem)在pos位置插入一个elem拷贝，传回新数据位置。 c.insert(pos,n,elem)在pos位置插入n个elem数据。无返回值。 c.insert(pos,beg,end)在pos位置插入在[beg,end)区间的数据。无返回值。 c.max_size()返回容器中最大数据的数量。 c.pop_back()删除最后一个数据。 c.push_back(elem)在尾部加入一个数据。 c.rbegin()传回一个逆向队列的第一个数据。 c.rend()传回一个逆向队列的最后一个数据的下一个位置。 c.resize(num)重新指定队列的长度。 c.reserve()保留适当的容量。 c.size()返回容器中实际数据的个数。 c1.swap(c2)、swap(c1,c2)将c1和c2元素互换。同上操作。 operator[]返回容器中指定位置的一个引用。 Setset（）是一种包含已排序对象的关联容器。 set集合容器实现了红黑树（Red-Black Tree）的平衡二叉检索树的数据结构，在插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，它不会插入相同键值的元素，而采取忽略处理。 平衡二叉树的检索使用中序遍历算法，检索效率高于vector、deque和list等容器。 对于set容器中的键值，不可直接去修改！应该先删除该键值，再插入新的键值。 特性1) 不能直接改变元素值，因为那样会打乱原本正确的顺序，要改变元素值必须先删除旧元素，则插入新元素。 2) 不提供直接存取元素的任何操作函数，只能通过迭代器进行间接存取，而且从迭代器角度来看，元素值是常数。 3) 元素比较动作只能用于型别相同的容器(即元素和排序准则必须相同)。 成员函数 begin()–返回指向第一个元素的迭代器。 clear()–清除所有元素。 count()–返回某个值元素的个数。 empty()–如果集合为空，返回true。 end()–返回指向最后一个元素的迭代器。 equal_range()–返回集合中与给定值相等的上下限的两个迭代器。 erase()–删除集合中的元素。 find()–返回一个指向被查找到元素的迭代器。 get_allocator()–返回集合的分配器。 insert()–在集合中插入元素。 lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器。 key_comp()–返回一个用于元素间值比较的函数。 max_size()–返回集合能容纳的元素的最大限值。 rbegin()–返回指向集合中最后一个元素的反向迭代器。 rend()–返回指向集合中第一个元素的反向迭代器。 size()–集合中元素的数目。 swap()–交换两个集合变量。 upper_bound()–返回大于某个值元素的迭代器。 value_comp()–返回一个用于比较元素间的值的函数。 set参考链接]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>合法标识符</tag>
        <tag>vector</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素性测试]]></title>
    <url>%2F2019%2F03%2F28%2F%E7%B4%A0%E6%80%A7%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[目录： 素性测试 随机算法 Fermat primality test Miller–Rabin primality test Solovay–Strassen primality test 确定型启发式算法 AKS primality test Baillie–PSW primality test 试除法 Lucas primality test Lucas–Lehmer primality test 素性测试所谓的素性测试就是判定一个整数是否为素数的方法。 素性测试算法分为确定型启发式算法以及随机算法。 随机算法Fermat primality test费马素性检验是一种素数判定法则，利用随机化算法判断一个数是合数还是可能是素数。 Miller–Rabin primality test米勒-拉宾素性检验是一种素数判定法则，利用随机化算法判断一个数是合数还是可能是素数。 Solovay–Strassen primality test 确定型启发式算法AKS primality testAKS素性测试（又被称为 Agrawal–Kayal–Saxena素性测试 和 Cyclotomic AKS test）是一个决定型素性测试算法 ，这个算法可以在多项式时间之内，决定一个给定整数是素数或者合数。 Baillie–PSW primality test维基百科参考链接 试除法Lucas primality test Lucas–Lehmer primality test维基百科参考链接]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>素性测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter-Widget框架（一）]]></title>
    <url>%2F2019%2F03%2F27%2FFlutter-Widget%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： Widget框架 简单实例 基础Widget 常用基础widget Text Row，Column Stack Container 手势 StatefulWidget 响应widget生命周期事件 Key 备注： Widget框架参考地址：Flutter中文网。 简单实例123456789101112import &apos;package:flutter/material.dart&apos;;void main() &#123; runApp( new Center( child: new Text( &apos;Hello, world!&apos;, textDirection: TextDirection.ltr, ), ), );&#125; 在编写应用程序时，通常会创建新的widget，这些widget是无状态的StatelessWidget或者是有状态的StatefulWidget， 具体的选择取决于您的widget是否需要管理一些状态。widget的主要工作是实现一个build函数，用以构建自身。 基础Widget常用基础widgetText创建一个带格式的文本。 Row，Column水平与垂直方向上面灵活的布局。 Stack与线性布局类似，允许Widget堆叠。同时可以使用Positioned来定位堆叠的Widget相对于Stack的上下左右四条边的位置。 Container创建矩形视觉元素。 手势手势的交互首先就是要检测输入的手势。 12345678910111213141516171819202122class MyButton extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new GestureDetector( onTap: () &#123; print(&apos;MyButton was tapped!&apos;); &#125;, child: new Container( height: 36.0, padding: const EdgeInsets.all(8.0), margin: const EdgeInsets.symmetric(horizontal: 8.0), decoration: new BoxDecoration( borderRadius: new BorderRadius.circular(5.0), color: Colors.lightGreen[500], ), child: new Center( child: new Text(&apos;Engage&apos;), ), ), ); &#125;&#125; GestureDetector widget并不具有显示效果，而是检测由用户做出的手势。 许多widget都会使用一个GestureDetector为其他widget提供可选的回调。 StatefulWidgetStatefulWidgets是特殊的widget，它知道如何生成State对象，然后用它来保持状态。 在Flutter中，Stateful与State是单独的对象，他们的对象具有不同的生命周期： Widget是临时对象，用于构建当前状态下的应用程序，而State对象在多次调用build()之间保持不变，允许它们记住信息(状态)。 在Flutter中，事件流是“向上”传递的，而状态流是“向下”传递的，重定向这一流程的共同父元素是State。 响应widget生命周期事件在StatefulWidget调用createState之后，框架将新的状态对象插入树中，然后调用状态对象的initState。 子类化State可以重写initState，以完成仅需要执行一次的工作。 当一个状态对象不再需要时，框架调用状态对象的dispose。 可以覆盖该dispose方法来执行清理工作。 Key可以使用key来控制框架将在widget重建时与哪些其他widget匹配。默认情况下，框架根据它们的runtimeType和它们的显示顺序来匹配。 使用key时，框架要求两个widget具有相同的key和runtimeType。 全局的key可以用来标识子Widget。同时在整个Widget结构中必须是全局唯一的，所以可以用全局Key来检索与WIdget关联的状态。 备注：Flutter中文网Widget目录]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>学习笔记</tag>
        <tag>Widget</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++常用函数]]></title>
    <url>%2F2019%2F03%2F26%2FC-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[目录： 前言 C++ cstdlib cctype algorithm cmath cstdlib C 前言目前在备战CCF，算法题刷了蛮多的了，这次就记录一下，常用的C++/C的函数。（只记录常用且实用的，不是大全，再次强调） C++cstdlib12345678910111213141516171819202122begin 得到指向字符串开头的Iterator（迭代器）end 得到指向字符串结尾的Iteratorrbegin 得到指向反向字符串开头的Iteratorrend 得到指向反向字符串结尾的Iteratorsize 得到字符串的大小length() 和size函数功能相同max_size 字符串可能的最大大小empty 判断是否为空operator[] 取第几个元素，相当于数组c_str 取得C风格的const char* 字符串swap 交换函数insert 插入字符append 追加字符push_back 追加字符erase 删除字符串clear 清空字符容器中所有内容replace 替代copy 字符串到空间find 查找,返回基于0的索引号substr(n1,len) 得到字符串从n1开始的长度为len的子串compare 比较字符串(支持所有的关系运算符)getline 从输入流中读入一行 cctype12345678910111213141516171819using ::isalpha; //是否字母using ::isdigit; //是否是数字using ::isgraph; //是否字母、数字或标点using ::islower; //是否小写using ::ispunct; //是否标点using ::isspace; //是否空格using ::isupper; //是否大写using ::isxdigit; //是否十六进制数字using ::tolower; //转为小写using ::toupper; //转为大写 algorithm 循环 对序列中的每个元素执行某项操作 for_each() 查找 在序列中找出某个值的第一次出现的位置 find(a,a+size,n) 返回b,当b=a+size即没找到，a为指针 在序列中找出符合某谓词的第一个元素 find_if() 在序列中找出一子序列的最后一次出现的位置 find_end() 在序列中找出第一次出现指定值集中之值位置 find_first_of() 在序列中找出相邻的一对值 adjacent_find() 计数 在序列中统计某个值出现的次数 count() 在序列中统计与某谓词匹配的次数 count_if() 比较 找出两个序列相异的第一个元素 mismatch() 两个序列中的对应元素都相同时为真 equal(a,a+n,b,cmp) 在序列中找到等于某值的连续n次出现的位置 equal_range(a,a+n,x) 搜索 在序列中找出一子序列的第一次出现的位置 search() 在序列中找出一值的连续n次出现的位置 search_n() 复制 从序列的第一个元素起进行复制 copy() 从序列的最后一个元素起进行复制 copy_backward() 交换 交换两个元素 swap() 交换指定范围的元素 swap_ranges() 交换由迭代器所指的两个元素 iter_swap() 变换 将某操作应用于指定范围的每个元素 transform() 替换 用一个给定值替换一些值 replace() 替换满足谓词的一些元素 replace_if() 复制序列时用一给定值替换元素 replace_copy() 复制序列时替换满足谓词的元素 replace_copy_if() 填充 用一给定值取代所有元素 fill() 用一给定值取代前n个元素 fill_n() 生成 用一操作的结果取代所有元素 generate() 用一操作的结果取代前n个元素 generate_n() 删除 删除具有给定值的元素 remove() 删除满足谓词的元素 remove_if() 复制序列时删除具有给定值的元素 remove_copy() 复制序列时删除满足谓词的元素 remove_copy_if() 唯一 删除相邻的重复元素 unique() 复制序列时删除相邻的重复元素 unique_copy() 反转 反转元素的次序 reverse(a,a+n) 复制序列时反转元素的次序 reverse_copy() 环移 循环移动元素 rotate(a,a+m,a+n)以m位置为界交换前后序列 复制序列时循环移动元素 rotate_copy() 随机 采用均匀分布来随机移动元素 random_shuffle() 划分 将满足某谓词的元素都放到前面 partition() 将满足某谓词的元素都放到前面并维持原顺序 stable_partition() 排序 以很好的平均效率排序 sort(a,a+20,cmp)bool cmp( int a, int b ){ return a&gt;b; }在容器中或string用begin（） 排序，并维持相同元素的原有顺序 stable_sort() 将序列的前一部分排好序 partial_sort() 复制的同时将序列的前一部分排好序 partial_sort_copy() 第n个元素 将第n各元素放到它的正确位置 nth_element() 二分检索 找到大于等于某值的第一次出现 lower_bound() 找到大于某值的第一次出现 upper_bound() 找到（在不破坏顺序的前提下）可插入给定值的最大范围 equal_range() 在有序序列中确定给定元素是否存在 binary_search() 归并 归并两个有序序列 merge() 归并两个接续的有序序列 inplace_merge() 有序结构上的集合操作 一序列为另一序列的子序列时为真 includes() 构造两个集合的有序并集 set_union() 构造两个集合的有序交集 set_intersection() 构造两个集合的有序差集 set_difference() 构造两个集合的有序对称差集（并-交） set_symmetric_difference() 堆操作 向堆中加入元素 push_heap() 从堆中弹出元素 pop_heap() 从序列构造堆 make_heap() 给堆排序 sort_heap() 最大和最小 两个值中较小的 min() 两个值中较大的 max() 序列中的最小元素 min_element(a,a+n) 序列中的最大元素 max_element() 词典比较 两个序列按字典序的第一个在前 lexicographical_compare() 排列生成器 按字典序的下一个排列 next_permutation() 按字典序的前一个排列 prev_permutation() cmath123456789using ::abs; //绝对值using ::exp; //指数值using ::fabs; //绝对值using ::fmod; //求余using ::sqrt; //开方 cstdlib1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253double atof(const char *str);把字符串str转换成double类型。等价于：strtod(str, (char**)NULL)。 int atoi(const char *str);把字符串str转换成int类型。等价于：(int)strtol(str, (char**)NULL, 10)。int rand(void);产生一个0到RAND_MAX之间的伪随机整数。RAND_MAX值至少为32767。void srand(unsigned int seed);设置新的伪随机数序列的种子为seed。种子的初值为1。void *malloc(size_t size);为大小为size的对象分配足够的内存，并返回指向所分配区域的第一个字节的指针；如果内存不足以满足要求，则返回NULL。不对分配的内存区域进行初始化。void free(void *ptr);释放ptr指向的内存空间，若ptr为NULL，则什么也不做。ptr必须指向先前用动态分配函数malloc、realloc或calloc分配的空间。void exit(int status);使程序正常终止。atexit函数以与注册相反的顺序被调用，所有打开的文件被刷新，所有打开的流被关闭。status的值如何被返回依具体的实现而定，但用0表示正常终止，也可用值EXIT_SUCCESS和EXIT_FAILURE。void qsort(void *base, size_t n, size_t size,int (*compare)(const void *, const void *));对由n个大小为size的对象构成的数组base进行升序排序。比较函数compare的形式如下：int func_name(const void *arg1, const voie *arg2);其返回值必须如下所示：arg1 &lt; arg2，返回值&lt;0；arg1 == arg2，返回值==0；arg1 &gt; arg2，返回值&gt;0。 C未完待续（貌似也差不多的说…）]]></content>
      <categories>
        <category>后端</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>常用函数</tag>
        <tag>用法</tag>
        <tag>备战CCF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10-64位Debug安装]]></title>
    <url>%2F2019%2F03%2F25%2FWin10-64%E4%BD%8DDebug%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[目录： 前言 正文 安装 配置 测试 Debug Debug常用功能 前言由于本学期开设了汇编实验这门课，相对应的，也有了汇编实验的实验课，由于需要用到debug，再加上win10需要配置，不像win7可以直接使用，这里就写一篇博客记录一下配置过程。 其实win10上使用debug一般有两种方法，一种是在电脑上面装上虚拟机，用win7直接使用debug，第二种就是今天介绍的用DOSBox来解决。 正文DOSBox是一种模拟器软件，主要是在IBM PC兼容机下，模拟旧时的操作系统：MS-DOS，支持许多IBM PC兼容的显卡和声卡，为本地的DOS程序提供执行环境，使这些程序可以正常运行于大多数现代计算机上的不同操作系统。DOSBox特别是为运行早期的计算机游戏所设计，主要以C++编写，是以GNU通用公共许可证许可发布的自由软件。 上面是对DOSBox的简单介绍，摘自维基百科，下面开始介绍具体流程。 首先，众所周知，win10上面是不支持直接使用debug的，如果一旦点击debug.exe的话，会报错。 安装关于debug与DOSBox的下载的话，都可以直接在搜索引擎搜索下载，这里要注意一下DOSBox的下载： DOSBox官网点击进去之后，会看到这样的画面。 然后就是点击这个，然后进去下载就可以。 下载完DOSBox之后会发现它是一个安装器，自己选择安装到哪里，但是一定要知道位置。至于debug.exe的安装位置的话，我的建议是，在C盘下面直接建一个MYDEBUG的文件夹，然后把相关文件放进去。（我这里的DEBUG是网盘里面找到的，实际上搜索下载的貌似只要一个debug.exe就可以） 配置安装完成之后，找到DOSBox安装目录下的DOSBox 0.74 Options.bat文件，然后双击: 然后在末尾添加如下代码： 123MOUNT C C:\MYDEBUGC:debug 这样配置的目的很单纯，只是让每次编译的时候不用准备前面这些条件，就可以直接使用，如果每次都要配置，太麻烦。 测试安装配置完之后自然要测试一下能不能用，先介绍一下debug，如下： DebugDebug是DOS、Windows都提供的实模式(8086方式)程序的调试工具。 使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级别跟踪程序的运行。 Debug常用功能1234567891011用Debug的R命令查看、改变CPU寄存器的内容; 用Debug的D命令查看内存中的内容; 用Debug的E命令改写内存中的内容; 用Debug的U命令将内存中的机器指令翻译成汇编指令; 用Debug的T命令执行一条机器指令; 用Debug的A命令以汇编指令的格式在内存中写入一条机器指令; 这里用命令测试一下是否可以使用： 绿色部分是之前配置的部分，红色箭头指向的就是命令，实测没问题可以使用，这样就可以开始愉快的汇编编程了。。。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Win10</tag>
        <tag>Debug</tag>
        <tag>DOSBox</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归递推与试除法]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%80%92%E5%BD%92%E9%80%92%E6%8E%A8%E4%B8%8E%E8%AF%95%E9%99%A4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录： 递推 递归 1.联系 2.区别 试除法（求解素数） 递推递推是一种经常被使用的简单算法，定义是一种用若干步可重复的简单运算来描述复杂问题的方法。 递推的特点在于，每一项都和他前面的若干项由一定的关联，这种关联一般可以通过递推关系式来表示，可以通过其前面若干项得出某项的数据。 对于递推问题的求解一般从初始的一个或若干个数据项出发，通过递推关系式逐步推进，从而得出想要的结果，这种求解问题的方法叫递推法。其中，初始的若干数据项称为边界。 简单实例如下： 喜欢西游记的同学肯定都知道悟空偷吃蟠桃的故事，你们一定都觉得这猴子太闹腾了，其实你们是有所不知：悟空是在研究一个数学问题！ 什么问题？他研究的问题是蟠桃一共有多少个！ 不过，到最后，他还是没能解决这个难题，呵呵^-^ 当时的情况是这样的： 第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？ Input 输入数据有多组，每组占一行，包含一个正整数n（1&lt;n&lt;30），表示只剩下一个桃子的时候是在第n天发生的。 Output 对于每组输入数据，输出第一天开始吃的时候桃子的总数，每个测试实例占一行。 Sample Input 2 4 Sample Output 4 22 分析： 这其实就是一个递推问题，需要注意的是，一般而言递推的计算效率要大于递归。由题意得f(n) = 2 * ( f(n-1) + 1 )，另外f(1)=1。这就可以求解出相应的答案了，由于题目太简单，这里只写思路。 代码： 12345678910111213141516171819202122#include &lt;stdio.h&gt; int peach(int n) &#123;//这里就是递推 if(n == 1) return 1; else &#123; long res = 1L; while(--n) res = 2 * (res + 1); return res; &#125;&#125; int main(void)&#123; int n; while(scanf(&quot;%d&quot;, &amp;n) != EOF) printf(&quot;%d\n&quot;, peach(n)); return 0;&#125; 递归上面说到，一般来说，递推的计算效率是高于递归的，那么递归与递推有什么区别和联系呢？ 1.联系递归和递推有一定的相似性。 这两个问题都可以描述为以下形式： f(n)=g(f(n-1)，…，f(0)) 这是二者的共同特点。 2.区别1）递归表现出来的是自己调用自己，递推则没有这样的形式。 2）递归是从问题的最终目标出发，将问题简单化，这就是逆向的求解。 递推则是从简单问题出发，正向的解决问题。 3）递归中，n是已知的。递推则可以是在计算中知道，不需要提前知道。 4）一般来说，递推的效率是大于递归的。 试除法（求解素数）一般来说，求解素数的话，要用到两种方式，一个是试除法一个是筛选法，这篇博客里面就写到了Eratosthenes筛选法，这里的话就介绍一下另外一种方法，试除法。试除法其实一般有很多种，这里只介绍一点。大致知道算法就行，现场写也可以。 123456789101112131415161718# include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdbool.h&gt;/*质数：一个自然数，如果只有1和它本身两个约数，这个数叫做质数（也称素数）．对于一个整数n，只需用小于等于√n所有素数去除，所以本算法的时间复杂度为O(√)的。*/bool IsPrime(int n,int prime[],int length)&#123; int i; for(i = 2; (long long)i*i &lt;= n&amp;&amp;prime[i]; i++) &#123; if(n %i == 0) return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>递推</tag>
        <tag>试除法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-略知一二]]></title>
    <url>%2F2019%2F03%2F23%2Fjava%E5%9F%BA%E7%A1%80-%E7%95%A5%E7%9F%A5%E4%B8%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[目录： Collection Set HashSet LinkedHashSet SortedSet TreeSet List ArrayList 构造方法 LinkedList 构造方法 Map 特性 方法 HashMap 常用操作 Iterator Collection集合中只能放置对象的引用，不能放置原生数据类型。 常用方法： 1234567891011121314151617181920212223242526272829303132333435// 将所有元素从一个列表复制到另一个列表Collections.copy(new ArrayList(), new ArrayList());// 如果两个指定collection中没有相同的元素,则返回 trueCollections.disjoint(new ArrayList(), new ArrayList());// 使用指定元素替换指定列表中的所有元素Collections.fill(new ArrayList(), new Object());// 返回指定 collection 中等于指定对象的元素数Collections.frequency(new ArrayList(), new Object());// 返回指定源列表中第一次出现指定目标列表的起始位置,如果没有出现这样的列表,则返回 -1Collections.indexOfSubList(new ArrayList(), new ArrayList());// 根据元素的自然顺序，返回给定 collection 的最大元素Collections.max(new ArrayList());// //根据元素的自然顺序，返回给定 collection 的最大元素Collections.min(new ArrayList());// 使用另一个值替换列表中出现的所有某一指定值Collections.replaceAll(new ArrayList(), &quot;oldVal&quot;, &quot;newVal&quot;);// 反转指定列表中元素的顺序Collections.reverse(new ArrayList());// 返回一个比较器,它强行反转Collections.reverseOrder();// 返回一个比较器,它强行反转指定比较器的顺序Collections.reverseOrder(new Comparator() &#123; @Override public int compare(Object o1, Object o2) &#123; return 0; &#125;&#125;);// 使用默认随机源随机更改指定列表的序列Collections.shuffle(new ArrayList());// 根据元素的自然顺序对指定列表按升序进行排序Collections.sort(new ArrayList());// 根据元素的自然顺序对指定列表按降序进行排序Collections.sort(new ArrayList(), Collections.reverseOrder());// 在指定列表的指定位置处交换元素Collections.swap(new ArrayList(), 1, 2); Set实现类：HashSet,LinkedHashSet. 子接口：SortSet，TreeSet. 不包含重复元素，最多包含一个null，元素没有顺序。 HashSetHashSet不是Ordered也不是Sorted,存储对象引用时是按照哈希策略来实现的, HashSet中是否存在一个对象是通过equals()和hashCode()协同判断，不保证顺序。 构造方法 123public HashSet() public HashSet(int initialCapacity) public HashSet(Collection c) 1public HashSet(Collection c) HashSet底层是使用HashMap实现的HashSet的add()方法详解: 判断已经存储在集合中的对象hashCode值是否与增加对象的hashCode值一致。 如果不一致,直接加进去。 如果一致,再进行equals()比较，如果equals()返回true,对象已经存在不增加进去，如果equals()返回false,把对象增加进去。 LinkedHashSetLinkedHashSet是Ordered,采用双链表实现的，有固定顺序,也就是插入顺序。LinkedHashSet底层是使用LinkedHashMap实现的。 构造方法 123public LinkedHashSet() public LinkedHashSet(int initialCapacity) public LinkedHashSet(Collection c) SortedSet保证迭代器按照元素递增顺序遍历的集合,可以按照元素的自然顺序进行排序。 常用方法： 123456789101112Object first() 返回此有序集合中当前第一个(最小的)元素 Object last() 返回此有序集合中最后一个(最大的)元素 SortedSet headSet(Object toElement) 返回此有序集合的部分视图,其元素严格小于toElement SortedSet tailSet(Object fromElement) 返回此有序集合的部分视图,其元素大于或等于fromElement SortedSet subSet(Object fromElement,Object toElement) 返回此有序集合的部分视图,元素范围从fromElement(包括)到toElement(不包括) Comparator comparator() 返回与此有序集合关联的比较器,如果使用元素的自然顺序,则返回 null TreeSetTreeSet是SortedSet接口的实现,元素不论以什么元素插入,在遍历的时候,都会以天然顺序遍历。因为它是自带排序的，所以如果想要增加自定义类型就必须指定排序的规则。TreeSet底层是使用TreeMap实现的。 构造方法 12345public TreeSet()public TreeSet(SortedSet s) public TreeSet(int initialCapacity)public TreeSet(Comparator&lt;? super E&gt;)public TreeSet(Collection c) List具有列表的功能,元素顺序均是按添加的先后进行排列的,允许重复的元素,允许多个null元素。 常用方法 1234567891011121314151617181920212223242526272829303132333435363738394041List list = new ArrayList();// 向列表的尾部追加指定的元素list.add(&quot;lwc&quot;);// 在列表的指定位置插入指定元素list.add(1, &quot;nxj&quot;);// 追加指定 collection 中的所有元素到此列表的结尾list.addAll(new ArrayList());// 从列表中移除所有元素list.clear();// 如果列表包含指定的元素,则返回truelist.contains(&quot;nxj&quot;);// 如果列表包含指定 collection 的所有元素,则返回 truelist.containsAll(new ArrayList());// 比较指定的对象与列表是否相等list.equals(new ArrayList());// 返回列表中指定位置的元素list.get(0);// 返回列表的哈希码值list.hashCode();// 返回列表中首次出现指定元素的索引,如果列表不包含此元素,则返回 -1list.indexOf(&quot;lwc&quot;);// 返回列表中最后出现指定元素的索引,如果列表不包含此元素,则返回 -1list.lastIndexOf(&quot;lwc&quot;);// 如果列表不包含元素,则返回 truelist.isEmpty();// 移除列表中指定位置的元素list.remove(0);// 移除列表中出现的首个指定元素list.remove(&quot;lwc&quot;);// 从列表中移除指定 collection 中包含的所有元素list.removeAll(new ArrayList());// 用指定元素替换列表中指定位置的元素list.set(0, &quot;lp&quot;);// 返回列表中的元素数list.size();// 返回列表中指定的fromIndex(包括)和toIndex(不包括)之间的部分视图list.subList(1, 2);// 返回以正确顺序包含列表中的所有元素的数组list.toArray();// 返回以正确顺序包含列表中所有元素的数组list.toArray(new String[] &#123; &quot;a&quot;, &quot;b&quot; &#125;); ArrayList构造方法123public ArrayList()public ArrayList(int initialCapacity)public ArrayList(Collection c) ArrayList依赖于数组实现的,初始长度为10的Object[],并且可随需要而增加的动态数组。 当元素超过10,那么ArrayList底层会新生成一个数组,长度为原来的1.5倍+1,然后将原数组内容复制到新数组中,并且后续增加的内容会放到新数组中,当新数组无法容纳增加的元素,重复该过程即可。 LinkedListLinkedList功能与ArrayList,Vector相同,内部是依赖双链表实现的,因此有很好的插入和删除性能,但随机访问元素的性能很差。 构造方法12public LinkedList()public LinkedList(Collection c) LinkedList类中有一个Entry内部类,Entry内部类包含3个部分向前的引用,向后的引用,数据 1header.next = header.previous = header; MapMap接口中键和值一一映射. 可以通过键来获取值. 特性 给定一个键和一个值，你可以将该值存储在一个Map对象. 之后，你可以通过键来访问对应的值。 当访问的值不存在的时候，方法就会抛出一个NoSuchElementException异常。 当对象的类型和Map里元素类型不兼容的时候，就会抛出一个 ClassCastException异常。 当在不允许使用Null对象的Map中使用Null对象，会抛出一个NullPointerException 异常。 当尝试修改一个只读的Map时，会抛出一个UnsupportedOperationException异常。 方法 1 void clear( ) 从此映射中移除所有映射关系（可选操作）。 2 boolean containsKey(Object k) 如果此映射包含指定键的映射关系，则返回 true。 3 boolean containsValue(Object v) 如果此映射将一个或多个键映射到指定值，则返回 true。 4 Set entrySet( ) 返回此映射中包含的映射关系的 Set 视图。 5 boolean equals(Object obj) 比较指定的对象与此映射是否相等。 6 Object get(Object k) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。 7 int hashCode( ) 返回此映射的哈希码值。 8 boolean isEmpty( ) 如果此映射未包含键-值映射关系，则返回 true。 9 Set keySet( ) 返回此映射中包含的键的 Set 视图。 10 Object put(Object k, Object v) 将指定的值与此映射中的指定键关联（可选操作）。 11 void putAll(Map m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。 12 Object remove(Object k) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。 13 int size( ) 返回此映射中的键-值映射关系数。 14 Collection values( ) 返回此映射中包含的值的 Collection 视图。 HashMap常用操作1.第一步就是给HashMap里面put一些键值对。 123456789101112HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put(5, 2); hashMap.put(9, 2); hashMap.put(8, 1); hashMap.put(7, 3); hashMap.put(16, 1); hashMap.put(10, 2); hashMap.put(6, 2); //下面两个键值对是没有存的，因为key存过的不会重复存储，只会覆盖之前的vlue hashMap.put(5, 2); hashMap.put(5, 3); 2.containsKey(Object key)方法，返回值为boolean，用于判断当前HashMap中是否包含key对应的key-value。 3.containsValue(Object value)方法，返回值为boolean，用于判断当前HashMap中是否包含value对应的key-value。 4.遍历HashMap的两种方式： 1）利用haspmap.entrySet().iterator()：利用迭代器，从Entry中取出键、取出值，推荐使用这种方式进行遍历，效率较高： 12345678Iterator&lt;Entry&lt;Integer, Integer&gt;&gt; iterator = hashMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Entry&lt;Integer, Integer&gt; entry = iterator.next(); Integer key = entry.getKey(); Integer value = entry.getValue(); System.out.print(key + &quot;---&gt;&quot; + value); System.out.println(); &#125; 2）利用hashmap.keySet().iterator()：利用键的迭代器，每次取出一个键，再根据键，从HashMap中取出值，这种方式的效率不高，不推荐使用： 1234567Iterator&lt;Integer&gt; iterator2 = hashMap.keySet().iterator(); while (iterator2.hasNext()) &#123; Integer key = iterator2.next(); Integer value = hashMap.get(key); System.out.print(key + &quot;---&quot; + value); System.out.println(); &#125; 参考链接 Iterator 在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。迭代器与枚举有两点不同： 1231、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。2、方法名称得到了改进。 接口定义： 12345public interface Iterator &#123; boolean hasNext(); Object next(); void remove();&#125; Object next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型。 boolean hasNext()：判断容器内是否还有可供访问的元素。 void remove()：删除迭代器刚越过的元素。 未完待续~~~]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>略知一二</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-略有小成]]></title>
    <url>%2F2019%2F03%2F22%2Fjava%E5%9F%BA%E7%A1%80-%E7%95%A5%E6%9C%89%E5%B0%8F%E6%88%90%2F</url>
    <content type="text"><![CDATA[目录： 基本数据类型 种类 占用空间 类型转换 包装类 类型转换方法 引用问题 System类 简介 成员变量 成员方法 RunTime类 Date与DateFormat 构造函数 方法 日期比较 SimpleDateFormat格式化日期 格式化编码 printf格式化日期 解析字符串 sleep Calendar类与GregorianCalendar类 基本数据类型种类 讲到基本类型的话，不可避免的就是字面量值，其实它的意思就是表面上的值。 byte、short、int、long类型变量都可以赋予整型字面量值，譬如byte a = 10、short b = 0x45都是合法的赋值操作。Java编译器在编译是会检查字面量值所表示的数字大小是否处于变量类型的合法范围内，如果不在，则无法通过编译。如果多种数值类型的数据进行数学运算时，计算结果的类型是其中这些数值中最高等级或者其更高等级类型。 占用空间byte（字节）用无符号的8位表示，它的取值范围是[-2^7, 2^7-1]。它是最小的整型类型，默认值是0。 short（短整型）用有符号的16位表示，它的取值范围是[-2^15, 2^15-1]。默认值是0。 int（整型）用有符号的32位表示，它的取值范围是[-2^31, 2^31-1]，计算机中用存放的是整型数值的二进制补码。默认值是0。 long（长整型）用有符号的64位表示，它的取值范围是[-2^63, 2^63-1]。它的字面量表示以l或者L结束，如 long a = 45454L。默认值是0L。 float（单精度浮点型）用32位表示，float类型字面量值通常以f或者F结束。由于整型可以自动转换为float类型，所以，也可以将整型字面量值直接赋予float类型变量。默认值是0F。 double（双精度浮点型）用64位表示，遵循IEEE 754规范。它能表示比float更高精度的数值。double是Java基本类型中能达到的最高精度，如果还不能满足要求，可以使用Java中的BigDecimal类。默认值是0.0。 char（字符）用无符号的16位表示，它的取值范围是[0, 2^16-1]。Java中使用Unicode字符集来表示字符，Unicode将人类语言的所有已知字符映射成16位数字，所以Java中的char是16位的。默认值是\u00000。 boolean（ 布尔型）只要true和false两个字面量值，可用于逻辑判断。boolean只能表示1位的信息量，但是它的大小并没有精确地定义。 类型转换在JAVA里面除了boolean类型之外，其他7中类型相互之间可以进行转换。转换分为自动转换和强制转换。对于自动转换（隐式），无需任何操作，而强制类型转换需要显式转换，即使用转换操作符（type）。 占用空间大小进行排序：byte &lt;（short=char）&lt; int &lt; long &lt; float &lt; double 类型转换的总则是：小可直接转大、大转小会失去精度。小转大是Java帮我们自动进行转换的，与正常的赋值操作完全一样；大转小需要进行强制转换操作，其语法是target-type var =（target-type） value。 特别注意：大转小有可能在某些情况下产生不可预估的问题。 包装类Java里面的每一种基本类型都会对应一个唯一的包装类，基本类型与其包装类都可以通过包装类中的静态或者成员方法进行转换。所有的包装类都是final修饰的，也就是它们都是无法被继承和重写的。 基础类型和包装类型都可以通过赋值语法赋值给对立的变量类型。 类型转换方法 引用问题在Java中，“==”符号判断的内存地址所对应的值的相等性，具体来说，基本类型判断值是否相等，引用类型判断其指向的地址是否相等。 举个例子： 1234567Integer a1 = 1;Integer a2 = 1;System.out.println(a1 == a2); // trueInteger b1 = 222;Integer b2 = 222;System.out.println(b1 == b2); // false 这是为什么呢？ 如果打开Integer类中的valueOf()方法会发现： 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) // 判断实参是否在可缓存范围内，默认为[-128, 127] return IntegerCache.cache[i + (-IntegerCache.low)]; // 如果在，则取出初始化的Integer对象 return new Integer(i); // 如果不在，则创建一个新的Integer对象&#125; 由于1属于[-128, 127]集合范围内，所以valueOf()每次都会取出同一个Integer对象，故第一个“==”判断结果为true； 而222不属于[-128, 127]集合范围内，所以valueOf()每次都会创建一个新的Integer对象，由于两个新创建的对象的地址不一样，故第一个“==”判断结果为false。 参考链接 System类简介system类在java中的作用其实就是类似于系统的作用，它的内部包含了很多系统级别的属性以及控制方法。 成员变量主要就是包含了in（标准输入流，键盘输入），out（标准输出流，显示器）以及err（标准错误输出流）。 out与err的差别 System.out在JVM和操作系统都具有缓存功能，其实就是输出的数据不一定实时输出，有时候会积攒到一定数量才会输出；System.err会实时输出。 成员方法1.static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 该方法的作用是数组拷贝，src为被拷贝的数组，srcPos为src要拷贝的初始位置，dest为目的数组，目的数组dest放置拷贝数据的初始位置，length为从src拷贝到的数据长度。 2.static long currentTimeMillis() 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 3.static void exit(int status) 该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。 4.static void gc() 请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 5.static Properties getProperties() 获取系统的属性信息，并存储到Properties集合中。Properties集合中存储的都是String类型的键值对。 6.static String getProperty(String key) 获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示： 7.static String setProperty(String key, String value) 给系统设置一些属性信息，这些信息是全局的，其他程序都可以使用。 RunTime类Runtime类封装了运行时的环境。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。该类无法创建对象。 常用方法 static Runtime getRuntime() 返回一个Runtime实例。 Process exec(String command) 指定某个exe文件并返回该程序进程，参数command为本地exe文件路径。 long freeMemory() 返回Java虚拟机中的空闲内存量，以字节为单位 long maxMemory() 返回Java虚拟机试图使用的最大内存量 long totalMemory() 返回Java虚拟机中的内存总量 Date与DateFormatDate是Java中提供来封装当前的日期与时间的类。 构造函数12Date( );//使用当前日期和时间来初始化对象。Date(long millisec);//接收一个参数，该参数是从1970年1月1日起的毫秒数。 方法 日期比较 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。 使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。 SimpleDateFormat格式化日期SimpleDateFormat 允许用户选择任何自定义日期时间格式来运行。 123456789101112import java.util.*;import java.text.*; public class DateDemo &#123; public static void main(String args[]) &#123; Date dNow = new Date( ); /*这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。*/ SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;); System.out.println(&quot;当前时间为: &quot; + ft.format(dNow)); &#125;&#125; 格式化编码 字母 描述 示例 G 纪元标记 AD y 四位年份 2001 M 月份 July or 07 d 一个月的日期 10 h A.M./P.M. (1~12)格式小时 12 H 一天中的小时 (0~23) 22 m 分钟数 30 s 秒数 55 S 毫秒数 234 E 星期几 Tuesday D 一年中的日子 360 F 一个月中第几周的周几 2 (second Wed. in July) w 一年中第几周 40 W 一个月中第几周 1 a A.M./P.M. 标记 PM k 一天中的小时(1~24) 24 K A.M./P.M. (0~11)格式小时 10 z 时区 Eastern Standard Time ‘ 文字定界符 Delimiter “ 单引号 ` printf格式化日期printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。 转 换 符 说 明 示 例 c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007 F “年-月-日”格式 2007-10-27 D “月/日/年”格式 10/27/07 r “HH:MM:SS PM”格式（12时制） 02:25:51 下午 T “HH:MM:SS”格式（24时制） 14:28:16 R “HH:MM”格式（24时制） 14:28 解析字符串SimpleDateFormat 类的parse()方法来按照对应的格式化存储来解析字符串。 sleepsleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。 1Thread.sleep(1000); // 休眠1秒 Calendar类与GregorianCalendar类略…]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>略有小成</tag>
        <tag>基本数据类型</tag>
        <tag>包装类</tag>
        <tag>System类</tag>
        <tag>Runtime类</tag>
        <tag>Date类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分拆素数和]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%88%86%E6%8B%86%E7%B4%A0%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[目录： 题目内容 题目分析 Eratosthenes筛选法 试探法（回溯法） 代码详解 题目内容 原题链接 题目分析很明显，本题的要求是要求解分解的个数，主要思路就是利用Eratosthenes筛选法来求必要的素数，然后用试探法来求分解的个数。 原理：对于任何一个可以分解为两个素数之和的偶数，其中一个必然是小于或者等于1/2的。 Eratosthenes筛选法筛选法又称筛法，具体做法是：先把N个自然数按次序排列起来。1不是质数，也不是合数，要划去。第二个数2是质数留下来，而把2后面所有能被2整除的数都划去。2后面第一个没划去的数是3，把3留下，再把3后面所有能被3整除的数都划去。3后面第一个没划去的数是5，把5留下，再把5后面所有能被5整除的数都划去。这样一直做下去，就会把不超过N的全部合数都筛掉，留下的就是不超过N的全部质数。 （合数：一个正整数，除了1和它本身以外，还能被其他正整数整除，这个数就叫做合数。） （质数（prime number）又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。） 埃拉托斯特尼筛选法是最为知名的产生素数的筛选法，适用于产生最小的N个素数。 该方法的唯一缺点是使用的存储空间大，可以进一步改进。 另外，该算法也不适用于计算某个范围内的全部素数。 试探法（回溯法）先选择某一种可能的情况进行试探，在试探过程中，一旦发现此选择的假设是错误的，就退回一步重新选择，继续向前试探，如此反复进行，直到证明解或者无解。 代码详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cmath&gt;#define Max 10000using namespace std;//Eratosthenes筛选法void eratosthenesFunction(int num[],int n)&#123; //两个参数一个是筛选的数组，一个是筛选的最大值 //由于数组在函数中修改的值类似于取址赋值，这里直接里面修改外面也修改了 num[0]=num[1]=0; num[2]=1;//从2开始的质数才算进去 //首先先初始化，把所有质数序号的数组值赋值为1 for(int i=3;i&lt;=n;i++) &#123; num[i]=1; i++; num[i]=0; &#125; int max=sqrt(n); for(int i=3;i&lt;=max;i++) &#123; //下面就开始筛选了，把所有的之前出现过的质数的倍数给去掉 if(num[i])&#123; for(int j=i+i;j&lt;n;j+=i)&#123; num[j]=0; &#125; &#125; &#125;&#125;int main()&#123; int num[Max+1]=&#123;0&#125;;//因为我们算的都是正数，意思是没有用到下标为0的 int sum,count;//依次表示的是输入的正数和拆分个数 eratosthenesFunction(num,Max);//送进去筛选 while(1)&#123; cin&gt;&gt;sum; if(sum==0) break;//要先判断是否是终止条件 count=0;//这个是必须的，在循环中每一次循环都是不同的数字，必须重置 for(int i=2;i&lt;sum/2;i++)&#123; //对于任何一个可以分解为两个素数之和的偶数，其中一个必然是小于或者等于1/2的。 if(num[i]&amp;&amp;num[sum-i])&#123; //这里就是判断是否是两个质数 if(i!=sum-i)&#123; count++; &#125; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl; &#125; return 0;&#125; 最后结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分拆素数和</tag>
        <tag>试探法</tag>
        <tag>Eratosthenes筛选法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart学习笔记(一)]]></title>
    <url>%2F2019%2F03%2F21%2FDart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： 前言 简单实例 重要概念 关键字 变量 未初始化 Final与const关键字 前言由于最近写的一个东西需要到Flutter，所以Dart语言也必须学好，不多说，现在立马就开始吧。由于是个人向的学习笔记，所以，默认是已经学过其他编程语言了，然后很多和其他类似的语法就不过多赘述，只是表达目前新的东西。 简单实例12345678910// 定义一个函数printInteger(int aNumber) &#123; print(&apos;The number is $aNumber.&apos;); // Print to console.&#125;// 程序执行入口main() &#123; var number = 42; // Declare and initialize a variable. printInteger(number); // Call a function.&#125; dart内置的类型包括int，string，list，bool。 print()用于显示输出。 main()是一种特殊的，必须的顶级函数，应用程序就从这里开始执行。 重要概念在变量中可以放置的所有东西都是对象，而每个对象都是类的实例。无论数字、函数和null都是对象。所有对象都继承自[Object]类。 尽管Dart是强类型的，但类型声明是可选的，因为Dart可以推断类型。 在上面的代码中，数字被推断为int类型。 如果要明确说明不需要任何类型，请使用[特殊类型dynamic]。 Dart支持通用类型，如List(整数列表)或List(任何类型的对象列表)。 Dart支持顶级函数(如main())，以及绑定到类或对象(分别是静态方法（static）和实例（instance）方法)的函数。您还可以在函数(嵌套或局部函数)中创建函数。 Dart支持顶级变量，以及绑定到类或对象(静态和实例变量)的变量。实例变量有时被称为字段或属性。 与Java不同，Dart没有公开、保护和私有的关键字。如果标识符以下划线()开头，则该标识符对其库是私有的。 标识符可以以字母或下划线()开头，然后是这些字符加上数字的任何组合。 有时候，某事物是一个表达（expression ）还是一个语句（statement）是很重要的，所以这两个词要准确。 关键字这就是Dart里面所有的关键字： (1)带有上标1的单词是内置标识符。避免使用内置标识符作为标识符。如果尝试为类或类型名使用内置标识符，则会发生编译时错误。 (2)使用上标2的单词是在Dart的1.0版本之后添加的与异步支持相关的更新的、有限的保留字。在以async, async, 或者 sync 标记的任何函数体中，不能使用async, await, 或者 yield作为标识符。 关键字表中的所有其他词都是保留词。不能使用保留词作为标识符。 变量未初始化未初始化的变量的初始值为null。甚至具有数字类型的变量最初也是null，因为数字——就像dart中的其他东西一样——是对象。 12int lineCount;assert(lineCount == null); Final与const关键字最终变量只能设置一次，const变量是一个编译时常数。(Const变量是隐式最终变量。)最终的顶级或类变量在第一次使用时被初始化。 注意:实例变量可以是final，但不能是const。[实例变量定义在对象一级，它可以被类中的任何方法或者其他类中的方法访问，但是不能被静态方法访问。] 对于想要在编译时确定并且不再变的变量，使用const。如果const变量位于类级别，则将其标记为静态const。 const关键字不只是声明常量变量。还可以使用它来创建常量值，以及声明创建常量值的构造函数。任何变量都可以赋一个常量值。]]></content>
      <categories>
        <category>后端</category>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>Flutter</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-渐入佳境]]></title>
    <url>%2F2019%2F03%2F21%2Fjava%E5%9F%BA%E7%A1%80-%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83%2F</url>
    <content type="text"><![CDATA[目录： 前言 对象实例化过程 方法的覆盖 定义 特点 final关键字 数据 类 方法 空final 前言关于Java基础系列的学习路线，我已经在安卓学习路线总结plus里面写到了，我是按照那个上面的路线来学习的，如果有不明白的地方的话，可以移步前往作为 参考，也可以当成是目录。 对象实例化过程1.检查类是否已经加载，如果没有加载的话就加载这个类，需要加载所有的父类。 2.在内存堆中分配对象空间，递归分配所有父类和子类属性空间.先父类型再子类型,属性默认自动初始化.自动初始化为”0”值。 3.进行属性的赋值。 4.递归调用父类的构造器（默认的是调用父类的无参数构造器）。 5.调用本类的构造器。 注意： 1）静态初始化是指执行静态初始化块儿里面的内容。 2）实例初始化是指执行实例初始化块儿里面的内容。 3）构造方法：一个名称跟类的名称一样的方法，特殊在于不带返回值。 实例： 123456789101112131415161718192021222324252627public class TestInstanceInit &#123;public static int n = 0;// 静态变量static &#123;// 这是静态初始化块print();System.out.println(&quot;this is static block&quot;);&#125;&#123;// 实例初始化块System.out.println(n);&#125;public TestInstanceInit() &#123;// 构造方法System.out.println(&quot;this is TestInstanceInit&apos;s constructor~&quot;);&#125;public static void print() &#123;// 静态方法System.out.println(&quot;this is static method~&quot;);System.out.println(n);n += 1;&#125;public static void main(String[] args) &#123;new TestInstanceInit();&#125;&#125; 输出结果是: 12345this is static method~0this is static block1this is TestInstanceInit&apos;s constructor~ 执行顺序： (静态变量、静态初始化块)&gt;(变量、初始化快)&gt;构造器。 静态变量和静态初始化快/变量和初始化快的先后顺序取决于它们在类中出现的先后顺序。 参考链接 方法的覆盖定义如果在子类中定义一个方法，其名称、返回类型及参数签名正好与父类中某个方法的名称、返回类型及参数签名相匹配，那么可以说，子类的方法覆盖了父类的方法。 特点 子类的方法名称返回类型及参数签名 必须与父类的一致。 子类方法不能缩小父类方法的访问权限。 子类方法不能抛出比父类方法更多的异常。 方法覆盖只存在于子类和父类之间，同一个类中只能重载。 父类的静态方法不能被子类覆盖为非静态方法。 子类可以定义于父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法（满足覆盖约束）， 而且Java虚拟机把静态方法和所属的类绑定，而把实例方法和所属的实例绑定。 父类的非静态方法不能被子类覆盖为静态方法。 父类的私有方法不能被子类覆盖。 父类的抽象方法可以被子类通过两种途径覆盖（即实现和覆盖）。 父类的非抽象方法可以被覆盖为抽象方法。 final关键字在Java中final关键字可以用来修饰数据，方法，参数以及类。 数据final修饰的基本类型，在初始化之后就不能在赋值了，同理，修饰的对象一旦引用被初始化指向一个对象的话，就无法把它改指向另外一个对象。 但是要注意，被final修饰的对象引用，只是对象的应用不能修改，但是其自身却是可以修改的。 类当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。 final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。 方法使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。 注意:类的private方法会被隐式的指定为final方法。 空final谓的”空白final”是指被声明的为final但又为给定初值的对象引用或者基本数据。无论在什么情况下，编译器都会去确保final在使用前必须被初始化。若不进行初始化，会提示错误，这就意味着，必须在域的定义处或者每个构造器中使用表达式对final进行赋值，这正是final域在使用前被初始化的原因所在。]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>渐入佳境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(二)]]></title>
    <url>%2F2019%2F03%2F20%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[目录： 函数定义与调用 定义函数 调用函数 特殊arguments rest参数 变量相关 变量提升 全局作用域 名字空间 局部作用域 常量 解构赋值 方法 apply 装饰器 四个常用的高阶函数 map reduce filter sort 闭包 函数作为返回值 箭头函数 generator 优势 函数定义与调用定义函数第一种方法如下： 123function hanshu()&#123; ...&#125; 1.function指出这是一个函数定义； 2.hanshu是函数的名称； 3.(x)括号内列出函数的参数，多个参数以,分隔； 4.{ … }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。 第二种方法如下： 123var hanshu = function (x) &#123; ...&#125;; function (x) { … }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量hanshu，所以，通过变量hanshu就可以调用该函数。这两种其实是完全等价的，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 调用函数JS中有点儿特殊，主要就是特殊在JS中对于一个函数传进去的参数不做限制，传多了没有问题，只是在内部没有用而已，传少了的话计算结果会变成NaN。如果想保险一点儿的话，可以直接在函数里面对于传进来的参数做判断即可。 特殊arguments在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array。意思也就是，就算函数并没有定义任何的变量，也是可以拿到参数的值。 rest参数（ES6引入）rest参数只能写在最后，前面用…标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。 特别注意:JS里面有一个自动在行末添加分号的性质，所以特别需要注意。 变量相关注意，由于JS支持函数嵌套，在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。 变量提升JS函数的特性，它执行前会扫描整个函数体，把所有声明的变量都放到顶部。但是要注意，它只是提升变量的声明，并没有提升变量的赋值。 所以为了避免有些错误，建议是在函数体内，把所有的变量声明都放到函数的开头。 全局作用域不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性。 1234var bianliang=&apos;thbelief&apos;;function hanshu()&#123; ...&#125; 这里的话，访问bianliang与访问window.bianliang是完全一样的。 同时，第二种函数的定义方式其实也是一种全局的。 123var hanshu = function (x) &#123; ...&#125;; 所以，其实JS只有一个全局作用域。 名字空间全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。 例如: 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = &apos;myapp&apos;;MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return &apos;foo&apos;;&#125;; 这个其实是一个特别实用的方法，必须提倡。 局部作用域在循环中，一般使用let替代var声明次级作用域的变量。 12345678&apos;use strict&apos;;function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; i += 1;&#125; 常量ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域。但是需要注意，不是所有的地方都支持，因为ES6才引进。 解构赋值可以直接对多个变量同时赋值。 123&apos;use strict&apos;;// 如果浏览器支持解构赋值就不会报错:var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;]; 注意，对数组元素进行解构赋值时，多个变量要用[…]括起来。 有些时候数组本身还有嵌套，也可以解构赋值，但是需要保持嵌套层次和位置的一致性。 解构赋值还有很多用法，这里就不一一阐述了，需要的时候直接去查就好啦。 方法在一个对象中绑定函数，这就是这个对象的方法。 1234567891011var thbelief = &#123; name: &apos;thbelief&apos;, birth: 1999, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;thbelief.age; // function thbelief.age()thbelief.age(); 同时，this关键字在JS里面也有和C++同样的作用，可以直接调用本函数的方法。 但是一定要用对象的形式调用，这才是指向本函数里面的方法，不然的话就是对于整个全局作用域来说的。 解决的方法其实也有，就是var that = this;这条语句加上去在用的地方就可以了。 apply虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，还是可以控制this的指向！ 要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 用apply修复getAge()调用： 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var thbelief = &#123; name: &apos;thbelief&apos;, birth: 1999, age: getAge&#125;;thbelief.age(); getAge.apply(thbelief, []); 另一个与apply()类似的方法是call()，唯一区别是： apply()把参数打包成Array再传入； call()把参数按顺序传入。 比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下： 12Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5 装饰器利用apply()，我们还可以动态改变函数的行为。 JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。 四个常用的高阶函数mapmap可以传入任意的变量或者自己定义的相关函数，比如说做一个2的次方运算，相比较于我们傻乎乎的使用循环一层一层的套，map作为高阶函数无疑是更加具有实力的。 1234567&apos;use strict&apos;;function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] reduceArray的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算。 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x * 10 + y;&#125;); // 13579 filter其实有点儿类似于Android里面的过滤器。它的作用就是将Array里面的某些元素过滤掉，然后返回剩下的元素。 和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 12345var arr = [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, null, undefined, &apos;C&apos;, &apos; &apos;];var r = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;);r; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] sort需要注意的是，sort默认的排序不是简简单单的针对于数字进行排序。 它的默认把所有元素先转换为String再排序。 同时，作为一个函数，sort可以传入一个比较函数来作为依据。 比如说下面这个按照数字大小来进行排序： 1234567891011&apos;use strict&apos;;var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;); 闭包函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 12345678function lazy_sum(arr) &#123; var sum = function () &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;); &#125; return sum;&#125; 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数： 1var f = lazy_sum([1, 2, 3, 4, 5]); // function sum() 调用函数f时，才真正计算求和的结果： 1f(); // 15 函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种“闭包（Closure）”的程序结构拥有极大的威力。 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为它只会锁定最后一个结果。如果一定要引用循环变量的话，方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。 闭包还有很多应用，这里只是阐述基本概念，相关的使用要用的时候自己查即可。 箭头函数是在ES6之后推出的，只支持ES6之后的版本。 12345x =&gt; x * x;//两者完全等价function (x) &#123; return x * x;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。 箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。 还有一种可以包含多条语句，这时候就不能省略{ … }和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; 1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 如果要返回一个对象，并且是单表达式： 12// ok:x =&gt; (&#123; foo: x &#125;) this： 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。由于this在箭头函数中已经被绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略… generatorgenerator（生成器）是ES6新引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。 定义： 12345function* foo(x) &#123; yield x + 1; yield x + 2; return x + 3;&#125; generator和函数不同的是，generator由function定义（注意多出的号），并且，除了return语句，还可以用yield返回多次。 优势1.因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。 2.把异步回调代码变成“同步”代码。（深） 参考链接]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(一)]]></title>
    <url>%2F2019%2F03%2F19%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： 简介 正文 总结 下个版本 简介Auto.js使用JavaScript作为脚本语言，目前使用Rhino 1.7.7.2作为脚本引擎，支持ES5与部分ES6特性。 最开始接触Auto.js只是单纯的想写一个I西科自动签到的脚本，接触后才发现，写这样一个脚本其实简单的不行，然后了解了Auto.js的相关特性之后，我决定好好的学习一下这个工具，毕竟，它实在是太简约了，不像其他的脚本语言那么复杂，虽然…有点儿bug，毕竟开发者自己也只是一个大学生，不能指望有多完善，但是这种自动化脚本编辑实在是太有魅力了。 正文最近正在开发的Script，主要目的是借用Auto.js自带的UI模块儿集成一个个人向的脚本库。 这个版本的展示图： 目前代码展示如下，由于太简单，懒得上传到Github了，直接贴代码（后期如果有升级或者说是改良，会在下一个博客继续写） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&quot;ui&quot;;//下面就是主界面ui.layout( &lt;vertical&gt; &lt;horizontal&gt; &lt;text text=&quot;菜单&quot; w=&quot;*&quot; h=&quot;*&quot; layout_weight=&quot;1&quot; gravity=&quot;center&quot; textSize=&quot;30sp&quot; color=&quot;#000000&quot;/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;autoReply&quot; text=&quot;QQ自动回复&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;button id=&quot;autoReplyClose&quot; text=&quot;关闭&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;autoSignIn&quot; text=&quot;i西科自动签到&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;button id=&quot;autoSignInClose&quot; text=&quot;关闭&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;/horizontal&gt; &lt;/vertical&gt;);//封装的回复方法function WhatReply(notificationText)&#123; if(notificationText==&apos;A&apos;)&#123; return(&quot;您好，我是主人正在开发的人工智障robot001.\n ——robot001欢喜的答道。&quot;); &#125; else if(notificationText==&apos;B&apos;)&#123; return(&quot;好的，我马上联系主人...\n ——robot001郑重的答道。&quot;); &#125; else&#123; return &quot;主人在忙呢！\n有问题请回复下列单个字母：\n A.robot是谁？\n B.有要事迅速联系thbelief. \n ——robot001如此回答道。&quot;; &#125;&#125;//先封装一个自动回复的方法function autoReplyFunction()&#123; auto();//检查是否开启了无障碍服务权限 events.observeNotification();//监听消息 events.onNotification(function(notification)&#123; var string1=&quot;com.tencent.mobileqq&quot;;//如果是QQ消息的话 if(string1==notification.getPackageName())&#123; notification.click();//点击直接进入对应的聊天界面 //跳转必须要用startActivity waitForPackage(&quot;com.tencent.mobileqq&quot;); var t=className(&quot;android.widget.EditText&quot;).id(&quot;input&quot;).findOnce();//找到聊天输入控件 t.setText(WhatReply(notification.getText()));//这里加入回复的方法 className(&quot;android.widget.Button&quot;).id(&quot;fun_btn&quot;).findOnce().click();//发送即可 home();//直接返回桌面 &#125; &#125;);&#125;;//自动签到的方法function autoSignInFunction()&#123; auto(); //打开i西科 launchApp(&quot;i西科&quot;); //跳转到相应的界面 waitForPackage(&quot;org.weixvn.frame&quot;); //找到首页上签到的按钮，点击进去 id(&quot;it_sign_in&quot;).clickable().findOne().click(); waitForActivity(&quot;com.example.z.iswust.view.activity.impl.SignInActivity&quot;); //点击签到 if(id(&quot;btn_signin&quot;).clickable().findOne().click())&#123; //完成任务后返回桌面 home(); toast(&quot;签到成功了哟，亲~~~&quot;); &#125; &#125;//自动回复按钮的点击事件ui.autoReply.click(()=&gt;&#123; //UI模式的情况下必须用Promise形式或者回调模式 confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123; if(sure)&#123; //修改控件信息必须更改线程 threads.start(function()&#123; autoReplyFunction(); &#125;) &#125; &#125;);&#125;);//自动回复按钮的关闭点击事件ui.autoReplyClose.click(()=&gt;&#123; //这里由于只有一个脚本，我就直接把所有的脚本都关闭了，如果是很多脚本的话必须改 engines.stopAll(); toast(&quot;自动回复脚本已经关闭了哦，亲~&quot;);&#125;);//i西科自动签到的点击事件ui.autoSignIn.click(()=&gt;&#123; confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123; if(sure)&#123; //修改控件信息必须更改线程 threads.start(function()&#123; //自动签到的方法 autoSignInFunction(); &#125;) &#125; &#125;);&#125;); 总结1.一定要判断是否开启了无障碍服务权限以及通知使用权。 2.无论是不是用intent跳转页面或者应用，都应该用waitForActivity或者waitForPackage来跳转，不然容易出错。 3.基于控件的操作的时候，一定要注意寻找的依据，尽量使用不重复的依据，例如desc或者说id这种，提高兼容性。 4.方法的封装应该是根据功能来的，这一点本版本还没有做完善。 5.提示信息一定要做到位，该Toast的地方就一定要毫不犹豫的Toast. 6.如果想进入某个界面做某事，可以直接在外面套个if，这样出错的几率会小很多，比如说本版本的autoSignInFunction函数里面的点击签到。 7.UI模式情况下必须使用Promise形式或者说是回调模式。 8.还有就是，运行多个脚本的时候，都要使用多线程。 下个版本1.UI界面做的是真的丑，下个版本尽量修复。 2.添加检查更新的功能，直接app内检查更新并更新到最新版本。 3.添加更多的脚本选项。 4.定时运行，比如说，定时自启之类的，例如本版本的i西科自动签到功能，定时启动签到。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(一)]]></title>
    <url>%2F2019%2F03%2F18%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： 入门 基本语法 数据类型 Number 字符串 布尔值 比较运算符 null和undefined 数组 对象 变量 strict模式 字符串 数组 length indexOf slice push和pop unshift和shift sort reverse splice concat join 多维数组 对象 条件判断 循环 for…in while do while Map和Set iterable 入门基本语法每个语句以;结束，语句块用{...}。但是，JavaScript并不强制要求在每个语句的结尾加;，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上;。 数据类型NumberJS里面不区分整数和浮点数，都是用Number统一表示。 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 字符串字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分。 布尔值只表示true或者false。和C++与Java中完全类似，这里不过多赘述。 比较运算符注意，JavaScript允许对任意数据类型做比较。 12false == 0; // truefalse === 0; // false 特别要注意上述两种格式。 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 这是JS自身设计的缺陷，大佬们都是推荐的是不要使用==比较，始终坚持使用===比较。 还要注意一点是，NaN这个特殊的Number与所有值都不相等，包括它自己。 1NaN === NaN; // false 唯一能够判断NaN的方法就是isNaN()函数。 1isNaN(NaN); // true 最后，浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： 1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true null和undefinednull表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。 1[1, 2, 3.14, &apos;HelloWorld&apos;, null, true]; 创建数组的另一个方法是Array()函数来实现： 1new Array(1, 2, 3); // 创建了数组[1, 2, 3] 对象JavaScript的对象是一组由键-值组成的无序集合。 12345678var person = &#123; name: &apos;thbeleif&apos;, age: 20, tags: [&apos;js&apos;, &apos;web&apos;, &apos;mobile&apos;], city: &apos;mianyang&apos;, hasCar: false, zipcode: null&#125;; JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性。 要获取一个对象的属性，需要用对象变量.属性名的方式： 12person.name; // &apos;thbelief&apos;person.zipcode; // null 变量变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。 在Chrome浏览器里面使用JS的时候，可以直接使用console.log(x)来打印变量的值。 相比较于alert()的对话框，前者看起来无疑是更舒心的。 strict模式在JS设计之初，如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量。 后面有了改良，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。 启用strict模式的方法是在JavaScript代码的第一行写上即可： 1&apos;use strict&apos;; 字符串如果字符串内部既包含’又包含”可以用转义字符\来标识。 1&apos;I\&apos;m \&quot;OK\&quot;!&apos;; ASCII字符可以以\x##形式的十六进制表示。 1&apos;\x41&apos;; // 完全等同于 &apos;A&apos; 还可以用\u####表示一个Unicode字符。 1&apos;\u4e2d\u6587&apos;; // 完全等同于 &apos;中文&apos; 由于多行字符串用\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ` … ` 也可以表示。 123`这是一个多行字符串`; 要把多个字符串连接起来，可以用+号连接。 1234var name = &apos;小明&apos;;var age = 20;var message = &apos;你好, &apos; + name + &apos;, 你今年&apos; + age + &apos;岁了!&apos;;alert(message); 字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果。JS对于字符串提供了许多的方法，但是调用这些方法只会返回一个新的字符串，而不会改变原有的字符串内容。 123toUpperCase()把一个字符串全部变为大写。indexOf()会搜索指定字符串出现的位置。substring()返回指定索引区间的子串。 数组lengthJavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。 Array可以通过length属性来取得长度。 同时，直接给Array的length赋一个新的值会导致Array大小的变化。 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array。 如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化。 123var arr = [1, 2, 3];arr[5] = &apos;x&apos;;arr; // arr变为[1, 2, 3, undefined, undefined, &apos;x&apos;] indexOfArray也可以通过indexOf()来搜索一个指定的元素的位置。 12345var arr = [10, 20, &apos;30&apos;, &apos;xyz&apos;];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf(&apos;30&apos;); // 元素&apos;30&apos;的索引为2 sliceslice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array。 123var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]arr.slice(3); // 从索引3开始到结束: [&apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;] 注意到slice()的起止参数包括开始索引，不包括结束索引。 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。 1234var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];var aCopy = arr.slice();aCopy; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]aCopy === arr; // false push和poppush()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉。 unshift和shift如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉。 sort按照默认顺序进行排序，也可以自定义顺序。 reverse翻转整个Array，把元素顺序翻转过来。 splice从指定的索引开始删除若干元素，然后再从该位置添加若干元素。 12345678910var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]// 只删除,不添加:arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]// 只添加,不删除:arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;] concat把当前的Array和另一个Array连接起来，并返回一个新的Array。 值得注意的是，concat()方法并没有修改当前Array，而是返回了一个新的Array。 join把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。如果Array的元素不是字符串，将自动转换为字符串后再连接。 多维数组如果数组的某个元素又是一个Array，则可以形成多维数组。 1var arr = [[1, 2, 3], [400, 500, 600], &apos;-&apos;]; 对象JS的对象是一种无序的集合数据类型，它由若干键值对组成。 JS用一个{…}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,。 访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用’’括起来。 JavaScript规定，访问不存在的属性不报错，而是返回undefined。 由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性。 1234567891011var thbelief = &#123; name: &apos;thbelief&apos;&#125;;xiaoming.age; // undefinedxiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming[&apos;name&apos;]; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 果我们要检测thbelief是否拥有某一属性，可以用in操作符。 1&apos;name&apos; in thbelief; // true 另外，如果in判断一个属性存在，这个属性不一定是thbelief的，它可能是thbelief继承得到的。 要判断一个属性是否是thbelief自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法： 12345var thbelief = &#123; name: &apos;thbelief&apos;&#125;;thbelief.hasOwnProperty(&apos;name&apos;); // truethbelief.hasOwnProperty(&apos;toString&apos;); // false 条件判断JavaScript可以使用if () { … } else { … }来进行条件判断。 同时，也可以像C++中一样进行多重的嵌套。 循环熟悉的是单独的For循环，但是还包括了其他的不熟悉的循环方式。 for…in它可以把一个对象的所有属性依次循环出来。 12345678var o = &#123; name: &apos;thbelief&apos;, age: 20, city: &apos;mianyang&apos;&#125;;for (var key in o) &#123; console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;&#125; 要过滤掉对象继承的属性，用hasOwnProperty()来实现。（前文对象中曾经提到） 值得注意的是，for … in对Array的循环得到的是String而不是Number。 while与C++中类似。 do while与C++中类似。 Map和SetMap是一组键值对的结构，具有极快的查找速度。 12var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);m.get(&apos;Michael&apos;); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法： 1234567var m = new Map(); // 空Mapm.set(&apos;Adam&apos;, 67); // 添加新的key-valuem.set(&apos;Bob&apos;, 59);m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: truem.get(&apos;Adam&apos;); // 67m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;m.get(&apos;Adam&apos;); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： 1234var m = new Map();m.set(&apos;Adam&apos;, 67);m.set(&apos;Adam&apos;, 88);m.get(&apos;Adam&apos;); // 88 Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果。 同样的，通过delete(key)方法可以删除元素。 iterable具有iterable类型的集合可以通过新的for … of循环来遍历。 123456789101112var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + &apos;=&apos; + x[1]);&#125; for … in循环遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。如果手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果： 12345var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.name = &apos;Hello&apos;;for (var x in a) &#123; console.log(x); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;name&apos;&#125; for … in循环将把name包括在内，但Array的length属性却不包括在内。 for … of循环则完全修复了这些问题，它只循环集合本身的元素： 12345var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.name = &apos;Hello&apos;;for (var x of a) &#123; console.log(x); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;&#125; 参考链接]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java番外-多线程编程]]></title>
    <url>%2F2019%2F03%2F09%2Fjava%E7%95%AA%E5%A4%96-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[目录： 1.线程与进程的异同： 2.线程的生命周期： 新建状态： 就绪状态： 运行状态： 阻塞状态： 死亡状态： 3.线程的优先级： 4.创建线程的三种方式： 通过Runnable接口创建线程： 通过集成Thread类来创建线程： 通过Callable和Future创建线程： 三种方式的对比： 线程的几个重要的概念： 1.线程与进程的异同：线程：一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 进程：一个进程包括了由操作系统分配的内存空间，包含了一个或者多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。 2.线程的生命周期： 相关解释： 新建状态：使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态：当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态：如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态：如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态：一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 3.线程的优先级：每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 4.创建线程的三种方式： 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 通过Runnable接口创建线程：实现Runnable是一个类只需要执行一个方法来调用run（）即可。 1public void run（） 该方法可以重写，要理解的是run（）可以调用其他方法，使用其他的类，并且声明变量，就像主线程一样。 在创建一个实现Runnable接口的类之后，可以在类中实例化一个线程对象。 Thread中定义了几个构造方法，例如： 1Thread(Runnable threadOb,String threadName); 这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。 新线程创建之后，你调用它的 start() 方法它才会运行。 1void start（）； 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142class RunnableDemo implements Runnable &#123; private Thread t; private String threadName; RunnableDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;); R1.start(); RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;); R2.start(); &#125; &#125; 运行结果： 12345678910111213141516Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 4Running Thread-2Thread: Thread-2, 4Thread: Thread-1, 3Thread: Thread-2, 3Thread: Thread-1, 2Thread: Thread-2, 2Thread: Thread-1, 1Thread: Thread-2, 1Thread Thread-1 exiting.Thread Thread-2 exiting. 通过集成Thread类来创建线程：该方法是创建一个新的类然后让这个类继承自Thread类，然后创建一个该类的实例即可。 继承类的时候必须重写run（）方法，该方法是新线程的入口点，它也必须调用start方法才可以执行。本质上也是实现了Runnable接口的一个实例。 123456789101112131415161718192021222324252627282930313233343536373839404142class ThreadDemo extends Thread &#123; private Thread t; private String threadName; ThreadDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;); T1.start(); ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;); T2.start(); &#125; &#125; 运行结果： 12345678910111213141516Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 4Running Thread-2Thread: Thread-2, 4Thread: Thread-1, 3Thread: Thread-2, 3Thread: Thread-1, 2Thread: Thread-2, 2Thread: Thread-1, 1Thread: Thread-2, 1Thread Thread-1 exiting.Thread Thread-2 exiting. 下表列出了Thread类的一些重要方法： 序号 方法描述 1 public void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 2 public void run() 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 3 public final void setName(String name) 改变线程名称，使之与参数 name 相同。 4 public final void setPriority(int priority) 更改线程的优先级。 5 public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程。 6 public final void join(long millisec) 等待该线程终止的时间最长为 millis 毫秒。 7 public void interrupt() 中断线程。 8 public final boolean isAlive() 测试线程是否处于活动状态。 测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。 序号 方法描述 1 public static void yield() 暂停当前正在执行的线程对象，并执行其他线程。 2 public static void sleep(long millisec) 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 3 public static boolean holdsLock(Object x) 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。 4 public static Thread currentThread() 返回对当前正在执行的线程对象的引用。 5 public static void dumpStack() 将当前线程的堆栈跟踪打印至标准错误流。 实例： 如下的ThreadClassDemo 程序演示了Thread类的一些方法： 123456789101112131415// 文件名 : DisplayMessage.java// 通过实现 Runnable 接口创建线程public class DisplayMessage implements Runnable &#123; private String message; public DisplayMessage(String message) &#123; this.message = message; &#125; public void run() &#123; while(true) &#123; System.out.println(message); &#125; &#125;&#125; 1234567891011121314151617181920// 文件名 : GuessANumber.java// 通过继承 Thread 类创建线程 public class GuessANumber extends Thread &#123; private int number; public GuessANumber(int number) &#123; this.number = number; &#125; public void run() &#123; int counter = 0; int guess = 0; do &#123; guess = (int) (Math.random() * 100 + 1); System.out.println(this.getName() + &quot; guesses &quot; + guess); counter++; &#125; while(guess != number); System.out.println(&quot;** Correct!&quot; + this.getName() + &quot;in&quot; + counter + &quot;guesses.**&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233// 文件名 : ThreadClassDemo.javapublic class ThreadClassDemo &#123; public static void main(String [] args) &#123; Runnable hello = new DisplayMessage(&quot;Hello&quot;); Thread thread1 = new Thread(hello); thread1.setDaemon(true); thread1.setName(&quot;hello&quot;); System.out.println(&quot;Starting hello thread...&quot;); thread1.start(); Runnable bye = new DisplayMessage(&quot;Goodbye&quot;); Thread thread2 = new Thread(bye); thread2.setPriority(Thread.MIN_PRIORITY); thread2.setDaemon(true); System.out.println(&quot;Starting goodbye thread...&quot;); thread2.start(); System.out.println(&quot;Starting thread3...&quot;); Thread thread3 = new GuessANumber(27); thread3.start(); try &#123; thread3.join(); &#125;catch(InterruptedException e) &#123; System.out.println(&quot;Thread interrupted.&quot;); &#125; System.out.println(&quot;Starting thread4...&quot;); Thread thread4 = new GuessANumber(75); thread4.start(); System.out.println(&quot;main() is ending...&quot;); &#125;&#125; 运行结果： 1234567891011121314Starting hello thread...Starting goodbye thread...HelloHelloHelloHelloHelloHelloGoodbyeGoodbyeGoodbyeGoodbyeGoodbye....... 通过Callable和Future创建线程： 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。 实例： 123456789101112131415161718192021222324252627282930313233343536public class CallableThreadTest implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for(int i = 0;i &lt; 100;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i); if(i==20) &#123; new Thread(ft,&quot;有返回值的线程&quot;).start(); &#125; &#125; try &#123; System.out.println(&quot;子线程的返回值：&quot;+ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i = 0; for(;i&lt;100;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125; return i; &#125; &#125; 三种方式的对比： 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。 线程的几个重要的概念：1）线程同步。 2）线程间通信。 3）线程死锁。 4）线程控制，包括挂起停止与恢复。]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>番外</tag>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-融会贯通]]></title>
    <url>%2F2019%2F03%2F07%2Fjava%E5%9F%BA%E7%A1%80-%E8%9E%8D%E4%BC%9A%E8%B4%AF%E9%80%9A%2F</url>
    <content type="text"><![CDATA[目录： 1.继承： 1）概念： 2）格式： 3）类型： 4）特性： 5）关键字： extends关键字： implements关键字： super与this关键字： final关键字： 注意： 2.重写与重载： 1）重写： 概念： Super关键字的使用： 2）重载： 规则： 3）重载与重写的区别： 4）总结： 3.多态： 1）概念： 2）表现： 3）优点： 4）执行条件： 5）虚函数： 6）实现方式： 4.抽象类： 1）概念： 2）实例： 3）继承抽象类： 4）抽象方法： 5）总结： 5.封装： 1）概念： 2）优点： 3）实现步骤： 4）实例： 6.接口： 1）概念： 2）接口与类的相似点： 3）接口与类的区别： 4）接口特性： 5）抽象类与接口的区别： 6）接口的声明： 7）接口的实现： 8）接口的继承： 9）接口的多继承： 10）标记接口： 7.包： 1）作用： 2）创建包： 3）import关键字： 4）package目录结构： 5）设置CLASSPATH系统变量： 1.继承：1）概念：继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 2）格式：12345class 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; 3）类型：注意：java不支持多继承，但是支持多重继承。 4）特性：子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 5）关键字：注意：继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 extends关键字：在java中，类的继承是单一的继承，也就是说，一个类只能拥有一个父类，所以extends只能继承一个类。 123456789101112public class Animal &#123; private String name; private int id; public Animal(String myName, String myid) &#123; //初始化属性值 &#125; public void eat() &#123; //吃的方法的具体实现 &#125; public void sleep() &#123; //睡觉的方法的具体实现 &#125; &#125; public class Penguin extends Animal&#123; &#125; implements关键字：使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 1234567891011public interface A &#123; public void eat(); public void sleep();&#125; public interface B &#123; public void show();&#125; public class C implements A,B &#123;&#125; super与this关键字：super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用。 123456789101112131415161718192021222324class Animal &#123; void eat() &#123; System.out.println(&quot;animal : eat&quot;); &#125;&#125; class Dog extends Animal &#123; void eat() &#123; System.out.println(&quot;dog : eat&quot;); &#125; void eatTest() &#123; this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); &#125;&#125; final关键字：final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。 注:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final 123456声明类：final class 类名 &#123;//类体&#125;声明方法：修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;//方法体&#125; 注意：子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。 2.重写与重载：1）重写：概念：重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。其实就是外形不变，核心重写的意思。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 12345678910111213141516171819202122class Animal&#123; public void move()&#123; System.out.println(&quot;动物可以移动&quot;); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println(&quot;狗可以跑和走&quot;); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 &#125;&#125; 结果： 12动物可以移动狗可以跑和走 Super关键字的使用：当需要在子类中调用父类的被重写方法的时候，就必须使用super关键字。 123456789101112131415161718192021class Animal&#123; public void move()&#123; System.out.println(&quot;动物可以移动&quot;); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; super.move(); // 应用super类的方法 System.out.println(&quot;狗可以跑和走&quot;); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal b = new Dog(); // Dog 对象 b.move(); //执行 Dog类的方法 &#125;&#125; 结果： 12动物可以移动狗可以跑和走 2）重载：重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 规则：被重载的方法必须改变参数列表（参数的个数或者类型不一样）。 被重载的方法可以改变返回类型。 被重载的方法可以改变访问修饰符。 被重载的方法可以声明新的或者更广的检查异常。 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 1234567891011121314151617181920212223242526272829public class Overloading &#123; public int test()&#123; System.out.println(&quot;test1&quot;); return 1; &#125; public void test(int a)&#123; System.out.println(&quot;test2&quot;); &#125; //以下两个参数类型顺序不同 public String test(int a,String s)&#123; System.out.println(&quot;test3&quot;); return &quot;returntest3&quot;; &#125; public String test(String s,int a)&#123; System.out.println(&quot;test4&quot;); return &quot;returntest4&quot;; &#125; public static void main(String[] args)&#123; Overloading o = new Overloading(); System.out.println(o.test()); o.test(1); System.out.println(o.test(1,&quot;test3&quot;)); System.out.println(o.test(&quot;test4&quot;,1)); &#125;&#125; 3）重载与重写的区别： 4）总结：方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 (3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 3.多态：1）概念：多态就是同一个行为具有多个不同表现形式或者形态的能力。 （同一个接口，使用不同的实例而执行不同的操作） 2）表现：1234567现实中，比如我们按下 F1 键这个动作：如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 3）优点： 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 4）执行条件： 继承 重写 父类引用指向子类对象 例如： 1Parent p = new Child(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat Cat c = (Cat)a; // 向下转型 c.work(); // 调用的是 Cat 的 work &#125; public static void show(Animal a) &#123; a.eat(); // 类型判断 if (a instanceof Cat) &#123; // 猫做的事 Cat c = (Cat)a; c.work(); &#125; else if (a instanceof Dog) &#123; // 狗做的事 Dog c = (Dog)a; c.work(); &#125; &#125; &#125; abstract class Animal &#123; abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void work() &#123; System.out.println(&quot;抓老鼠&quot;); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; public void work() &#123; System.out.println(&quot;看家&quot;); &#125; &#125; 结果： 123456吃鱼抓老鼠吃骨头看家吃鱼抓老鼠 5）虚函数：虚函数的存在是为了多态。 Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。 6）实现方式：三种方式，包括：重写，接口，抽象类和抽象方法。 4.抽象类：1）概念：在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 2）实例：在java中使用abstract class来定义抽象类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 文件名 : Employee.java */public abstract class Employee&#123; private String name; private String address; private int number; public Employee(String name, String address, int number) &#123; System.out.println(&quot;Constructing an Employee&quot;); this.name = name; this.address = address; this.number = number; &#125; public double computePay() &#123; System.out.println(&quot;Inside Employee computePay&quot;); return 0.0; &#125; public void mailCheck() &#123; System.out.println(&quot;Mailing a check to &quot; + this.name + &quot; &quot; + this.address); &#125; public String toString() &#123; return name + &quot; &quot; + address + &quot; &quot; + number; &#125; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String newAddress) &#123; address = newAddress; &#125; public int getNumber() &#123; return number; &#125;&#125; 如果尝试以下例子： 123456789101112/* 文件名 : AbstractDemo.java */public class AbstractDemo&#123; public static void main(String [] args) &#123; /* 以下是不允许的，会引发错误 */ Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); &#125;&#125; 编译时会显示以下的错误： 1234Employee.java:46: Employee is abstract; cannot be instantiated Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); ^1 error 3）继承抽象类：可以通过一般的方法直接继承Employee类： 123456789101112131415161718192021222324252627282930313233/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; //Annual salary public Salary(String name, String address, int number, double salary) &#123; super(name, address, number); setSalary(salary); &#125; public void mailCheck() &#123; System.out.println(&quot;Within mailCheck of Salary class &quot;); System.out.println(&quot;Mailing check to &quot; + getName() + &quot; with salary &quot; + salary); &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double newSalary) &#123; if(newSalary &gt;= 0.0) &#123; salary = newSalary; &#125; &#125; public double computePay() &#123; System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; &#125;&#125; 尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。 123456789101112131415/* 文件名 : AbstractDemo.java */public class AbstractDemo&#123; public static void main(String [] args) &#123; Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00); Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00); System.out.println(&quot;Call mailCheck using Salary reference --&quot;); s.mailCheck(); System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); &#125;&#125; 运行结果如下： 123456789Constructing an EmployeeConstructing an EmployeeCall mailCheck using Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400. 4）抽象方法：如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。 Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。 抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。 12345678910public abstract class Employee&#123; private String name; private String address; private int number; public abstract double computePay(); //...&#125; 声明抽象方法会造成以下两个结果： 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 如果Salary类继承了Employee类，那么它必须实现computePay()方法： 12345678910111213/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; // Annual salary public double computePay() &#123; System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; &#125; //...&#125; 5）总结： 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 5.封装：1）概念：封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 2）优点： 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 3）实现步骤：修改属性的可见性来限制属性的访问（一般限制为private），例如： 1234public class Person &#123; private String name; private int age;&#125; 这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如： 1234567891011121314151617181920public class Person&#123; private String name; private int age;​ public int getAge()&#123; return age; &#125;​ public String getName()&#123; return name; &#125;​ public void setAge(int age)&#123; this.age = age; &#125;​ public void setName(String name)&#123; this.name = name; &#125;&#125; 之所以采用this关键字是为了解决实例变量和局部变量之间发生的同名冲突。 4）实例：12345678910111213141516171819202122232425262728293031/* 文件名: EncapTest.java */public class EncapTest&#123; private String name; private String idNum; private int age; public int getAge()&#123; return age; &#125; public String getName()&#123; return name; &#125; public String getIdNum()&#123; return idNum; &#125; public void setAge( int newAge)&#123; age = newAge; &#125; public void setName(String newName)&#123; name = newName; &#125; public void setIdNum( String newId)&#123; idNum = newId; &#125;&#125; 以上实例中public方法是外部类访问该类成员变量的入口。 通常情况下，这些方法被称为getter和setter方法。 因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。 通过如下的例子说明EncapTest类的变量怎样被访问： 123456789101112/* F文件名 : RunEncap.java */public class RunEncap&#123; public static void main(String args[])&#123; EncapTest encap = new EncapTest(); encap.setName(&quot;James&quot;); encap.setAge(20); encap.setIdNum(&quot;12343ms&quot;); System.out.print(&quot;Name : &quot; + encap.getName()+ &quot; Age : &quot;+ encap.getAge()); &#125;&#125; 运行结果： 1Name : James Age : 20 6.接口：1）概念：接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 2）接口与类的相似点： 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 3）接口与类的区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 4）接口特性： 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 5）抽象类与接口的区别： 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 6）接口的声明：1234[可见度] interface 接口名称 [extends 其他的接口名名] &#123; // 声明变量 // 抽象方法&#125; interface关键字用来声明一个接口。 123456789/* 文件名 : NameOfInterface.java */import java.lang.*;//引入包 public interface NameOfInterface&#123; //任何类型 final, static 字段 //抽象方法&#125; 接口有如下特性： 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。 接口中的方法都是公有的。 实例： 12345/* 文件名 : Animal.java */interface Animal &#123; public void eat(); public void travel();&#125; 7）接口的实现：当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。 类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 实现一个接口的语法，可以使用这个公式： 1...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ... 实例： 123456789101112131415161718192021/* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(&quot;Mammal eats&quot;); &#125; public void travel()&#123; System.out.println(&quot;Mammal travels&quot;); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 运行结果： 12Mammal eatsMammal travels 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 8）接口的继承：一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 下面的Sports接口被Hockey和Football接口继承： 1234567891011121314151617181920212223// 文件名: Sports.javapublic interface Sports&#123; public void setHomeTeam(String name); public void setVisitingTeam(String name);&#125; // 文件名: Football.javapublic interface Football extends Sports&#123; public void homeTeamScored(int points); public void visitingTeamScored(int points); public void endOfQuarter(int quarter);&#125; // 文件名: Hockey.javapublic interface Hockey extends Sports&#123; public void homeGoalScored(); public void visitingGoalScored(); public void endOfPeriod(int period); public void overtimePeriod(int ot);&#125; Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。 相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。 9）接口的多继承：在Java中，类的多继承是不合法，但接口允许多继承。 在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示： 1public interface Hockey extends Sports, Event 以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法。 10）标记接口：最常用的继承接口是没有包含任何方法的接口。 标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。 标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。 例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下： 123package java.util;public interface EventListener&#123;&#125; 没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的： 建立一个公共的父接口： 正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。 向一个类添加数据类型： 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。 7.包：为了更好的组织类，包就产生了，主要是用来区别类名的命名空间。 1）作用： 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 包语句的语法格式为： 1package pkg1[．pkg2[．pkg3…]]; 例如,一个Something.java 文件它的内容： 1234package net.java.util;public class Something&#123; ...&#125; 那么它的路径应该是 net/java/util/Something.java 这样保存的。 package(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。 一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。 以下是一些 Java 中的包： java.lang-打包基础的类 java.io-包含输入输出功能的函数 开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。 由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。 2）创建包：创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。 例子： 让我们来看一个例子，这个例子创建了一个叫做animals的包。通常使用小写的字母来命名避免与类、接口名字的冲突。 在 animals 包中加入一个接口（interface）： 1234567/* 文件名: Animal.java */package animals; interface Animal &#123; public void eat(); public void travel();&#125; 接下来，在同一个包中加入该接口的实现： 1234567891011121314151617181920212223package animals; /* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(&quot;Mammal eats&quot;); &#125; public void travel()&#123; System.out.println(&quot;Mammal travels&quot;); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 然后，编译这两个文件，并把他们放在一个叫做animals的子目录中。 用下面的命令来运行： 12345$ mkdir animals$ cp Animal.class MammalInt.class animals$ java animals/MammalIntMammal eatsMammal travel 3）import关键字：为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为： 1import package1[.package2…].(classname|*); 如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 例子： 下面的 payroll 包已经包含了 Employee 类，接下来向 payroll 包中添加一个 Boss 类。Boss 类引用 Employee 类的时候可以不用使用 payroll 前缀，Boss类的实例如下。 123456789package payroll; public class Boss&#123; public void payEmployee(Employee e) &#123; e.mailCheck(); &#125;&#125; 如果 Boss 类不在 payroll 包中又会怎样？Boss 类必须使用下面几种方法之一来引用其他包中的类。 使用类全名描述，例如： 1payroll.Employee 用 import 关键字引入，使用通配符 “*”： 1import payroll.*; 使用 import 关键字引入 Employee 类: 1import payroll.Employee; 注意： 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 4）package目录结构：类放在包中会有两种主要的结果： 包名成为类名的一部分，正如我们前面讨论的一样。 包名必须与相应的字节码所在的目录结构相吻合。 下面是管理你自己 java 中文件的一种简单方式： 将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如： 1234567// 文件名 : Car.java package vehicle; public class Car &#123; // 类实现 &#125; 接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。 1....\vehicle\Car.java 现在，正确的类名和路径将会是如下样子： 类名 -&gt; vehicle.Car 路径名 -&gt; vehicle\Car.java (在 windows 系统中) 通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。 例如：有一个 com.runoob.test 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录： 1....\com\runoob\test\Runoob.java 编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如： 123456789// 文件名: Runoob.java package com.runoob.test;public class Runoob &#123; &#125;class Google &#123; &#125; 现在，我们用-d选项来编译这个文件，如下： 1$javac -d . Runoob.java 这样会像下面这样放置编译了的文件： 12.\com\runoob\test\Runoob.class.\com\runoob\test\Google.class 你可以像下面这样来导入所有 \com\runoob\test\ 中定义的类、接口等： 1import com.runoob.test.*; 编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。 12&lt;path-one&gt;\sources\com\runoob\test\Runoob.java&lt;path-two&gt;\classes\com\runoob\test\Google.class 这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。 类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。 一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。 5）设置CLASSPATH系统变量：用下面的命令显示当前的CLASSPATH变量： Windows 平台（DOS 命令行下）：C:> set CLASSPATH UNIX 平台（Bourne shell 下）：# echo $CLASSPATH 删除当前CLASSPATH变量内容： Windows 平台（DOS 命令行下）：C:> set CLASSPATH= UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH 设置CLASSPATH变量: Windows 平台（DOS 命令行下）： C:> set CLASSPATH=C:\users\jack\java\classes UNIX 平台（Bourne shell 下）：# CLASSPATH=/home/jack/java/classes; export CLASSPATH]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>融会贯通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中STL用法]]></title>
    <url>%2F2019%2F03%2F04%2FC-%E4%B8%ADSTL%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录： 1.1STL的含义： 1.2STL六大组件： 1.3容器： 1.4STL迭代器： 1.5算法： &lt;一&gt;查找算法(13个)：判断容器中是否包含某个值 &lt;二&gt;排序和通用算法(14个)：提供元素排序策略 &lt;三&gt;删除和替换算法(15个) &lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合 &lt;五&gt;算术算法(4个) &lt;六&gt;生成和异变算法(6个) &lt;七&gt;关系算法(8个) &lt;八&gt;集合算法(4个) &lt;九&gt;堆算法(4个) 1.1STL的含义：STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。 STL的一个重要的特点就是数据结构和算法的分离。例如：由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组。 STL另外的一个特点就是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。 1.2STL六大组件：1）容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器； 2）迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象； 3）算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用； 4）仿函数（Function object） 5）迭代适配器（Adaptor） 6）空间配制器（allocator） 1.3容器：STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。 （1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；Vectors：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；Deques：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；Lists：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针； （2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap；Sets/Multisets：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；Maps/Multimaps：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找； 容器类自动申请和释放内存，无需new和delete操作。vector基于模板实现，需包含头文件vector。 12345678910111213141516171819202122232425262728293031//1.定义和初始化 vector&lt;int&gt; vec1; //默认初始化，vec1为空 vector&lt;int&gt; vec2(vec1); //使用vec1初始化vec2 vector&lt;int&gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2 vector&lt;int&gt; vec4(10); //10个值为的元素 vector&lt;int&gt; vec5(10,4); //10个值为的元素//2.常用操作方法 vec1.push_back(100); //添加元素 int size = vec1.size(); //元素个数 bool isEmpty = vec1.empty(); //判断是否为空 cout&lt;&lt;vec1[0]&lt;&lt;endl; //取得第一个元素 vec1.insert(vec1.end(),5,3); //从vec1.back位置插入个值为的元素 vec1.pop_back(); //删除末尾元素 vec1.erase(vec1.begin(),vec1.end());//删除之间的元素，其他元素前移 cout&lt;&lt;(vec1==vec2)?true:false; //判断是否相等==、！=、&gt;=、&lt;=... vector&lt;int&gt;::iterator iter = vec1.begin(); //获取迭代器首地址 vec1.clear(); //清空元素//3.遍历 //下标法 int length = vec1.size(); for(int i=0;i&lt;length;i++) &#123; cout&lt;&lt;vec1[i]; &#125; cout&lt;&lt;endl&lt;&lt;endl; //迭代器法 vector&lt;int&gt;::const_iterator iterator = vec1.begin(); for(;iterator != vec1.end();iterator++) &#123; cout&lt;&lt;*iterator; &#125; 1.4STL迭代器：Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator,实例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; v.push_back(3); //数组尾部插入3 v.push_back(2); v.push_back(1); v.push_back(0); cout &lt;&lt; &quot; 下标 &quot; &lt;&lt; v[3] &lt;&lt; endl; cout &lt;&lt; &quot; 迭代器 &quot; &lt;&lt; endl; for(vector&lt;int&gt;::iterator i = v.begin();i!= v.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //在第一个元素之前插入111 insert begin+n是在第n个元素之前插入 v.insert(v.begin(),111); //在最后一个元素之后插入222 insert end + n 是在n个元素之后插入 v.insert(v.end(),222); for(vector&lt;int&gt;::iterator i = v.begin();i!= v.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; vector&lt;int&gt; arr(10); for(int i = 0; i &lt; 10; i++) &#123; arr[i] = i; &#125; for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //删除 同insert arr.erase(arr.begin()); for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl ; arr.erase(arr.begin(),arr.begin()+5); for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl ; return 0 ; &#125; 数组转置： reverse(v.begin(),v.end()) 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; for(int i = 0; i &lt; 10; ++i) &#123; v.push_back(i); &#125; for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; reverse(v.begin(),v.end()); for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 1.5算法：算法部分主要由头文件algorithm，numeric和functional组成。 algorithm是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。 numeric体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。 functional中则定义了一些模板类，用以声明函数对象。STL中算法大致分为四类： 1）非可变序列算法：指不直接修改其所操作的容器内容的算法。 2）可变序列算法：指可以修改它们所操作的容器内容的算法。 3）排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。 4）数值算法：对容器内容进行数值计算。 &lt;一&gt;查找算法(13个)：判断容器中是否包含某个值adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。 binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。 count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。 count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。 equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示 upper_bound。 find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。 find_end: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代替等于操作。 find_first_of: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。 find_if: 使用输入的函数代替等于操作符执行find。 lower_bound: 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。 upper_bound: 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。 search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。 search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。 &lt;二&gt;排序和通用算法(14个)：提供元素排序策略inplace_merge: 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。 merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。 nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。 partial_sort: 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。 partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。 partition: 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。 random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。 reverse: 将指定范围内元素重新反序排序。 reverse_copy: 与reverse类似，不过将结果写入另一个容器。 rotate: 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。 rotate_copy: 与rotate类似，不过将结果写入另一个容器。 sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。 stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。 stable_partition: 与partition类似，不过不保证保留容器中的相对顺序。 &lt;三&gt;删除和替换算法(15个)copy: 复制序列 copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。 iter_swap: 交换两个ForwardIterator的值。 remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。 remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。 remove_if: 删除指定范围内输入操作结果为true的所有元素。 remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。 replace: 将指定范围内所有等于vold的元素都用vnew代替。 replace_copy: 与replace类似，不过将结果写入另一个容器。 replace_if: 将指定范围内所有操作结果为true的元素用新值代替。 replace_copy_if: 与replace_if，不过将结果写入另一个容器。 swap: 交换存储在两个对象中的值。 swap_range: 将指定范围内的元素与另一个序列元素值进行交换。 unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。 unique_copy: 与unique类似，不过把结果输出到另一个容器。 &lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。 prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。 &lt;五&gt;算术算法(4个)accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。 partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。 inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。 adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。 &lt;六&gt;生成和异变算法(6个)fill: 将输入值赋给标志范围内的所有元素。 fill_n: 将输入值赋给first到first+n范围内的所有元素。 for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。 generate: 连续调用输入的函数来填充指定的范围。 generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。 transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。 &lt;七&gt;关系算法(8个)equal: 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。 includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。 lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。 max: 返回两个元素中较大一个。重载版本使用自定义比较操作。 max_element: 返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。 min: 返回两个元素中较小一个。重载版本使用自定义比较操作。 min_element: 返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。 mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。 &lt;八&gt;集合算法(4个)set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。 set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。 set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。 set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。 &lt;九&gt;堆算法(4个)make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。 pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。 push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。 sort_heap: 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。 ……]]></content>
      <categories>
        <category>后端</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>用法</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础 初窥门径]]></title>
    <url>%2F2019%2F02%2F27%2FJava%E5%9F%BA%E7%A1%80-%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%2F</url>
    <content type="text"><![CDATA[目录： 1.Java的基本数据类型： 对应的包装类： 基本数据类型的默认值： 2.Java分支循环： 分支语句： if语句： switch语句： 三目运算符： 转义符： 循环语句： for循环： while语句： 3.String、StringBuffer、StringBuilder： 区别： String对象： String本质： 常量池： 实例： StringBuffer字符串变量（线程安全）是一个容器，最终会通过toString方法变成字符串： StringBuilder 字符串变量（非线程安全）： String与StringBuffer区别： 在修改的时候对象自身是否改变： 是否可变测试： 初始化区别： StringBuffer对象和String对象之间的互转: 偏重： 总结： StringBuffer与StringBuilder区别： 4.正则表达式： 1.1正则表达式的含义： 1.2具体实例： 1.3常见的匹配符号： 1.4元字符： 1.5限定符： 1.6分组和反向引用： 1.7仅分组却无反向引用： 1.8分组的反向引用副本： 1.9否定先行断言： 1.10指定正则表达式的模式： 1.11java中的反斜杠： 1.12易错： 1.13内置的字符串正则处理方法： 1.14：模式和匹配： 1.15：几个常用的例子： 1）中文的匹配： 2）数字范围的匹配： 3）img标签的匹配： 4）贪婪与非贪婪模式的匹配： 1.16：在线正则工具： 1.Java的基本数据类型：1234567整型 byte（字节型） short（短整型） int long（长整型）浮点型 float（单精度浮点型） double（双精度浮点型）逻辑型 boolean(它只有两个值可取 true false)字符型 char 对应的包装类：java.lang.Byte、java.lang.Short、java.lang.Integer、java.lang.Long、java.lang.Float、java.lang.Double、java.lang.Boolean、java.lang.Character. 基本数据类型的默认值： 2.Java分支循环：分支语句：123顺序语句分支语句循环语句 if语句：123456789if(boolean类型表达式)&#123; 语句1&#125;else&#123; 语句2&#125; switch语句：1234567891011121314151617181920switch(变量)&#123; case常量1:语句1;break; case常量2:语句2;break; case常量3: 语句3; break; default: 语句0; break;&#125;注：default可以忽略掉~ 三目运算符：123表达式1?表达式2:表达式3表达式1是布尔类型的，右边的问号表示判断它是true还是false，如果是true，整个表达式返回表达式2，如果是false整个表达式返回表达式3 转义符：12345678910111213回车(return) &apos;\r&apos; 13换行(nextLine) &apos;\n&apos; 10(在windows中执行换行动作用\r\n；在linux中执行换行动作用\n)制表(tab) &apos;\t&apos; (可以用来对齐打印的文字)双引号 &apos;\&quot;&apos; (反斜杠+双引号表示双引号字符)单引号 &apos;\&apos;&apos; (反斜杠+单引号表示单引号字符)反斜杠 &apos;\\&apos; (两个反斜杠表示一个反斜杠) 循环语句：for循环：1234567891011for(表达式1;表达式2;表达式3)&#123; 语句&#125;表达式1 在循环开始前执行一次，一般用于初始化表达式2 循环条件，一般为boolean类型，为true则循环继续，为false则循环终止(不写则表示一直为true)表达式3 每次循环在语句执行完后执行，一般用于对循环条件进行变更 while语句：12345678910111213141516171819while(条件)&#123; 语句&#125;当条件为true时，不停地执行语句do...while语句do&#123; 语句&#125;while(条件);和while逻辑一样，但是会先执行语句，再判断。do...while在任何情况下至少执行一次语句。 3.String、StringBuffer、StringBuilder：区别：123String对象是常量，它的值不能被创建后改变，StringBuffer和StringBuilder可以可变；StringBuilder非线程安全（单线程使用），String与StringBuffer线程安全（多线程使用）；如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。 String对象：String本质：String是值不可变的常量，是线程安全的。 String类使用了final修饰符，String类是不可继承的。 常量池：常量池是一个内存空间，不同于使用new关键字创建的对象所在的堆空间。 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复创建相等变量时节省了很多时间。 在编译期被确定，并被保存在已编译的.class文件中的一些数据，包括类、方法、接口等中的常量和字符串常量。常量池还具备动态性，运行期间可以将新的常量放入池中。java中基本类型的包装类的大部分都实现了常量池技术， 即Byte,Short,Integer,Long,Character,Boolean； 实例：12String s1 = new String(&quot;s1&quot;) ; String s2 = new String(&quot;s1&quot;) ; 1234// 3个，编译期在常量池中创建1个，即“s1”常量对象；运行期堆中创建2个，即s1和s2对象。String s1 = &quot;s1&quot;; String s2 = s1; s2 = &quot;s2&quot;; StringBuffer字符串变量（线程安全）是一个容器，最终会通过toString方法变成字符串：12345678910111213141516public final class StringBuffer extends AbstractStringBuilder implements Serializable, Appendable, CharSequence &#123; /** * Constructs a string buffer with no characters in it and an initial capacity of 16 characters. */ public StringBuffer() &#123; super(16); &#125; public synchronized StringBuffer append(int i) &#123; super.append(i); return this; &#125; public synchronized StringBuffer delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; StringBuilder 字符串变量（非线程安全）：12345678910111213public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, Appendable, CharSequence &#123; public StringBuilder() &#123; super(16); &#125; public StringBuilder append(String str) &#123; super.append(str); return this; &#125; public StringBuilder delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; String与StringBuffer区别：在修改的时候对象自身是否改变：（1） String在修改时不会改变对象自身 在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String 。 12String str = &quot;abc&quot;;//地址str1str = &quot;def&quot;;//地址str2 （2） StringBuffer在修改时会改变对象自身 每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。StringBuffer 上的主要操作是 append 和 insert 方法。 12StringBuffer strBuffer = new StringBuffer(&quot;abc&quot;);//地址strBuffer,值是abcstrBuffer.append(&quot;def&quot;);//地址strBuffer,值是abcdef 是否可变测试：String的地址已改变，对象已经改变为另一个；StringBuffer地址不变，还是同样的对象。 初始化区别：123String：StringBuffer s = null; StringBuffer s = “abc”; 1234StringBuffer：StringBuffer s = null; //结果警告：Null pointer access: The variable result can only be null at this locationStringBuffer s = new StringBuffer();//StringBuffer对象是一个空的对象StringBuffer s = new StringBuffer(“abc”);//创建带有内容的StringBuffer对象,对象的内容就是字符串”abc” StringBuffer对象和String对象之间的互转:他们属于不同的类型，不能直接进行强制类型转换。 1234String s = “abc”;StringBuffer sb1 = new StringBuffer(“123”);StringBuffer sb2 = new StringBuffer(s); //String转换为StringBufferString s1 = sb1.toString(); //StringBuffer转换为String 偏重：StringBuffer类中的方法主要偏重于对于字符串的变化，例如追加、插入和删除等，常用方法有：append方法、insert方法、deleteCharAt方法、reverse方法等。 总结：（1）如果要操作少量的数据用 String； （2）（多线程下）经常需要对一个字符串进行修改，例如追加、插入和删除等操作，使用StringBuffer要更加适合一些。 StringBuffer与StringBuilder区别：1.StringBuilder是一个可变的对象，是5.0新增的，提供一个与StringBuffer兼容的API，但不保证同步，主要是用在字符串缓冲区被单个线程使用的时候。 2.线程安全性： ​ StringBuffer：线程安全。 ​ StringBuilder：线程非安全。 3.大部分情况下：StringBuffer&gt;String 同时由于String对象不可变，重复新建对象：StringBuffer对象可变。 4.StringBuilder&gt;StringBuffer 当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的。 5.特殊情况下，String&gt;StringBuffer 123//String效率是远要比StringBuffer快的：String S1 = “This is only a” + “ simple” + “ test”;StringBuffer Sb = new StringBuilder(“This is only a”).append(“simple”).append(“ test”); 12345//String速度是非常慢的：String S2 = “This is only a”;String S3 = “ simple”;String S4 = “ test”;String S1 = S2 +S3 + S4; 6.总结： 123（1）如果要操作少量的数据用 String；（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。 参考链接 4.正则表达式：1.1正则表达式的含义：定义一个搜索模式的字符串。 正则表达式可以用于搜索、编辑和操作文本。 分析过程：首先正则表达式应用的是文本字符串（text/string），它会以定义的模式从左到右匹配文本，每个源字符只匹配一次。 1.2具体实例：123this is text 精确匹配字符串 &quot;this is text&quot;this\s+is\s+text 匹配单词 &quot;this&quot; 后跟一个或多个空格字符，后跟词 &quot;is&quot; 后跟一个或多个空格字符，后跟词 &quot;text&quot;^\d+(\.\d+)? ^ 定义模式必须匹配字符串的开始，d+ 匹配一个或多个数字，? 表明小括号内的语句是可选的，\. 匹配 &quot;.&quot;，小括号表示分组。例如匹配：&quot;5&quot;、&quot;1.5&quot; 和 &quot;2.21&quot; 1.3常见的匹配符号： 正则表达式 描述 . 匹配所有单个字符，除了换行符（Linux 中换行是 \n，Windows 中换行是 \r\n） ^regex 正则必须匹配字符串开头 regex$ 正则必须匹配字符串结尾 [abc] 复选集定义，匹配字母 a 或 b 或 c [abc][vz] 复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z [^abc] 当插入符 ^ 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c [a-d1-7] 范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间，但不匹配 d1 XZ 匹配 X 后直接跟着 Z X\ Z 匹配 X 或 Z 1.4元字符： 正则表达式 描述 \d 匹配一个数字，是 [0-9] 的简写 \D 匹配一个非数字，是 [^0-9] 的简写 \s 匹配一个空格，是 [ \t\n\x0b\r\f] 的简写 \S 匹配一个非空格 \w 匹配一个单词字符（大小写字母、数字、下划线），是 [a-zA-Z_0-9] 的简写 \W 匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 [^\w] 1.5限定符：限定符定义了一个元素可以发生的频率。 正则表达式 描述 举例 * 匹配 &gt;=0 个，是 {0,} 的简写 X* 表示匹配零个或多个字母 X，.*表示匹配任何字符串 + 匹配 &gt;=1 个，是 {1,} 的简写 X+ 表示匹配一个或多个字母 X ? 匹配 1 个或 0 个，是 {0,1} 的简写 X? 表示匹配 0 个或 1 个字母 X {X} 只匹配 X 个字符 \d{3} 表示匹配 3 个数字，.{10}表示匹配任何长度是 10 的字符串 {X,Y} 匹配 &gt;=X 且 &lt;=Y 个 \d{1,4} 表示匹配至少 1 个最多 4 个数字 *? 如果 ? 是限定符 * 或 + 或 ? 或 {} 后面的第一个字符，那么表示非贪婪模式（尽可能少的匹配字符），而不是默认的贪婪模式 1.6分组和反向引用：小括号 () 可以达到对正则表达式进行分组的效果。 模式分组后会在正则表达式中创建反向引用。反向引用会保存匹配模式分组的字符串片断，这使得我们可以获取并使用这个字符串片断。 在以正则表达式替换字符串的语法中，是通过 $ 来引用分组的反向引用，$0 是匹配完整模式的字符串（注意在 JavaScript 中是用 $&amp; 表示）；$1 是第一个分组的反向引用；$2 是第二个分组的反向引用，以此类推。 示例： 123456789101112131415package com.wuxianjiezh.demo.regex;public class RegexTest &#123; public static void main(String[] args) &#123; // 去除单词与 , 和 . 之间的空格 String Str = &quot;Hello , World .&quot;; String pattern = &quot;(\\w)(\\s+)([.,])&quot;; // $0 匹配 `(\w)(\s+)([.,])` 结果为 `o空格,` 和 `d空格.` // $1 匹配 `(\w)` 结果为 `o` 和 `d` // $2 匹配 `(\s+)` 结果为 `空格` 和 `空格` // $3 匹配 `([.,])` 结果为 `,` 和 `.` System.out.println(Str.replaceAll(pattern, &quot;$1$3&quot;)); // Hello, World. &#125;&#125; 上面的例子中，我们使用了 [.] 来匹配普通字符 . 而不需要使用 [\\.]。因为正则对于 [] 中的 .，会自动处理为 [\.]，即普通字符 . 进行匹配。 1.7仅分组却无反向引用：当我们在小括号 () 内的模式开头加入 ?:，那么表示这个模式仅分组，但不创建反向引用。 示例： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;img.jpg&quot;; // 分组且创建反向引用 Pattern pattern = Pattern.compile(&quot;(jpg|png)&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); System.out.println(matcher.group(1)); &#125; &#125;&#125; 运行结果： 12jpgjpg 若源码改为： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;img.jpg&quot;; // 分组但不创建反向引用 Pattern pattern = Pattern.compile(&quot;(?:jpg|png)&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); System.out.println(matcher.group(1)); &#125; &#125;&#125; 运行结果： 1234jpgException in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: No group 1 at java.util.regex.Matcher.group(Matcher.java:538) at com.wuxianjiezh.regex.RegexTest.main(RegexTest.java:15) 1.8分组的反向引用副本：Java 中可以在小括号中使用 ?&lt;name&gt; 将小括号中匹配的内容保存为一个名字为 name 的副本。 示例： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;@wxj 你好啊&quot;; Pattern pattern = Pattern.compile(&quot;@(?&lt;first&gt;\\w+\\s)&quot;); // 保存一个副本 Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); System.out.println(matcher.group(1)); System.out.println(matcher.group(&quot;first&quot;)); &#125; &#125;&#125; 运行结果： 123@wxj wxj wxj 1.9否定先行断言：我们可以创建否定先行断言模式的匹配，即某个字符串后面不包含另一个字符串的匹配模式。 否定先行断言模式通过 (?!pattern) 定义。比如，我们匹配后面不是跟着 “b” 的 “a”： 1a(?!b) 1.10指定正则表达式的模式：可以在正则的开头指定模式修饰符。 (?i) 使正则忽略大小写。 (?s) 表示单行模式（”single line mode”）使正则的 . 匹配所有字符，包括换行符。 (?m) 表示多行模式（”multi-line mode”），使正则的 ^ 和 $ 匹配字符串中每行的开始和结束。 1.11java中的反斜杠：反斜杠 \ 在 Java 中表示转义字符，这意味着 \ 在 Java 拥有预定义的含义。 这里例举两个特别重要的用法： 在匹配 . 或 { 或 [ 或 ( 或 ? 或 $ 或 ^ 或 * 这些特殊字符时，需要在前面加上 \\，比如匹配 . 时，Java 中要写为 \\.，但对于正则表达式来说就是 \.。 在匹配 \ 时，Java 中要写为 \\\\，但对于正则表达式来说就是 \\。 注意：Java 中的正则表达式字符串有两层含义，首先 Java 字符串转义出符合正则表达式语法的字符串，然后再由转义后的正则表达式进行模式匹配。 1.12易错： [jpg|png] 代表匹配 j 或 p 或 g 或 p 或 n 或 g 中的任意一个字符。 (jpg|png) 代表匹配 jpg 或 png。 1.13内置的字符串正则处理方法：在 Java 中有四个内置的运行正则表达式的方法，分别是 matches()、split())、replaceFirst()、replaceAll()。注意 replace() 方法不支持正则表达式。 方法 描述 s.matches(&quot;regex&quot;) 当仅且当正则匹配整个字符串时返回 true s.split(&quot;regex&quot;) 按匹配的正则表达式切片字符串 s.replaceFirst(&quot;regex&quot;, &quot;replacement&quot;) 替换首次匹配的字符串片段 s.replaceAll(&quot;regex&quot;, &quot;replacement&quot;) 替换所有匹配的字符 实例： 1234567891011121314151617181920package com.wuxianjiezh.regex;public class RegexTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;wxj&quot;.matches(&quot;wxj&quot;)); System.out.println(&quot;----------&quot;); String[] array = &quot;w x j&quot;.split(&quot;\\s&quot;); for (String item : array) &#123; System.out.println(item); &#125; System.out.println(&quot;----------&quot;); System.out.println(&quot;w x j&quot;.replaceFirst(&quot;\\s&quot;, &quot;-&quot;)); System.out.println(&quot;----------&quot;); System.out.println(&quot;w x j&quot;.replaceAll(&quot;\\s&quot;, &quot;-&quot;)); &#125;&#125; 运行结果： 123456789true----------wxj----------w-x j----------w-x-j 1.14：模式和匹配：Java 中使用正则表达式需要用到两个类，分别为 java.util.regex.Pattern 和 java.util.regex.Matcher。 第一步，通过正则表达式创建模式对象 Pattern。 第二步，通过模式对象 Pattern，根据指定字符串创建匹配对象 Matcher。 第三步，通过匹配对象 Matcher，根据正则表达式操作字符串。 来个例子，加深理解： 123456789101112131415161718192021222324252627package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String text = &quot;Hello Regex!&quot;; Pattern pattern = Pattern.compile(&quot;\\w+&quot;); // Java 中忽略大小写，有两种写法： // Pattern pattern = Pattern.compile(&quot;\\w+&quot;, Pattern.CASE_INSENSITIVE); // Pattern pattern = Pattern.compile(&quot;(?i)\\w+&quot;); // 推荐写法 Matcher matcher = pattern.matcher(text); // 遍例所有匹配的序列 while (matcher.find()) &#123; System.out.print(&quot;Start index: &quot; + matcher.start()); System.out.print(&quot; End index: &quot; + matcher.end() + &quot; &quot;); System.out.println(matcher.group()); &#125; // 创建第两个模式，将空格替换为 tab Pattern replace = Pattern.compile(&quot;\\s+&quot;); Matcher matcher2 = replace.matcher(text); System.out.println(matcher2.replaceAll(&quot;\t&quot;)); &#125;&#125; 运行结果： 123Start index: 0 End index: 5 HelloStart index: 6 End index: 11 RegexHello Regex! 1.15：几个常用的例子：1）中文的匹配：[\u4e00-\u9fa5]+ 代表匹配中文字。 12345678910111213141516package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;閑人到人间&quot;; Pattern pattern = Pattern.compile(&quot;[\\u4e00-\\u9fa5]+&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); &#125; &#125;&#125; 运行结果： 1閑人到人间 2）数字范围的匹配：比如，匹配 1990 到 2017。 注意：这里有个新手易范的错误，就是正则 [1990-2017]，实际这个正则只匹配 0 或 1 或 2 或 7 或 9 中的任一个字符。 正则表达式匹配数字范围时，首先要确定最大值与最小值，最后写中间值。 正确的匹配方式： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;1990\n2010\n2017&quot;; // 这里应用了 (?m) 的多行匹配模式，只为方便我们测试输出 // &quot;^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$&quot; 为判断 1990-2017 正确的正则表达式 Pattern pattern = Pattern.compile(&quot;(?m)^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); &#125; &#125;&#125; 运行结果： 123199020102017 3）img标签的匹配：比如，获取图片文件内容，这里我们考虑了一些不规范的 img 标签写法： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;&lt;img src=&apos;aaa.jpg&apos; /&gt;&lt;img src=bbb.png/&gt;&lt;img src=\&quot;ccc.png\&quot;/&gt;&quot; + &quot;&lt;img src=&apos;ddd.exe&apos;/&gt;&lt;img src=&apos;eee.jpn&apos;/&gt;&quot;; // 这里我们考虑了一些不规范的 img 标签写法，比如：空格、引号 Pattern pattern = Pattern.compile(&quot;&lt;img\\s+src=(?:[&apos;\&quot;])?(?&lt;src&gt;\\w+.(jpg|png))(?:[&apos;\&quot;])?\\s*/&gt;&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group(&quot;src&quot;)); &#125; &#125;&#125; 运行结果： 123aaa.jpgbbb.pngccc.png 4）贪婪与非贪婪模式的匹配：比如，获取 div 标签中的文本内容： 1234567891011121314151617181920212223242526package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;&lt;div&gt;文章标题&lt;/div&gt;&lt;div&gt;发布时间&lt;/div&gt;&quot;; // 贪婪模式 Pattern pattern = Pattern.compile(&quot;&lt;div&gt;(?&lt;title&gt;.+)&lt;/div&gt;&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group(&quot;title&quot;)); &#125; System.out.println(&quot;--------------&quot;); // 非贪婪模式 pattern = Pattern.compile(&quot;&lt;div&gt;(?&lt;title&gt;.+?)&lt;/div&gt;&quot;); matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group(&quot;title&quot;)); &#125; &#125;&#125; 运行结果： 1234文章标题&lt;/div&gt;&lt;div&gt;发布时间--------------文章标题发布时间 1.16：在线正则工具：JavaScript、Python在线表达工具]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>初窥门径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用指令（个人向）]]></title>
    <url>%2F2019%2F02%2F26%2Fhexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： Hexo的常用指令： 1.新建文章： 2.新建页面： 3.生成静态页面： 4.开启本地服务器的端口： 5.部署到网页上： 6.清除文件： 7.查看hexo版本： 8.复合指令： 9.卸载hexo： 10.如何安装旧版本hexo： 11.特殊操作：Hexo支持目录： 12.博客加密（个人向） 13.萌宠添加（个人向） Hexo的常用指令：1.新建文章：如果文章名包含空格必须加双引号，如果没有则可以不加。 1$ hexo new &quot;articleName&quot; 2.新建页面：新建一个题为“pageName”的页面，此时会在/source/目录下生成一个名为pageName的文件夹，其中包含一份 index 的md文件； 1$ hexo new page &quot;pageName&quot; 3.生成静态页面：主要是为了方便调试自己的博客，在未发布之前检查是否有问题。 12$ hexo generate$ hexo g 4.开启本地服务器的端口：开启预览访问的端口，默认端口为4000。关闭server使用 ctrl + c。 本地网址如下： 1http://localhost：4000 命令为： 12$ hexo server$ hexo s 在使用hexo server 可能会遇到端口被占用的情况，不妨使用以下指令来更改端口： 1$ hexo server -p 4001 5.部署到网页上：将目录下的 .deploy_git 文件夹部署到Github。部署前需要预先 hexo generate 生成静态文件。 关闭server使用 ctrl + c。 “INFO Deploy done: git”时即表示部署已经完成。 12$ hexo deploy$ hexo d 6.清除文件：清除目录下的缓存文件（db.json）和已经生成的静态文件（public）文件。网页正常情况下可以忽略此条命令。 1$ hexo clean 7.查看hexo版本：查看当前使用的hexo的版本号。 1$ hexo version 8.复合指令：hexo g -d # 等价于 hexo generate –deploy ：生成静态文件并部署。hexo s -d # 等价于 hexo deploy –generate ：开启预览并部署到Github。 简写形式hexo n #等价于 hexo newhexo g #等价于 hexo generatehexo s #等价于 hexo serverhexo d #等价于 hexo deployhexo v #等价于 hexo version 12$ hexo g -d$ hexo s -d 9.卸载hexo：3.0.0版本执行npm uninstall hexo-cli -g，之前版本执行npm uninstall hexo -g. 10.如何安装旧版本hexo：先卸载当前版本，以2.8.3为例，执行npm install hexo@2.8.3 -g，再初始化并安装依赖和插件。 11.特殊操作：Hexo支持目录：1.安装hexo-toc插件： 1npm install hexo-toc --save 2.配置站点配置文件_config.yml： 12toc: maxdepth: 5 3.使用： 在markdown文章中加入TOC占位符即可自动生成目录： 1&lt;!-- toc --&gt; 4.效果： 12.博客加密（个人向）使用：（已配置好） 在博客的开头加上这一段文字即可。 1password: 123456 //自定义密码 13.萌宠添加（个人向）安装插件 1npm install hexo-helper-live2d --save 添加配置 12345678910111213141516171819live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: # 这是白猫的模型 use: live2d-widget-model-tororo display: # 设置模型的位置 position: right width: 120 height: 240 mobile: show: false react: opacityDefault: 1 opacityOnHover: 1 下载模型 1npm install &#123;your model&apos;s package name&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>备忘</tag>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android学习路线总结plus]]></title>
    <url>%2F2019%2F02%2F26%2Fandroid%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%80%BB%E7%BB%93plus%2F</url>
    <content type="text"><![CDATA[目录： 1.java se基础： 2.android UI编程： 1）android初级控件的使用： 2）android高级控件的使用： 3）对话框与菜单的使用： 4）控件的布局方法： 5）多activity的管理： 6）自定义控件的实现方法： 3.android网络编程以及数据储存： 1）基于android平台的http通讯： 2）android数据储存技术： 4.进阶之路： 初级工程师： 中级工程师： 高级工程师： 1.java se基础：1).Java基本数据类型与表达式，分支循环。2).String和StringBuffer的使用、正则表达式。3).面向对象的抽象，封装，继承，多态，类与对象，对象初始化和回收；构造函数、this关键字、方法和方法的参数传递过程、static关键字、内部类。4).对象实例化过程、方法的覆盖、final关键字、抽象类、接口、继承的优点和缺点剖析；对象的多态性：子类和父类之间的转换、抽象类和接口在多态中的应用、多态带来的好处。5).Java异常处理，异常的机制原理。6).常用的设计模式：Singleton、Template、Strategy模式。7).JavaAPI介绍：种基本数据类型包装类，System和Runtime类，Date和DateFomat类等。8).Java集合介绍：Collection、Set、List、ArrayList、LinkedList、Hashset、Map、HashMap、Iterator等常用集合类API。9).JavaI/O输入输出流：File和FileRandomAccess类，字节流InputStream和OutputStream，字符流Reader和Writer，以及相应实现类，IO性能分析，字节和字符的转化流，包装流的概念，以及常用包装类，计算机编码。10).Java高级特性：反射和泛型。11).多线程原理：如何在程序中创建多线程(Thread、Runnable)，线程安全问题，线程的同步，线程之间的通讯、死锁。 2.android UI编程：1）android初级控件的使用：TextView控件的使用Button控件的使用方法EditText控件的使用方法ImageView的使用方法RadioButton的使用方法Checkbox的使用方法Menu的使用方法 2）android高级控件的使用：ListView的使用方法GridView的使用方法Adapter的使用方法Spinner的使用方法Gallary的使用方法ScrollView的使用方法RecyclerView 3）对话框与菜单的使用：Dialog的基本概念BlockquoteAlertDialog的使用方法DatePickerDialog的使用方法Menu的使用方法自定义Menu的实现方法 4）控件的布局方法：线性布局的使用方法相对布局的使用方法 5）多activity的管理：AndroidManifest.xml文件的作用Intent的使用方法使用Intent传递数据的方法启动Activity的方法IntentFilter的使用方法Activity Group的使用方法 6）自定义控件的实现方法：自定义ListView的实现方法可折叠ListView的使用方法自定义Adapter的实现方法自定义View的实现方法动态控件布局的上实现方法上拉刷新下拉加载更多 3.android网络编程以及数据储存：1）基于android平台的http通讯：Http协议回顾使用Get方法向服务器提交数据的方法使用POST方法向服务器提交数据的实现方法使用Http协议实现多线程下载使用Http协议实现断点续传 2）android数据储存技术：SQLite3数据库简介SQL语句回顾SQLite3编程接口介绍SQLite3事务管理SQLite3游标使用方法SQLite3性能分析访问SDCard的方法访问SharedPreferences的方法 4.进阶之路：初级工程师： 基本知识点比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术 书籍推荐《第一行代码 Android》、《疯狂Android》 中级工程师： AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别； Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用； 多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等； 事件分发：弹性滑动、滑动冲突等； 玩转View：View的绘制原理、各种自定义View； 动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理； 懂性能优化、熟悉mat等工具 懂点常见的设计模式 书籍推荐《Android开发艺术探索》、《Android群英传》 高级工程师： 继续加深理解”稍微深入的知识点“中所定义的内容 了解系统核心机制： 了解SystemServer的启动过程 了解主线程的消息循环模型 了解AMS和PMS的工作原理 能够回答问题”一个应用存在多少个Window？“ 了解四大组件的大概工作流程 … 基本知识点的细节 Activity的启动模式以及异常情况下不同Activity的表现 Service的onBind和onReBind的关联 onServiceDisconnected(ComponentName className)和binderDied()的区别 AsyncTask在不同版本上的表现细节 线程池的细节和参数配置 … 熟悉设计模式，有架构意识学习方法 书籍推荐《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》 参考链接]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>总结</tag>
        <tag>学习路线</tag>
        <tag>plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习路线总结（个人向）]]></title>
    <url>%2F2019%2F01%2F14%2FAndroid%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： Java基础： Java高阶： 数据结构及算法： 数据结构： 算法： Android基础： Android技术难点 Android框架层源码掌握 各种原理，经典第三方库源码系列 Android进程通信以及多进程开发 Android动画机制 Android绘图原理 Android页面恢复 混合开发及Android WebView应用 Gradle，自动化构建，持续集成相关 Android系统 Android Studio编译过程 Android架构： Android优化： 移动开发外围 服务器开发相关 前端开发相关 开发调试各种工具 Java基础：Java Object类方法 HashMap原理，Hash冲突，并发集合，线程安全集合及实现原理 HashMap 和 HashTable 区别 HashCode 作用，如何重载hashCode方法 ArrayList与LinkList区别与联系 GC机制 Java反射机制，Java代理模式 Java泛型 Synchronized原理 Volatile实现原理 方法锁、对象锁、类锁的意义和区别 线程同步的方法：Synchronized、lock、reentrantLock分析 Java锁的种类: 公平锁、乐观锁、互斥锁、分段锁、偏向锁、自旋锁等 ThreadLocal的原理和用法 ThreadPool的用法和示例 wait()和sleep()的区别 Java高阶：Java虚拟机，Java运行，Java GC机制（可达性分析法，引用计数法） Java对象的完整生命周期 JVM内存模型 进程间通信，线程间通信 JVM类加载机制 Java引用类型 设计模式：除常用设计模式之外，特别的，反射机制，代理模式 HTTP协议和HTTPS协议 Socket协议，Socket实现长连接 TCP和UDP协议 HTTP协议中GET和POST的具体实现 序列化和反序列化 线程池的实现原理 数据库基础知识：多表查询、索引、数据库事务 数据结构及算法：数据结构：栈和队列 数组和链表，自定义一个动态数组 Hash表，及Hash冲突的解决 二叉树 B+ B-树 基础排序算法：重点 快排、归并排序、堆排序（大根堆、小根堆） 快排的优化 二分查找与变种二分查找 哈夫曼树、红黑树 字符串操作，字符串查找，KMP算法 图的BFS、DFS、prim、Dijkstra算法（高阶技能） 经典问题：海量数据的处理 （10亿个数中找出最大的10000个数 TOP K问题） 算法：分治算法 动态规划 贪心算法 分支限界法 Android基础：Application生命周期 Android Activity生命周期 Android Service、IntentService，Service和组件间通信 Activity的onNewIntent Fragment的懒加载实现，参数传递与保存 ContentProvider实例详解 BroadcastReceiver使用总结 Android消息机制 Binder机制，共享内存实现原理 Android 事件分发机制 Android 多线程的实现：Thread、HandlerThread、AsyncTask、IntentService、RxJava ActivityThread工作原理 嵌套滑动实现原理 RecyclerView与ListView(缓存原理，区别联系，优缺点) View的绘制原理，自定义View，自定义ViewGroup View、SurfaceView 与 TextureView 主线程Looper.loop为什么不会造成死循环 ViewPager的缓存实现 requestLayout，invalidate，postInvalidate区别与联系 AndroidP新特性 Android两种虚拟机 ADB常用命令 Asset目录与res目录的区别 Android SQLite的使用入门 Android开发高级： 附：一般Android高级工程师招聘要求： 熟悉Android SDK，熟悉Android UI，熟悉Android各种调试工具； 有丰富的Android应用架构能力，能够独立主导并架构App；3. Mobile Web 开发经验；具备各种复合技能：熟悉iOS、H5、Python、.NET等多种开发语言的优先考虑； 对Android性能优化，安全，软件加固，自动化测试有深刻认识; 博客，开源项目 Android技术难点AIDL、Binder、多进程、View的绘制流程、事件分发、消息队列等。这类知识对于定位自己为高级Android工程师的人来说是必须掌握的，同时他也是能鉴别高级和初中级工程师的一块试金石，其中binder是Android系统进程间通信最重要的手段之一，现阶段app的发展离不开多进程的运用，经常会启动例如定位、推送等需要在后台开启动的进程来来保证主进程的内存运行；所以合理的使用多进程也是十分必要的；view的绘制是我们自定义控件的理论基础，只有掌握了view是如何绘制的才能个性化的自定义控件；事件分发一直是Android开发的难点之一，也是必须掌握的；关于handler机制也是android的一块难点，因为包括Asynctask、系统启动、Intentservice等底层都是通过handler来实现的，所以掌握后handler机制不仅能提高你的实战开发能力，更能让你系统的了解整个android系统运作的情况。 Android框架层源码掌握Android框架层有很多东西，以下几个是高级程序员必须要掌握的： Android包管理机制，核心PackageManagerService Window管理，核心WindowManagerService Android Activity启动和管理，核心ActivityManagerService 根Activity工作流程 Context关联类 各种原理，经典第三方库源码系列 自定义LayoutManager，RecyclerView中如何自定义LayoutManager VLayout实现原理，即如何自定义LayoutManager Glide加载原理，缓存方案，LRU算法 Retrofit的实现与原理 OKHttp3的使用，网络请求中的Intercept EventBus实现原理 ButterKnife实现原理 RxJava实现原理 Dagger依赖注入 热修复实现原理，解决方案 组件化原理和解决方案 Android进程通信以及多进程开发Android 多进程和Application关系 经典解决方案：多进程通信解决方案：Andromeda Android动画机制经典学习资料：HenCoder: 给高级Android工程师的进阶手册 Android绘图原理经典学习资料：HenCoder: 给高级Android工程师的进阶手册 Android页面恢复Android的页面恢复采用以下两个方法： onSaveInstanceState(Bundle outState) onRestoreInstanceState(Bundle savedInstanceState) onSaveInstanceState: 当Activity容易被系统销毁时，会触发该方法。具体的说 用户点击Home键 用户点击Home键，切换到其他应用程序 有电话来了等附加操作 混合开发及Android WebView应用混合开发涉及到的知识点主要包括： APP调用WebView加载url 掌握WebView的封装，了解所有的WebSettings配置，掌握WebViewClient、WebChromeClient 掌握WebView和Native双向通信机制，会自己封装双向通信中间件 对WebView的封装可参考：GitHub: AgentWeb 对通信中间件原理理解：GitHub：webprogress Gradle，自动化构建，持续集成相关Android系统Android Studio编译过程其中使用到的编译工具： aapt、aidl、Java Compiler、dex、 zipalign 主要步骤描述： 通过aapt打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样） 处理.aidl文件，生成对应的Java接口文件 通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex 通过apkbuilder工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk 通过Jarsigner工具，对上面的apk进行debug或release签名 通过zipalign工具，将签名后的apk进行对齐处理。 Android架构： MVC模式 MVP模式 MVVM模式 CLEAN模式 组件化开发 跨平台开发：Flutter、ReactNative（RN未来要黄，了解一下就好） Android优化： 移动开发外围服务器开发相关 SpringBoot技术 Restful API开发 网络协议理解：TCP/IP、HTTP/HTTPS、OSI七层协议 授权认证协议： OAuth2.0 等 基本的数据库技术 数据缓存技术：Memcached、Redis，Web缓存原理 消息队列技术 监控、日志分析技术 前端开发相关前端开发知识很多，框架层出不穷，本质的东西却只有以下这些。 核心必备：HTML、CSS、JavaScript 入门提高：浏览器兼容性、自定义UI和动效 中级技能：框架层出不穷，当前以vue.js、react.js 为核心 协作开发技能：包管理、模块化，工具采用 npm、webpack等 高级技能：框架原理源码研究 开发调试各种工具 性能分析工具：Memory Monitor 性能追踪及方法执行分析： TraceView 视图分析：Hierarchy Viewer ApkTool- 用于反向工程Android Apk文件的工具 Lint- Android lint工具是一个静态代码分析工具 Dex2Jar- 使用android .dex和java .class文件的工具 参考链接]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>总结</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用语法]]></title>
    <url>%2F2019%2F01%2F12%2FMarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录： 前言 一.标题 二.字体 三.引用 四.分割线 五.图片 六.超链接 七.列表 八.表格 九.代码 十.流程图 前言​ Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 一.标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 注意：这里的标准语法是必须#结束后再加上一个空格再加上想要写的文字。（但是有些地方貌似不加空格也可以，例如简书。但是最好还是按照标准的语法来写） 二.字体加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 三.引用在引用的文字前面加上&gt;即可。引用也可以嵌套，比如说两个&gt;&gt;三个&gt;&gt;&gt;之类的，貌似可以一直加下去，但是好像没什么用… 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;这是引用的内容 四.分割线三个或者三个以上的-或者*都可以。 1234-------******** 五.图片1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 六.超链接12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 例如： 12[简书](http://jianshu.com)[百度](http://baidu.com) 七.列表无序列表用-+*任何一种都可以。 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 有序列表数字加点即可。 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 列表嵌套：上一级和下一级之间敲上三个空格即可。 八.表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 九.代码单行代码直接代码之间分别用一个反引号包起来即可。 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行。 12345(```) 代码... 代码... 代码...(```) 十.流程图123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; ` 参考文章：Markdown基本语法]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Android6.0以上部分权限的动态获取]]></title>
    <url>%2F2019%2F01%2F12%2F%E5%85%B3%E4%BA%8EAndroid6-0%E4%BB%A5%E4%B8%8A%E9%83%A8%E5%88%86%E6%9D%83%E9%99%90%E7%9A%84%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[普通权限暂且不表，下面只列举Android6.0以后必须进行动态申请的权限。 下面以SD卡读取权限作为例子（如果实在不懂的话可以直接复制粘贴，只需要改一下权限的名称即可）： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 请求授权 */ private void requestPermission()&#123; if (Build.VERSION.SDK_INT &gt;= 23) &#123; int checkCallPhonePermission = ContextCompat.checkSelfPermission (this, Manifest.permission.READ_EXTERNAL_STORAGE); if (checkCallPhonePermission != PackageManager.PERMISSION_GRANTED) &#123; //在String[]中传入需要申请的权限 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 1); &#125; else&#123; //sendHomework(); //已经拥有了权限 Toast.makeText(this,"已经获取读SD卡权限",Toast.LENGTH_SHORT).show(); &#125; &#125; else &#123; //低版本 Toast.makeText(this,"已经获取读SD卡权限",Toast.LENGTH_SHORT).show(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //sendHomework(); //获取权限成功后的处理 Toast.makeText(this,"已经成功获取读SD卡权限",Toast.LENGTH_SHORT).show(); &#125; else &#123; //showToast("fail"); //获取权限失败的处理 Toast.makeText(this,"获取读SD卡权限失败",Toast.LENGTH_SHORT).show(); &#125; break; default: super.onRequestPermissionsResult(requestCode, permissions, grantResults); &#125; &#125; 对于新手来说，需要注意的是，如果你想要使用这个动态权限，除了上面这段代码之外，你还需要在项目的Manifest中注册你想要获取的权限（一般来说，只要不是危险权限，无论Android6.0前后，只要注册之后就可以直接使用了，但是危险权限，除了注册之外还需要手动的动态申请）。 另外，除了上面这段代码和注册之外，还需要在初始化之前在MainActivity中写上 1requestPermission() 来调用下面写的动态申请。 参考文章：Android6.0动态权限]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动态权限</tag>
        <tag>安卓6.0以上</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真机调试时如何用Androidstudio查询SQLite数据库]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E6%97%B6%E5%A6%82%E4%BD%95%E7%94%A8Androidstudio%E6%9F%A5%E8%AF%A2SQLite%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[目录： 前言： 1.首先在app对应下的build.gradle里面添加下面依赖： 2.自定义一个MyApplication继承Application，在onCreate中初始化stetho： 3.修改下列相关： 4.打开Chrome浏览器，输入网址： 5.点击弹出的网页Resource-&gt;Web SQL即可看到，下面是我的数据库显示情况： 前言：今天在调试一个有关于SQLite数据库的app的时候，突发奇想，想在手机上直接找到对应的db文件查看，结果是显而易见的，并没有找到相应的调试app的包名以及对应的文件夹。 然后在网上找了很多方法，试过之后，找到一个较方便且便捷的方法。如下： 1.首先在app对应下的build.gradle里面添加下面依赖：1234// Stetho coreimplementation &apos;com.facebook.stetho:stetho:1.3.1&apos;//If you want to add a network helperimplementation &apos;com.facebook.stetho:stetho-okhttp3:1.3.1&apos; 2.自定义一个MyApplication继承Application，在onCreate中初始化stetho：123456789101112131415public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); init(); &#125; private void init()&#123; Stetho.initializeWithDefaults(this); new OkHttpClient.Builder() .addNetworkInterceptor(new StethoInterceptor()) .build(); &#125;&#125; 3.修改下列相关：在AndroidManifest.xml中修改android:name=”.MyApplication” 然后运行app到手机上即可。 4.打开Chrome浏览器，输入网址：1chrome://inspect 操作好之后就是显示手机型号，下面有一个inspect直接点击即可。 5.点击弹出的网页Resource-&gt;Web SQL即可看到，下面是我的数据库显示情况： 这样就很简单啦，又方便又快捷！]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SQLite</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶（个人向）]]></title>
    <url>%2F2019%2F01%2F09%2FHexo%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言： 正文： 关于如何将自己的博客推送至百度与谷歌（默认情况下是不会被爬取的，这个时候就需要我们主动出击，让我们的博客可以直接被搜索到） 提交百度搜索引擎：（谷歌同理，过程一样） 站点地图： 安装百度谷歌的站点地图： 向谷歌提交链接： 百度收录： sitemap： 结语：百度的抓取速度是真的慢，另外，github.io的博客不允许百度蜘蛛爬取，直接再把博客推送到coding.me即可，百度收录的时候一定要用coding.me的网址。关于如何推送到coding，与github类似… 前言：首先，在我们刚刚搭建好这个博客的时候，我们会发现自己的博客显得很是简陋以及，单调，这个时候就是显示个性化的好时机了。hexo主题个性化是一个集合了许多方法的网址，可以参考。当然这只是沧海一粟，不值一提。还有更多的，诸如留言板，相册，网易云外链之类的优秀功能，具体详情可以直接百度，这里不过多赘述。 正文：关于如何将自己的博客推送至百度与谷歌（默认情况下是不会被爬取的，这个时候就需要我们主动出击，让我们的博客可以直接被搜索到）原因：Github和Coding都做了防爬虫处理，这样子我们博客可能就无法被搜索引擎收录，需要我们手动提交！ 验证是否被百度或者谷歌收录，即在相应的搜索栏中输入： 1site: thbelief.coding.me （注：site:后面是你的博客网址） 如果显示找不到相关网址，即没有被收录。如果找到了….那就恭喜不用操作了。 言归正传，回到正题。 提交百度搜索引擎：（谷歌同理，过程一样）登录百度搜索引擎 ps：可能需要个人信息认证，按照提示认证即可！ 然后是：添加站点-&gt;输入博客网址-&gt;设置站点领域（我设置的是信息技术）-&gt;选择验证方式。 这里只介绍第一种验证方式：文件验证 1.请点击 下载验证文件 获取验证文件 2.将验证文件放置于您所配置hexo博客的根目录下 3.点击这里确认验证文件可以正常访问 4.请点击“完成验证”按钮 注：为保持验证通过的状态,成功验证后请不要删除HTML文件 然后git bash输入框内输入hexo g -d部署到网站上面即可。 站点地图：站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 安装百度谷歌的站点地图：123npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 然后打开站点配置文件： 将url设置为你的站点名称。 然后执行hexo clean 以及 hexo g。 这样在你的网站根目录的public文件夹下生成sitemap.xml文件和baidusitemap.xml文件： 其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。 向谷歌提交链接：google站点平台：谷歌站点，然后就是注册账号、验证站点、提交sitemap， 提交site之后即可。 注意：无论是百度还是谷歌，都不是已通过就能直接搜索到，谷歌大致需要几小时，百度大致一个月左右，请耐心等待。 百度收录：百度收录较慢。故设置自动推送： 在主题配置文件下设置,将baidu_push设置为true： 12# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true sitemap：将生成的baidusitemap.xml提交到百度站点 点击链接提交： 然后刷新页面即可。 结语：百度的抓取速度是真的慢，另外，github.io的博客不允许百度蜘蛛爬取，直接再把博客推送到coding.me即可，百度收录的时候一定要用coding.me的网址。关于如何推送到coding，与github类似…]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用hexo+Github搭建个人博客（个人向）]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： hexo的介绍 准备 NodeJS Hexo安装 GitHub部分 Github Page 配置SSH 发布 更改主题 hexo的介绍官网上的描述是Hexo是一个快速，简单而强大的博客框架。我们可以使用Markdown（或其他语言）来编写文章，同时Hexo可以在几秒钟内生成具有美丽主题的静态文件以供我们使用。 简单来说它就是一个主打简单快速的博客框架，这个可以对比下知名度更高一些的WordPress，相对来说后者更强，不过更适合有服务器的人使用，只想做一个简单博客的首选hexo。 准备首先必须安装Git和NodeJS。（安装过程傻瓜式next操作即可） 注意一点就是NodeJS的路径。推荐D:\NodeJS (原因后面会阐述) 检测NodeJS是否安装成功的方式是： 输入Win+R输入cmd打开控制台输入下面代码： 12node -vnpm -v 如果两个都返回版本号即安装成功，否则需要再配环境变量。 NodeJS1.在NodeJS安装路径下面建立”node_global”及”node_cache”两个文件夹。 2.启动cmd输入： 12npm config set prefix &quot;D:\Program Files\nodejs\node_global&quot;npm config set cache &quot;D:\Program Files\nodejs\node_cache&quot; 3.配置环境变量： 环境变量-&gt;Path-&gt;编辑：添加上下面三行：（有的话就不用了） 123D:\NodeJS\D:\NodeJS\node_globalD:\NodeJs\node_cache 4.测试是否配置完成： 如果打开cmd输入下面代码然后在node_global目录下有express目录即完成了。 1npm install express -g Hexo安装打开git bash（为了避免出现错误后面的操作在git bash进行） 首先新建一个存放hexo文件的目录，例如在D盘根目录新建hexo文件夹，然后cd到该目录下，开始安装 1234567$ cd D:hexo/ #换成你的目录$ npm install -g hexo-cli #安装hexo脚手架$ hexo init #Hexo自动在当前文件夹下下载搭建网站所需的所有文件$ npm install #安装依赖包$ hexo g #完整命令为hexo generate，生成静态文件$ hexo s #完整命令为hexo server，启动服务器，用来本地预览 用浏览器访问http://localhost:4000，这时就可以看到了一个比较漂亮的博客了，这个是hexo的默认主题landscape，而我们会使用的是NexT主题，后面会说到怎么配置。 GitHub部分Github Page打开github主页，新建仓库（repository），这里要注意仓库的名称，比如我的帐号是thbelief，那么仓库名称应该是：thbelief.github.io。然后选择Public（公开）。 配置SSH以上过程完成后就是把hexo生成的静态页面上传了，到这里还没结束，还需要配置SSH，首先要本地生成公钥私钥 1$ ssh-keygen -t rsa -C &quot;你的邮件地址&quot; 引号里面的内容输入你的邮箱地址，然后回车，会提示你文件保存的路径，这时候按回车键确认，然后会提示你输入密码，输入即可（输入密码是看不到的），然后会确认输入一次，就可以在刚刚的路径看到生成了两个文件，一个是id_rsa，另一个是id_rsa.pub，用sublime打开id_rsa.pub然后选中里面的全部内容，复制下来。打开GitHub或Coding的SSH页面Github：setting–&gt;SSH and GPG keys–&gt;New SSH key在Key下面的框中粘贴刚刚复制的东西。 发布打开D:\hexo，用sublime打开_config.yml文件，文件最后可以看到 12deploy: type: 修改（注意要换上自己的链接） 12345deploy: type: git repository: git@github.com:yourname/yourname.github.io.git #发布到github #repository: git@git.coding.net:yourname/yourname.git #发布到Coding branch: master ctrl+s保存修改。打开git bash在当前目录输入以下命令： 1$ hexo d #完整命令为hexo deploy，将本地文件发布到page服务平台上 如遇遇到异常可以 12$ hexo clean &amp;&amp; hexo g$ hexo d 如果出现以下异常 1ERROR Deployer not found: git 尝试输入以下命令，然后重新执行刚刚的两条命令 1$ npm install hexo-deployer-git --save 这时候如果弹出一个对话框，输入在github/coding上面的用户名和密码即可这时候我们就可以在浏览器输入https://yourname.github.io 或者https://youname.coding.me 打开。（yourname记得替换） 更改主题D:\hexo目录下的theme文件夹下存放的就是博客的主题，hexo便是依据主题来生成静态文件的，挑选主题可以在官网https://hexo.io/themes/ 查找，根据自己的喜好来挑选。下载主题的一般方式如下： 12$ cd your-hexo-site #eg:D:\hexo$ git clone &#123;主题链接&#125; themes/&#123;主题名称&#125; 但是最好还是直接去官网下载压缩包解压到hexo目录下面的themes中，因为国内下这个很慢。（解压的时候名字一定要换成next，方便后序操作） 其实还有一种方法，也是对第一种方法的补充，直接更换npm的来源地，换成淘宝的即可，详情百度，这里不过多赘述。 启用主题的方式也很简单sublime打开上文提到的hexo目录下的_config.yml，ctrl+f输入theme查找这个关键字，修改其主题名称为下载的主题名称即可。 1theme: &#123;主题名称&#125; 以本人使用的next主题为例：下载最新版： 12$ cd D:hexo/$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改hexo目录下的_config.yml 1theme: next 具体可以到主题官网看看–NexT 参考文章：hexo搭建个人博客]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
</search>
