<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础-渐入佳境]]></title>
    <url>%2F2019%2F03%2F21%2Fjava%E5%9F%BA%E7%A1%80-%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83%2F</url>
    <content type="text"><![CDATA[目录： 前言 对象实例化过程 方法的覆盖 定义 特点 final关键字 数据 类 方法 空final 前言关于Java基础系列的学习路线，我已经在安卓学习路线总结plus里面写到了，我是按照那个上面的路线来学习的，如果有不明白的地方的话，可以移步前往作为 参考，也可以当成是目录。 对象实例化过程1.检查类是否已经加载，如果没有加载的话就加载这个类，需要加载所有的父类。 2.在内存堆中分配对象空间，递归分配所有父类和子类属性空间.先父类型再子类型,属性默认自动初始化.自动初始化为”0”值。 3.进行属性的赋值。 4.递归调用父类的构造器（默认的是调用父类的无参数构造器）。 5.调用本类的构造器。 注意： 1）静态初始化是指执行静态初始化块儿里面的内容。 2）实例初始化是指执行实例初始化块儿里面的内容。 3）构造方法：一个名称跟类的名称一样的方法，特殊在于不带返回值。 实例： 123456789101112131415161718192021222324252627public class TestInstanceInit &#123;public static int n = 0;// 静态变量static &#123;// 这是静态初始化块print();System.out.println(&quot;this is static block&quot;);&#125;&#123;// 实例初始化块System.out.println(n);&#125;public TestInstanceInit() &#123;// 构造方法System.out.println(&quot;this is TestInstanceInit&apos;s constructor~&quot;);&#125;public static void print() &#123;// 静态方法System.out.println(&quot;this is static method~&quot;);System.out.println(n);n += 1;&#125;public static void main(String[] args) &#123;new TestInstanceInit();&#125;&#125; 输出结果是: 12345this is static method~0this is static block1this is TestInstanceInit&apos;s constructor~ 执行顺序： (静态变量、静态初始化块)&gt;(变量、初始化快)&gt;构造器。 静态变量和静态初始化快/变量和初始化快的先后顺序取决于它们在类中出现的先后顺序。 参考链接 方法的覆盖定义如果在子类中定义一个方法，其名称、返回类型及参数签名正好与父类中某个方法的名称、返回类型及参数签名相匹配，那么可以说，子类的方法覆盖了父类的方法。 特点 子类的方法名称返回类型及参数签名 必须与父类的一致。 子类方法不能缩小父类方法的访问权限。 子类方法不能抛出比父类方法更多的异常。 方法覆盖只存在于子类和父类之间，同一个类中只能重载。 父类的静态方法不能被子类覆盖为非静态方法。 子类可以定义于父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法（满足覆盖约束）， 而且Java虚拟机把静态方法和所属的类绑定，而把实例方法和所属的实例绑定。 父类的非静态方法不能被子类覆盖为静态方法。 父类的私有方法不能被子类覆盖。 父类的抽象方法可以被子类通过两种途径覆盖（即实现和覆盖）。 父类的非抽象方法可以被覆盖为抽象方法。 final关键字在Java中final关键字可以用来修饰数据，方法，参数以及类。 数据final修饰的基本类型，在初始化之后就不能在赋值了，同理，修饰的对象一旦引用被初始化指向一个对象的话，就无法把它改指向另外一个对象。 但是要注意，被final修饰的对象引用，只是对象的应用不能修改，但是其自身却是可以修改的。 类当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。 final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。 方法使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。 注意:类的private方法会被隐式的指定为final方法。 空final谓的”空白final”是指被声明的为final但又为给定初值的对象引用或者基本数据。无论在什么情况下，编译器都会去确保final在使用前必须被初始化。若不进行初始化，会提示错误，这就意味着，必须在域的定义处或者每个构造器中使用表达式对final进行赋值，这正是final域在使用前被初始化的原因所在。]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>渐入佳境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(二)]]></title>
    <url>%2F2019%2F03%2F20%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[目录： 函数定义与调用 定义函数 调用函数 特殊arguments rest参数 变量相关 变量提升 全局作用域 名字空间 局部作用域 常量 解构赋值 方法 apply 装饰器 四个常用的高阶函数 map reduce filter sort 闭包 函数作为返回值 箭头函数 generator 优势 函数定义与调用定义函数第一种方法如下： 123function hanshu()&#123; ...&#125; 1.function指出这是一个函数定义； 2.hanshu是函数的名称； 3.(x)括号内列出函数的参数，多个参数以,分隔； 4.{ … }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。 第二种方法如下： 123var hanshu = function (x) &#123; ...&#125;; function (x) { … }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量hanshu，所以，通过变量hanshu就可以调用该函数。这两种其实是完全等价的，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 调用函数JS中有点儿特殊，主要就是特殊在JS中对于一个函数传进去的参数不做限制，传多了没有问题，只是在内部没有用而已，传少了的话计算结果会变成NaN。如果想保险一点儿的话，可以直接在函数里面对于传进来的参数做判断即可。 特殊arguments在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array。意思也就是，就算函数并没有定义任何的变量，也是可以拿到参数的值。 rest参数（ES6引入）rest参数只能写在最后，前面用…标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。 特别注意:JS里面有一个自动在行末添加分号的性质，所以特别需要注意。 变量相关注意，由于JS支持函数嵌套，在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。 变量提升JS函数的特性，它执行前会扫描整个函数体，把所有声明的变量都放到顶部。但是要注意，它只是提升变量的声明，并没有提升变量的赋值。 所以为了避免有些错误，建议是在函数体内，把所有的变量声明都放到函数的开头。 全局作用域不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性。 1234var bianliang=&apos;thbelief&apos;;function hanshu()&#123; ...&#125; 这里的话，访问bianliang与访问window.bianliang是完全一样的。 同时，第二种函数的定义方式其实也是一种全局的。 123var hanshu = function (x) &#123; ...&#125;; 所以，其实JS只有一个全局作用域。 名字空间全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。 例如: 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = &apos;myapp&apos;;MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return &apos;foo&apos;;&#125;; 这个其实是一个特别实用的方法，必须提倡。 局部作用域在循环中，一般使用let替代var声明次级作用域的变量。 12345678&apos;use strict&apos;;function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; i += 1;&#125; 常量ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域。但是需要注意，不是所有的地方都支持，因为ES6才引进。 解构赋值可以直接对多个变量同时赋值。 123&apos;use strict&apos;;// 如果浏览器支持解构赋值就不会报错:var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;]; 注意，对数组元素进行解构赋值时，多个变量要用[…]括起来。 有些时候数组本身还有嵌套，也可以解构赋值，但是需要保持嵌套层次和位置的一致性。 解构赋值还有很多用法，这里就不一一阐述了，需要的时候直接去查就好啦。 方法在一个对象中绑定函数，这就是这个对象的方法。 1234567891011var thbelief = &#123; name: &apos;thbelief&apos;, birth: 1999, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;thbelief.age; // function thbelief.age()thbelief.age(); 同时，this关键字在JS里面也有和C++同样的作用，可以直接调用本函数的方法。 但是一定要用对象的形式调用，这才是指向本函数里面的方法，不然的话就是对于整个全局作用域来说的。 解决的方法其实也有，就是var that = this;这条语句加上去在用的地方就可以了。 apply虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，还是可以控制this的指向！ 要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 用apply修复getAge()调用： 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var thbelief = &#123; name: &apos;thbelief&apos;, birth: 1999, age: getAge&#125;;thbelief.age(); getAge.apply(thbelief, []); 另一个与apply()类似的方法是call()，唯一区别是： apply()把参数打包成Array再传入； call()把参数按顺序传入。 比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下： 12Math.max.apply(null, [3, 5, 4]); // 5Math.max.call(null, 3, 5, 4); // 5 装饰器利用apply()，我们还可以动态改变函数的行为。 JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。 四个常用的高阶函数mapmap可以传入任意的变量或者自己定义的相关函数，比如说做一个2的次方运算，相比较于我们傻乎乎的使用循环一层一层的套，map作为高阶函数无疑是更加具有实力的。 1234567&apos;use strict&apos;;function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] reduceArray的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算。 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x * 10 + y;&#125;); // 13579 filter其实有点儿类似于Android里面的过滤器。它的作用就是将Array里面的某些元素过滤掉，然后返回剩下的元素。 和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 12345var arr = [&apos;A&apos;, &apos;&apos;, &apos;B&apos;, null, undefined, &apos;C&apos;, &apos; &apos;];var r = arr.filter(function (s) &#123; return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法&#125;);r; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] sort需要注意的是，sort默认的排序不是简简单单的针对于数字进行排序。 它的默认把所有元素先转换为String再排序。 同时，作为一个函数，sort可以传入一个比较函数来作为依据。 比如说下面这个按照数字大小来进行排序： 1234567891011&apos;use strict&apos;;var arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;); 闭包函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 12345678function lazy_sum(arr) &#123; var sum = function () &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;); &#125; return sum;&#125; 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数： 1var f = lazy_sum([1, 2, 3, 4, 5]); // function sum() 调用函数f时，才真正计算求和的结果： 1f(); // 15 函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种“闭包（Closure）”的程序结构拥有极大的威力。 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为它只会锁定最后一个结果。如果一定要引用循环变量的话，方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。 闭包还有很多应用，这里只是阐述基本概念，相关的使用要用的时候自己查即可。 箭头函数是在ES6之后推出的，只支持ES6之后的版本。 12345x =&gt; x * x;//两者完全等价function (x) &#123; return x * x;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。 箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。 还有一种可以包含多条语句，这时候就不能省略{ … }和return： 12345678x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125; 1234567891011121314// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 如果要返回一个对象，并且是单表达式： 12// ok:x =&gt; (&#123; foo: x &#125;) this： 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。由于this在箭头函数中已经被绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略… generatorgenerator（生成器）是ES6新引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。 定义： 12345function* foo(x) &#123; yield x + 1; yield x + 2; return x + 3;&#125; generator和函数不同的是，generator由function定义（注意多出的号），并且，除了return语句，还可以用yield返回多次。 优势1.因为generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。 2.把异步回调代码变成“同步”代码。（深） 参考链接]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto.js Script开发(一)]]></title>
    <url>%2F2019%2F03%2F19%2FAuto-js-Script%E5%BC%80%E5%8F%91-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： 简介 正文 总结 下个版本 简介Auto.js使用JavaScript作为脚本语言，目前使用Rhino 1.7.7.2作为脚本引擎，支持ES5与部分ES6特性。 最开始接触Auto.js只是单纯的想写一个I西科自动签到的脚本，接触后才发现，写这样一个脚本其实简单的不行，然后了解了Auto.js的相关特性之后，我决定好好的学习一下这个工具，毕竟，它实在是太简约了，不像其他的脚本语言那么复杂，虽然…有点儿bug，毕竟开发者自己也只是一个大学生，不能指望有多完善，但是这种自动化脚本编辑实在是太有魅力了。 正文最近正在开发的Script，主要目的是借用Auto.js自带的UI模块儿集成一个个人向的脚本库。 这个版本的展示图： 目前代码展示如下，由于太简单，懒得上传到Github了，直接贴代码（后期如果有升级或者说是改良，会在下一个博客继续写） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&quot;ui&quot;;//下面就是主界面ui.layout( &lt;vertical&gt; &lt;horizontal&gt; &lt;text text=&quot;菜单&quot; w=&quot;*&quot; h=&quot;*&quot; layout_weight=&quot;1&quot; gravity=&quot;center&quot; textSize=&quot;30sp&quot; color=&quot;#000000&quot;/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;autoReply&quot; text=&quot;QQ自动回复&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;button id=&quot;autoReplyClose&quot; text=&quot;关闭&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;/horizontal&gt; &lt;horizontal&gt; &lt;button id=&quot;autoSignIn&quot; text=&quot;i西科自动签到&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;button id=&quot;autoSignInClose&quot; text=&quot;关闭&quot; w=&quot;*&quot; h=&quot;*&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; layout_weight=&quot;1&quot;/&gt; &lt;/horizontal&gt; &lt;/vertical&gt;);//封装的回复方法function WhatReply(notificationText)&#123; if(notificationText==&apos;A&apos;)&#123; return(&quot;您好，我是主人正在开发的人工智障robot001.\n ——robot001欢喜的答道。&quot;); &#125; else if(notificationText==&apos;B&apos;)&#123; return(&quot;好的，我马上联系主人...\n ——robot001郑重的答道。&quot;); &#125; else&#123; return &quot;主人在忙呢！\n有问题请回复下列单个字母：\n A.robot是谁？\n B.有要事迅速联系thbelief. \n ——robot001如此回答道。&quot;; &#125;&#125;//先封装一个自动回复的方法function autoReplyFunction()&#123; auto();//检查是否开启了无障碍服务权限 events.observeNotification();//监听消息 events.onNotification(function(notification)&#123; var string1=&quot;com.tencent.mobileqq&quot;;//如果是QQ消息的话 if(string1==notification.getPackageName())&#123; notification.click();//点击直接进入对应的聊天界面 //跳转必须要用startActivity waitForPackage(&quot;com.tencent.mobileqq&quot;); var t=className(&quot;android.widget.EditText&quot;).id(&quot;input&quot;).findOnce();//找到聊天输入控件 t.setText(WhatReply(notification.getText()));//这里加入回复的方法 className(&quot;android.widget.Button&quot;).id(&quot;fun_btn&quot;).findOnce().click();//发送即可 home();//直接返回桌面 &#125; &#125;);&#125;;//自动签到的方法function autoSignInFunction()&#123; auto(); //打开i西科 launchApp(&quot;i西科&quot;); //跳转到相应的界面 waitForPackage(&quot;org.weixvn.frame&quot;); //找到首页上签到的按钮，点击进去 id(&quot;it_sign_in&quot;).clickable().findOne().click(); waitForActivity(&quot;com.example.z.iswust.view.activity.impl.SignInActivity&quot;); //点击签到 if(id(&quot;btn_signin&quot;).clickable().findOne().click())&#123; //完成任务后返回桌面 home(); toast(&quot;签到成功了哟，亲~~~&quot;); &#125; &#125;//自动回复按钮的点击事件ui.autoReply.click(()=&gt;&#123; //UI模式的情况下必须用Promise形式或者回调模式 confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123; if(sure)&#123; //修改控件信息必须更改线程 threads.start(function()&#123; autoReplyFunction(); &#125;) &#125; &#125;);&#125;);//自动回复按钮的关闭点击事件ui.autoReplyClose.click(()=&gt;&#123; //这里由于只有一个脚本，我就直接把所有的脚本都关闭了，如果是很多脚本的话必须改 engines.stopAll(); toast(&quot;自动回复脚本已经关闭了哦，亲~&quot;);&#125;);//i西科自动签到的点击事件ui.autoSignIn.click(()=&gt;&#123; confirm(&quot;友情提示：亲，请确保你的无障碍服务权限以及通知使用权限打开了哟~~~&quot;).then(sure =&gt; &#123; if(sure)&#123; //修改控件信息必须更改线程 threads.start(function()&#123; //自动签到的方法 autoSignInFunction(); &#125;) &#125; &#125;);&#125;); 总结1.一定要判断是否开启了无障碍服务权限以及通知使用权。 2.无论是不是用intent跳转页面或者应用，都应该用waitForActivity或者waitForPackage来跳转，不然容易出错。 3.基于控件的操作的时候，一定要注意寻找的依据，尽量使用不重复的依据，例如desc或者说id这种，提高兼容性。 4.方法的封装应该是根据功能来的，这一点本版本还没有做完善。 5.提示信息一定要做到位，该Toast的地方就一定要毫不犹豫的Toast. 6.如果想进入某个界面做某事，可以直接在外面套个if，这样出错的几率会小很多，比如说本版本的autoSignInFunction函数里面的点击签到。 7.UI模式情况下必须使用Promise形式或者说是回调模式。 8.还有就是，运行多个脚本的时候，都要使用多线程。 下个版本1.UI界面做的是真的丑，下个版本尽量修复。 2.添加检查更新的功能，直接app内检查更新并更新到最新版本。 3.添加更多的脚本选项。 4.定时运行，比如说，定时自启之类的，例如本版本的i西科自动签到功能，定时启动签到。]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Auto.js</category>
      </categories>
      <tags>
        <tag>移动端开发</tag>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>脚本</tag>
        <tag>Script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记(一)]]></title>
    <url>%2F2019%2F03%2F18%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[目录： 入门 基本语法 数据类型 Number 字符串 布尔值 比较运算符 null和undefined 数组 对象 变量 strict模式 字符串 数组 length indexOf slice push和pop unshift和shift sort reverse splice concat join 多维数组 对象 条件判断 循环 for…in while do while Map和Set iterable 入门基本语法每个语句以;结束，语句块用{...}。但是，JavaScript并不强制要求在每个语句的结尾加;，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上;。 数据类型NumberJS里面不区分整数和浮点数，都是用Number统一表示。 123456123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity 字符串字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分。 布尔值只表示true或者false。和C++与Java中完全类似，这里不过多赘述。 比较运算符注意，JavaScript允许对任意数据类型做比较。 12false == 0; // truefalse === 0; // false 特别要注意上述两种格式。 第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 这是JS自身设计的缺陷，大佬们都是推荐的是不要使用==比较，始终坚持使用===比较。 还要注意一点是，NaN这个特殊的Number与所有值都不相等，包括它自己。 1NaN === NaN; // false 唯一能够判断NaN的方法就是isNaN()函数。 1isNaN(NaN); // true 最后，浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： 1Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true null和undefinednull表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。 1[1, 2, 3.14, &apos;HelloWorld&apos;, null, true]; 创建数组的另一个方法是Array()函数来实现： 1new Array(1, 2, 3); // 创建了数组[1, 2, 3] 对象JavaScript的对象是一组由键-值组成的无序集合。 12345678var person = &#123; name: &apos;thbeleif&apos;, age: 20, tags: [&apos;js&apos;, &apos;web&apos;, &apos;mobile&apos;], city: &apos;mianyang&apos;, hasCar: false, zipcode: null&#125;; JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性。 要获取一个对象的属性，需要用对象变量.属性名的方式： 12person.name; // &apos;thbelief&apos;person.zipcode; // null 变量变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。 在Chrome浏览器里面使用JS的时候，可以直接使用console.log(x)来打印变量的值。 相比较于alert()的对话框，前者看起来无疑是更舒心的。 strict模式在JS设计之初，如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量。 后面有了改良，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。 启用strict模式的方法是在JavaScript代码的第一行写上即可： 1&apos;use strict&apos;; 字符串如果字符串内部既包含’又包含”可以用转义字符\来标识。 1&apos;I\&apos;m \&quot;OK\&quot;!&apos;; ASCII字符可以以\x##形式的十六进制表示。 1&apos;\x41&apos;; // 完全等同于 &apos;A&apos; 还可以用\u####表示一个Unicode字符。 1&apos;\u4e2d\u6587&apos;; // 完全等同于 &apos;中文&apos; 由于多行字符串用\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ` … ` 也可以表示。 123`这是一个多行字符串`; 要把多个字符串连接起来，可以用+号连接。 1234var name = &apos;小明&apos;;var age = 20;var message = &apos;你好, &apos; + name + &apos;, 你今年&apos; + age + &apos;岁了!&apos;;alert(message); 字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果。JS对于字符串提供了许多的方法，但是调用这些方法只会返回一个新的字符串，而不会改变原有的字符串内容。 123toUpperCase()把一个字符串全部变为大写。indexOf()会搜索指定字符串出现的位置。substring()返回指定索引区间的子串。 数组lengthJavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。 Array可以通过length属性来取得长度。 同时，直接给Array的length赋一个新的值会导致Array大小的变化。 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array。 如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化。 123var arr = [1, 2, 3];arr[5] = &apos;x&apos;;arr; // arr变为[1, 2, 3, undefined, undefined, &apos;x&apos;] indexOfArray也可以通过indexOf()来搜索一个指定的元素的位置。 12345var arr = [10, 20, &apos;30&apos;, &apos;xyz&apos;];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf(&apos;30&apos;); // 元素&apos;30&apos;的索引为2 sliceslice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array。 123var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]arr.slice(3); // 从索引3开始到结束: [&apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;] 注意到slice()的起止参数包括开始索引，不包括结束索引。 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。 1234var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;];var aCopy = arr.slice();aCopy; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;]aCopy === arr; // false push和poppush()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉。 unshift和shift如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉。 sort按照默认顺序进行排序，也可以自定义顺序。 reverse翻转整个Array，把元素顺序翻转过来。 splice从指定的索引开始删除若干元素，然后再从该位置添加若干元素。 12345678910var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]// 只删除,不添加:arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]// 只添加,不删除:arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;] concat把当前的Array和另一个Array连接起来，并返回一个新的Array。 值得注意的是，concat()方法并没有修改当前Array，而是返回了一个新的Array。 join把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。如果Array的元素不是字符串，将自动转换为字符串后再连接。 多维数组如果数组的某个元素又是一个Array，则可以形成多维数组。 1var arr = [[1, 2, 3], [400, 500, 600], &apos;-&apos;]; 对象JS的对象是一种无序的集合数据类型，它由若干键值对组成。 JS用一个{…}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,。 访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用’’括起来。 JavaScript规定，访问不存在的属性不报错，而是返回undefined。 由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性。 1234567891011var thbelief = &#123; name: &apos;thbelief&apos;&#125;;xiaoming.age; // undefinedxiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming[&apos;name&apos;]; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 果我们要检测thbelief是否拥有某一属性，可以用in操作符。 1&apos;name&apos; in thbelief; // true 另外，如果in判断一个属性存在，这个属性不一定是thbelief的，它可能是thbelief继承得到的。 要判断一个属性是否是thbelief自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法： 12345var thbelief = &#123; name: &apos;thbelief&apos;&#125;;thbelief.hasOwnProperty(&apos;name&apos;); // truethbelief.hasOwnProperty(&apos;toString&apos;); // false 条件判断JavaScript可以使用if () { … } else { … }来进行条件判断。 同时，也可以像C++中一样进行多重的嵌套。 循环熟悉的是单独的For循环，但是还包括了其他的不熟悉的循环方式。 for…in它可以把一个对象的所有属性依次循环出来。 12345678var o = &#123; name: &apos;thbelief&apos;, age: 20, city: &apos;mianyang&apos;&#125;;for (var key in o) &#123; console.log(key); // &apos;name&apos;, &apos;age&apos;, &apos;city&apos;&#125; 要过滤掉对象继承的属性，用hasOwnProperty()来实现。（前文对象中曾经提到） 值得注意的是，for … in对Array的循环得到的是String而不是Number。 while与C++中类似。 do while与C++中类似。 Map和SetMap是一组键值对的结构，具有极快的查找速度。 12var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);m.get(&apos;Michael&apos;); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法： 1234567var m = new Map(); // 空Mapm.set(&apos;Adam&apos;, 67); // 添加新的key-valuem.set(&apos;Bob&apos;, 59);m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: truem.get(&apos;Adam&apos;); // 67m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;m.get(&apos;Adam&apos;); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： 1234var m = new Map();m.set(&apos;Adam&apos;, 67);m.set(&apos;Adam&apos;, 88);m.get(&apos;Adam&apos;); // 88 Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果。 同样的，通过delete(key)方法可以删除元素。 iterable具有iterable类型的集合可以通过新的for … of循环来遍历。 123456789101112var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];var s = new Set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]);var m = new Map([[1, &apos;x&apos;], [2, &apos;y&apos;], [3, &apos;z&apos;]]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + &apos;=&apos; + x[1]);&#125; for … in循环遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。如果手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果： 12345var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.name = &apos;Hello&apos;;for (var x in a) &#123; console.log(x); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;name&apos;&#125; for … in循环将把name包括在内，但Array的length属性却不包括在内。 for … of循环则完全修复了这些问题，它只循环集合本身的元素： 12345var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];a.name = &apos;Hello&apos;;for (var x of a) &#123; console.log(x); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos;&#125; 参考链接]]></content>
      <categories>
        <category>后端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Auto.js</tag>
        <tag>JS</tag>
        <tag>JavaScript</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java番外-多线程编程]]></title>
    <url>%2F2019%2F03%2F09%2Fjava%E7%95%AA%E5%A4%96-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[目录： 1.线程与进程的异同： 2.线程的生命周期： 新建状态： 就绪状态： 运行状态： 阻塞状态： 死亡状态： 3.线程的优先级： 4.创建线程的三种方式： 通过Runnable接口创建线程： 通过集成Thread类来创建线程： 通过Callable和Future创建线程： 三种方式的对比： 线程的几个重要的概念： 1.线程与进程的异同：线程：一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 进程：一个进程包括了由操作系统分配的内存空间，包含了一个或者多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。 2.线程的生命周期： 相关解释： 新建状态：使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态：当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态：如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态：如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态：一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 3.线程的优先级：每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 4.创建线程的三种方式： 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。 通过Runnable接口创建线程：实现Runnable是一个类只需要执行一个方法来调用run（）即可。 1public void run（） 该方法可以重写，要理解的是run（）可以调用其他方法，使用其他的类，并且声明变量，就像主线程一样。 在创建一个实现Runnable接口的类之后，可以在类中实例化一个线程对象。 Thread中定义了几个构造方法，例如： 1Thread(Runnable threadOb,String threadName); 这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。 新线程创建之后，你调用它的 start() 方法它才会运行。 1void start（）； 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142class RunnableDemo implements Runnable &#123; private Thread t; private String threadName; RunnableDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;); R1.start(); RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;); R2.start(); &#125; &#125; 运行结果： 12345678910111213141516Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 4Running Thread-2Thread: Thread-2, 4Thread: Thread-1, 3Thread: Thread-2, 3Thread: Thread-1, 2Thread: Thread-2, 2Thread: Thread-1, 1Thread: Thread-2, 1Thread Thread-1 exiting.Thread Thread-2 exiting. 通过集成Thread类来创建线程：该方法是创建一个新的类然后让这个类继承自Thread类，然后创建一个该类的实例即可。 继承类的时候必须重写run（）方法，该方法是新线程的入口点，它也必须调用start方法才可以执行。本质上也是实现了Runnable接口的一个实例。 123456789101112131415161718192021222324252627282930313233343536373839404142class ThreadDemo extends Thread &#123; private Thread t; private String threadName; ThreadDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;); T1.start(); ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;); T2.start(); &#125; &#125; 运行结果： 12345678910111213141516Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 4Running Thread-2Thread: Thread-2, 4Thread: Thread-1, 3Thread: Thread-2, 3Thread: Thread-1, 2Thread: Thread-2, 2Thread: Thread-1, 1Thread: Thread-2, 1Thread Thread-1 exiting.Thread Thread-2 exiting. 下表列出了Thread类的一些重要方法： 序号 方法描述 1 public void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 2 public void run() 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 3 public final void setName(String name) 改变线程名称，使之与参数 name 相同。 4 public final void setPriority(int priority) 更改线程的优先级。 5 public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程。 6 public final void join(long millisec) 等待该线程终止的时间最长为 millis 毫秒。 7 public void interrupt() 中断线程。 8 public final boolean isAlive() 测试线程是否处于活动状态。 测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。 序号 方法描述 1 public static void yield() 暂停当前正在执行的线程对象，并执行其他线程。 2 public static void sleep(long millisec) 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 3 public static boolean holdsLock(Object x) 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。 4 public static Thread currentThread() 返回对当前正在执行的线程对象的引用。 5 public static void dumpStack() 将当前线程的堆栈跟踪打印至标准错误流。 实例： 如下的ThreadClassDemo 程序演示了Thread类的一些方法： 123456789101112131415// 文件名 : DisplayMessage.java// 通过实现 Runnable 接口创建线程public class DisplayMessage implements Runnable &#123; private String message; public DisplayMessage(String message) &#123; this.message = message; &#125; public void run() &#123; while(true) &#123; System.out.println(message); &#125; &#125;&#125; 1234567891011121314151617181920// 文件名 : GuessANumber.java// 通过继承 Thread 类创建线程 public class GuessANumber extends Thread &#123; private int number; public GuessANumber(int number) &#123; this.number = number; &#125; public void run() &#123; int counter = 0; int guess = 0; do &#123; guess = (int) (Math.random() * 100 + 1); System.out.println(this.getName() + &quot; guesses &quot; + guess); counter++; &#125; while(guess != number); System.out.println(&quot;** Correct!&quot; + this.getName() + &quot;in&quot; + counter + &quot;guesses.**&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233// 文件名 : ThreadClassDemo.javapublic class ThreadClassDemo &#123; public static void main(String [] args) &#123; Runnable hello = new DisplayMessage(&quot;Hello&quot;); Thread thread1 = new Thread(hello); thread1.setDaemon(true); thread1.setName(&quot;hello&quot;); System.out.println(&quot;Starting hello thread...&quot;); thread1.start(); Runnable bye = new DisplayMessage(&quot;Goodbye&quot;); Thread thread2 = new Thread(bye); thread2.setPriority(Thread.MIN_PRIORITY); thread2.setDaemon(true); System.out.println(&quot;Starting goodbye thread...&quot;); thread2.start(); System.out.println(&quot;Starting thread3...&quot;); Thread thread3 = new GuessANumber(27); thread3.start(); try &#123; thread3.join(); &#125;catch(InterruptedException e) &#123; System.out.println(&quot;Thread interrupted.&quot;); &#125; System.out.println(&quot;Starting thread4...&quot;); Thread thread4 = new GuessANumber(75); thread4.start(); System.out.println(&quot;main() is ending...&quot;); &#125;&#125; 运行结果： 1234567891011121314Starting hello thread...Starting goodbye thread...HelloHelloHelloHelloHelloHelloGoodbyeGoodbyeGoodbyeGoodbyeGoodbye....... 通过Callable和Future创建线程： 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。 实例： 123456789101112131415161718192021222324252627282930313233343536public class CallableThreadTest implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for(int i = 0;i &lt; 100;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i); if(i==20) &#123; new Thread(ft,&quot;有返回值的线程&quot;).start(); &#125; &#125; try &#123; System.out.println(&quot;子线程的返回值：&quot;+ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i = 0; for(;i&lt;100;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125; return i; &#125; &#125; 三种方式的对比： 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。 线程的几个重要的概念：1）线程同步。 2）线程间通信。 3）线程死锁。 4）线程控制，包括挂起停止与恢复。]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>番外</tag>
        <tag>多线程</tag>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-融会贯通]]></title>
    <url>%2F2019%2F03%2F07%2Fjava%E5%9F%BA%E7%A1%80-%E8%9E%8D%E4%BC%9A%E8%B4%AF%E9%80%9A%2F</url>
    <content type="text"><![CDATA[目录： 1.继承： 1）概念： 2）格式： 3）类型： 4）特性： 5）关键字： extends关键字： implements关键字： super与this关键字： final关键字： 注意： 2.重写与重载： 1）重写： 概念： Super关键字的使用： 2）重载： 规则： 3）重载与重写的区别： 4）总结： 3.多态： 1）概念： 2）表现： 3）优点： 4）执行条件： 5）虚函数： 6）实现方式： 4.抽象类： 1）概念： 2）实例： 3）继承抽象类： 4）抽象方法： 5）总结： 5.封装： 1）概念： 2）优点： 3）实现步骤： 4）实例： 6.接口： 1）概念： 2）接口与类的相似点： 3）接口与类的区别： 4）接口特性： 5）抽象类与接口的区别： 6）接口的声明： 7）接口的实现： 8）接口的继承： 9）接口的多继承： 10）标记接口： 7.包： 1）作用： 2）创建包： 3）import关键字： 4）package目录结构： 5）设置CLASSPATH系统变量： 1.继承：1）概念：继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 2）格式：12345class 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; 3）类型：注意：java不支持多继承，但是支持多重继承。 4）特性：子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 5）关键字：注意：继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 extends关键字：在java中，类的继承是单一的继承，也就是说，一个类只能拥有一个父类，所以extends只能继承一个类。 123456789101112public class Animal &#123; private String name; private int id; public Animal(String myName, String myid) &#123; //初始化属性值 &#125; public void eat() &#123; //吃的方法的具体实现 &#125; public void sleep() &#123; //睡觉的方法的具体实现 &#125; &#125; public class Penguin extends Animal&#123; &#125; implements关键字：使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 1234567891011public interface A &#123; public void eat(); public void sleep();&#125; public interface B &#123; public void show();&#125; public class C implements A,B &#123;&#125; super与this关键字：super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用。 123456789101112131415161718192021222324class Animal &#123; void eat() &#123; System.out.println(&quot;animal : eat&quot;); &#125;&#125; class Dog extends Animal &#123; void eat() &#123; System.out.println(&quot;dog : eat&quot;); &#125; void eatTest() &#123; this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); &#125;&#125; final关键字：final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。 注:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final 123456声明类：final class 类名 &#123;//类体&#125;声明方法：修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;//方法体&#125; 注意：子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。 2.重写与重载：1）重写：概念：重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。其实就是外形不变，核心重写的意思。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 12345678910111213141516171819202122class Animal&#123; public void move()&#123; System.out.println(&quot;动物可以移动&quot;); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println(&quot;狗可以跑和走&quot;); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 &#125;&#125; 结果： 12动物可以移动狗可以跑和走 Super关键字的使用：当需要在子类中调用父类的被重写方法的时候，就必须使用super关键字。 123456789101112131415161718192021class Animal&#123; public void move()&#123; System.out.println(&quot;动物可以移动&quot;); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; super.move(); // 应用super类的方法 System.out.println(&quot;狗可以跑和走&quot;); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal b = new Dog(); // Dog 对象 b.move(); //执行 Dog类的方法 &#125;&#125; 结果： 12动物可以移动狗可以跑和走 2）重载：重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 规则：被重载的方法必须改变参数列表（参数的个数或者类型不一样）。 被重载的方法可以改变返回类型。 被重载的方法可以改变访问修饰符。 被重载的方法可以声明新的或者更广的检查异常。 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 1234567891011121314151617181920212223242526272829public class Overloading &#123; public int test()&#123; System.out.println(&quot;test1&quot;); return 1; &#125; public void test(int a)&#123; System.out.println(&quot;test2&quot;); &#125; //以下两个参数类型顺序不同 public String test(int a,String s)&#123; System.out.println(&quot;test3&quot;); return &quot;returntest3&quot;; &#125; public String test(String s,int a)&#123; System.out.println(&quot;test4&quot;); return &quot;returntest4&quot;; &#125; public static void main(String[] args)&#123; Overloading o = new Overloading(); System.out.println(o.test()); o.test(1); System.out.println(o.test(1,&quot;test3&quot;)); System.out.println(o.test(&quot;test4&quot;,1)); &#125;&#125; 3）重载与重写的区别： 4）总结：方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 (3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 3.多态：1）概念：多态就是同一个行为具有多个不同表现形式或者形态的能力。 （同一个接口，使用不同的实例而执行不同的操作） 2）表现：1234567现实中，比如我们按下 F1 键这个动作：如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 3）优点： 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 4）执行条件： 继承 重写 父类引用指向子类对象 例如： 1Parent p = new Child(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat Cat c = (Cat)a; // 向下转型 c.work(); // 调用的是 Cat 的 work &#125; public static void show(Animal a) &#123; a.eat(); // 类型判断 if (a instanceof Cat) &#123; // 猫做的事 Cat c = (Cat)a; c.work(); &#125; else if (a instanceof Dog) &#123; // 狗做的事 Dog c = (Dog)a; c.work(); &#125; &#125; &#125; abstract class Animal &#123; abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void work() &#123; System.out.println(&quot;抓老鼠&quot;); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; public void work() &#123; System.out.println(&quot;看家&quot;); &#125; &#125; 结果： 123456吃鱼抓老鼠吃骨头看家吃鱼抓老鼠 5）虚函数：虚函数的存在是为了多态。 Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。 6）实现方式：三种方式，包括：重写，接口，抽象类和抽象方法。 4.抽象类：1）概念：在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 2）实例：在java中使用abstract class来定义抽象类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 文件名 : Employee.java */public abstract class Employee&#123; private String name; private String address; private int number; public Employee(String name, String address, int number) &#123; System.out.println(&quot;Constructing an Employee&quot;); this.name = name; this.address = address; this.number = number; &#125; public double computePay() &#123; System.out.println(&quot;Inside Employee computePay&quot;); return 0.0; &#125; public void mailCheck() &#123; System.out.println(&quot;Mailing a check to &quot; + this.name + &quot; &quot; + this.address); &#125; public String toString() &#123; return name + &quot; &quot; + address + &quot; &quot; + number; &#125; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String newAddress) &#123; address = newAddress; &#125; public int getNumber() &#123; return number; &#125;&#125; 如果尝试以下例子： 123456789101112/* 文件名 : AbstractDemo.java */public class AbstractDemo&#123; public static void main(String [] args) &#123; /* 以下是不允许的，会引发错误 */ Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); &#125;&#125; 编译时会显示以下的错误： 1234Employee.java:46: Employee is abstract; cannot be instantiated Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); ^1 error 3）继承抽象类：可以通过一般的方法直接继承Employee类： 123456789101112131415161718192021222324252627282930313233/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; //Annual salary public Salary(String name, String address, int number, double salary) &#123; super(name, address, number); setSalary(salary); &#125; public void mailCheck() &#123; System.out.println(&quot;Within mailCheck of Salary class &quot;); System.out.println(&quot;Mailing check to &quot; + getName() + &quot; with salary &quot; + salary); &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double newSalary) &#123; if(newSalary &gt;= 0.0) &#123; salary = newSalary; &#125; &#125; public double computePay() &#123; System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; &#125;&#125; 尽管我们不能实例化一个 Employee 类的对象，但是如果我们实例化一个 Salary 类对象，该对象将从 Employee 类继承 7 个成员方法，且通过该方法可以设置或获取三个成员变量。 123456789101112131415/* 文件名 : AbstractDemo.java */public class AbstractDemo&#123; public static void main(String [] args) &#123; Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00); Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00); System.out.println(&quot;Call mailCheck using Salary reference --&quot;); s.mailCheck(); System.out.println(&quot;\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); &#125;&#125; 运行结果如下： 123456789Constructing an EmployeeConstructing an EmployeeCall mailCheck using Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400. 4）抽象方法：如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。 Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。 抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。 12345678910public abstract class Employee&#123; private String name; private String address; private int number; public abstract double computePay(); //...&#125; 声明抽象方法会造成以下两个结果： 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 如果Salary类继承了Employee类，那么它必须实现computePay()方法： 12345678910111213/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; // Annual salary public double computePay() &#123; System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; &#125; //...&#125; 5）总结： 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 5.封装：1）概念：封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 2）优点： 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 3）实现步骤：修改属性的可见性来限制属性的访问（一般限制为private），例如： 1234public class Person &#123; private String name; private int age;&#125; 这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如： 1234567891011121314151617181920public class Person&#123; private String name; private int age;​ public int getAge()&#123; return age; &#125;​ public String getName()&#123; return name; &#125;​ public void setAge(int age)&#123; this.age = age; &#125;​ public void setName(String name)&#123; this.name = name; &#125;&#125; 之所以采用this关键字是为了解决实例变量和局部变量之间发生的同名冲突。 4）实例：12345678910111213141516171819202122232425262728293031/* 文件名: EncapTest.java */public class EncapTest&#123; private String name; private String idNum; private int age; public int getAge()&#123; return age; &#125; public String getName()&#123; return name; &#125; public String getIdNum()&#123; return idNum; &#125; public void setAge( int newAge)&#123; age = newAge; &#125; public void setName(String newName)&#123; name = newName; &#125; public void setIdNum( String newId)&#123; idNum = newId; &#125;&#125; 以上实例中public方法是外部类访问该类成员变量的入口。 通常情况下，这些方法被称为getter和setter方法。 因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。 通过如下的例子说明EncapTest类的变量怎样被访问： 123456789101112/* F文件名 : RunEncap.java */public class RunEncap&#123; public static void main(String args[])&#123; EncapTest encap = new EncapTest(); encap.setName(&quot;James&quot;); encap.setAge(20); encap.setIdNum(&quot;12343ms&quot;); System.out.print(&quot;Name : &quot; + encap.getName()+ &quot; Age : &quot;+ encap.getAge()); &#125;&#125; 运行结果： 1Name : James Age : 20 6.接口：1）概念：接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 2）接口与类的相似点： 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 3）接口与类的区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 4）接口特性： 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 5）抽象类与接口的区别： 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 6）接口的声明：1234[可见度] interface 接口名称 [extends 其他的接口名名] &#123; // 声明变量 // 抽象方法&#125; interface关键字用来声明一个接口。 123456789/* 文件名 : NameOfInterface.java */import java.lang.*;//引入包 public interface NameOfInterface&#123; //任何类型 final, static 字段 //抽象方法&#125; 接口有如下特性： 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。 接口中的方法都是公有的。 实例： 12345/* 文件名 : Animal.java */interface Animal &#123; public void eat(); public void travel();&#125; 7）接口的实现：当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。 类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 实现一个接口的语法，可以使用这个公式： 1...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ... 实例： 123456789101112131415161718192021/* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(&quot;Mammal eats&quot;); &#125; public void travel()&#123; System.out.println(&quot;Mammal travels&quot;); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 运行结果： 12Mammal eatsMammal travels 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 8）接口的继承：一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 下面的Sports接口被Hockey和Football接口继承： 1234567891011121314151617181920212223// 文件名: Sports.javapublic interface Sports&#123; public void setHomeTeam(String name); public void setVisitingTeam(String name);&#125; // 文件名: Football.javapublic interface Football extends Sports&#123; public void homeTeamScored(int points); public void visitingTeamScored(int points); public void endOfQuarter(int quarter);&#125; // 文件名: Hockey.javapublic interface Hockey extends Sports&#123; public void homeGoalScored(); public void visitingGoalScored(); public void endOfPeriod(int period); public void overtimePeriod(int ot);&#125; Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。 相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。 9）接口的多继承：在Java中，类的多继承是不合法，但接口允许多继承。 在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示： 1public interface Hockey extends Sports, Event 以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法。 10）标记接口：最常用的继承接口是没有包含任何方法的接口。 标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。 标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。 例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下： 123package java.util;public interface EventListener&#123;&#125; 没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的： 建立一个公共的父接口： 正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。 向一个类添加数据类型： 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。 7.包：为了更好的组织类，包就产生了，主要是用来区别类名的命名空间。 1）作用： 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 包语句的语法格式为： 1package pkg1[．pkg2[．pkg3…]]; 例如,一个Something.java 文件它的内容： 1234package net.java.util;public class Something&#123; ...&#125; 那么它的路径应该是 net/java/util/Something.java 这样保存的。 package(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。 一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。 以下是一些 Java 中的包： java.lang-打包基础的类 java.io-包含输入输出功能的函数 开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。 由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。 2）创建包：创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。 例子： 让我们来看一个例子，这个例子创建了一个叫做animals的包。通常使用小写的字母来命名避免与类、接口名字的冲突。 在 animals 包中加入一个接口（interface）： 1234567/* 文件名: Animal.java */package animals; interface Animal &#123; public void eat(); public void travel();&#125; 接下来，在同一个包中加入该接口的实现： 1234567891011121314151617181920212223package animals; /* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(&quot;Mammal eats&quot;); &#125; public void travel()&#123; System.out.println(&quot;Mammal travels&quot;); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 然后，编译这两个文件，并把他们放在一个叫做animals的子目录中。 用下面的命令来运行： 12345$ mkdir animals$ cp Animal.class MammalInt.class animals$ java animals/MammalIntMammal eatsMammal travel 3）import关键字：为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为： 1import package1[.package2…].(classname|*); 如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 例子： 下面的 payroll 包已经包含了 Employee 类，接下来向 payroll 包中添加一个 Boss 类。Boss 类引用 Employee 类的时候可以不用使用 payroll 前缀，Boss类的实例如下。 123456789package payroll; public class Boss&#123; public void payEmployee(Employee e) &#123; e.mailCheck(); &#125;&#125; 如果 Boss 类不在 payroll 包中又会怎样？Boss 类必须使用下面几种方法之一来引用其他包中的类。 使用类全名描述，例如： 1payroll.Employee 用 import 关键字引入，使用通配符 “*”： 1import payroll.*; 使用 import 关键字引入 Employee 类: 1import payroll.Employee; 注意： 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 4）package目录结构：类放在包中会有两种主要的结果： 包名成为类名的一部分，正如我们前面讨论的一样。 包名必须与相应的字节码所在的目录结构相吻合。 下面是管理你自己 java 中文件的一种简单方式： 将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如： 1234567// 文件名 : Car.java package vehicle; public class Car &#123; // 类实现 &#125; 接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。 1....\vehicle\Car.java 现在，正确的类名和路径将会是如下样子： 类名 -&gt; vehicle.Car 路径名 -&gt; vehicle\Car.java (在 windows 系统中) 通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。 例如：有一个 com.runoob.test 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录： 1....\com\runoob\test\Runoob.java 编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如： 123456789// 文件名: Runoob.java package com.runoob.test;public class Runoob &#123; &#125;class Google &#123; &#125; 现在，我们用-d选项来编译这个文件，如下： 1$javac -d . Runoob.java 这样会像下面这样放置编译了的文件： 12.\com\runoob\test\Runoob.class.\com\runoob\test\Google.class 你可以像下面这样来导入所有 \com\runoob\test\ 中定义的类、接口等： 1import com.runoob.test.*; 编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。 12&lt;path-one&gt;\sources\com\runoob\test\Runoob.java&lt;path-two&gt;\classes\com\runoob\test\Google.class 这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。 类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。 一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。 5）设置CLASSPATH系统变量：用下面的命令显示当前的CLASSPATH变量： Windows 平台（DOS 命令行下）：C:> set CLASSPATH UNIX 平台（Bourne shell 下）：# echo $CLASSPATH 删除当前CLASSPATH变量内容： Windows 平台（DOS 命令行下）：C:> set CLASSPATH= UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH 设置CLASSPATH变量: Windows 平台（DOS 命令行下）： C:> set CLASSPATH=C:\users\jack\java\classes UNIX 平台（Bourne shell 下）：# CLASSPATH=/home/jack/java/classes; export CLASSPATH]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>融会贯通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中STL用法]]></title>
    <url>%2F2019%2F03%2F04%2FC-%E4%B8%ADSTL%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录： 1.1STL的含义： 1.2STL六大组件： 1.3容器： 1.4STL迭代器： 1.5算法： &lt;一&gt;查找算法(13个)：判断容器中是否包含某个值 &lt;二&gt;排序和通用算法(14个)：提供元素排序策略 &lt;三&gt;删除和替换算法(15个) &lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合 &lt;五&gt;算术算法(4个) &lt;六&gt;生成和异变算法(6个) &lt;七&gt;关系算法(8个) &lt;八&gt;集合算法(4个) &lt;九&gt;堆算法(4个) 1.1STL的含义：STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。 STL的一个重要的特点就是数据结构和算法的分离。例如：由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组。 STL另外的一个特点就是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。 1.2STL六大组件：1）容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器； 2）迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象； 3）算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用； 4）仿函数（Function object） 5）迭代适配器（Adaptor） 6）空间配制器（allocator） 1.3容器：STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。 （1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；Vectors：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；Deques：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；Lists：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针； （2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap；Sets/Multisets：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；Maps/Multimaps：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找； 容器类自动申请和释放内存，无需new和delete操作。vector基于模板实现，需包含头文件vector。 12345678910111213141516171819202122232425262728293031//1.定义和初始化 vector&lt;int&gt; vec1; //默认初始化，vec1为空 vector&lt;int&gt; vec2(vec1); //使用vec1初始化vec2 vector&lt;int&gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2 vector&lt;int&gt; vec4(10); //10个值为的元素 vector&lt;int&gt; vec5(10,4); //10个值为的元素//2.常用操作方法 vec1.push_back(100); //添加元素 int size = vec1.size(); //元素个数 bool isEmpty = vec1.empty(); //判断是否为空 cout&lt;&lt;vec1[0]&lt;&lt;endl; //取得第一个元素 vec1.insert(vec1.end(),5,3); //从vec1.back位置插入个值为的元素 vec1.pop_back(); //删除末尾元素 vec1.erase(vec1.begin(),vec1.end());//删除之间的元素，其他元素前移 cout&lt;&lt;(vec1==vec2)?true:false; //判断是否相等==、！=、&gt;=、&lt;=... vector&lt;int&gt;::iterator iter = vec1.begin(); //获取迭代器首地址 vec1.clear(); //清空元素//3.遍历 //下标法 int length = vec1.size(); for(int i=0;i&lt;length;i++) &#123; cout&lt;&lt;vec1[i]; &#125; cout&lt;&lt;endl&lt;&lt;endl; //迭代器法 vector&lt;int&gt;::const_iterator iterator = vec1.begin(); for(;iterator != vec1.end();iterator++) &#123; cout&lt;&lt;*iterator; &#125; 1.4STL迭代器：Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator,实例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; v.push_back(3); //数组尾部插入3 v.push_back(2); v.push_back(1); v.push_back(0); cout &lt;&lt; &quot; 下标 &quot; &lt;&lt; v[3] &lt;&lt; endl; cout &lt;&lt; &quot; 迭代器 &quot; &lt;&lt; endl; for(vector&lt;int&gt;::iterator i = v.begin();i!= v.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //在第一个元素之前插入111 insert begin+n是在第n个元素之前插入 v.insert(v.begin(),111); //在最后一个元素之后插入222 insert end + n 是在n个元素之后插入 v.insert(v.end(),222); for(vector&lt;int&gt;::iterator i = v.begin();i!= v.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; vector&lt;int&gt; arr(10); for(int i = 0; i &lt; 10; i++) &#123; arr[i] = i; &#125; for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //删除 同insert arr.erase(arr.begin()); for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl ; arr.erase(arr.begin(),arr.begin()+5); for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl ; return 0 ; &#125; 数组转置： reverse(v.begin(),v.end()) 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; for(int i = 0; i &lt; 10; ++i) &#123; v.push_back(i); &#125; for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; reverse(v.begin(),v.end()); for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125; 1.5算法：算法部分主要由头文件algorithm，numeric和functional组成。 algorithm是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。 numeric体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。 functional中则定义了一些模板类，用以声明函数对象。STL中算法大致分为四类： 1）非可变序列算法：指不直接修改其所操作的容器内容的算法。 2）可变序列算法：指可以修改它们所操作的容器内容的算法。 3）排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。 4）数值算法：对容器内容进行数值计算。 &lt;一&gt;查找算法(13个)：判断容器中是否包含某个值adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。 binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。 count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。 count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。 equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示 upper_bound。 find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。 find_end: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代替等于操作。 find_first_of: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。 find_if: 使用输入的函数代替等于操作符执行find。 lower_bound: 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。 upper_bound: 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。 search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。 search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。 &lt;二&gt;排序和通用算法(14个)：提供元素排序策略inplace_merge: 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。 merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。 nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。 partial_sort: 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。 partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。 partition: 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。 random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。 reverse: 将指定范围内元素重新反序排序。 reverse_copy: 与reverse类似，不过将结果写入另一个容器。 rotate: 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。 rotate_copy: 与rotate类似，不过将结果写入另一个容器。 sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。 stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。 stable_partition: 与partition类似，不过不保证保留容器中的相对顺序。 &lt;三&gt;删除和替换算法(15个)copy: 复制序列 copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。 iter_swap: 交换两个ForwardIterator的值。 remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。 remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。 remove_if: 删除指定范围内输入操作结果为true的所有元素。 remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。 replace: 将指定范围内所有等于vold的元素都用vnew代替。 replace_copy: 与replace类似，不过将结果写入另一个容器。 replace_if: 将指定范围内所有操作结果为true的元素用新值代替。 replace_copy_if: 与replace_if，不过将结果写入另一个容器。 swap: 交换存储在两个对象中的值。 swap_range: 将指定范围内的元素与另一个序列元素值进行交换。 unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。 unique_copy: 与unique类似，不过把结果输出到另一个容器。 &lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。 prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。 &lt;五&gt;算术算法(4个)accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。 partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。 inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。 adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。 &lt;六&gt;生成和异变算法(6个)fill: 将输入值赋给标志范围内的所有元素。 fill_n: 将输入值赋给first到first+n范围内的所有元素。 for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。 generate: 连续调用输入的函数来填充指定的范围。 generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。 transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。 &lt;七&gt;关系算法(8个)equal: 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。 includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。 lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。 max: 返回两个元素中较大一个。重载版本使用自定义比较操作。 max_element: 返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。 min: 返回两个元素中较小一个。重载版本使用自定义比较操作。 min_element: 返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。 mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。 &lt;八&gt;集合算法(4个)set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。 set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。 set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。 set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。 &lt;九&gt;堆算法(4个)make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。 pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。 push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。 sort_heap: 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。 ……]]></content>
      <categories>
        <category>后端</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
        <tag>用法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础 初窥门径]]></title>
    <url>%2F2019%2F02%2F27%2FJava%E5%9F%BA%E7%A1%80-%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%2F</url>
    <content type="text"><![CDATA[目录： 1.Java的基本数据类型： 对应的包装类： 基本数据类型的默认值： 2.Java分支循环： 分支语句： if语句： switch语句： 三目运算符： 转义符： 循环语句： for循环： while语句： 3.String、StringBuffer、StringBuilder： 区别： String对象： String本质： 常量池： 实例： StringBuffer字符串变量（线程安全）是一个容器，最终会通过toString方法变成字符串： StringBuilder 字符串变量（非线程安全）： String与StringBuffer区别： 在修改的时候对象自身是否改变： 是否可变测试： 初始化区别： StringBuffer对象和String对象之间的互转: 偏重： 总结： StringBuffer与StringBuilder区别： 4.正则表达式： 1.1正则表达式的含义： 1.2具体实例： 1.3常见的匹配符号： 1.4元字符： 1.5限定符： 1.6分组和反向引用： 1.7仅分组却无反向引用： 1.8分组的反向引用副本： 1.9否定先行断言： 1.10指定正则表达式的模式： 1.11java中的反斜杠： 1.12易错： 1.13内置的字符串正则处理方法： 1.14：模式和匹配： 1.15：几个常用的例子： 1）中文的匹配： 2）数字范围的匹配： 3）img标签的匹配： 4）贪婪与非贪婪模式的匹配： 1.16：在线正则工具： 1.Java的基本数据类型：1234567整型 byte（字节型） short（短整型） int long（长整型）浮点型 float（单精度浮点型） double（双精度浮点型）逻辑型 boolean(它只有两个值可取 true false)字符型 char 对应的包装类：java.lang.Byte、java.lang.Short、java.lang.Integer、java.lang.Long、java.lang.Float、java.lang.Double、java.lang.Boolean、java.lang.Character. 基本数据类型的默认值： 2.Java分支循环：分支语句：123顺序语句分支语句循环语句 if语句：123456789if(boolean类型表达式)&#123; 语句1&#125;else&#123; 语句2&#125; switch语句：1234567891011121314151617181920switch(变量)&#123; case常量1:语句1;break; case常量2:语句2;break; case常量3: 语句3; break; default: 语句0; break;&#125;注：default可以忽略掉~ 三目运算符：123表达式1?表达式2:表达式3表达式1是布尔类型的，右边的问号表示判断它是true还是false，如果是true，整个表达式返回表达式2，如果是false整个表达式返回表达式3 转义符：12345678910111213回车(return) &apos;\r&apos; 13换行(nextLine) &apos;\n&apos; 10(在windows中执行换行动作用\r\n；在linux中执行换行动作用\n)制表(tab) &apos;\t&apos; (可以用来对齐打印的文字)双引号 &apos;\&quot;&apos; (反斜杠+双引号表示双引号字符)单引号 &apos;\&apos;&apos; (反斜杠+单引号表示单引号字符)反斜杠 &apos;\\&apos; (两个反斜杠表示一个反斜杠) 循环语句：for循环：1234567891011for(表达式1;表达式2;表达式3)&#123; 语句&#125;表达式1 在循环开始前执行一次，一般用于初始化表达式2 循环条件，一般为boolean类型，为true则循环继续，为false则循环终止(不写则表示一直为true)表达式3 每次循环在语句执行完后执行，一般用于对循环条件进行变更 while语句：12345678910111213141516171819while(条件)&#123; 语句&#125;当条件为true时，不停地执行语句do...while语句do&#123; 语句&#125;while(条件);和while逻辑一样，但是会先执行语句，再判断。do...while在任何情况下至少执行一次语句。 3.String、StringBuffer、StringBuilder：区别：123String对象是常量，它的值不能被创建后改变，StringBuffer和StringBuilder可以可变；StringBuilder非线程安全（单线程使用），String与StringBuffer线程安全（多线程使用）；如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。 String对象：String本质：String是值不可变的常量，是线程安全的。 String类使用了final修饰符，String类是不可继承的。 常量池：常量池是一个内存空间，不同于使用new关键字创建的对象所在的堆空间。 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复创建相等变量时节省了很多时间。 在编译期被确定，并被保存在已编译的.class文件中的一些数据，包括类、方法、接口等中的常量和字符串常量。常量池还具备动态性，运行期间可以将新的常量放入池中。java中基本类型的包装类的大部分都实现了常量池技术， 即Byte,Short,Integer,Long,Character,Boolean； 实例：12String s1 = new String(&quot;s1&quot;) ; String s2 = new String(&quot;s1&quot;) ; 1234// 3个，编译期在常量池中创建1个，即“s1”常量对象；运行期堆中创建2个，即s1和s2对象。String s1 = &quot;s1&quot;; String s2 = s1; s2 = &quot;s2&quot;; StringBuffer字符串变量（线程安全）是一个容器，最终会通过toString方法变成字符串：12345678910111213141516public final class StringBuffer extends AbstractStringBuilder implements Serializable, Appendable, CharSequence &#123; /** * Constructs a string buffer with no characters in it and an initial capacity of 16 characters. */ public StringBuffer() &#123; super(16); &#125; public synchronized StringBuffer append(int i) &#123; super.append(i); return this; &#125; public synchronized StringBuffer delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; StringBuilder 字符串变量（非线程安全）：12345678910111213public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, Appendable, CharSequence &#123; public StringBuilder() &#123; super(16); &#125; public StringBuilder append(String str) &#123; super.append(str); return this; &#125; public StringBuilder delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; String与StringBuffer区别：在修改的时候对象自身是否改变：（1） String在修改时不会改变对象自身 在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String 。 12String str = &quot;abc&quot;;//地址str1str = &quot;def&quot;;//地址str2 （2） StringBuffer在修改时会改变对象自身 每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。StringBuffer 上的主要操作是 append 和 insert 方法。 12StringBuffer strBuffer = new StringBuffer(&quot;abc&quot;);//地址strBuffer,值是abcstrBuffer.append(&quot;def&quot;);//地址strBuffer,值是abcdef 是否可变测试：String的地址已改变，对象已经改变为另一个；StringBuffer地址不变，还是同样的对象。 初始化区别：123String：StringBuffer s = null; StringBuffer s = “abc”; 1234StringBuffer：StringBuffer s = null; //结果警告：Null pointer access: The variable result can only be null at this locationStringBuffer s = new StringBuffer();//StringBuffer对象是一个空的对象StringBuffer s = new StringBuffer(“abc”);//创建带有内容的StringBuffer对象,对象的内容就是字符串”abc” StringBuffer对象和String对象之间的互转:他们属于不同的类型，不能直接进行强制类型转换。 1234String s = “abc”;StringBuffer sb1 = new StringBuffer(“123”);StringBuffer sb2 = new StringBuffer(s); //String转换为StringBufferString s1 = sb1.toString(); //StringBuffer转换为String 偏重：StringBuffer类中的方法主要偏重于对于字符串的变化，例如追加、插入和删除等，常用方法有：append方法、insert方法、deleteCharAt方法、reverse方法等。 总结：（1）如果要操作少量的数据用 String； （2）（多线程下）经常需要对一个字符串进行修改，例如追加、插入和删除等操作，使用StringBuffer要更加适合一些。 StringBuffer与StringBuilder区别：1.StringBuilder是一个可变的对象，是5.0新增的，提供一个与StringBuffer兼容的API，但不保证同步，主要是用在字符串缓冲区被单个线程使用的时候。 2.线程安全性： ​ StringBuffer：线程安全。 ​ StringBuilder：线程非安全。 3.大部分情况下：StringBuffer&gt;String 同时由于String对象不可变，重复新建对象：StringBuffer对象可变。 4.StringBuilder&gt;StringBuffer 当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的。 5.特殊情况下，String&gt;StringBuffer 123//String效率是远要比StringBuffer快的：String S1 = “This is only a” + “ simple” + “ test”;StringBuffer Sb = new StringBuilder(“This is only a”).append(“simple”).append(“ test”); 12345//String速度是非常慢的：String S2 = “This is only a”;String S3 = “ simple”;String S4 = “ test”;String S1 = S2 +S3 + S4; 6.总结： 123（1）如果要操作少量的数据用 String；（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。 参考链接 4.正则表达式：1.1正则表达式的含义：定义一个搜索模式的字符串。 正则表达式可以用于搜索、编辑和操作文本。 分析过程：首先正则表达式应用的是文本字符串（text/string），它会以定义的模式从左到右匹配文本，每个源字符只匹配一次。 1.2具体实例：123this is text 精确匹配字符串 &quot;this is text&quot;this\s+is\s+text 匹配单词 &quot;this&quot; 后跟一个或多个空格字符，后跟词 &quot;is&quot; 后跟一个或多个空格字符，后跟词 &quot;text&quot;^\d+(\.\d+)? ^ 定义模式必须匹配字符串的开始，d+ 匹配一个或多个数字，? 表明小括号内的语句是可选的，\. 匹配 &quot;.&quot;，小括号表示分组。例如匹配：&quot;5&quot;、&quot;1.5&quot; 和 &quot;2.21&quot; 1.3常见的匹配符号： 正则表达式 描述 . 匹配所有单个字符，除了换行符（Linux 中换行是 \n，Windows 中换行是 \r\n） ^regex 正则必须匹配字符串开头 regex$ 正则必须匹配字符串结尾 [abc] 复选集定义，匹配字母 a 或 b 或 c [abc][vz] 复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z [^abc] 当插入符 ^ 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c [a-d1-7] 范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间，但不匹配 d1 XZ 匹配 X 后直接跟着 Z X\ Z 匹配 X 或 Z 1.4元字符： 正则表达式 描述 \d 匹配一个数字，是 [0-9] 的简写 \D 匹配一个非数字，是 [^0-9] 的简写 \s 匹配一个空格，是 [ \t\n\x0b\r\f] 的简写 \S 匹配一个非空格 \w 匹配一个单词字符（大小写字母、数字、下划线），是 [a-zA-Z_0-9] 的简写 \W 匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 [^\w] 1.5限定符：限定符定义了一个元素可以发生的频率。 正则表达式 描述 举例 * 匹配 &gt;=0 个，是 {0,} 的简写 X* 表示匹配零个或多个字母 X，.*表示匹配任何字符串 + 匹配 &gt;=1 个，是 {1,} 的简写 X+ 表示匹配一个或多个字母 X ? 匹配 1 个或 0 个，是 {0,1} 的简写 X? 表示匹配 0 个或 1 个字母 X {X} 只匹配 X 个字符 \d{3} 表示匹配 3 个数字，.{10}表示匹配任何长度是 10 的字符串 {X,Y} 匹配 &gt;=X 且 &lt;=Y 个 \d{1,4} 表示匹配至少 1 个最多 4 个数字 *? 如果 ? 是限定符 * 或 + 或 ? 或 {} 后面的第一个字符，那么表示非贪婪模式（尽可能少的匹配字符），而不是默认的贪婪模式 1.6分组和反向引用：小括号 () 可以达到对正则表达式进行分组的效果。 模式分组后会在正则表达式中创建反向引用。反向引用会保存匹配模式分组的字符串片断，这使得我们可以获取并使用这个字符串片断。 在以正则表达式替换字符串的语法中，是通过 $ 来引用分组的反向引用，$0 是匹配完整模式的字符串（注意在 JavaScript 中是用 $&amp; 表示）；$1 是第一个分组的反向引用；$2 是第二个分组的反向引用，以此类推。 示例： 123456789101112131415package com.wuxianjiezh.demo.regex;public class RegexTest &#123; public static void main(String[] args) &#123; // 去除单词与 , 和 . 之间的空格 String Str = &quot;Hello , World .&quot;; String pattern = &quot;(\\w)(\\s+)([.,])&quot;; // $0 匹配 `(\w)(\s+)([.,])` 结果为 `o空格,` 和 `d空格.` // $1 匹配 `(\w)` 结果为 `o` 和 `d` // $2 匹配 `(\s+)` 结果为 `空格` 和 `空格` // $3 匹配 `([.,])` 结果为 `,` 和 `.` System.out.println(Str.replaceAll(pattern, &quot;$1$3&quot;)); // Hello, World. &#125;&#125; 上面的例子中，我们使用了 [.] 来匹配普通字符 . 而不需要使用 [\\.]。因为正则对于 [] 中的 .，会自动处理为 [\.]，即普通字符 . 进行匹配。 1.7仅分组却无反向引用：当我们在小括号 () 内的模式开头加入 ?:，那么表示这个模式仅分组，但不创建反向引用。 示例： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;img.jpg&quot;; // 分组且创建反向引用 Pattern pattern = Pattern.compile(&quot;(jpg|png)&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); System.out.println(matcher.group(1)); &#125; &#125;&#125; 运行结果： 12jpgjpg 若源码改为： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;img.jpg&quot;; // 分组但不创建反向引用 Pattern pattern = Pattern.compile(&quot;(?:jpg|png)&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); System.out.println(matcher.group(1)); &#125; &#125;&#125; 运行结果： 1234jpgException in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: No group 1 at java.util.regex.Matcher.group(Matcher.java:538) at com.wuxianjiezh.regex.RegexTest.main(RegexTest.java:15) 1.8分组的反向引用副本：Java 中可以在小括号中使用 ?&lt;name&gt; 将小括号中匹配的内容保存为一个名字为 name 的副本。 示例： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;@wxj 你好啊&quot;; Pattern pattern = Pattern.compile(&quot;@(?&lt;first&gt;\\w+\\s)&quot;); // 保存一个副本 Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); System.out.println(matcher.group(1)); System.out.println(matcher.group(&quot;first&quot;)); &#125; &#125;&#125; 运行结果： 123@wxj wxj wxj 1.9否定先行断言：我们可以创建否定先行断言模式的匹配，即某个字符串后面不包含另一个字符串的匹配模式。 否定先行断言模式通过 (?!pattern) 定义。比如，我们匹配后面不是跟着 “b” 的 “a”： 1a(?!b) 1.10指定正则表达式的模式：可以在正则的开头指定模式修饰符。 (?i) 使正则忽略大小写。 (?s) 表示单行模式（”single line mode”）使正则的 . 匹配所有字符，包括换行符。 (?m) 表示多行模式（”multi-line mode”），使正则的 ^ 和 $ 匹配字符串中每行的开始和结束。 1.11java中的反斜杠：反斜杠 \ 在 Java 中表示转义字符，这意味着 \ 在 Java 拥有预定义的含义。 这里例举两个特别重要的用法： 在匹配 . 或 { 或 [ 或 ( 或 ? 或 $ 或 ^ 或 * 这些特殊字符时，需要在前面加上 \\，比如匹配 . 时，Java 中要写为 \\.，但对于正则表达式来说就是 \.。 在匹配 \ 时，Java 中要写为 \\\\，但对于正则表达式来说就是 \\。 注意：Java 中的正则表达式字符串有两层含义，首先 Java 字符串转义出符合正则表达式语法的字符串，然后再由转义后的正则表达式进行模式匹配。 1.12易错： [jpg|png] 代表匹配 j 或 p 或 g 或 p 或 n 或 g 中的任意一个字符。 (jpg|png) 代表匹配 jpg 或 png。 1.13内置的字符串正则处理方法：在 Java 中有四个内置的运行正则表达式的方法，分别是 matches()、split())、replaceFirst()、replaceAll()。注意 replace() 方法不支持正则表达式。 方法 描述 s.matches(&quot;regex&quot;) 当仅且当正则匹配整个字符串时返回 true s.split(&quot;regex&quot;) 按匹配的正则表达式切片字符串 s.replaceFirst(&quot;regex&quot;, &quot;replacement&quot;) 替换首次匹配的字符串片段 s.replaceAll(&quot;regex&quot;, &quot;replacement&quot;) 替换所有匹配的字符 实例： 1234567891011121314151617181920package com.wuxianjiezh.regex;public class RegexTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;wxj&quot;.matches(&quot;wxj&quot;)); System.out.println(&quot;----------&quot;); String[] array = &quot;w x j&quot;.split(&quot;\\s&quot;); for (String item : array) &#123; System.out.println(item); &#125; System.out.println(&quot;----------&quot;); System.out.println(&quot;w x j&quot;.replaceFirst(&quot;\\s&quot;, &quot;-&quot;)); System.out.println(&quot;----------&quot;); System.out.println(&quot;w x j&quot;.replaceAll(&quot;\\s&quot;, &quot;-&quot;)); &#125;&#125; 运行结果： 123456789true----------wxj----------w-x j----------w-x-j 1.14：模式和匹配：Java 中使用正则表达式需要用到两个类，分别为 java.util.regex.Pattern 和 java.util.regex.Matcher。 第一步，通过正则表达式创建模式对象 Pattern。 第二步，通过模式对象 Pattern，根据指定字符串创建匹配对象 Matcher。 第三步，通过匹配对象 Matcher，根据正则表达式操作字符串。 来个例子，加深理解： 123456789101112131415161718192021222324252627package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String text = &quot;Hello Regex!&quot;; Pattern pattern = Pattern.compile(&quot;\\w+&quot;); // Java 中忽略大小写，有两种写法： // Pattern pattern = Pattern.compile(&quot;\\w+&quot;, Pattern.CASE_INSENSITIVE); // Pattern pattern = Pattern.compile(&quot;(?i)\\w+&quot;); // 推荐写法 Matcher matcher = pattern.matcher(text); // 遍例所有匹配的序列 while (matcher.find()) &#123; System.out.print(&quot;Start index: &quot; + matcher.start()); System.out.print(&quot; End index: &quot; + matcher.end() + &quot; &quot;); System.out.println(matcher.group()); &#125; // 创建第两个模式，将空格替换为 tab Pattern replace = Pattern.compile(&quot;\\s+&quot;); Matcher matcher2 = replace.matcher(text); System.out.println(matcher2.replaceAll(&quot;\t&quot;)); &#125;&#125; 运行结果： 123Start index: 0 End index: 5 HelloStart index: 6 End index: 11 RegexHello Regex! 1.15：几个常用的例子：1）中文的匹配：[\u4e00-\u9fa5]+ 代表匹配中文字。 12345678910111213141516package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;閑人到人间&quot;; Pattern pattern = Pattern.compile(&quot;[\\u4e00-\\u9fa5]+&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); &#125; &#125;&#125; 运行结果： 1閑人到人间 2）数字范围的匹配：比如，匹配 1990 到 2017。 注意：这里有个新手易范的错误，就是正则 [1990-2017]，实际这个正则只匹配 0 或 1 或 2 或 7 或 9 中的任一个字符。 正则表达式匹配数字范围时，首先要确定最大值与最小值，最后写中间值。 正确的匹配方式： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;1990\n2010\n2017&quot;; // 这里应用了 (?m) 的多行匹配模式，只为方便我们测试输出 // &quot;^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$&quot; 为判断 1990-2017 正确的正则表达式 Pattern pattern = Pattern.compile(&quot;(?m)^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group()); &#125; &#125;&#125; 运行结果： 123199020102017 3）img标签的匹配：比如，获取图片文件内容，这里我们考虑了一些不规范的 img 标签写法： 123456789101112131415161718package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;&lt;img src=&apos;aaa.jpg&apos; /&gt;&lt;img src=bbb.png/&gt;&lt;img src=\&quot;ccc.png\&quot;/&gt;&quot; + &quot;&lt;img src=&apos;ddd.exe&apos;/&gt;&lt;img src=&apos;eee.jpn&apos;/&gt;&quot;; // 这里我们考虑了一些不规范的 img 标签写法，比如：空格、引号 Pattern pattern = Pattern.compile(&quot;&lt;img\\s+src=(?:[&apos;\&quot;])?(?&lt;src&gt;\\w+.(jpg|png))(?:[&apos;\&quot;])?\\s*/&gt;&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group(&quot;src&quot;)); &#125; &#125;&#125; 运行结果： 123aaa.jpgbbb.pngccc.png 4）贪婪与非贪婪模式的匹配：比如，获取 div 标签中的文本内容： 1234567891011121314151617181920212223242526package com.wuxianjiezh.regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String str = &quot;&lt;div&gt;文章标题&lt;/div&gt;&lt;div&gt;发布时间&lt;/div&gt;&quot;; // 贪婪模式 Pattern pattern = Pattern.compile(&quot;&lt;div&gt;(?&lt;title&gt;.+)&lt;/div&gt;&quot;); Matcher matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group(&quot;title&quot;)); &#125; System.out.println(&quot;--------------&quot;); // 非贪婪模式 pattern = Pattern.compile(&quot;&lt;div&gt;(?&lt;title&gt;.+?)&lt;/div&gt;&quot;); matcher = pattern.matcher(str); while (matcher.find()) &#123; System.out.println(matcher.group(&quot;title&quot;)); &#125; &#125;&#125; 运行结果： 1234文章标题&lt;/div&gt;&lt;div&gt;发布时间--------------文章标题发布时间 1.16：在线正则工具：JavaScript、Python在线表达工具]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>初窥门径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用指令（个人向）]]></title>
    <url>%2F2019%2F02%2F26%2Fhexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： Hexo的常用指令： 1.新建文章： 2.新建页面： 3.生成静态页面： 4.开启本地服务器的端口： 5.部署到网页上： 6.清除文件： 7.查看hexo版本： 8.复合指令： 9.卸载hexo： 10.如何安装旧版本hexo： 特殊操作：Hexo支持目录： Hexo的常用指令：1.新建文章：如果文章名包含空格必须加双引号，如果没有则可以不加。 1$ hexo new &quot;articleName&quot; 2.新建页面：新建一个题为“pageName”的页面，此时会在/source/目录下生成一个名为pageName的文件夹，其中包含一份 index 的md文件； 1$ hexo new page &quot;pageName&quot; 3.生成静态页面：主要是为了方便调试自己的博客，在未发布之前检查是否有问题。 12$ hexo generate$ hexo g 4.开启本地服务器的端口：开启预览访问的端口，默认端口为4000。关闭server使用 ctrl + c。 本地网址如下： 1http://localhost：4000 命令为： 12$ hexo server$ hexo s 在使用hexo server 可能会遇到端口被占用的情况，不妨使用以下指令来更改端口： 1$ hexo server -p 4001 5.部署到网页上：将目录下的 .deploy_git 文件夹部署到Github。部署前需要预先 hexo generate 生成静态文件。 关闭server使用 ctrl + c。 “INFO Deploy done: git”时即表示部署已经完成。 12$ hexo deploy$ hexo d 6.清除文件：清除目录下的缓存文件（db.json）和已经生成的静态文件（public）文件。网页正常情况下可以忽略此条命令。 1$ hexo clean 7.查看hexo版本：查看当前使用的hexo的版本号。 1$ hexo version 8.复合指令：hexo g -d # 等价于 hexo generate –deploy ：生成静态文件并部署。hexo s -d # 等价于 hexo deploy –generate ：开启预览并部署到Github。 简写形式hexo n #等价于 hexo newhexo g #等价于 hexo generatehexo s #等价于 hexo serverhexo d #等价于 hexo deployhexo v #等价于 hexo version 12$ hexo g -d$ hexo s -d 9.卸载hexo：3.0.0版本执行npm uninstall hexo-cli -g，之前版本执行npm uninstall hexo -g. 10.如何安装旧版本hexo：先卸载当前版本，以2.8.3为例，执行npm install hexo@2.8.3 -g，再初始化并安装依赖和插件。 特殊操作：Hexo支持目录：1.安装hexo-toc插件： 1npm install hexo-toc --save 2.配置站点配置文件_config.yml： 12toc: maxdepth: 5 3.使用： 在markdown文章中加入TOC占位符即可自动生成目录： 1&lt;!-- toc --&gt; 4.效果：]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>备忘</tag>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android学习路线总结plus]]></title>
    <url>%2F2019%2F02%2F26%2Fandroid%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%80%BB%E7%BB%93plus%2F</url>
    <content type="text"><![CDATA[目录： 1.java se基础： 2.android UI编程： 1）android初级控件的使用： 2）android高级控件的使用： 3）对话框与菜单的使用： 4）控件的布局方法： 5）多activity的管理： 6）自定义控件的实现方法： 3.android网络编程以及数据储存： 1）基于android平台的http通讯： 2）android数据储存技术： 4.进阶之路： 初级工程师： 中级工程师： 高级工程师： 1.java se基础：1).Java基本数据类型与表达式，分支循环。2).String和StringBuffer的使用、正则表达式。3).面向对象的抽象，封装，继承，多态，类与对象，对象初始化和回收；构造函数、this关键字、方法和方法的参数传递过程、static关键字、内部类。4).对象实例化过程、方法的覆盖、final关键字、抽象类、接口、继承的优点和缺点剖析；对象的多态性：子类和父类之间的转换、抽象类和接口在多态中的应用、多态带来的好处。5).Java异常处理，异常的机制原理。6).常用的设计模式：Singleton、Template、Strategy模式。7).JavaAPI介绍：种基本数据类型包装类，System和Runtime类，Date和DateFomat类等。8).Java集合介绍：Collection、Set、List、ArrayList、LinkedList、Hashset、Map、HashMap、Iterator等常用集合类API。9).JavaI/O输入输出流：File和FileRandomAccess类，字节流InputStream和OutputStream，字符流Reader和Writer，以及相应实现类，IO性能分析，字节和字符的转化流，包装流的概念，以及常用包装类，计算机编码。10).Java高级特性：反射和泛型。11).多线程原理：如何在程序中创建多线程(Thread、Runnable)，线程安全问题，线程的同步，线程之间的通讯、死锁。 2.android UI编程：1）android初级控件的使用：TextView控件的使用Button控件的使用方法EditText控件的使用方法ImageView的使用方法RadioButton的使用方法Checkbox的使用方法Menu的使用方法 2）android高级控件的使用：ListView的使用方法GridView的使用方法Adapter的使用方法Spinner的使用方法Gallary的使用方法ScrollView的使用方法RecyclerView 3）对话框与菜单的使用：Dialog的基本概念BlockquoteAlertDialog的使用方法DatePickerDialog的使用方法Menu的使用方法自定义Menu的实现方法 4）控件的布局方法：线性布局的使用方法相对布局的使用方法 5）多activity的管理：AndroidManifest.xml文件的作用Intent的使用方法使用Intent传递数据的方法启动Activity的方法IntentFilter的使用方法Activity Group的使用方法 6）自定义控件的实现方法：自定义ListView的实现方法可折叠ListView的使用方法自定义Adapter的实现方法自定义View的实现方法动态控件布局的上实现方法上拉刷新下拉加载更多 3.android网络编程以及数据储存：1）基于android平台的http通讯：Http协议回顾使用Get方法向服务器提交数据的方法使用POST方法向服务器提交数据的实现方法使用Http协议实现多线程下载使用Http协议实现断点续传 2）android数据储存技术：SQLite3数据库简介SQL语句回顾SQLite3编程接口介绍SQLite3事务管理SQLite3游标使用方法SQLite3性能分析访问SDCard的方法访问SharedPreferences的方法 4.进阶之路：初级工程师： 基本知识点比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术 书籍推荐《第一行代码 Android》、《疯狂Android》 中级工程师： AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别； Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用； 多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等； 事件分发：弹性滑动、滑动冲突等； 玩转View：View的绘制原理、各种自定义View； 动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理； 懂性能优化、熟悉mat等工具 懂点常见的设计模式 书籍推荐《Android开发艺术探索》、《Android群英传》 高级工程师： 继续加深理解”稍微深入的知识点“中所定义的内容 了解系统核心机制： 了解SystemServer的启动过程 了解主线程的消息循环模型 了解AMS和PMS的工作原理 能够回答问题”一个应用存在多少个Window？“ 了解四大组件的大概工作流程 … 基本知识点的细节 Activity的启动模式以及异常情况下不同Activity的表现 Service的onBind和onReBind的关联 onServiceDisconnected(ComponentName className)和binderDied()的区别 AsyncTask在不同版本上的表现细节 线程池的细节和参数配置 … 熟悉设计模式，有架构意识学习方法 书籍推荐《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》 参考链接]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>总结</tag>
        <tag>学习路线</tag>
        <tag>plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习路线总结（个人向）]]></title>
    <url>%2F2019%2F01%2F14%2FAndroid%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： Java基础： Java高阶： 数据结构及算法： 数据结构： 算法： Android基础： Android技术难点 Android框架层源码掌握 各种原理，经典第三方库源码系列 Android进程通信以及多进程开发 Android动画机制 Android绘图原理 Android页面恢复 混合开发及Android WebView应用 Gradle，自动化构建，持续集成相关 Android系统 Android Studio编译过程 Android架构： Android优化： 移动开发外围 服务器开发相关 前端开发相关 开发调试各种工具 Java基础：Java Object类方法 HashMap原理，Hash冲突，并发集合，线程安全集合及实现原理 HashMap 和 HashTable 区别 HashCode 作用，如何重载hashCode方法 ArrayList与LinkList区别与联系 GC机制 Java反射机制，Java代理模式 Java泛型 Synchronized原理 Volatile实现原理 方法锁、对象锁、类锁的意义和区别 线程同步的方法：Synchronized、lock、reentrantLock分析 Java锁的种类: 公平锁、乐观锁、互斥锁、分段锁、偏向锁、自旋锁等 ThreadLocal的原理和用法 ThreadPool的用法和示例 wait()和sleep()的区别 Java高阶：Java虚拟机，Java运行，Java GC机制（可达性分析法，引用计数法） Java对象的完整生命周期 JVM内存模型 进程间通信，线程间通信 JVM类加载机制 Java引用类型 设计模式：除常用设计模式之外，特别的，反射机制，代理模式 HTTP协议和HTTPS协议 Socket协议，Socket实现长连接 TCP和UDP协议 HTTP协议中GET和POST的具体实现 序列化和反序列化 线程池的实现原理 数据库基础知识：多表查询、索引、数据库事务 数据结构及算法：数据结构：栈和队列 数组和链表，自定义一个动态数组 Hash表，及Hash冲突的解决 二叉树 B+ B-树 基础排序算法：重点 快排、归并排序、堆排序（大根堆、小根堆） 快排的优化 二分查找与变种二分查找 哈夫曼树、红黑树 字符串操作，字符串查找，KMP算法 图的BFS、DFS、prim、Dijkstra算法（高阶技能） 经典问题：海量数据的处理 （10亿个数中找出最大的10000个数 TOP K问题） 算法：分治算法 动态规划 贪心算法 分支限界法 Android基础：Application生命周期 Android Activity生命周期 Android Service、IntentService，Service和组件间通信 Activity的onNewIntent Fragment的懒加载实现，参数传递与保存 ContentProvider实例详解 BroadcastReceiver使用总结 Android消息机制 Binder机制，共享内存实现原理 Android 事件分发机制 Android 多线程的实现：Thread、HandlerThread、AsyncTask、IntentService、RxJava ActivityThread工作原理 嵌套滑动实现原理 RecyclerView与ListView(缓存原理，区别联系，优缺点) View的绘制原理，自定义View，自定义ViewGroup View、SurfaceView 与 TextureView 主线程Looper.loop为什么不会造成死循环 ViewPager的缓存实现 requestLayout，invalidate，postInvalidate区别与联系 AndroidP新特性 Android两种虚拟机 ADB常用命令 Asset目录与res目录的区别 Android SQLite的使用入门 Android开发高级： 附：一般Android高级工程师招聘要求： 熟悉Android SDK，熟悉Android UI，熟悉Android各种调试工具； 有丰富的Android应用架构能力，能够独立主导并架构App；3. Mobile Web 开发经验；具备各种复合技能：熟悉iOS、H5、Python、.NET等多种开发语言的优先考虑； 对Android性能优化，安全，软件加固，自动化测试有深刻认识; 博客，开源项目 Android技术难点AIDL、Binder、多进程、View的绘制流程、事件分发、消息队列等。这类知识对于定位自己为高级Android工程师的人来说是必须掌握的，同时他也是能鉴别高级和初中级工程师的一块试金石，其中binder是Android系统进程间通信最重要的手段之一，现阶段app的发展离不开多进程的运用，经常会启动例如定位、推送等需要在后台开启动的进程来来保证主进程的内存运行；所以合理的使用多进程也是十分必要的；view的绘制是我们自定义控件的理论基础，只有掌握了view是如何绘制的才能个性化的自定义控件；事件分发一直是Android开发的难点之一，也是必须掌握的；关于handler机制也是android的一块难点，因为包括Asynctask、系统启动、Intentservice等底层都是通过handler来实现的，所以掌握后handler机制不仅能提高你的实战开发能力，更能让你系统的了解整个android系统运作的情况。 Android框架层源码掌握Android框架层有很多东西，以下几个是高级程序员必须要掌握的： Android包管理机制，核心PackageManagerService Window管理，核心WindowManagerService Android Activity启动和管理，核心ActivityManagerService 根Activity工作流程 Context关联类 各种原理，经典第三方库源码系列 自定义LayoutManager，RecyclerView中如何自定义LayoutManager VLayout实现原理，即如何自定义LayoutManager Glide加载原理，缓存方案，LRU算法 Retrofit的实现与原理 OKHttp3的使用，网络请求中的Intercept EventBus实现原理 ButterKnife实现原理 RxJava实现原理 Dagger依赖注入 热修复实现原理，解决方案 组件化原理和解决方案 Android进程通信以及多进程开发Android 多进程和Application关系 经典解决方案：多进程通信解决方案：Andromeda Android动画机制经典学习资料：HenCoder: 给高级Android工程师的进阶手册 Android绘图原理经典学习资料：HenCoder: 给高级Android工程师的进阶手册 Android页面恢复Android的页面恢复采用以下两个方法： onSaveInstanceState(Bundle outState) onRestoreInstanceState(Bundle savedInstanceState) onSaveInstanceState: 当Activity容易被系统销毁时，会触发该方法。具体的说 用户点击Home键 用户点击Home键，切换到其他应用程序 有电话来了等附加操作 混合开发及Android WebView应用混合开发涉及到的知识点主要包括： APP调用WebView加载url 掌握WebView的封装，了解所有的WebSettings配置，掌握WebViewClient、WebChromeClient 掌握WebView和Native双向通信机制，会自己封装双向通信中间件 对WebView的封装可参考：GitHub: AgentWeb 对通信中间件原理理解：GitHub：webprogress Gradle，自动化构建，持续集成相关Android系统Android Studio编译过程其中使用到的编译工具： aapt、aidl、Java Compiler、dex、 zipalign 主要步骤描述： 通过aapt打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样） 处理.aidl文件，生成对应的Java接口文件 通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex 通过apkbuilder工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk 通过Jarsigner工具，对上面的apk进行debug或release签名 通过zipalign工具，将签名后的apk进行对齐处理。 Android架构： MVC模式 MVP模式 MVVM模式 CLEAN模式 组件化开发 跨平台开发：Flutter、ReactNative（RN未来要黄，了解一下就好） Android优化： 移动开发外围服务器开发相关 SpringBoot技术 Restful API开发 网络协议理解：TCP/IP、HTTP/HTTPS、OSI七层协议 授权认证协议： OAuth2.0 等 基本的数据库技术 数据缓存技术：Memcached、Redis，Web缓存原理 消息队列技术 监控、日志分析技术 前端开发相关前端开发知识很多，框架层出不穷，本质的东西却只有以下这些。 核心必备：HTML、CSS、JavaScript 入门提高：浏览器兼容性、自定义UI和动效 中级技能：框架层出不穷，当前以vue.js、react.js 为核心 协作开发技能：包管理、模块化，工具采用 npm、webpack等 高级技能：框架原理源码研究 开发调试各种工具 性能分析工具：Memory Monitor 性能追踪及方法执行分析： TraceView 视图分析：Hierarchy Viewer ApkTool- 用于反向工程Android Apk文件的工具 Lint- Android lint工具是一个静态代码分析工具 Dex2Jar- 使用android .dex和java .class文件的工具 参考链接]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>总结</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用语法]]></title>
    <url>%2F2019%2F01%2F12%2FMarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录： 前言 一.标题 二.字体- [加粗](#加粗) - [斜体](#斜体) - [斜体加粗](#斜体加粗) - [删除线](#删除线) 三.引用 四.分割线 五.图片 六.超链接 七.列表 八.表格 九.代码 十.流程图 前言​ Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 一.标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 注意：这里的标准语法是必须#结束后再加上一个空格再加上想要写的文字。（但是有些地方貌似不加空格也可以，例如简书。但是最好还是按照标准的语法来写） 二.字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 三.引用在引用的文字前面加上&gt;即可。引用也可以嵌套，比如说两个&gt;&gt;三个&gt;&gt;&gt;之类的，貌似可以一直加下去，但是好像没什么用… 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;这是引用的内容 四.分割线三个或者三个以上的-或者*都可以。 1234-------******** 五.图片1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 六.超链接12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 例如： 12[简书](http://jianshu.com)[百度](http://baidu.com) 七.列表无序列表用-+*任何一种都可以。 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 有序列表数字加点即可。 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 列表嵌套：上一级和下一级之间敲上三个空格即可。 八.表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 九.代码单行代码直接代码之间分别用一个反引号包起来即可。 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行。 12345(```) 代码... 代码... 代码...(```) 十.流程图123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; ` 参考文章：Markdown基本语法]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Android6.0以上部分权限的动态获取]]></title>
    <url>%2F2019%2F01%2F12%2F%E5%85%B3%E4%BA%8EAndroid6-0%E4%BB%A5%E4%B8%8A%E9%83%A8%E5%88%86%E6%9D%83%E9%99%90%E7%9A%84%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[普通权限暂且不表，下面只列举Android6.0以后必须进行动态申请的权限。 下面以SD卡读取权限作为例子（如果实在不懂的话可以直接复制粘贴，只需要改一下权限的名称即可）： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 请求授权 */ private void requestPermission()&#123; if (Build.VERSION.SDK_INT &gt;= 23) &#123; int checkCallPhonePermission = ContextCompat.checkSelfPermission (this, Manifest.permission.READ_EXTERNAL_STORAGE); if (checkCallPhonePermission != PackageManager.PERMISSION_GRANTED) &#123; //在String[]中传入需要申请的权限 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 1); &#125; else&#123; //sendHomework(); //已经拥有了权限 Toast.makeText(this,"已经获取读SD卡权限",Toast.LENGTH_SHORT).show(); &#125; &#125; else &#123; //低版本 Toast.makeText(this,"已经获取读SD卡权限",Toast.LENGTH_SHORT).show(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //sendHomework(); //获取权限成功后的处理 Toast.makeText(this,"已经成功获取读SD卡权限",Toast.LENGTH_SHORT).show(); &#125; else &#123; //showToast("fail"); //获取权限失败的处理 Toast.makeText(this,"获取读SD卡权限失败",Toast.LENGTH_SHORT).show(); &#125; break; default: super.onRequestPermissionsResult(requestCode, permissions, grantResults); &#125; &#125; 对于新手来说，需要注意的是，如果你想要使用这个动态权限，除了上面这段代码之外，你还需要在项目的Manifest中注册你想要获取的权限（一般来说，只要不是危险权限，无论Android6.0前后，只要注册之后就可以直接使用了，但是危险权限，除了注册之外还需要手动的动态申请）。 另外，除了上面这段代码和注册之外，还需要在初始化之前在MainActivity中写上 1requestPermission() 来调用下面写的动态申请。 参考文章：Android6.0动态权限]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动态权限</tag>
        <tag>安卓6.0以上</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真机调试时如何用Androidstudio查询SQLite数据库]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E6%97%B6%E5%A6%82%E4%BD%95%E7%94%A8Androidstudio%E6%9F%A5%E8%AF%A2SQLite%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[目录： 前言： 1.首先在app对应下的build.gradle里面添加下面依赖： 2.自定义一个MyApplication继承Application，在onCreate中初始化stetho： 3.修改下列相关： 4.打开Chrome浏览器，输入网址： 5.点击弹出的网页Resource-&gt;Web SQL即可看到，下面是我的数据库显示情况： 前言：今天在调试一个有关于SQLite数据库的app的时候，突发奇想，想在手机上直接找到对应的db文件查看，结果是显而易见的，并没有找到相应的调试app的包名以及对应的文件夹。 然后在网上找了很多方法，试过之后，找到一个较方便且便捷的方法。如下： 1.首先在app对应下的build.gradle里面添加下面依赖：1234// Stetho coreimplementation &apos;com.facebook.stetho:stetho:1.3.1&apos;//If you want to add a network helperimplementation &apos;com.facebook.stetho:stetho-okhttp3:1.3.1&apos; 2.自定义一个MyApplication继承Application，在onCreate中初始化stetho：123456789101112131415public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); init(); &#125; private void init()&#123; Stetho.initializeWithDefaults(this); new OkHttpClient.Builder() .addNetworkInterceptor(new StethoInterceptor()) .build(); &#125;&#125; 3.修改下列相关：在AndroidManifest.xml中修改android:name=”.MyApplication” 然后运行app到手机上即可。 4.打开Chrome浏览器，输入网址：1chrome://inspect 操作好之后就是显示手机型号，下面有一个inspect直接点击即可。 5.点击弹出的网页Resource-&gt;Web SQL即可看到，下面是我的数据库显示情况： 这样就很简单啦，又方便又快捷！]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SQLite</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶（个人向）]]></title>
    <url>%2F2019%2F01%2F09%2FHexo%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言： 正文： 关于如何将自己的博客推送至百度与谷歌（默认情况下是不会被爬取的，这个时候就需要我们主动出击，让我们的博客可以直接被搜索到） 提交百度搜索引擎：（谷歌同理，过程一样） 站点地图： 安装百度谷歌的站点地图： 向谷歌提交链接： 百度收录： sitemap： 结语：百度的抓取速度是真的慢，另外，github.io的博客不允许百度蜘蛛爬取，直接再把博客推送到coding.me即可，百度收录的时候一定要用coding.me的网址。关于如何推送到coding，与github类似… 前言：首先，在我们刚刚搭建好这个博客的时候，我们会发现自己的博客显得很是简陋以及，单调，这个时候就是显示个性化的好时机了。hexo主题个性化是一个集合了许多方法的网址，可以参考。当然这只是沧海一粟，不值一提。还有更多的，诸如留言板，相册，网易云外链之类的优秀功能，具体详情可以直接百度，这里不过多赘述。 正文：关于如何将自己的博客推送至百度与谷歌（默认情况下是不会被爬取的，这个时候就需要我们主动出击，让我们的博客可以直接被搜索到）原因：Github和Coding都做了防爬虫处理，这样子我们博客可能就无法被搜索引擎收录，需要我们手动提交！ 验证是否被百度或者谷歌收录，即在相应的搜索栏中输入： 1site: thbelief.coding.me （注：site:后面是你的博客网址） 如果显示找不到相关网址，即没有被收录。如果找到了….那就恭喜不用操作了。 言归正传，回到正题。 提交百度搜索引擎：（谷歌同理，过程一样）登录百度搜索引擎 ps：可能需要个人信息认证，按照提示认证即可！ 然后是：添加站点-&gt;输入博客网址-&gt;设置站点领域（我设置的是信息技术）-&gt;选择验证方式。 这里只介绍第一种验证方式：文件验证 1.请点击 下载验证文件 获取验证文件 2.将验证文件放置于您所配置hexo博客的根目录下 3.点击这里确认验证文件可以正常访问 4.请点击“完成验证”按钮 注：为保持验证通过的状态,成功验证后请不要删除HTML文件 然后git bash输入框内输入hexo g -d部署到网站上面即可。 站点地图：站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 安装百度谷歌的站点地图：123npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 然后打开站点配置文件： 将url设置为你的站点名称。 然后执行hexo clean 以及 hexo g。 这样在你的网站根目录的public文件夹下生成sitemap.xml文件和baidusitemap.xml文件： 其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。 向谷歌提交链接：google站点平台：谷歌站点，然后就是注册账号、验证站点、提交sitemap， 提交site之后即可。 注意：无论是百度还是谷歌，都不是已通过就能直接搜索到，谷歌大致需要几小时，百度大致一个月左右，请耐心等待。 百度收录：百度收录较慢。故设置自动推送： 在主题配置文件下设置,将baidu_push设置为true： 12# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true sitemap：将生成的baidusitemap.xml提交到百度站点 点击链接提交： 然后刷新页面即可。 结语：百度的抓取速度是真的慢，另外，github.io的博客不允许百度蜘蛛爬取，直接再把博客推送到coding.me即可，百度收录的时候一定要用coding.me的网址。关于如何推送到coding，与github类似…]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用hexo+Github搭建个人博客（个人向）]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： hexo的介绍 准备 NodeJS Hexo安装 GitHub部分 Github Page 配置SSH 发布 更改主题 hexo的介绍官网上的描述是Hexo是一个快速，简单而强大的博客框架。我们可以使用Markdown（或其他语言）来编写文章，同时Hexo可以在几秒钟内生成具有美丽主题的静态文件以供我们使用。 简单来说它就是一个主打简单快速的博客框架，这个可以对比下知名度更高一些的WordPress，相对来说后者更强，不过更适合有服务器的人使用，只想做一个简单博客的首选hexo。 准备首先必须安装Git和NodeJS。（安装过程傻瓜式next操作即可） 注意一点就是NodeJS的路径。推荐D:\NodeJS (原因后面会阐述) 检测NodeJS是否安装成功的方式是： 输入Win+R输入cmd打开控制台输入下面代码： 12node -vnpm -v 如果两个都返回版本号即安装成功，否则需要再配环境变量。 NodeJS1.在NodeJS安装路径下面建立”node_global”及”node_cache”两个文件夹。 2.启动cmd输入： 12npm config set prefix &quot;D:\Program Files\nodejs\node_global&quot;npm config set cache &quot;D:\Program Files\nodejs\node_cache&quot; 3.配置环境变量： 环境变量-&gt;Path-&gt;编辑：添加上下面三行：（有的话就不用了） 123D:\NodeJS\D:\NodeJS\node_globalD:\NodeJs\node_cache 4.测试是否配置完成： 如果打开cmd输入下面代码然后在node_global目录下有express目录即完成了。 1npm install express -g Hexo安装打开git bash（为了避免出现错误后面的操作在git bash进行） 首先新建一个存放hexo文件的目录，例如在D盘根目录新建hexo文件夹，然后cd到该目录下，开始安装 1234567$ cd D:hexo/ #换成你的目录$ npm install -g hexo-cli #安装hexo脚手架$ hexo init #Hexo自动在当前文件夹下下载搭建网站所需的所有文件$ npm install #安装依赖包$ hexo g #完整命令为hexo generate，生成静态文件$ hexo s #完整命令为hexo server，启动服务器，用来本地预览 用浏览器访问http://localhost:4000，这时就可以看到了一个比较漂亮的博客了，这个是hexo的默认主题landscape，而我们会使用的是NexT主题，后面会说到怎么配置。 GitHub部分Github Page打开github主页，新建仓库（repository），这里要注意仓库的名称，比如我的帐号是thbelief，那么仓库名称应该是：thbelief.github.io。然后选择Public（公开）。 配置SSH以上过程完成后就是把hexo生成的静态页面上传了，到这里还没结束，还需要配置SSH，首先要本地生成公钥私钥 1$ ssh-keygen -t rsa -C &quot;你的邮件地址&quot; 引号里面的内容输入你的邮箱地址，然后回车，会提示你文件保存的路径，这时候按回车键确认，然后会提示你输入密码，输入即可（输入密码是看不到的），然后会确认输入一次，就可以在刚刚的路径看到生成了两个文件，一个是id_rsa，另一个是id_rsa.pub，用sublime打开id_rsa.pub然后选中里面的全部内容，复制下来。打开GitHub或Coding的SSH页面Github：setting–&gt;SSH and GPG keys–&gt;New SSH key在Key下面的框中粘贴刚刚复制的东西。 发布打开D:\hexo，用sublime打开_config.yml文件，文件最后可以看到 12deploy: type: 修改（注意要换上自己的链接） 12345deploy: type: git repository: git@github.com:yourname/yourname.github.io.git #发布到github #repository: git@git.coding.net:yourname/yourname.git #发布到Coding branch: master ctrl+s保存修改。打开git bash在当前目录输入以下命令： 1$ hexo d #完整命令为hexo deploy，将本地文件发布到page服务平台上 如遇遇到异常可以 12$ hexo clean &amp;&amp; hexo g$ hexo d 如果出现以下异常 1ERROR Deployer not found: git 尝试输入以下命令，然后重新执行刚刚的两条命令 1$ npm install hexo-deployer-git --save 这时候如果弹出一个对话框，输入在github/coding上面的用户名和密码即可这时候我们就可以在浏览器输入https://yourname.github.io 或者https://youname.coding.me 打开。（yourname记得替换） 更改主题D:\hexo目录下的theme文件夹下存放的就是博客的主题，hexo便是依据主题来生成静态文件的，挑选主题可以在官网https://hexo.io/themes/ 查找，根据自己的喜好来挑选。下载主题的一般方式如下： 12$ cd your-hexo-site #eg:D:\hexo$ git clone &#123;主题链接&#125; themes/&#123;主题名称&#125; 但是最好还是直接去官网下载压缩包解压到hexo目录下面的themes中，因为国内下这个很慢。（解压的时候名字一定要换成next，方便后序操作） 其实还有一种方法，也是对第一种方法的补充，直接更换npm的来源地，换成淘宝的即可，详情百度，这里不过多赘述。 启用主题的方式也很简单sublime打开上文提到的hexo目录下的_config.yml，ctrl+f输入theme查找这个关键字，修改其主题名称为下载的主题名称即可。 1theme: &#123;主题名称&#125; 以本人使用的next主题为例：下载最新版： 12$ cd D:hexo/$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改hexo目录下的_config.yml 1theme: next 具体可以到主题官网看看–NexT 参考文章：hexo搭建个人博客]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
</search>
