<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础 初窥门径]]></title>
    <url>%2F2019%2F02%2F27%2FJava%E5%9F%BA%E7%A1%80-%E5%88%9D%E7%AA%A5%E9%97%A8%E5%BE%84%2F</url>
    <content type="text"><![CDATA[目录： 1.Java的基本数据类型： 对应的包装类： 基本数据类型的默认值： 2.Java分支循环： 分支语句： if语句： switch语句： 三目运算符： 转义符： 循环语句： for循环： while语句： 3.String、StringBuffer、StringBuilder： 区别： String对象： String本质： 常量池： 实例： StringBuffer字符串变量（线程安全）是一个容器，最终会通过toString方法变成字符串： StringBuilder 字符串变量（非线程安全）： String与StringBuffer区别： 在修改的时候对象自身是否改变： 是否可变测试： 初始化区别： StringBuffer对象和String对象之间的互转: 偏重： 总结： StringBuffer与StringBuilder区别： 1.Java的基本数据类型：1234567整型 byte（字节型） short（短整型） int long（长整型）浮点型 float（单精度浮点型） double（双精度浮点型）逻辑型 boolean(它只有两个值可取 true false)字符型 char 对应的包装类：java.lang.Byte、java.lang.Short、java.lang.Integer、java.lang.Long、java.lang.Float、java.lang.Double、java.lang.Boolean、java.lang.Character. 基本数据类型的默认值： 2.Java分支循环：分支语句：123顺序语句分支语句循环语句 if语句：123456789if(boolean类型表达式)&#123; 语句1&#125;else&#123; 语句2&#125; switch语句：1234567891011121314151617181920switch(变量)&#123; case常量1:语句1;break; case常量2:语句2;break; case常量3: 语句3; break; default: 语句0; break;&#125;注：default可以忽略掉~ 三目运算符：123表达式1?表达式2:表达式3表达式1是布尔类型的，右边的问号表示判断它是true还是false，如果是true，整个表达式返回表达式2，如果是false整个表达式返回表达式3 转义符：12345678910111213回车(return) &apos;\r&apos; 13换行(nextLine) &apos;\n&apos; 10(在windows中执行换行动作用\r\n；在linux中执行换行动作用\n)制表(tab) &apos;\t&apos; (可以用来对齐打印的文字)双引号 &apos;\&quot;&apos; (反斜杠+双引号表示双引号字符)单引号 &apos;\&apos;&apos; (反斜杠+单引号表示单引号字符)反斜杠 &apos;\\&apos; (两个反斜杠表示一个反斜杠) 循环语句：for循环：1234567891011for(表达式1;表达式2;表达式3)&#123; 语句&#125;表达式1 在循环开始前执行一次，一般用于初始化表达式2 循环条件，一般为boolean类型，为true则循环继续，为false则循环终止(不写则表示一直为true)表达式3 每次循环在语句执行完后执行，一般用于对循环条件进行变更 while语句：12345678910111213141516171819while(条件)&#123; 语句&#125;当条件为true时，不停地执行语句do...while语句do&#123; 语句&#125;while(条件);和while逻辑一样，但是会先执行语句，再判断。do...while在任何情况下至少执行一次语句。 3.String、StringBuffer、StringBuilder：区别：123String对象是常量，它的值不能被创建后改变，StringBuffer和StringBuilder可以可变；StringBuilder非线程安全（单线程使用），String与StringBuffer线程安全（多线程使用）；如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。 String对象：String本质：String是值不可变的常量，是线程安全的。 String类使用了final修饰符，String类是不可继承的。 常量池：常量池是一个内存空间，不同于使用new关键字创建的对象所在的堆空间。 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复创建相等变量时节省了很多时间。 在编译期被确定，并被保存在已编译的.class文件中的一些数据，包括类、方法、接口等中的常量和字符串常量。常量池还具备动态性，运行期间可以将新的常量放入池中。java中基本类型的包装类的大部分都实现了常量池技术， 即Byte,Short,Integer,Long,Character,Boolean； 实例：12String s1 = new String(&quot;s1&quot;) ; String s2 = new String(&quot;s1&quot;) ; 1234// 3个，编译期在常量池中创建1个，即“s1”常量对象；运行期堆中创建2个，即s1和s2对象。String s1 = &quot;s1&quot;; String s2 = s1; s2 = &quot;s2&quot;; StringBuffer字符串变量（线程安全）是一个容器，最终会通过toString方法变成字符串：12345678910111213141516public final class StringBuffer extends AbstractStringBuilder implements Serializable, Appendable, CharSequence &#123; /** * Constructs a string buffer with no characters in it and an initial capacity of 16 characters. */ public StringBuffer() &#123; super(16); &#125; public synchronized StringBuffer append(int i) &#123; super.append(i); return this; &#125; public synchronized StringBuffer delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; StringBuilder 字符串变量（非线程安全）：12345678910111213public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, Appendable, CharSequence &#123; public StringBuilder() &#123; super(16); &#125; public StringBuilder append(String str) &#123; super.append(str); return this; &#125; public StringBuilder delete(int start, int end) &#123; super.delete(start, end); return this; &#125;&#125; String与StringBuffer区别：在修改的时候对象自身是否改变：（1） String在修改时不会改变对象自身 在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String 。 12String str = &quot;abc&quot;;//地址str1str = &quot;def&quot;;//地址str2 （2） StringBuffer在修改时会改变对象自身 每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。StringBuffer 上的主要操作是 append 和 insert 方法。 12StringBuffer strBuffer = new StringBuffer(&quot;abc&quot;);//地址strBuffer,值是abcstrBuffer.append(&quot;def&quot;);//地址strBuffer,值是abcdef 是否可变测试：String的地址已改变，对象已经改变为另一个；StringBuffer地址不变，还是同样的对象。 初始化区别：123String：StringBuffer s = null; StringBuffer s = “abc”; 1234StringBuffer：StringBuffer s = null; //结果警告：Null pointer access: The variable result can only be null at this locationStringBuffer s = new StringBuffer();//StringBuffer对象是一个空的对象StringBuffer s = new StringBuffer(“abc”);//创建带有内容的StringBuffer对象,对象的内容就是字符串”abc” StringBuffer对象和String对象之间的互转:他们属于不同的类型，不能直接进行强制类型转换。 1234String s = “abc”;StringBuffer sb1 = new StringBuffer(“123”);StringBuffer sb2 = new StringBuffer(s); //String转换为StringBufferString s1 = sb1.toString(); //StringBuffer转换为String 偏重：StringBuffer类中的方法主要偏重于对于字符串的变化，例如追加、插入和删除等，常用方法有：append方法、insert方法、deleteCharAt方法、reverse方法等。 总结：（1）如果要操作少量的数据用 String； （2）（多线程下）经常需要对一个字符串进行修改，例如追加、插入和删除等操作，使用StringBuffer要更加适合一些。 StringBuffer与StringBuilder区别：1.StringBuilder是一个可变的对象，是5.0新增的，提供一个与StringBuffer兼容的API，但不保证同步，主要是用在字符串缓冲区被单个线程使用的时候。 2.线程安全性： ​ StringBuffer：线程安全。 ​ StringBuilder：线程非安全。 3.大部分情况下：StringBuffer&gt;String 同时由于String对象不可变，重复新建对象：StringBuffer对象可变。 4.StringBuilder&gt;StringBuffer 当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然他的速度最快，但是可以保证StringBuffer是可以正确操作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的。 5.特殊情况下，String&gt;StringBuffer 123//String效率是远要比StringBuffer快的：String S1 = “This is only a” + “ simple” + “ test”;StringBuffer Sb = new StringBuilder(“This is only a”).append(“simple”).append(“ test”); 12345//String速度是非常慢的：String S2 = “This is only a”;String S3 = “ simple”;String S4 = “ test”;String S1 = S2 +S3 + S4; 6.总结： 123（1）如果要操作少量的数据用 String；（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。 参考链接]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>初窥门径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用指令（个人向）]]></title>
    <url>%2F2019%2F02%2F26%2Fhexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： Hexo的常用指令： 1.新建文章： 2.新建页面： 3.生成静态页面： 4.开启本地服务器的端口： 5.部署到网页上： 6.清除文件： 7.查看hexo版本： 8.复合指令： 9.卸载hexo： 10.如何安装旧版本hexo： 特殊操作：Hexo支持目录： Hexo的常用指令：1.新建文章：如果文章名包含空格必须加双引号，如果没有则可以不加。 1$ hexo new &quot;articleName&quot; 2.新建页面：新建一个题为“pageName”的页面，此时会在/source/目录下生成一个名为pageName的文件夹，其中包含一份 index 的md文件； 1$ hexo new page &quot;pageName&quot; 3.生成静态页面：主要是为了方便调试自己的博客，在未发布之前检查是否有问题。 12$ hexo generate$ hexo g 4.开启本地服务器的端口：开启预览访问的端口，默认端口为4000。关闭server使用 ctrl + c。 本地网址如下： 1http://localhost：4000 命令为： 12$ hexo server$ hexo s 在使用hexo server 可能会遇到端口被占用的情况，不妨使用以下指令来更改端口： 1$ hexo server -p 4001 5.部署到网页上：将目录下的 .deploy_git 文件夹部署到Github。部署前需要预先 hexo generate 生成静态文件。 关闭server使用 ctrl + c。 “INFO Deploy done: git”时即表示部署已经完成。 12$ hexo deploy$ hexo d 6.清除文件：清除目录下的缓存文件（db.json）和已经生成的静态文件（public）文件。网页正常情况下可以忽略此条命令。 1$ hexo clean 7.查看hexo版本：查看当前使用的hexo的版本号。 1$ hexo version 8.复合指令：hexo g -d # 等价于 hexo generate –deploy ：生成静态文件并部署。hexo s -d # 等价于 hexo deploy –generate ：开启预览并部署到Github。 简写形式hexo n #等价于 hexo newhexo g #等价于 hexo generatehexo s #等价于 hexo serverhexo d #等价于 hexo deployhexo v #等价于 hexo version 12$ hexo g -d$ hexo s -d 9.卸载hexo：3.0.0版本执行npm uninstall hexo-cli -g，之前版本执行npm uninstall hexo -g. 10.如何安装旧版本hexo：先卸载当前版本，以2.8.3为例，执行npm install hexo@2.8.3 -g，再初始化并安装依赖和插件。 特殊操作：Hexo支持目录：1.安装hexo-toc插件： 1npm install hexo-toc --save 2.配置站点配置文件_config.yml： 12toc: maxdepth: 5 3.使用： 在markdown文章中加入TOC占位符即可自动生成目录： 1&lt;!-- toc --&gt; 4.效果：]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>备忘</tag>
        <tag>指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android学习路线总结plus]]></title>
    <url>%2F2019%2F02%2F26%2Fandroid%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%80%BB%E7%BB%93plus%2F</url>
    <content type="text"><![CDATA[目录： 1.java se基础： 2.android UI编程： 1）android初级控件的使用： 2）android高级控件的使用： 3）对话框与菜单的使用： 4）控件的布局方法： 5）多activity的管理： 6）自定义控件的实现方法： 3.android网络编程以及数据储存： 1）基于android平台的http通讯： 2）android数据储存技术： 4.进阶之路： 初级工程师： 中级工程师： 高级工程师： 1.java se基础：1).Java基本数据类型与表达式，分支循环。2).String和StringBuffer的使用、正则表达式。3).面向对象的抽象，封装，继承，多态，类与对象，对象初始化和回收；构造函数、this关键字、方法和方法的参数传递过程、static关键字、内部类。4).对象实例化过程、方法的覆盖、final关键字、抽象类、接口、继承的优点和缺点剖析；对象的多态性：子类和父类之间的转换、抽象类和接口在多态中的应用、多态带来的好处。5).Java异常处理，异常的机制原理。6).常用的设计模式：Singleton、Template、Strategy模式。7).JavaAPI介绍：种基本数据类型包装类，System和Runtime类，Date和DateFomat类等。8).Java集合介绍：Collection、Set、List、ArrayList、LinkedList、Hashset、Map、HashMap、Iterator等常用集合类API。9).JavaI/O输入输出流：File和FileRandomAccess类，字节流InputStream和OutputStream，字符流Reader和Writer，以及相应实现类，IO性能分析，字节和字符的转化流，包装流的概念，以及常用包装类，计算机编码。10).Java高级特性：反射和泛型。11).多线程原理：如何在程序中创建多线程(Thread、Runnable)，线程安全问题，线程的同步，线程之间的通讯、死锁。 2.android UI编程：1）android初级控件的使用：TextView控件的使用Button控件的使用方法EditText控件的使用方法ImageView的使用方法RadioButton的使用方法Checkbox的使用方法Menu的使用方法 2）android高级控件的使用：ListView的使用方法GridView的使用方法Adapter的使用方法Spinner的使用方法Gallary的使用方法ScrollView的使用方法RecyclerView 3）对话框与菜单的使用：Dialog的基本概念BlockquoteAlertDialog的使用方法DatePickerDialog的使用方法Menu的使用方法自定义Menu的实现方法 4）控件的布局方法：线性布局的使用方法相对布局的使用方法 5）多activity的管理：AndroidManifest.xml文件的作用Intent的使用方法使用Intent传递数据的方法启动Activity的方法IntentFilter的使用方法Activity Group的使用方法 6）自定义控件的实现方法：自定义ListView的实现方法可折叠ListView的使用方法自定义Adapter的实现方法自定义View的实现方法动态控件布局的上实现方法上拉刷新下拉加载更多 3.android网络编程以及数据储存：1）基于android平台的http通讯：Http协议回顾使用Get方法向服务器提交数据的方法使用POST方法向服务器提交数据的实现方法使用Http协议实现多线程下载使用Http协议实现断点续传 2）android数据储存技术：SQLite3数据库简介SQL语句回顾SQLite3编程接口介绍SQLite3事务管理SQLite3游标使用方法SQLite3性能分析访问SDCard的方法访问SharedPreferences的方法 4.进阶之路：初级工程师： 基本知识点比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术 书籍推荐《第一行代码 Android》、《疯狂Android》 中级工程师： AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别； Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用； 多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等； 事件分发：弹性滑动、滑动冲突等； 玩转View：View的绘制原理、各种自定义View； 动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理； 懂性能优化、熟悉mat等工具 懂点常见的设计模式 书籍推荐《Android开发艺术探索》、《Android群英传》 高级工程师： 继续加深理解”稍微深入的知识点“中所定义的内容 了解系统核心机制： 了解SystemServer的启动过程 了解主线程的消息循环模型 了解AMS和PMS的工作原理 能够回答问题”一个应用存在多少个Window？“ 了解四大组件的大概工作流程 … 基本知识点的细节 Activity的启动模式以及异常情况下不同Activity的表现 Service的onBind和onReBind的关联 onServiceDisconnected(ComponentName className)和binderDied()的区别 AsyncTask在不同版本上的表现细节 线程池的细节和参数配置 … 熟悉设计模式，有架构意识学习方法 书籍推荐《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》 参考链接]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>总结</tag>
        <tag>学习路线</tag>
        <tag>plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习路线总结（个人向）]]></title>
    <url>%2F2019%2F01%2F14%2FAndroid%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： Java基础： Java高阶： 数据结构及算法： 数据结构： 算法： Android基础： Android技术难点 Android框架层源码掌握 各种原理，经典第三方库源码系列 Android进程通信以及多进程开发 Android动画机制 Android绘图原理 Android页面恢复 混合开发及Android WebView应用 Gradle，自动化构建，持续集成相关 Android系统 Android Studio编译过程 Android架构： Android优化： 移动开发外围 服务器开发相关 前端开发相关 开发调试各种工具 Java基础：Java Object类方法 HashMap原理，Hash冲突，并发集合，线程安全集合及实现原理 HashMap 和 HashTable 区别 HashCode 作用，如何重载hashCode方法 ArrayList与LinkList区别与联系 GC机制 Java反射机制，Java代理模式 Java泛型 Synchronized原理 Volatile实现原理 方法锁、对象锁、类锁的意义和区别 线程同步的方法：Synchronized、lock、reentrantLock分析 Java锁的种类: 公平锁、乐观锁、互斥锁、分段锁、偏向锁、自旋锁等 ThreadLocal的原理和用法 ThreadPool的用法和示例 wait()和sleep()的区别 Java高阶：Java虚拟机，Java运行，Java GC机制（可达性分析法，引用计数法） Java对象的完整生命周期 JVM内存模型 进程间通信，线程间通信 JVM类加载机制 Java引用类型 设计模式：除常用设计模式之外，特别的，反射机制，代理模式 HTTP协议和HTTPS协议 Socket协议，Socket实现长连接 TCP和UDP协议 HTTP协议中GET和POST的具体实现 序列化和反序列化 线程池的实现原理 数据库基础知识：多表查询、索引、数据库事务 数据结构及算法：数据结构：栈和队列 数组和链表，自定义一个动态数组 Hash表，及Hash冲突的解决 二叉树 B+ B-树 基础排序算法：重点 快排、归并排序、堆排序（大根堆、小根堆） 快排的优化 二分查找与变种二分查找 哈夫曼树、红黑树 字符串操作，字符串查找，KMP算法 图的BFS、DFS、prim、Dijkstra算法（高阶技能） 经典问题：海量数据的处理 （10亿个数中找出最大的10000个数 TOP K问题） 算法：分治算法 动态规划 贪心算法 分支限界法 Android基础：Application生命周期 Android Activity生命周期 Android Service、IntentService，Service和组件间通信 Activity的onNewIntent Fragment的懒加载实现，参数传递与保存 ContentProvider实例详解 BroadcastReceiver使用总结 Android消息机制 Binder机制，共享内存实现原理 Android 事件分发机制 Android 多线程的实现：Thread、HandlerThread、AsyncTask、IntentService、RxJava ActivityThread工作原理 嵌套滑动实现原理 RecyclerView与ListView(缓存原理，区别联系，优缺点) View的绘制原理，自定义View，自定义ViewGroup View、SurfaceView 与 TextureView 主线程Looper.loop为什么不会造成死循环 ViewPager的缓存实现 requestLayout，invalidate，postInvalidate区别与联系 AndroidP新特性 Android两种虚拟机 ADB常用命令 Asset目录与res目录的区别 Android SQLite的使用入门 Android开发高级： 附：一般Android高级工程师招聘要求： 熟悉Android SDK，熟悉Android UI，熟悉Android各种调试工具； 有丰富的Android应用架构能力，能够独立主导并架构App；3. Mobile Web 开发经验；具备各种复合技能：熟悉iOS、H5、Python、.NET等多种开发语言的优先考虑； 对Android性能优化，安全，软件加固，自动化测试有深刻认识; 博客，开源项目 Android技术难点AIDL、Binder、多进程、View的绘制流程、事件分发、消息队列等。这类知识对于定位自己为高级Android工程师的人来说是必须掌握的，同时他也是能鉴别高级和初中级工程师的一块试金石，其中binder是Android系统进程间通信最重要的手段之一，现阶段app的发展离不开多进程的运用，经常会启动例如定位、推送等需要在后台开启动的进程来来保证主进程的内存运行；所以合理的使用多进程也是十分必要的；view的绘制是我们自定义控件的理论基础，只有掌握了view是如何绘制的才能个性化的自定义控件；事件分发一直是Android开发的难点之一，也是必须掌握的；关于handler机制也是android的一块难点，因为包括Asynctask、系统启动、Intentservice等底层都是通过handler来实现的，所以掌握后handler机制不仅能提高你的实战开发能力，更能让你系统的了解整个android系统运作的情况。 Android框架层源码掌握Android框架层有很多东西，以下几个是高级程序员必须要掌握的： Android包管理机制，核心PackageManagerService Window管理，核心WindowManagerService Android Activity启动和管理，核心ActivityManagerService 根Activity工作流程 Context关联类 各种原理，经典第三方库源码系列 自定义LayoutManager，RecyclerView中如何自定义LayoutManager VLayout实现原理，即如何自定义LayoutManager Glide加载原理，缓存方案，LRU算法 Retrofit的实现与原理 OKHttp3的使用，网络请求中的Intercept EventBus实现原理 ButterKnife实现原理 RxJava实现原理 Dagger依赖注入 热修复实现原理，解决方案 组件化原理和解决方案 Android进程通信以及多进程开发Android 多进程和Application关系 经典解决方案：多进程通信解决方案：Andromeda Android动画机制经典学习资料：HenCoder: 给高级Android工程师的进阶手册 Android绘图原理经典学习资料：HenCoder: 给高级Android工程师的进阶手册 Android页面恢复Android的页面恢复采用以下两个方法： onSaveInstanceState(Bundle outState) onRestoreInstanceState(Bundle savedInstanceState) onSaveInstanceState: 当Activity容易被系统销毁时，会触发该方法。具体的说 用户点击Home键 用户点击Home键，切换到其他应用程序 有电话来了等附加操作 混合开发及Android WebView应用混合开发涉及到的知识点主要包括： APP调用WebView加载url 掌握WebView的封装，了解所有的WebSettings配置，掌握WebViewClient、WebChromeClient 掌握WebView和Native双向通信机制，会自己封装双向通信中间件 对WebView的封装可参考：GitHub: AgentWeb 对通信中间件原理理解：GitHub：webprogress Gradle，自动化构建，持续集成相关Android系统Android Studio编译过程其中使用到的编译工具： aapt、aidl、Java Compiler、dex、 zipalign 主要步骤描述： 通过aapt打包res资源文件，生成R.java、resources.arsc和res文件（二进制 &amp; 非二进制如res/raw和pic保持原样） 处理.aidl文件，生成对应的Java接口文件 通过Java Compiler编译R.java、Java接口文件、Java源文件，生成.class文件 通过dex命令，将.class文件和第三方库中的.class文件处理生成classes.dex 通过apkbuilder工具，将aapt生成的resources.arsc和res文件、assets文件和classes.dex一起打包生成apk 通过Jarsigner工具，对上面的apk进行debug或release签名 通过zipalign工具，将签名后的apk进行对齐处理。 Android架构： MVC模式 MVP模式 MVVM模式 CLEAN模式 组件化开发 跨平台开发：Flutter、ReactNative（RN未来要黄，了解一下就好） Android优化： 移动开发外围服务器开发相关 SpringBoot技术 Restful API开发 网络协议理解：TCP/IP、HTTP/HTTPS、OSI七层协议 授权认证协议： OAuth2.0 等 基本的数据库技术 数据缓存技术：Memcached、Redis，Web缓存原理 消息队列技术 监控、日志分析技术 前端开发相关前端开发知识很多，框架层出不穷，本质的东西却只有以下这些。 核心必备：HTML、CSS、JavaScript 入门提高：浏览器兼容性、自定义UI和动效 中级技能：框架层出不穷，当前以vue.js、react.js 为核心 协作开发技能：包管理、模块化，工具采用 npm、webpack等 高级技能：框架原理源码研究 开发调试各种工具 性能分析工具：Memory Monitor 性能追踪及方法执行分析： TraceView 视图分析：Hierarchy Viewer ApkTool- 用于反向工程Android Apk文件的工具 Lint- Android lint工具是一个静态代码分析工具 Dex2Jar- 使用android .dex和java .class文件的工具 参考链接]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>总结</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用语法]]></title>
    <url>%2F2019%2F01%2F12%2FMarkdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录： 前言 一.标题 二.字体- [加粗](#加粗) - [斜体](#斜体) - [斜体加粗](#斜体加粗) - [删除线](#删除线) 三.引用 四.分割线 五.图片 六.超链接 七.列表 八.表格 九.代码 十.流程图 前言​ Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 一.标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 注意：这里的标准语法是必须#结束后再加上一个空格再加上想要写的文字。（但是有些地方貌似不加空格也可以，例如简书。但是最好还是按照标准的语法来写） 二.字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 三.引用在引用的文字前面加上&gt;即可。引用也可以嵌套，比如说两个&gt;&gt;三个&gt;&gt;&gt;之类的，貌似可以一直加下去，但是好像没什么用… 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;这是引用的内容 四.分割线三个或者三个以上的-或者*都可以。 1234-------******** 五.图片1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 六.超链接12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 例如： 12[简书](http://jianshu.com)[百度](http://baidu.com) 七.列表无序列表用-+*任何一种都可以。 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 有序列表数字加点即可。 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 列表嵌套：上一级和下一级之间敲上三个空格即可。 八.表格1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 九.代码单行代码直接代码之间分别用一个反引号包起来即可。 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行。 12345(```) 代码... 代码... 代码...(```) 十.流程图123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; ` 参考文章：Markdown基本语法]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Android6.0以上部分权限的动态获取]]></title>
    <url>%2F2019%2F01%2F12%2F%E5%85%B3%E4%BA%8EAndroid6-0%E4%BB%A5%E4%B8%8A%E9%83%A8%E5%88%86%E6%9D%83%E9%99%90%E7%9A%84%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[普通权限暂且不表，下面只列举Android6.0以后必须进行动态申请的权限。 下面以SD卡读取权限作为例子（如果实在不懂的话可以直接复制粘贴，只需要改一下权限的名称即可）： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 请求授权 */ private void requestPermission()&#123; if (Build.VERSION.SDK_INT &gt;= 23) &#123; int checkCallPhonePermission = ContextCompat.checkSelfPermission (this, Manifest.permission.READ_EXTERNAL_STORAGE); if (checkCallPhonePermission != PackageManager.PERMISSION_GRANTED) &#123; //在String[]中传入需要申请的权限 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE&#125;, 1); &#125; else&#123; //sendHomework(); //已经拥有了权限 Toast.makeText(this,"已经获取读SD卡权限",Toast.LENGTH_SHORT).show(); &#125; &#125; else &#123; //低版本 Toast.makeText(this,"已经获取读SD卡权限",Toast.LENGTH_SHORT).show(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //sendHomework(); //获取权限成功后的处理 Toast.makeText(this,"已经成功获取读SD卡权限",Toast.LENGTH_SHORT).show(); &#125; else &#123; //showToast("fail"); //获取权限失败的处理 Toast.makeText(this,"获取读SD卡权限失败",Toast.LENGTH_SHORT).show(); &#125; break; default: super.onRequestPermissionsResult(requestCode, permissions, grantResults); &#125; &#125; 对于新手来说，需要注意的是，如果你想要使用这个动态权限，除了上面这段代码之外，你还需要在项目的Manifest中注册你想要获取的权限（一般来说，只要不是危险权限，无论Android6.0前后，只要注册之后就可以直接使用了，但是危险权限，除了注册之外还需要手动的动态申请）。 另外，除了上面这段代码和注册之外，还需要在初始化之前在MainActivity中写上 1requestPermission() 来调用下面写的动态申请。 参考文章：Android6.0动态权限]]></content>
      <categories>
        <category>移动端开发</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动态权限</tag>
        <tag>安卓6.0以上</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[真机调试时如何用Androidstudio查询SQLite数据库]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E6%97%B6%E5%A6%82%E4%BD%95%E7%94%A8Androidstudio%E6%9F%A5%E8%AF%A2SQLite%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[目录： 前言： 1.首先在app对应下的build.gradle里面添加下面依赖： 2.自定义一个MyApplication继承Application，在onCreate中初始化stetho： 3.修改下列相关： 4.打开Chrome浏览器，输入网址：chrome://inspect 5.点击弹出的网页Resource-&gt;Web SQL即可看到，下面是我的数据库显示情况： 前言：今天在调试一个有关于SQLite数据库的app的时候，突发奇想，想在手机上直接找到对应的db文件查看，结果是显而易见的，并没有找到相应的调试app的包名以及对应的文件夹。 然后在网上找了很多方法，试过之后，找到一个较方便且便捷的方法。如下： 1.首先在app对应下的build.gradle里面添加下面依赖：1234// Stetho coreimplementation &apos;com.facebook.stetho:stetho:1.3.1&apos;//If you want to add a network helperimplementation &apos;com.facebook.stetho:stetho-okhttp3:1.3.1&apos; 2.自定义一个MyApplication继承Application，在onCreate中初始化stetho：123456789101112131415public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); init(); &#125; private void init()&#123; Stetho.initializeWithDefaults(this); new OkHttpClient.Builder() .addNetworkInterceptor(new StethoInterceptor()) .build(); &#125;&#125; 3.修改下列相关：在AndroidManifest.xml中修改android:name=”.MyApplication” 然后运行app到手机上即可。 4.打开Chrome浏览器，输入网址： 操作好之后就是显示手机型号，下面有一个inspect直接点击即可。 5.点击弹出的网页Resource-&gt;Web SQL即可看到，下面是我的数据库显示情况： 这样就很简单啦，又方便又快捷！]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SQLite</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo进阶（个人向）]]></title>
    <url>%2F2019%2F01%2F09%2FHexo%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： 前言： 正文： 关于如何将自己的博客推送至百度与谷歌（默认情况下是不会被爬取的，这个时候就需要我们主动出击，让我们的博客可以直接被搜索到） 提交百度搜索引擎：（谷歌同理，过程一样） 站点地图： 安装百度谷歌的站点地图： 向谷歌提交链接： 百度收录： sitemap： 结语：百度的抓取速度是真的慢，另外，github.io的博客不允许百度蜘蛛爬取，直接再把博客推送到coding.me即可，百度收录的时候一定要用coding.me的网址。关于如何推送到coding，与github类似… 前言：首先，在我们刚刚搭建好这个博客的时候，我们会发现自己的博客显得很是简陋以及，单调，这个时候就是显示个性化的好时机了。hexo主题个性化是一个集合了许多方法的网址，可以参考。当然这只是沧海一粟，不值一提。还有更多的，诸如留言板，相册，网易云外链之类的优秀功能，具体详情可以直接百度，这里不过多赘述。 正文：关于如何将自己的博客推送至百度与谷歌（默认情况下是不会被爬取的，这个时候就需要我们主动出击，让我们的博客可以直接被搜索到）原因：Github和Coding都做了防爬虫处理，这样子我们博客可能就无法被搜索引擎收录，需要我们手动提交！ 验证是否被百度或者谷歌收录，即在相应的搜索栏中输入： 1site: thbelief.coding.me （注：site:后面是你的博客网址） 如果显示找不到相关网址，即没有被收录。如果找到了….那就恭喜不用操作了。 言归正传，回到正题。 提交百度搜索引擎：（谷歌同理，过程一样）登录百度搜索引擎 ps：可能需要个人信息认证，按照提示认证即可！ 然后是：添加站点-&gt;输入博客网址-&gt;设置站点领域（我设置的是信息技术）-&gt;选择验证方式。 这里只介绍第一种验证方式：文件验证 1.请点击 下载验证文件 获取验证文件 2.将验证文件放置于您所配置hexo博客的根目录下 3.点击这里确认验证文件可以正常访问 4.请点击“完成验证”按钮 注：为保持验证通过的状态,成功验证后请不要删除HTML文件 然后git bash输入框内输入hexo g -d部署到网站上面即可。 站点地图：站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 安装百度谷歌的站点地图：123npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 然后打开站点配置文件： 将url设置为你的站点名称。 然后执行hexo clean 以及 hexo g。 这样在你的网站根目录的public文件夹下生成sitemap.xml文件和baidusitemap.xml文件： 其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。 向谷歌提交链接：google站点平台：谷歌站点，然后就是注册账号、验证站点、提交sitemap， 提交site之后即可。 注意：无论是百度还是谷歌，都不是已通过就能直接搜索到，谷歌大致需要几小时，百度大致一个月左右，请耐心等待。 百度收录：百度收录较慢。故设置自动推送： 在主题配置文件下设置,将baidu_push设置为true： 12# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true sitemap：将生成的baidusitemap.xml提交到百度站点 点击链接提交： 然后刷新页面即可。 结语：百度的抓取速度是真的慢，另外，github.io的博客不允许百度蜘蛛爬取，直接再把博客推送到coding.me即可，百度收录的时候一定要用coding.me的网址。关于如何推送到coding，与github类似…]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用hexo+Github搭建个人博客（个人向）]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%AA%E4%BA%BA%E5%90%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录： hexo的介绍 准备 NodeJS Hexo安装 GitHub部分 Github Page 配置SSH 发布 更改主题 hexo的介绍官网上的描述是Hexo是一个快速，简单而强大的博客框架。我们可以使用Markdown（或其他语言）来编写文章，同时Hexo可以在几秒钟内生成具有美丽主题的静态文件以供我们使用。 简单来说它就是一个主打简单快速的博客框架，这个可以对比下知名度更高一些的WordPress，相对来说后者更强，不过更适合有服务器的人使用，只想做一个简单博客的首选hexo。 准备首先必须安装Git和NodeJS。（安装过程傻瓜式next操作即可） 注意一点就是NodeJS的路径。推荐D:\NodeJS (原因后面会阐述) 检测NodeJS是否安装成功的方式是： 输入Win+R输入cmd打开控制台输入下面代码： 12node -vnpm -v 如果两个都返回版本号即安装成功，否则需要再配环境变量。 NodeJS1.在NodeJS安装路径下面建立”node_global”及”node_cache”两个文件夹。 2.启动cmd输入： 12npm config set prefix &quot;D:\Program Files\nodejs\node_global&quot;npm config set cache &quot;D:\Program Files\nodejs\node_cache&quot; 3.配置环境变量： 环境变量-&gt;Path-&gt;编辑：添加上下面三行：（有的话就不用了） 123D:\NodeJS\D:\NodeJS\node_globalD:\NodeJs\node_cache 4.测试是否配置完成： 如果打开cmd输入下面代码然后在node_global目录下有express目录即完成了。 1npm install express -g Hexo安装打开git bash（为了避免出现错误后面的操作在git bash进行） 首先新建一个存放hexo文件的目录，例如在D盘根目录新建hexo文件夹，然后cd到该目录下，开始安装 1234567$ cd D:hexo/ #换成你的目录$ npm install -g hexo-cli #安装hexo脚手架$ hexo init #Hexo自动在当前文件夹下下载搭建网站所需的所有文件$ npm install #安装依赖包$ hexo g #完整命令为hexo generate，生成静态文件$ hexo s #完整命令为hexo server，启动服务器，用来本地预览 用浏览器访问http://localhost:4000，这时就可以看到了一个比较漂亮的博客了，这个是hexo的默认主题landscape，而我们会使用的是NexT主题，后面会说到怎么配置。 GitHub部分Github Page打开github主页，新建仓库（repository），这里要注意仓库的名称，比如我的帐号是thbelief，那么仓库名称应该是：thbelief.github.io。然后选择Public（公开）。 配置SSH以上过程完成后就是把hexo生成的静态页面上传了，到这里还没结束，还需要配置SSH，首先要本地生成公钥私钥 1$ ssh-keygen -t rsa -C &quot;你的邮件地址&quot; 引号里面的内容输入你的邮箱地址，然后回车，会提示你文件保存的路径，这时候按回车键确认，然后会提示你输入密码，输入即可（输入密码是看不到的），然后会确认输入一次，就可以在刚刚的路径看到生成了两个文件，一个是id_rsa，另一个是id_rsa.pub，用sublime打开id_rsa.pub然后选中里面的全部内容，复制下来。打开GitHub或Coding的SSH页面Github：setting–&gt;SSH and GPG keys–&gt;New SSH key在Key下面的框中粘贴刚刚复制的东西。 发布打开D:\hexo，用sublime打开_config.yml文件，文件最后可以看到 12deploy: type: 修改（注意要换上自己的链接） 12345deploy: type: git repository: git@github.com:yourname/yourname.github.io.git #发布到github #repository: git@git.coding.net:yourname/yourname.git #发布到Coding branch: master ctrl+s保存修改。打开git bash在当前目录输入以下命令： 1$ hexo d #完整命令为hexo deploy，将本地文件发布到page服务平台上 如遇遇到异常可以 12$ hexo clean &amp;&amp; hexo g$ hexo d 如果出现以下异常 1ERROR Deployer not found: git 尝试输入以下命令，然后重新执行刚刚的两条命令 1$ npm install hexo-deployer-git --save 这时候如果弹出一个对话框，输入在github/coding上面的用户名和密码即可这时候我们就可以在浏览器输入https://yourname.github.io 或者https://youname.coding.me 打开。（yourname记得替换） 更改主题D:\hexo目录下的theme文件夹下存放的就是博客的主题，hexo便是依据主题来生成静态文件的，挑选主题可以在官网https://hexo.io/themes/ 查找，根据自己的喜好来挑选。下载主题的一般方式如下： 12$ cd your-hexo-site #eg:D:\hexo$ git clone &#123;主题链接&#125; themes/&#123;主题名称&#125; 但是最好还是直接去官网下载压缩包解压到hexo目录下面的themes中，因为国内下这个很慢。（解压的时候名字一定要换成next，方便后序操作） 其实还有一种方法，也是对第一种方法的补充，直接更换npm的来源地，换成淘宝的即可，详情百度，这里不过多赘述。 启用主题的方式也很简单sublime打开上文提到的hexo目录下的_config.yml，ctrl+f输入theme查找这个关键字，修改其主题名称为下载的主题名称即可。 1theme: &#123;主题名称&#125; 以本人使用的next主题为例：下载最新版： 12$ cd D:hexo/$ git clone https://github.com/iissnan/hexo-theme-next themes/next 修改hexo目录下的_config.yml 1theme: next 具体可以到主题官网看看–NexT 参考文章：hexo搭建个人博客]]></content>
      <categories>
        <category>前端</category>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
        <tag>前端</tag>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
</search>
